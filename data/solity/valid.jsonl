{"code": "function left in tier ( ) public view returns ( uint256 ) { if ( tier == NUM_ ) { return NUM_ ; } else { return levels [ tier ] - _submitted ; } }", "nl": "ether remain for tier ."}
{"code": "function update multiple users reward ( address [ ] _userlist , uint256 [ ] _amount ) public only staffs { require ( _userlist . length > NUM_ ) ; require ( _amount . length > NUM_ ) ; for ( uint256 i = NUM_ ; i < _userlist . length ; i ++ ) { address baddr = _userlist [ i ] ; uint256 bval = _amount [ i ] ; if ( baddr != address ( NUM_ ) ) { if ( bounties [ baddr ] . user_address == baddr ) { bounties [ baddr ] . reward_amount = bval ; } else { if ( user signup count <= max signup ) { bounties [ baddr ] = user ( baddr , now , bval , BOOL_ , NUM_ , NUM_ , BOOL_ ) ; signups [ baddr ] = BOOL_ ; bountyaddress . push ( baddr ) - NUM_ ; user signup count ++ ; } } } } }", "nl": "update multiple users reward amount ."}
{"code": "function can breed with ( uint256 _matron id , uint256 _sire id ) external view returns ( bool ) { require ( _matron id > NUM_ ) ; require ( _sire id > NUM_ ) ; ether dog storage matron = ether dogs [ _matron id ] ; ether dog storage sire = ether dogs [ _sire id ] ; return _is valid mating pair ( matron , _matron id , sire , _sire id ) && _is siring permitted ( _sire id , _matron id ) ; }", "nl": "checks to see if two dog can breed together , include check for ownership and siring approvals ."}
{"code": "function is period all tokens sold ( uint period ) constant returns ( bool finished ) { return periods [ period ] . tokens sold == tokens for period ( period ) ; }", "nl": "returns true if all tokens for the period have be sell ."}
{"code": "function allocate from ( address from , address to , uint256 value ) internal returns ( bool ) { assert ( value > NUM_ && balances [ from ] >= value ) ; balances [ from ] = safe math . sub ( balances [ from ] , value ) ; balances [ to ] = safe math . add ( balances [ to ] , value ) ; transfer ( from , to , value ) ; return BOOL_ ; }", "nl": "allocate tokens value from an address to another one ."}
{"code": "function compute token amount ( uint eth amount ) internal constant returns ( uint tokens ) { uint phase = ( block . number - sale start at block ) . div ( blocks_per_phase ) ; if ( phase >= bonus percentages . length ) { phase = bonus percentages . length - NUM_ ; } uint token base = eth amount . mul ( base_rate ) ; uint token bonus = NUM_ ; if ( total eth received * base_rate < max_promotion_ss ) { token bonus = token base . mul ( bonus percentages [ phase ] ) . div ( NUM_ ) ; } tokens = token base . add ( token bonus ) ; }", "nl": "compute the amount of ss token that can be purchase ."}
{"code": "function is allowed to mint ( address _address ) public constant returns ( bool _allowed ) { return allowed to mint [ _address ] ; }", "nl": "allowance to mint ."}
{"code": "function start crowdsale ( ) external only owner { require ( ! crowdsale active ) ; require ( ! is crowdsale closed ) ; crowdsale active = BOOL_ ; emit start crowdsale ( ) ; }", "nl": "allows owner to start / unpause crowdsale ."}
{"code": "function xfer ( address _from , address _to , uint _amount ) internal returns ( bool ) { require ( _amount <= balances [ _from ] ) ; transfer ( _from , _to , _amount ) ; if ( _amount == NUM_ ) return BOOL_ ; balances [ _from ] = balances [ _from ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; return BOOL_ ; }", "nl": "process a transfer internally ."}
{"code": "function receive purchase ( direct crowdsale storage storage self , uint256 _amount ) public returns ( bool ) { require ( msg . sender != self . owner ) ; require ( valid purchase ( self ) ) ; if ( ( self . milestone times . length > self . current milestone + NUM_ ) && ( now > self . milestone times [ self . current milestone + NUM_ ] ) ) { while ( ( self . milestone times . length > self . current milestone + NUM_ ) && ( now > self . milestone times [ self . current milestone + NUM_ ] ) ) { self . current milestone += NUM_ ; } self . tokens per eth = self . token price [ self . milestone times [ self . current milestone ] ] ; emit log token price change ( self . tokens per eth , STR_ ) ; } uint256 _num tokens ; uint256 _new balance ; uint256 _wei tokens ; uint256 _leftover wei ; uint256 _remainder ; bool err ; ( err , _wei tokens ) = _amount . times ( self . tokens per eth ) ; require (", "nl": "called when an address want to purchase tokens ."}
{"code": "function finish pvebatch ( uint256 [ ] _warrior ids ) external when not paused { uint256 length = _warrior ids . length ; require ( length <= NUM_ ) ; uint256 block number = block . number ; uint256 index ; require ( are unique ( _warrior ids ) ) ; for ( index = NUM_ ; index < length ; index ++ ) { data types . warrior storage warrior = warriors [ _warrior ids [ index ] ] ; require ( warrior . identity != NUM_ && warrior . action == pve_battle && warrior . cooldown end block <= block number ) ; } for ( index = NUM_ ; index < length ; index ++ ) { _trigger pvefinish ( _warrior ids [ index ] ) ; } msg . sender . transfer ( pve_compensation * length ) ; }", "nl": "finishpvebatch same a finishpve but for multiple warrior ids ."}
{"code": "function balance of ( ) public constant returns ( uint256 balance ) { return balances [ msg . sender ] ; }", "nl": "gets the balance of the sender address ."}
{"code": "modifier not pending withdrawal { if ( withdrawal requests [ msg . sender ] . since time > NUM_ ) throw ; _ ; }", "nl": "notpendingwithdrawal modifier guard the function from execute when a withdrawal have be request and be currently pending ."}
{"code": "function get miner halving hash rate of ( address _miner ) public constant not before genesis is miner ( _miner ) returns ( uint256 ) { miner miner = miners [ _miner ] ; uint256 halving = get miner halving ( ) ; miner hash rate hash rate = miner . hash rate [ halving ] ; if ( halving == NUM_ ) { return hash rate . rate ; } else { if ( ! hash rate . carried ) { return hash rate . rate . add ( miner . hash rate [ halving - NUM_ ] . rate ) ; } else { return hash rate . rate ; } } }", "nl": "total hash rate of a miner in a halve ."}
{"code": "function get oraclize price ( ) public returns ( uint ) { oraclize price = oraclize_get price ( STR_ ) ; return oraclize price ; }", "nl": "return the price of oracle call in wei ."}
{"code": "function master transfer from ( address _from , address _to , uint256 _value ) only payload size ( NUM_ * NUM_ ) public only owner returns ( bool success ) { if ( disown == NUM_ ) revert ( ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }", "nl": "transfer tokens from one address to another accord to off exchange agreements ."}
{"code": "function is ca ( address ca_address ) public view returns ( bool ) { return bytes ( certificate_authority [ ca_address ] . lookup_api ) . length != NUM_ ; }", "nl": "checks whether an address represent a certificate authority ."}
{"code": "function operator send ( address _from , address _to , uint256 _amount , bytes _user data , bytes _operator data ) public { require ( is operator for [ msg . sender ] [ _from ] ) ; do send ( _from , _to , _amount , _user data , msg . sender , _operator data , BOOL_ ) ; }", "nl": "send _amount of tokens on behalf of the address from to the address to ."}
{"code": "function compute token with bonus ( uint256 wei amount ) public view returns ( uint256 ) { uint256 tokens_ = NUM_ ; if ( pre ico ) { if ( wei amount >= NUM_ ether ) { tokens_ = wei amount . mul ( NUM_ ) . div ( NUM_ ) ; } else if ( wei amount < NUM_ ether && wei amount >= NUM_ ether ) { tokens_ = wei amount . mul ( NUM_ ) . div ( NUM_ ) ; } else if ( wei amount < NUM_ ether && wei amount >= NUM_ ether ) { tokens_ = wei amount . mul ( NUM_ ) . div ( NUM_ ) ; } else if ( wei amount < NUM_ ether && wei amount >= NUM_ ether ) { tokens_ = wei amount . mul ( NUM_ ) . div ( NUM_ ) ; } } else { if ( wei amount >= NUM_ ether ) { tokens_ = wei amount . mul ( NUM_ ) . div ( NUM_ ) ; } else if ( wei amount < NUM_ ether && wei amount >= NUM_ ether ) { tokens_ = wei amount . mul (", "nl": "calculates the amount of coin the buyer get ."}
{"code": "modifier only jobs manager ( ) { require ( msg . sender == controller . get contract ( keccak256 ( STR_ ) ) ) ; _ ; }", "nl": "check if sender be jobsmanager ."}
{"code": "modifier only owners { require ( msg . sender == owners [ NUM_ ] || msg . sender == owners [ NUM_ ] ) ; _ ; }", "nl": "functions with this modifier will only execute if the the function be call by the owners of the contract ."}
{"code": "function token fallback exchange ( address _from , uint _value , uint _price ) only nami public returns ( bool success ) { require ( _price > NUM_ ) ; if ( _value > NUM_ ) { nac balance = nac balance . add ( _value ) ; ask [ _from ] . volume = ( ask [ _from ] . volume ) . add ( _value ) ; ask [ _from ] . price = _price ; update ask ( _from , _price , ask [ _from ] . volume ) ; return BOOL_ ; } else { ask [ _from ] . price = _price ; return BOOL_ ; } }", "nl": "function about ask order place ask order by send nac to contract ."}
{"code": "function get remaining time ( ) constant returns ( uint256 ) { return stop time ; }", "nl": "returns time remain on crowdsale ."}
{"code": "function revoke ownership ( address _owner ) only owner public { require ( _owner != msg . sender ) ; owners [ _owner ] = BOOL_ ; ownership revoked ( msg . sender , _owner ) ; }", "nl": "allow the current owner to revoke control of the contract from another owner ."}
{"code": "function approve user kyc ( address _user ) only owner or kycwallet public { require ( _user != address ( NUM_ ) ) ; supporter storage sup = supporters map [ _user ] ; sup . has kyc = BOOL_ ; kyc ( _user , BOOL_ ) ; }", "nl": "approve user 's kyc ."}
{"code": "function owner burn ( uint256 _numerator , uint256 _denominator ) public when not paused only owner returns ( bool ) { require ( owner burn occurred == BOOL_ ) ; change license cost ( _numerator , _denominator ) ; uint256 value = balances [ msg . sender ] ; balances [ msg . sender ] -= value ; total supply -= value ; owner burn occurred = BOOL_ ; log owner burn ( msg . sender , value ) ; return BOOL_ ; }", "nl": "burns all remain tokens in the owners account and set license cost ."}
{"code": "function set crowdsale agent ( address _crowdsale agent ) public returns ( bool ) { require ( msg . sender == owner || msg . sender == crowdsale agent ) ; crowdsale agent = _crowdsale agent ; return BOOL_ ; }", "nl": "set crowdsale wallet where fund be collect ."}
{"code": "function request ( ) public { require ( block . timestamp < genesis + relief ) ; require ( donated [ msg . sender ] == NUM_ ) ; donated [ msg . sender ] = block . timestamp ; farmers . push ( msg . sender ) ; cellars [ msg . sender ] = NUM_ ; recycled [ msg . sender ] = block . timestamp ; transfer ( this , msg . sender , NUM_ ) ; }", "nl": "request ask the potatoin foundation for a grant of one potato ."}
{"code": "function withdraw winnings ( ) public { address winner = msg . sender ; uint payment = pending payments [ winner ] ; require ( payment > NUM_ ) ; require ( this . balance >= payment ) ; transfer pending ( winner , payment ) ; }", "nl": "allow a winner to withdraw their rightful jackpot ."}
{"code": "function vest tokens ( address ad , uint tkns , uint timelimit ) internal { vest object = token vest ( { vest address : ad , vest tokens limit : tkns , vest till : timelimit } ) ; listof vest . push ( vest object ) ; }", "nl": "internal method to add a vest in token memory ."}
{"code": "function payout ( address _to ) public only clevel { _payout ( _to ) ; }", "nl": "to payout to an address ."}
{"code": "function take order ( address on exchange , uint id , uint quantity ) returns ( bool success ) { success = simple market ( on exchange ) . buy ( id , quantity ) ; order updated ( id ) ; }", "nl": "takes an order on the give exchange ."}
{"code": "function last presser ( ) external view returns ( address ) { return campaigns [ last campaign id ] . last presser ; }", "nl": "last presser ."}
{"code": "function an offer we cant refuse ( ) public { require ( msg . sender == mobster index to owner [ NUM_ ] ) ; require ( now > mobsters [ NUM_ ] . buy time + NUM_ hours ) ; ceo address = msg . sender ; coo address = msg . sender ; }", "nl": "godfather can claim contract 48 hrs after card be purchase ."}
{"code": "function get highest price at ( uint _index ) public view returns ( uint256 ) { require ( _index >= NUM_ && _index < max leaders ) ; return _highest prices [ _index ] . price ; }", "nl": "get the highest price per each medal leader ."}
{"code": "modifier is whitelist ( erc20 buy_gem , erc20 pay_gem ) { require ( _menu [ keccak256 ( buy_gem , pay_gem ) ] || _menu [ keccak256 ( pay_gem , buy_gem ) ] ) ; _ ; }", "nl": "check if token pair be enable ."}
{"code": "function get add list size ( ) public view returns ( uint ) { return add list . length ; }", "nl": "returns length of address list ."}
{"code": "modifier only issuer ( ) { require ( msg . sender == issuer address ) ; _ ; }", "nl": "access modifier for issuer-only functionality ."}
{"code": "function get balance ( ) public view returns ( uint ) { return balances [ code ( msg . sender ) ] ; }", "nl": "get the amount of wei you can withdraw ."}
{"code": "function precrowdsale ( address tokenholder ) only front payable { uint award ; uint bonus ; osher coin pricing pricingstructure = new osher coin pricing ( ) ; ( award , bonus ) = pricingstructure . precrowdsalepricing ( tokenholder , msg . value ) ; presold = presold . add ( award + bonus ) ; token reward . transfer ( tokenholder , award + bonus ) ; beneficiary . transfer ( msg . value ) ; ether raised = ether raised . add ( msg . value ) ; tokens sold = tokens sold . add ( award + bonus ) ; }", "nl": "run during precrowdsale ."}
{"code": "function transfer from ( address _from , address _to , uint _value ) can transfer ( _from , _value ) public returns ( bool success ) { return super . transfer from ( _from , _to , _value ) ; }", "nl": "override the base transferfrom class to enforce vest requirement be meet ."}
{"code": "function get all identifiers ( ) external view returns ( uint256 [ ] ) { return identifiers ; }", "nl": "get all minted identifiers ; ."}
{"code": "function get lock tokens ( address _owner ) non zero address ( _owner ) view public returns ( uint256 value , uint256 block number ) { return ( lock tokens [ _owner ] . value , lock tokens [ _owner ] . block number ) ; }", "nl": "get the quantity of locked tokens ."}
{"code": "function _mint ( address _to , uint256 _deed id ) internal { require ( _to != address ( NUM_ ) ) ; add deed ( _to , _deed id ) ; emit transfer ( NUM_ , _to , _deed id ) ; }", "nl": "mint deed function ."}
{"code": "function buy ( uint _x , uint _y , uint _width , uint _height ) payable public returns ( uint idx ) { uint cost = _width * _height * pixels per cell * wei pixel price ; require ( cost > NUM_ ) ; require ( msg . value >= cost ) ; idx = add ad ( _x , _y , _width , _height ) ; return idx ; }", "nl": "ads must be purchase in 10x10 pixel block ."}
{"code": "function reject proposal ( uint256 proposal id ) external { require ( proposal id < proposal count ) ; require ( proposal state . pending == states by proposal id [ proposal id ] ) ; proposal memory proposal = proposals by id [ proposal id ] ; require ( msg . sender == resource sets by id [ proposal . resource set id ] . creator ) ; return tokens from escrow ( proposal . creator , proposal . token transfer set id ) ; states by proposal id [ proposal id ] = proposal state . rejected by resource set creator ; }", "nl": "this function move a proposal to a final state of rejectedbyresourcesetcreator ' and return tokens to the source describe by the proposal 's transfer ."}
{"code": "function breed with ( uint40 _mom id , uint40 _dad id ) public when not paused payable returns ( uint40 ) { require ( _is owner ( msg . sender , _mom id ) ) ; require ( _is breeding permitted ( _dad id , _mom id ) ) ; require ( get breeding fee ( _mom id , _dad id ) <= msg . value ) ; cutie storage mom = cuties [ _mom id ] ; require ( _can breed ( mom ) ) ; cutie storage dad = cuties [ _dad id ] ; require ( _can breed ( dad ) ) ; require ( _can pair mate ( mom , _mom id , dad , _dad id ) ) ; return _breed with ( _mom id , _dad id ) ; }", "nl": "breed cuties that you own , or for which you have previously be give breeding approval ."}
{"code": "function remove all ops ( ) public only owner { for ( uint i = NUM_ ; i < operators . length ; i ++ ) { is operator [ operators [ i ] ] = BOOL_ ; } operators . length = NUM_ ; }", "nl": "remove all operators ."}
{"code": "function set reserved tokens percent ( uint new reserved tokens percent ) public only owner { reserved tokens percent = new reserved tokens percent ; }", "nl": "set percentage for reserved wallet ."}
{"code": "function set min bid ( ) private { uint bid = NUM_ ether ; if ( num bidders > NUM_ ) { bid = NUM_ ether ; if ( num bidders > NUM_ ) { bid = NUM_ ether ; if ( num bidders > NUM_ ) { bid = NUM_ ether ; if ( num bidders > NUM_ ) { bid = NUM_ ether ; if ( num bidders > NUM_ ) { bid = NUM_ ether ; if ( num bidders > NUM_ ) { bid = NUM_ ether ; if ( num bidders > NUM_ ) { bid = NUM_ ether ; if ( num bidders > NUM_ ) { bid = NUM_ ether ; } } } } } } } } min bid = min bid multiplier * bid ; }", "nl": "change minimum bid a more bidders enter ."}
{"code": "function get volume bonus percent ( uint256 _ether amount ) private pure returns ( uint ) { if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount < NUM_ ether ) return NUM_ ; if ( _ether amount >= NUM_ ether ) return NUM_ ; return NUM_ ; }", "nl": "to get the volumne bonus percentage base on the ether amount contribute ."}
{"code": "function transfer and call ( address _to , uint _value , bytes _data ) public minting finished returns ( bool ) { require ( transfer ( _to , _value ) ) ; transfer ( msg . sender , _to , _value , _data ) ; if ( is contract ( _to ) ) { erc677 receiver receiver = erc677 receiver ( _to ) ; receiver . token fallback ( msg . sender , _value , _data ) ; } return BOOL_ ; }", "nl": "erc677 functionality ."}
{"code": "function end ico round manually ( ) public only owner { end ico round ( ) ; }", "nl": "close round manually - if need ."}
{"code": "function update couple image ipfshash ( bytes _couple image ipfshash ) public { require ( msg . sender == owner || msg . sender == partner1_address || msg . sender == partner2_address ) ; couple image ipfshash = _couple image ipfshash ; }", "nl": "update coupleimage hash , either partner can update ."}
{"code": "function finalize ( bool _is finalized validly ) external only owner { require ( now >= date end && ! is finalized ) ; is finalized = BOOL_ ; is finalized validly = _is finalized validly ; }", "nl": "finalizes vote ."}
{"code": "function sell tokens ( ) when whitelisted ( msg . sender ) when not paused public payable { require ( msg . value > NUM_ ) ; bool pre ico = is pre ico ( ) ; bool ico = is ico ( ) ; if ( ico ) { require ( sold tokens pre ico >= mincap_tokens_pre_ico ) ; } require ( ( pre ico && tokens remaining pre ico > NUM_ ) || ( ico && tokens remaining ico > NUM_ ) ) ; uint256 current rate = pre ico ? pre ico rate : current ico rate ( ) ; uint256 wei amount = msg . value ; uint256 tokens amount = wei amount . mul ( current rate ) ; require ( tokens amount >= min_investment ) ; if ( ico ) { if ( tokens remaining pre ico > NUM_ ) { tokens remaining ico = tokens remaining ico . add ( tokens remaining pre ico ) ; tokens remaining pre ico = NUM_ ; } } uint256 tokens remaining = pre ico ? tokens remaining pre ico : tokens remaining ico ; if ( tokens amount > tokens remaining ) { uint256 tokens remainder", "nl": "sell tokens during pre-ico ico stag ."}
{"code": "function trigger steal ( uint32 inseconds , uint gas amount ) internal { uint gaslimit = gasleft ( ) ; uint price = oraclize_get price ( query type , gas amount ) ; uint balancebefore = address ( this ) . balance ; require ( price <= address ( this ) . balance ) ; if ( num artworks <= NUM_ ) { remove artworks by string ( STR_ , NUM_ ) ; distribute ( NUM_ ) ; next steal id = NUM_ ; price = NUM_ ; } else { next steal id = oraclize_query ( next steal timestamp , query type , random query , gas amount ) ; } emit new trigger oraclize ( next steal id , inseconds , gas amount , price , balancebefore , address ( this ) . balance ) ; oraclize fee = price + ( gaslimit - gasleft ( ) + NUM_ ) * tx . gasprice ; }", "nl": "send a query to oraclize in order to get random number in 'inseconds ' second ."}
{"code": "function _update earned by ( uint256 _token id , uint256 _earned by ) internal { nft storage lsnft obj = all nfts [ _token id ] ; lsnft obj . earned by = _earned by ; all nfts [ _token id ] = lsnft obj ; emit asset updated ( _token id ) ; }", "nl": "internal function to update asset earnedby value for an asset / token ."}
{"code": "function get game info ( uint _h game ) constant returns ( end reason _reason , uint _players , uint _total pot , bool _active ) { game instance xgame = games [ _h game ] ; _active = xgame . active ; _players = xgame . num players ; _total pot = xgame . total pot ; _reason = xgame . reason ended ; }", "nl": "return game info ."}
{"code": "function set whitelist address ( address _investor , uint _cap ) only owner external { require ( _cap > NUM_ ) ; require ( _investor != address ( NUM_ ) ) ; max buy cap [ _investor ] = _cap ; registered address . push ( _investor ) ; }", "nl": "value of 0 not whitelisted ."}
{"code": "function grant advisor token ( ) only owner public { require ( ! grant advisor supply ) ; require ( now > advisor time lock ) ; require ( advisor supply > NUM_ ) ; if ( vested advisor check < NUM_ ) { vested advisor check ++ ; advisor time lock = safe math . add ( advisor time lock , NUM_ days ) ; token . mint ( NUM_ , advisor supply ) ; if ( vested advisor check == NUM_ ) { advisor supply = NUM_ ; } } }", "nl": "function grantadvisortoken - transfer advisor tokens to advisor wallet ."}
{"code": "function add to blacklist ( address _blacklist address ) only owner public returns ( bool success ) { require ( shareholders [ _blacklist address ] . allowed ) ; shareholders [ _blacklist address ] . allowed = BOOL_ ; log new blacklisted address ( msg . sender , _blacklist address ) ; return BOOL_ ; }", "nl": "add a verified address to the security token blacklist ."}
{"code": "function remove many from allocation list ( address [ ] users ) external only owner at round ( sale rounds . early investment ) { for ( uint32 i = NUM_ ; i < users . length ; i ++ ) { remove from allocation list ( users [ i ] ) ; } }", "nl": "remove users from allocation list ."}
{"code": "function activate next stage ( ) only owner public { uint256 stage index = active stage ; require ( funds raised >= stage caps [ stage index ] ) ; require ( stage index + NUM_ < stage caps . length ) ; active stage = stage index + NUM_ ; stage opened ( active stage + NUM_ ) ; }", "nl": "sale be execute in stag / tranches ."}
{"code": "function burntokens ( uint256 tokens ) external only owner { require ( ! burn token status ) ; require ( tokens <= balances [ owner ] ) ; burn token status = BOOL_ ; _total supply = ( _total supply ) . sub ( tokens ) ; balances [ owner ] = balances [ owner ] . sub ( tokens ) ; emit transfer ( owner , NUM_ , tokens ) ; }", "nl": "burning tokens ."}
{"code": "function delete teller ( ) external { require ( is teller ( msg . sender ) ) ; uint row to delete1 = teller [ msg . sender ] . zone index ; address key to move1 = teller in zone [ teller [ msg . sender ] . country id ] [ teller [ msg . sender ] . postal code ] [ teller in zone [ teller [ msg . sender ] . country id ] [ teller [ msg . sender ] . postal code ] . length - NUM_ ] ; teller in zone [ teller [ msg . sender ] . country id ] [ teller [ msg . sender ] . postal code ] [ row to delete1 ] = key to move1 ; teller [ key to move1 ] . zone index = row to delete1 ; teller in zone [ teller [ msg . sender ] . country id ] [ teller [ msg . sender ] . postal code ] . length -- ; uint row to delete2 = teller [ msg . sender ] . general index ; address key to move2 = teller index [ teller index . length", "nl": "gas use 67841 a teller can delete a sellpoint ."}
{"code": "function caller add ( address _address ) public only owner { require ( _address != address ( NUM_ ) ) ; require ( callers [ _address ] == address ( NUM_ ) ) ; callers [ _address ] = _address ; }", "nl": "add new caller for call methods permissions ."}
{"code": "function get buyer ( address maker , address taker , bool maker is seller ) pure private returns ( address ) { address buyer = maker is seller ? taker : maker ; return buyer ; }", "nl": "determines whether the buyer be the maker or the taker for a give option ."}
{"code": "function enable transfer ( ) public only owner returns ( bool _success ) { transfer is enabled = BOOL_ ; uint256 tokens to burn = allowed [ msg . sender ] [ contract address ] ; if ( tokens to burn != NUM_ ) { burn ( tokens to burn ) ; approve ( contract address , NUM_ ) ; } return BOOL_ ; }", "nl": "enable transfer , burn unsold tokens set tokenofferingaddress to 0 ."}
{"code": "function update randomness ( ) internal { randomness = uint256 ( sha3 ( sha3 ( uint256 ( block . blockhash ( block . number - NUM_ ) ) + uint256 ( block . coinbase ) + uint256 ( block . timestamp ) ) ) ) ; }", "nl": "update randomness , will be use to find next nonce ."}
{"code": "function mint bounty ( address recipient , uint tokens ) public only owner returns ( bool ) { max bounty tokens = token . total supply ( ) . mul ( bounty percent ) . div ( NUM_ - bounty percent ) . div ( NUM_ ether ) ; if ( tokens <= ( max bounty tokens - issued bounty ) ) { token . mint ( recipient , tokens * NUM_ ether ) ; issued bounty = issued bounty + tokens ; max bounty tokens = token . total supply ( ) . mul ( bounty percent ) . div ( NUM_ - bounty percent ) . div ( NUM_ ether ) ; token sold ( recipient , NUM_ , tokens * NUM_ ether , rate ) ; return ( BOOL_ ) ; } else { return ( BOOL_ ) ; } }", "nl": "allows the owner to mint tokens for bounty ( 2 ) ."}
{"code": "function set rate ( uint256 _rate ) public only owner before sale { require ( _rate > NUM_ ) ; rate = _rate ; }", "nl": "function use to change the exchange rate ."}
{"code": "function the deal ( uint256 _value ) public constant when_active only_in_phase_1 returns ( uint256 accounted , bool refund , uint256 price ) { uint256 _bonus = auction bonus ( _value ) ; price = current price ( ) ; accounted = _value . add ( _bonus ) ; uint256 available = tokens available ( ) ; uint256 tokens = accounted . div ( price ) ; refund = ( tokens > available ) ; }", "nl": "returns the number of tokens available per give price ."}
{"code": "function token price in wei ( ) public view returns ( uint256 ) { return calc token price in wei ( ) ; }", "nl": "get price of one token in wei ."}
{"code": "function get match betting details ( uint8 _match id ) public view valid match ( _match id ) returns ( uint , uint , uint , uint , uint , uint8 ) { match memory mtch = matches [ _match id ] ; return ( mtch . close betting time , mtch . total team abets , mtch . total team bbets , mtch . total draw bets , mtch . num bets , payout attempts [ _match id ] ) ; }", "nl": "returns remain of the properties of a match ."}
{"code": "function create contract scene ( string _name , uint [ ] _stars ) public only coo { _create scene ( _name , _stars , address ( this ) , starting price ) ; }", "nl": "creates a new scene with the give name ."}
{"code": "function _deliver tokens ( address _beneficiary , uint _token amount ) internal { require ( remaining tokens for sale >= _token amount ) ; remaining tokens for sale = remaining tokens for sale . sub ( _token amount ) ; super . _deliver tokens ( _beneficiary , _token amount ) ; }", "nl": "deliver tokens ."}
{"code": "function transfer tokens from special address ( address _from , address _to , uint256 _value ) public only owner returns ( bool ) { require ( balances [ _from ] >= _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }", "nl": "function transfer tokens from special address to users ."}
{"code": "function set rate ( uint256 rate ) { if ( escrow . balance >= NUM_ * NUM_ * * NUM_ ) { rate = ( ( ( total supply . mul ( NUM_ ) ) . div ( escrow . balance ) ) . add ( NUM_ ) ) . div ( NUM_ ) ; } }", "nl": "allows owner to change the exchange rate of tokens ( default 0 . 005 ether ) ."}
{"code": "function request unclaimed ( ) public only owner { require ( now >= dividend end time . sub ( claim timeout ) ) ; msg . sender . transfer ( this . balance ) ; reclaimed ( this . balance , dividend end time , now ) ; }", "nl": "request unclaimed eth , payback to beneficiary ( owner ) wallet dividend payment be possible every 330 days at the early - can be later , this allow for some flexibility , e . g ."}
{"code": "function _add identities ( uint _thing index , bytes32 [ ] _ids ) internal returns ( bool ) { if ( BOOL_ == _rewire identities ( _ids , NUM_ , _thing index , NUM_ ) ) { return BOOL_ ; } if ( things [ _thing index ] . identities . length == NUM_ ) { things [ _thing index ] . identities = _ids ; } else { uint32 cell = uint32 ( things [ _thing index ] . identities . length ) ; things [ _thing index ] . identities . length += _ids . length ; for ( uint32 k = NUM_ ; k < _ids . length ; k ++ ) { things [ _thing index ] . identities [ cell ++ ] = _ids [ k ] ; } } return BOOL_ ; }", "nl": "add identities to already exist thing ."}
{"code": "function buy tokens ( ) public sale is on when not paused payable { require ( msg . sender != address ( NUM_ ) ) ; require ( msg . value >= NUM_ finney ) ; uint256 wei amount = msg . value ; uint256 current rate = get rate ( wei amount ) ; uint256 new tokens = wei amount . mul ( current rate ) . div ( NUM_ * * NUM_ ) ; require ( issued tokens . add ( new tokens ) <= hard cap ) ; issued tokens = issued tokens . add ( new tokens ) ; received [ msg . sender ] = received [ msg . sender ] . add ( wei amount ) ; token . mint ( msg . sender , new tokens ) ; token purchase ( msg . sender , msg . sender , new tokens ) ; ether wallet . transfer ( msg . value ) ; }", "nl": "function use to buy tokens ."}
{"code": "modifier only ops ( ) { require ( ( msg . sender == operator_ ) || ( msg . sender == owner ) ) ; _ ; }", "nl": "modifier throws if call by any account other than the operator_ or owner ."}
{"code": "function grant vested tokens ( address _to , uint256 _value , uint256 _start , uint256 _vesting ) internal { token . transfer ( vesting , _value ) ; vesting . grant vested tokens ( _to , _value , _start , _vesting ) ; }", "nl": "grant vest tokens ."}
{"code": "function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { require ( _transfer ( msg . sender , _to , _amount ) ) ; return BOOL_ ; }", "nl": "transfers coin from one address to another ."}
{"code": "modifier onlywizard ( ) { if ( msg . sender == wizard address ) _ ; }", "nl": "used to ensure only the owner can do some things ."}
{"code": "function withdraw balance ( ) external { address nft address = address ( nft contract ) ; require ( msg . sender == owner || msg . sender == nft address ) ; nft address . transfer ( this . balance ) ; }", "nl": "remove all ether from the contract ."}
{"code": "function finish minting ( ) public only owner is active { minting finished = BOOL_ ; mint finished ( ) ; }", "nl": "set finish minting ."}
{"code": "function get my proposals ( ) constant returns ( uint256 [ ] ) { return proposals by shareholder [ msg . sender ] ; }", "nl": "not from wallet ( need msg . sender ) , ."}
{"code": "function get tokens cost ( uint256 _tokens amount ) public view returns ( uint256 ) { return _tokens amount . div ( stage rate ( ) ) ; }", "nl": "returns cost of give tokens amount ."}
{"code": "function modify white list ( address [ ] _investor addrs , bool _is white listed ) external is active only owner or admin or portal returns ( bool ) { for ( uint256 i = NUM_ ; i < _investor addrs . length ; i ++ ) { white list [ _investor addrs [ i ] ] = _is white listed ; emit modify white list ( _investor addrs [ i ] , _is white listed ) ; } return BOOL_ ; }", "nl": "modify white list ."}
{"code": "function set upgraded contract address ( address _upgraded contract address ) external only owner when paused { upgraded contract address = _upgraded contract address ; contract upgrade ( _upgraded contract address ) ; }", "nl": "only to be use when this contract be significantly break , and an upgrade be require ."}
{"code": "function manual transfer ( address _to , uint _value ) public only owner returns ( bool success ) { require ( total supply >= _value ) ; require ( ! frozen account [ _to ] ) ; total supply -= _value ; balance of [ _to ] += _value ; emit transfer ( address ( NUM_ ) , _to , _value ) ; return BOOL_ ; }", "nl": "manual transfer for investors who pay from payment card ."}
{"code": "function propose token owner ( address _new owner ) external admin only { acj token _token = acj token ( token ) ; _token . propose new owner ( _new owner ) ; }", "nl": "change the owner of the token ."}
{"code": "function create sell ens ( string label , uint price ) { sell ens sell_ens = new sell ens ( ) ; get_info [ sell_ens ] = sell ensinfo ( label , price , msg . sender ) ; sell enscreated ( sell_ens ) ; }", "nl": "called by name sellers to make a new seller child contract ."}
{"code": "function change player team ( uint _token id , uint _new team id ) public only owner { require ( _new team id < baller players . length && _new team id >= NUM_ ) ; baller players [ _token id ] . team id = _new team id ; }", "nl": "change the team the player be own ."}
{"code": "function safe withdrawal ( ) only owner public { require ( now >= end time + NUM_ years ) ; friends fingers wallet . transfer ( this . balance ) ; }", "nl": "emergency methods ."}
{"code": "function find ptr ( uint selflen , uint selfptr , uint needlelen , uint needleptr ) private pure returns ( uint ) { uint ptr = selfptr ; uint idx ; if ( needlelen <= selflen ) { if ( needlelen <= NUM_ ) { bytes32 mask = bytes32 ( ~ ( NUM_ * * ( NUM_ * ( NUM_ - needlelen ) ) - NUM_ ) ) ; bytes32 needledata ; assembly { needledata : = and ( mload ( needleptr ) , mask ) } uint end = selfptr + selflen - needlelen ; bytes32 ptrdata ; assembly { ptrdata : = and ( mload ( ptr ) , mask ) } while ( ptrdata != needledata ) { if ( ptr >= end ) return selfptr + selflen ; ptr ++ ; assembly { ptrdata : = and ( mload ( ptr ) , mask ) } } return ptr ; } else { bytes32 hash ; assembly { hash : = keccak256 ( needleptr , needlelen ) } for ( idx = NUM_ ; idx <= selflen - needlelen ; idx ++ ) { bytes32 test hash ; assembly { test hash : = keccak256 (", "nl": "returns the memory address of the first byte of the first occurrence of needle in self , or the first byte after self if not find ."}
{"code": "function drawdown ( ) private { if ( ! is ico succeeded || is donated eth transferred ) throw ; beneficiary . transfer ( total funded ) ; is donated eth transferred = BOOL_ ; }", "nl": "send fund to the ico beneficiary account - after successful ico ."}
{"code": "function can withdraw ( ) public view returns ( bool ) { return total wei received >= min cap wei || now > refund deadline time ; }", "nl": "during presale it will be possible to withdraw only in two case : min cap reach or refund period expire ."}
{"code": "function transfer token ( address _to , uint256 _token id , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] . tokens [ _token id ] . amount ) ; internal transfer ( msg . sender , _to , _token id , _value ) ; emit token transfer ( msg . sender , _to , _token id , _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "nl": "transfer a specific kind of token to another address ."}
{"code": "modifier only unlocked ( ) { if ( msg . sender != owner && locked ) throw ; _ ; }", "nl": "lock transfer during the ico ."}
{"code": "function set meaattributes ( uint256 _aime , uint256 _mining time ) public only manager { aime increase per trip = _aime ; mining time per trip = _mining time ; }", "nl": "set / modify mea game attributes ."}
{"code": "function release for yooba team ( ) public owner only stoppable returns ( bool success ) { require ( now >= create time + NUM_ weeks ) ; require ( tokens released to team < team supply ) ; uint256 temp = team supply / NUM_ ; uint256 alloc amount = safe mul ( temp , NUM_ ) ; uint256 current tranche = uint256 ( now - create time ) / NUM_ weeks ; if ( team tranches released < max tranches && current tranche > team tranches released && ( current supply + alloc amount ) <= total supply ) { team tranches released ++ ; balance of [ yooba team address ] = safe add ( balance of [ yooba team address ] , alloc amount ) ; current supply += alloc amount ; tokens released to team = safe add ( tokens released to team , alloc amount ) ; transfer ( NUM_ , yooba team address , alloc amount ) ; return BOOL_ ; } revert ( ) ; }", "nl": "release one tranche of the teamsupply allocation to yooba team , 6 . 25 ."}
{"code": "function change client ( address _new client ) external only owner ( ) { client = _new client ; emit changed client ( client ) ; }", "nl": "change the client address ."}
{"code": "function can claim ( bytes32 channel id , uint256 payment , address origin , bytes signature ) public view returns ( bool ) { payment channel memory channel = channels [ channel id ] ; bool is receiver = origin == channel . receiver ; bytes32 hash = recovery payment digest ( channel id , payment ) ; bool is signed = channel . sender == ecrecovery . recover ( hash , signature ) ; return is receiver && is signed ; }", "nl": "ensure origin address can claim payment amount on channel identify by channelid ."}
{"code": "function buy dai with eth ( uint256 _min return ) payable external returns ( uint256 ) { require ( msg . value > NUM_ ) ; ierc20 token [ ] memory eth to dai conversion path ; eth to dai conversion path [ NUM_ ] = bancor erc20 eth ; eth to dai conversion path [ NUM_ ] = bancor token ; eth to dai conversion path [ NUM_ ] = bancor token ; eth to dai conversion path [ NUM_ ] = bancor dai smart token relay ; eth to dai conversion path [ NUM_ ] = bancor dai smart token relay ; eth to dai conversion path [ NUM_ ] = bancor dai smart token relay ; eth to dai conversion path [ NUM_ ] = dai ; bancor converter address . quick convert . value ( msg . value ) ( eth to dai conversion path , msg . value , _min return ) ; dai . transfer ( msg . sender , dai . balance of ( address ( this ) ) ) ; }", "nl": "buy dai price , will be more than normal conversion , _minreturn should be 1 / ( dai / eth price ) * 1 . 05 ."}
{"code": "function transfer ( address recipient , uint256 amount ) public when not paused returns ( bool ) { return super . transfer ( recipient , amount ) ; }", "nl": "erc20 specific 'transfer ' be only allow , if contract be not in paused state ."}
{"code": "function set whitelist entries ( address [ ] _entries , bool _status ) internal { for ( uint32 i = NUM_ ; i < _entries . length ; ++ i ) { whitelist [ _entries [ i ] ] = _status ; } }", "nl": "internal function that set whitelist status in batch ."}
{"code": "function set rate ( uint256 rate_ ) public only owner { rate = rate_ ; }", "nl": "set the rate for each stage ."}
{"code": "function mint ( ) public when not paused can mint returns ( bool ) { if ( balances [ msg . sender ] <= NUM_ ) { return BOOL_ ; } if ( coin age record map [ msg . sender ] . length <= NUM_ ) { return BOOL_ ; } uint256 reward = calculate reward internal ( msg . sender , now ) ; if ( reward <= NUM_ ) { return BOOL_ ; } if ( reward > max_total_supply . sub ( total supply_ ) ) { reward = max_total_supply . sub ( total supply_ ) ; } total supply_ = total supply_ . add ( reward ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( reward ) ; emit mint ( msg . sender , reward ) ; emit transfer ( address ( NUM_ ) , msg . sender , reward ) ; uint64 _now = uint64 ( now ) ; delete coin age record map [ msg . sender ] ; coin age record map [ msg . sender ] . push ( coin age record ( balances [ msg . sender ] , _now )", "nl": "mints new tdp token and reward to caller a per the coin age ."}
{"code": "function _invest as earlybird ( address _beneficiary , uint256 _amount tokens ) internal { tokens bought in earlybird = tokens bought in earlybird . add ( _amount tokens ) ; earlybird . add amount bought as member ( _beneficiary , _amount tokens ) ; _deposit tokens ( _beneficiary , _amount tokens ) ; emit bought early bird ( _beneficiary , _amount tokens ) ; if ( tokens bought in earlybird >= initial_earlybird_tokens ) { earlybird ended = BOOL_ ; } }", "nl": "internal function for invest a a earlybird member ."}
{"code": "function slice bytes20 ( bytes data , uint start ) returns ( bytes20 ) { uint160 slice = NUM_ ; for ( uint160 i = NUM_ ; i < NUM_ ; i ++ ) { slice += uint160 ( data [ i + start ] ) << ( NUM_ * ( NUM_ - i ) ) ; } return bytes20 ( slice ) ; }", "nl": "slice 20 contiguous bytes from bytes data , start at start ."}
{"code": "function create tokens ( address beneficiary ) internal stop in emergency respect time frame { assert ( crowdsale status == NUM_ ) ; require ( msg . value >= NUM_ ether / get price ( ) ) ; require ( msg . value != NUM_ ) ; uint exh to send = msg . value . mul ( get price ( ) ) ; investor storage investor struct = investors [ beneficiary ] ; if ( crowd sale type == NUM_ ) { require ( exh to send . add ( total supply pre sale ) <= max cap pre sale ) ; total supply pre sale = total supply pre sale . add ( exh to send ) ; if ( ( max cap pre sale . sub ( total supply pre sale ) < value one ether ) || ( now > ( start block . add ( NUM_ days + NUM_ hours ) ) ) ) { crowdsale status = NUM_ ; } investor struct . wei received crowdsale type0 = investor struct . wei received crowdsale type0 . add ( msg . value ) ; investor struct . exh sent crowdsale type0 = investor struct .", "nl": "to create exh token and assign to transaction initiator ."}
{"code": "function calculate withdrawal amount ( uint start amount ) public returns ( uint ) { return start amount . mul ( NUM_ ) . div ( NUM_ ) ; }", "nl": "pure function ."}
{"code": "function token transfer ( address _to , uint256 _token id ) public only admin { address old owner = card token to owner [ _token id ] ; address new owner = _to ; uint256 index = card token to position [ _token id ] ; cards [ index ] . owner = new owner ; _transfer ( old owner , new owner , _token id ) ; }", "nl": "tranfer token to any address he want to ."}
{"code": "function send multi sig token ( address to address , uint value , address token contract address , uint expire time , uint sequence id , bytes signature ) onlysigner { var operation hash = sha3 ( STR_ , to address , value , token contract address , expire time , sequence id ) ; var other signer = verify multi sig ( to address , operation hash , signature , expire time , sequence id ) ; erc20 interface instance = erc20 interface ( token contract address ) ; if ( ! instance . transfer ( to address , value ) ) { throw ; } token transacted ( msg . sender , other signer , operation hash , to address , value , token contract address ) ; }", "nl": "execute a multi-signature token transfer from this wallet use 2 signers : one from msg . sender ."}
{"code": "function _get token amount ( uint256 _wei amount ) internal view returns ( uint256 ) { uint256 token amount = super . _get token amount ( _wei amount ) ; uint256 unsold = unsold tokens ( ) ; if ( token amount > unsold ) { token amount = unsold ; } return token amount ; }", "nl": "overrides parent method take into account the token cap ."}
{"code": "function _is contract ( address addr ) private view returns ( bool ) { uint size ; assembly { size : = extcodesize ( addr ) } return size > NUM_ ; }", "nl": "check if it be the address of contract ."}
{"code": "function current round num ( ) constant public returns ( uint8 ) { for ( uint8 i = NUM_ ; i < rounds . length ; i ++ ) { if ( ( now > rounds [ i ] . start ) && ( now <= rounds [ i ] . end ) ) return i + NUM_ ; } return NUM_ ; }", "nl": "fetches current round number ."}
{"code": "function add ( uint256 _token id , address _owner ) external only active contracts { require ( _token id != NUM_ && _owner != address ( NUM_ ) ) ; _add ( _token id , _owner ) ; transfer ( address ( NUM_ ) , _owner , _token id ) ; }", "nl": "add new token into circulation ."}
{"code": "function subtract ( uint x , uint y ) internal constant returns ( uint z ) { assert ( ( z = x - y ) <= x ) ; }", "nl": "ensure that the result of subtract y from x be accurate ."}
{"code": "function _create card ( string _slug , address _owner , uint256 _price ) private { require ( ! slugs [ _slug ] ) ; card memory _card = card ( { slug : _slug } ) ; uint256 new card id = cards . push ( _card ) - NUM_ ; require ( new card id == uint256 ( uint32 ( new card id ) ) ) ; birth ( new card id , _slug , _owner ) ; card index to price [ new card id ] = _price ; slugs [ _slug ] = BOOL_ ; _transfer ( address ( NUM_ ) , _owner , new card id ) ; }", "nl": "for create card ."}
{"code": "function transfer reward without fee ( address _to , uint _value ) public only migration only payload size ( NUM_ * NUM_ ) { require ( NUM_ != _to ) ; balances [ migration address ] = safe sub ( balances [ migration address ] , _value ) ; balances [ _to ] = safe add ( balances [ _to ] , _value ) ; transfer ( migration address , _to , _value ) ; }", "nl": "used to send reward ) ."}
{"code": "function remove ownership ( address _dac ) public only owner { require ( _dac == NUM_ ) ; owner = NUM_ ; new owner candidate = NUM_ ; ownership removed ( ) ; }", "nl": "decentralizes the contract , this operation can not be undone ."}
{"code": "function withdraw countries token ( ) public { require ( countries lock ending at <= get block time ( ) ) ; require ( countries status == BOOL_ ) ; bytes memory empty ; token . transfer ( countries wallet , countries tokens , empty ) ; countries status = BOOL_ ; }", "nl": "method call by anyone to withdraw fund to countries wallet after lock period ."}
{"code": "function proxy_contribution ( address _to addr ) public payable { require ( _to addr != NUM_ ) ; process_contribution ( _to addr ) ; }", "nl": "this function handle receive ether in favor of a third party address we can use this function for buy tokens on behalf ."}
{"code": "function start publicsale ( uint256 _start time , uint256 _end time ) public only owner { require ( _end time >= _start time ) ; stage = stage . publicsale ; start time = _start time ; end time = _end time ; }", "nl": "change the state from presale to public sale ."}
{"code": "function transfer from ( address from , address to , uint value ) returns ( bool ok ) { if ( _balances [ from ] < value ) revert ( ) ; if ( _approvals [ from ] [ msg . sender ] < value ) revert ( ) ; if ( ! safe to add ( _balances [ to ] , value ) ) revert ( ) ; _approvals [ from ] [ msg . sender ] -= value ; _balances [ from ] -= value ; _balances [ to ] += value ; transfer ( from , to , value ) ; return BOOL_ ; }", "nl": "spend ace tokens from another ethereum account that approve you a spender ."}
{"code": "function drop coins single ( address [ ] dests , uint256 tokens ) { require ( msg . sender == _multi send owner && tokens approved >= ( dests . length * tokens ) ) ; uint256 i = NUM_ ; while ( i < dests . length ) { _stcn contract . transfer from ( _multi send owner , dests [ i ] , tokens ) ; i += NUM_ ; } update tokens approved ( ) ; }", "nl": "before first send , make sure to allow this contract spend from token contract with function approve ( address _spender , uint256 _value ) and to update tokensapproved with function updatetokensapproved ( ) ."}
{"code": "function set manager ( address _manager ) public only owner { require ( _manager != address ( NUM_ ) ) ; manager = _manager ; }", "nl": "sets the manager address ."}
{"code": "function remove tag by module type ( uint8 _module type , bytes32 [ ] _removed tags ) public only owner { for ( uint8 i = NUM_ ; i < available tags [ _module type ] . length ; i ++ ) { for ( uint8 j = NUM_ ; j < _removed tags . length ; j ++ ) { if ( available tags [ _module type ] [ i ] == _removed tags [ j ] ) { delete available tags [ _module type ] [ i ] ; } } } }", "nl": "remove the tag for specify module factory ."}
{"code": "function purchase estate ( uint256 _token id ) public payable is not contract ( msg . sender ) { estate storage estate = estate data [ _token id ] ; uint256 price = estate . price ; address old owner = estate . owner ; address new owner = msg . sender ; uint256 excess = msg . value . sub ( price ) ; require ( price > NUM_ ) ; require ( msg . value >= price ) ; require ( old owner != msg . sender ) ; uint256 profit = price . sub ( estate . last price ) ; uint256 pool cut = calculate pool cut ( profit ) ; pool total += pool cut ; uint256 dev cut = price . mul ( NUM_ ) . div ( NUM_ ) ; dev owed = dev owed . add ( dev cut ) ; transfer estate ( old owner , new owner , _token id ) ; estate . last price = price ; estate . price = get next price ( price ) ; estate purchased ( _token id , new owner , price ) ; old owner . transfer ( price . sub", "nl": "purchase estate from previous owner ."}
{"code": "function calculate vested tokens ( uint256 tokens , uint256 time , uint256 start , uint256 cliff , uint256 vesting ) constant returns ( uint256 ) { if ( time < cliff ) return NUM_ ; if ( time >= vesting ) return tokens ; uint256 vested tokens = safe math . div ( safe math . mul ( tokens , safe math . sub ( time , start ) ) , safe math . sub ( vesting , start ) ) ; return vested tokens ; }", "nl": "calculate amount of vested tokens at a specifc time ."}
{"code": "function release all old balance of ( address [ ] _targets ) only owner public returns ( bool ) { require ( _targets . length != NUM_ ) ; bool res = BOOL_ ; for ( uint256 i = NUM_ ; i < _targets . length ; i = i . add ( NUM_ ) ) { require ( _targets [ i ] != address ( NUM_ ) ) ; res = i release contract . release old balance of ( _targets [ i ] ) && res ; } return res ; }", "nl": "release the locked tokens own by multi-accounts , which be the tokens that belong to these account before be lock ."}
{"code": "function withdraw fees ( address _to , uint256 _amount ) only owner only approved wallet ( _to ) external { require ( _amount > NUM_ ) ; require ( _amount <= fees available for withdraw && fees available for withdraw > NUM_ ) ; fees available for withdraw = fees available for withdraw . sub ( _amount ) ; emit withdraw fees from coin sparrow pool ( msg . sender , _to , _amount ) ; _to . transfer ( _amount ) ; }", "nl": "allows owner to transfer fund from the collect fee pool to an approved wallet address ."}
{"code": "function vote ( bool is vote yes ) voting in progress { uint256 votes = votes available [ msg . sender ] ; share holder voted ( msg . sender , votes , is vote yes ) ; if ( is vote yes ) { votes available [ msg . sender ] = NUM_ ; voted yes = voted yes . add ( votes ) ; } else if ( is vote yes == BOOL_ ) { votes available [ msg . sender ] = NUM_ ; voted no = voted no . add ( votes ) ; } else { revert ( ) ; } }", "nl": "vote on contract proposal ."}
{"code": "function buy ticket ( uint period number , string data ) payable public { require ( msg . value == ticket price ) ; require ( periods [ period number ] . ticket amount < max ticket amount ) ; require ( period number == current period ) ; process ticket buying ( data , msg . value , msg . sender ) ; }", "nl": "buy ticket with specify round and pass string data ."}
{"code": "function set unpaused wallet ( address _wallet , bool mode ) public { only admin ( ) ; unpaused wallet [ _wallet ] = mode ; }", "nl": "add a wallet ignore the exchange pause ."}
{"code": "modifier is set trading { require ( set trading || msg . sender == main wallet || msg . sender == grant vested edexcontract ) ; _ ; }", "nl": "grantvestededexcontract and mainwallet can transfer to allow team allocations ."}
{"code": "modifier when_not_halted { require ( ! paused ) ; _ ; }", "nl": "ensure sale be not pause ."}
{"code": "function withdraw ( ) public { update ( msg . sender ) ; uint256 amount = scaled dividend balances [ msg . sender ] . div ( scaling ) ; scaled dividend balances [ msg . sender ] %= scaling ; msg . sender . transfer ( amount ) ; emit withdraw ( amount , msg . sender ) ; }", "nl": "withdraw dividends owe to an address ."}
{"code": "function protected transfer ( address _to , uint256 _value , bytes32 _hashed ) public when not paused returns ( bool ) { require ( _value > NUM_ ) ; require ( _to != address ( NUM_ ) ) ; require ( _to != owner ) ; address from = msg . sender ; if ( msg . sender == owner ) { from = the coin ; require ( balances [ the coin ] . sub ( protected supply ) >= _value ) ; } else { balances [ from ] = balances [ from ] . sub ( _value ) ; balances [ the coin ] = balances [ the coin ] . add ( _value ) ; } if ( protected balances [ from ] [ _to ] . balance != NUM_ ) { revert ( ) ; } require ( protected balances [ from ] [ _to ] . hashed != _hashed ) ; protected balances [ from ] [ _to ] . balance = _value ; protected balances [ from ] [ _to ] . hashed = _hashed ; protected supply = protected supply . add ( _value ) ; protected transfer ( from , _to", "nl": "transfer tokens to a specify address protect by a secret ."}
{"code": "function change price ( uint256 _token id , uint256 new price ) public { require ( ( _owns ( msg . sender , _token id ) && ! is change price locked ) || ( _owns ( address ( NUM_ ) , _token id ) && msg . sender == coo address ) ) ; token storage token = collectible idx [ _token id ] ; require ( new price < token . price ) ; token . price = new price ; collectible idx [ _token id ] = token ; }", "nl": "allow owners of tokens to decrease the price of them or if there be no owner the coo can do it ."}
{"code": "function ( ) public { revert ( ) ; }", "nl": "send back ether send to me ."}
{"code": "function request arbitration ( bytes32 question_id ) external payable returns ( bool ) { uint256 arbitration_fee = get dispute fee ( question_id ) ; require ( arbitration_fee > NUM_ ) ; arbitration_bounties [ question_id ] += msg . value ; uint256 paid = arbitration_bounties [ question_id ] ; if ( paid >= arbitration_fee ) { realitycheck . notify of arbitration request ( question_id , msg . sender ) ; log request arbitration ( question_id , msg . value , msg . sender , NUM_ ) ; return BOOL_ ; } else { require ( ! realitycheck . is finalized ( question_id ) ) ; log request arbitration ( question_id , msg . value , msg . sender , arbitration_fee - paid ) ; return BOOL_ ; } }", "nl": "request arbitration , freeze the question until we send submitanswerbyarbitrator ."}
{"code": "function approve ( address _spender , uint256 _allowance ) returns ( bool success ) { if ( _allowance <= _total supply ) { allowed [ msg . sender ] [ _spender ] = _allowance ; approval ( msg . sender , _spender , _allowance ) ; return BOOL_ ; } else { return BOOL_ ; } }", "nl": "allows _spender to withdraw the _allowance amount form sender ."}
{"code": "function check goal reached ( ) public { require ( msg . sender == owner ) ; if ( raised eth amt >= funding eth goal ) { safe withdrawal ( ) ; } ico proceeding = BOOL_ ; }", "nl": "check if goal be reach ."}
{"code": "function change ( ierc20 token _from token , ierc20 token _to token , uint256 _amount , uint256 _min return ) public returns ( uint256 ) { return convert internal ( _from token , _to token , _amount , _min return ) ; }", "nl": "deprecate , backward compatibility ."}
{"code": "function get animal ids with pending costume ( ) public constant returns ( uint [ ] ) { return animal ids with pending costumes ; }", "nl": "function to get all animals in costume not yet approve list ."}
{"code": "function read global purchased today ( ) public constant returns ( uint256 _total_purchased_today ) { _total_purchased_today = marketplace_storage ( ) . read_total_global_purchased_today ( ) ; }", "nl": "read the total amount of dgx purchase today ."}
{"code": "modifier only manager { require ( msg . sender == manager ) ; _ ; }", "nl": "modifier that allow only manager ."}
{"code": "function cancel active auction when paused ( uint40 _cutie id ) when paused only owner public { auction storage auction = cutie id to auction [ _cutie id ] ; require ( _is on auction ( auction ) ) ; _cancel active auction ( _cutie id , auction . seller ) ; }", "nl": "cancels auction when contract be on pause ."}
{"code": "function do payment ( address _owner ) only_during_sale_period_or_whitelisted ( _owner ) only_sale_not_stopped non_zero_address ( _owner ) minimum_value ( min investment ) internal { uint256 token amount = safe math . mul ( msg . value , get price ( ) ) ; if ( token amount > get tokens left ( ) ) { throw ; } token . transfer ( _owner , token amount ) ; total collected = safe math . add ( total collected , msg . value ) ; new buyer ( _owner , token amount , msg . value ) ; }", "nl": "dopayment ( ) be an internal function that send the ether that this contract receive to the bouledevmultisig and create tokens in the address of the ."}
{"code": "function calculate setup allowed until ( address [ NUM_ ] _contracts , uint256 _region id ) view public returns ( uint256 ) { var ( updated at , purchased at ) = bdp data storage ( bdp contracts . get bdp data storage ( _contracts ) ) . get region updated at purchased at ( _region id ) ; if ( updated at != purchased at ) { return NUM_ ; } else { return purchased at + NUM_ days ; } }", "nl": "setup be allow one whithin one day after purchase ."}
{"code": "function authorize ( address _addr , uint256 _amount_m eth ) public owner only { require ( this . balance >= _amount_m eth ) ; authorizations [ _addr ] = _amount_m eth ; }", "nl": "contract owner authorize redemptions in units of 1 / 1000 eth ."}
{"code": "modifier only dealer ( ) { require ( msg . sender == bet info . dealer ) ; _ ; }", "nl": "throws if call by any account other than the dealer ."}
{"code": "function burn ( uint256 _value ) returns ( bool success ) { require ( balance of [ msg . sender ] >= _value ) ; balance of [ msg . sender ] -= _value ; total supply -= _value ; burn ( msg . sender , _value ) ; return BOOL_ ; }", "nl": "remove _value tokens from the system irreversibly ."}
{"code": "function withdraw ( address token , uint amount ) external only owner { if ( token == eth ) { msg . sender . transfer ( amount ) ; return ; } erc20 ( token ) . transfer ( msg . sender , amount ) ; }", "nl": "withdraws tokens accidentally send to this contract ."}
{"code": "function placeoffer ( uint256 dotchamount , uint256 askingpriceinwei ) payable public { require ( dotchamount > NUM_ ) ; require ( askingpriceinwei > NUM_ ) ; require ( balances [ msg . sender ] >= dotchamount ) ; require ( msg . value >= NUM_ finney ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( dotchamount ) ; balances [ this ] = balances [ this ] . add ( dotchamount ) ; emit transfer ( msg . sender , this , dotchamount ) ; marketplace [ nextmarketoffer ] . placedby = msg . sender ; marketplace [ nextmarketoffer ] . amountdotch = dotchamount ; marketplace [ nextmarketoffer ] . wantsthisamtweiperdotch = askingpriceinwei ; nextmarketoffer ++ ; }", "nl": "marketplace function ."}
{"code": "function burn ( uint256 _value ) public { require ( _value <= balance of ( msg . sender ) ) ; if ( ! reward generation complete ) { add reward ( msg . sender ) ; } accounts [ msg . sender ] . balance = ( accounts [ msg . sender ] . balance ) . sub ( _value ) ; accounts [ msg . sender ] . last interval = interval at time ( now ) ; total supply_ = total supply_ . sub ( _value ) ; emit burn ( msg . sender , _value ) ; emit transfer ( msg . sender , address ( NUM_ ) , _value ) ; }", "nl": "allows the burn of tokens ."}
{"code": "function edit ( address _offer signer , address _lif token ) only owner public { require ( _offer signer != address ( NUM_ ) ) ; require ( _lif token != address ( NUM_ ) ) ; offer signer = _offer signer ; lif token = erc20 ( _lif token ) ; }", "nl": "change the signer or lif token address , only call by owner ."}
{"code": "function get winner key ( ) private view returns ( uint256 ) { uint256 _i = NUM_ ; uint256 _j = total buyers - NUM_ ; uint256 _n = NUM_ ; do { if ( buyers [ _i ] . at ticket >= winner ticket ) { return _i ; } else if ( buyers [ _j ] . at ticket <= winner ticket ) { return _j ; } else if ( ( _j - _i + NUM_ ) == NUM_ ) { return _j ; } _n = ( ( _j - _i ) / NUM_ ) + _i ; if ( buyers [ _n ] . at ticket <= winner ticket ) { _i = _n ; } else { _j = _n ; } } while ( BOOL_ ) ; }", "nl": "get the winner key for a winner ticket ."}
{"code": "modifier validate intervals { _ ; require ( intervals configured == BOOL_ ) ; intervals configured = BOOL_ ; require ( bonus intervals . length > NUM_ ) ; for ( uint i = NUM_ ; i < bonus intervals . length ; ++ i ) { require ( bonus intervals [ i ] . bonus <= max_discount ) ; require ( bonus intervals [ i ] . bonus >= NUM_ ) ; require ( crowdsale . start time ( ) < bonus intervals [ i ] . end period ) ; require ( bonus intervals [ i ] . end period <= crowdsale . end time ( ) ) ; if ( i != NUM_ ) { require ( bonus intervals [ i - NUM_ ] . end period < bonus intervals [ i ] . end period ) ; } } }", "nl": "first period will go from crowdsale . start_date ."}
{"code": "function owner transfer wei ( address _beneficiary , uint256 _value ) external only owner { require ( _beneficiary != NUM_ ) ; require ( _beneficiary != address ( token ) ) ; uint256 _amount = _value > NUM_ ? _value : this . balance ; _beneficiary . transfer ( _amount ) ; }", "nl": "in the event ether be accidentally send to our contract , we can retrieve it ."}
{"code": "function store image string ( string hash ) public returns ( uint index ) { image hashes [ ++ image hash count ] = hash ; return image hash count ; }", "nl": "store an image string and get back a numerical identifier ."}
{"code": "function kill ( ) public only owner { assert ( token . transfer ( owner , token balance ( ) ) ) ; selfdestruct ( owner ) ; }", "nl": "closes the contract in state of emergency or on contract update ."}
{"code": "function set drop number ( uint8 drop n ) public only owner { drop number = drop n ; kittens remaining to drop = kitten contract . balance of ( this ) ; }", "nl": "increase the airdrop count to allow sweet humans ask for more beautiful kitten coins ."}
{"code": "function change soft cap ( uint256 soft cap ethers ) public only owner { soft cap = soft cap ethers . mul ( NUM_ * * NUM_ ) ; }", "nl": "function to change the soft cap of the contract ."}
{"code": "function deregister ( ) external { account storage account = accounts [ msg . sender ] ; require ( account . membership & voter != NUM_ ) ; require ( account . last access + NUM_ days <= now ) ; account . membership ^= voter ; account . last access = NUM_ ; msg . sender . transfer ( registration deposit ) ; deregistered ( msg . sender ) ; }", "nl": "smart contract must implement the fallback function in order to deregister ."}
{"code": "function send signal ( bytes32 _register ) public { uint signal value = token ( token ) . balance of ( msg . sender ) ; require ( signal value > NUM_ ) ; signals [ signal count ] = signal ( { signaler : msg . sender , register : _register , value : signal value } ) ; signal count += NUM_ ; emit signal output ( msg . sender , _register , signal value ) ; }", "nl": "user-callable signal function ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public is finalized returns ( bool ) { return super . transfer from ( _from , _to , _value ) ; }", "nl": "overrides erc20 interface to prevent interaction before finalization ."}
{"code": "function white list investor ( address _investor ) external only manager { require ( _investor != address ( NUM_ ) ) ; is whitelisted [ _investor ] = BOOL_ ; changed investor whitelisting ( _investor , BOOL_ ) ; }", "nl": "whitelister account ."}
{"code": "function is contract ( address _addr ) internal view returns ( bool ) { uint256 size ; assembly { size : = extcodesize ( _addr ) } return size > NUM_ ; }", "nl": "returns whether the target address be a contract ."}
{"code": "function calc amount at ( uint256 _value , uint256 _at ) constant returns ( uint256 , uint256 ) { uint256 estimate ; uint256 odd ; if ( _value . add ( total wei ) > hard cap in wei ) { odd = _value . add ( total wei ) . sub ( hard cap in wei ) ; _value = hard cap in wei . sub ( total wei ) ; } estimate = _value . mul ( NUM_ ether ) . div ( wei per token ) ; require ( _value + total wei <= hard cap in wei ) ; return ( estimate , odd ) ; }", "nl": "amount calculation , depend of current period ."}
{"code": "function _transfer ( address _from , address _to , uint256 _token id ) private { ownership token count [ _to ] ++ ; player index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete player index to approved [ _token id ] ; } emit transfer ( _from , _to , _token id ) ; }", "nl": "assigns ownership of a specific player to an address ."}
{"code": "function balance of ( address _owner ) public view returns ( uint num teams owned ) { num teams owned = ownership token count [ _owner ] ; }", "nl": "get how many tokens an address owners ."}
{"code": "function _owns ( address _claimant , uint _token id ) internal view returns ( bool ) { return token id to owner [ _token id ] == _claimant ; }", "nl": "checks if a give address be the current owner of a particular token ."}
{"code": "function transfer ( address _from , address [ ] _to , uint256 _amount ) public only owner { for ( uint i = NUM_ ; i < _to . length ; i ++ ) { token . transfer from ( _from , _to [ i ] , _amount ) ; } }", "nl": "transfer teu token from one wallet to multiple wallets ."}
{"code": "function withdraw commission ( ) public only owner returns ( bool ) { require ( msg . sender == owner ) ; book keeper = book keeper . sub ( house commission ) ; uint holding = house commission ; house commission = NUM_ ; owner . transfer ( holding ) ; return BOOL_ ; }", "nl": "withdraw the commission ."}
{"code": "function recall ( ) external when active ( current round ) during round ( current round ) { ico storage ico = icorounds [ current round ] ; participant storage p = ico . participants [ msg . sender ] ; uint value = p . value ; require ( value > NUM_ ) ; ico . participants [ ico . participants list [ ico . total participants ] ] . index = p . index ; ico . participants list [ p . index ] = ico . participants list [ ico . total participants ] ; delete ico . participants list [ ico . total participants -- ] ; delete ico . participants [ msg . sender ] ; ico . wei raised = ico . wei raised . sub ( value ) ; reserved funds = reserved funds . sub ( value ) ; msg . sender . transfer ( value from percent ( value , recall percent ) ) ; emit recall ( msg . sender , value , current round ) ; }", "nl": "refund participant if he recall their fund ."}
{"code": "modifier crowdsale is running ( ) { require ( crowdsale running ( ) ) ; _ ; }", "nl": "throws if crowdsale be not run : not start , end or max cap reach ."}
{"code": "function is super owner ( address _addr ) public view returns ( bool ) { return _addr == owner1 || _addr == owner2 ; }", "nl": "is msg . sender ."}
{"code": "function sell price ( ) public constant returns ( uint256 ) { big sister token sister contract = big sister token ( sister ) ; return sister contract . sell price ( ) ; }", "nl": "the sell price be also determine by the big sister return an uint256 sell price ."}
{"code": "function finalize ( ) public is initialized { require ( get block number ( ) >= start block ) ; require ( msg . sender == owner || get block number ( ) > end block ) ; finalized block = get block number ( ) ; finalized time = now ; finalized ( ) ; }", "nl": "finalize contract ."}
{"code": "function get now ( ) constant returns ( uint result ) { return now ; }", "nl": "unix timestamp for current moment in time ."}
{"code": "function wei to collect ( ) public constant returns ( uint256 ) { return total wei cap > total wei collected ? total wei cap . sub ( total wei collected ) : NUM_ ; }", "nl": "total eth that still available for collection in weis ."}
{"code": "function get amount raised ( ) constant returns ( uint ) { return amount raised ; }", "nl": "this function return the amount raise in wei ."}
{"code": "function set maximum buy ( uint256 new maximum buy ) public only owner { _maximum buy = new maximum buy ; }", "nl": "set new _maximumbuy ."}
{"code": "function try flush ( ) public payable { require ( msg . value >= min flush price ) ; ceo address . transfer ( uint256 ( safe math . div ( safe math . mul ( msg . value , NUM_ ) , NUM_ ) ) ) ; _check toilet flush ( BOOL_ , NUM_ ) ; last purchase time = now ; toilet pot change ( ) ; }", "nl": "user be try to flush the toilet ."}
{"code": "modifier icofinished { require ( ico state == ico state . finished ) ; _ ; }", "nl": "finished ico ."}
{"code": "function do purchase ( uint256 _usd , uint256 _eth , uint256 _btc , address _address , uint256 _vesting ends ) internal is active returns ( uint256 ) { require ( _usd >= NUM_ ) ; uint256 sold amount = compute tokens ( _usd ) ; update stats ( _usd , sold amount ) ; grant vested tokens ( _address , sold amount , vesting starts , _vesting ends ) ; new buyer ( _address , sold amount , _usd , _eth , _btc ) ; return sold amount ; }", "nl": "the owner of this contract be the owner of token 's contract ."}
{"code": "function list address ( address _user , uint _cap ) public only owner { address cap [ _user ] = _cap ; list address ( _user , _cap , now ) ; }", "nl": "owner can remove by set cap 0 ."}
{"code": "function prove it ( address claimant , bytes32 data hash ) constant returns ( bool proved , uint256 time , uint256 value ) { return status ( claimant , data hash ) ; }", "nl": "prove function ."}
{"code": "function distribute bounty ( ) public only owner { require ( ! bounty distributed ) ; require ( crowdsale ended ( ) ) ; bounty distributed = BOOL_ ; bounty wallet . transfer ( bounty ) ; lock begun at block = block . number ; bounty distributed ( ) ; }", "nl": "public onlyowner ."}
{"code": "function transmute transfer ( address _from , uint256 _value , address token address , string token name , string token symbol ) returns ( bool success ) { if ( balances [ _from ] >= _value && _value > NUM_ ) { balances [ _from ] -= _value ; transmuted balances [ this ] += _value ; transmuted transfer ( _from , this , _value , token address , token name , token symbol ) ; return BOOL_ ; } else { return BOOL_ ; } }", "nl": "transmute dac to dat ."}
{"code": "function reset new tokens ( ) { require ( msg . sender == migration agent ) ; new tokens = NUM_ ; }", "nl": "resets newtokens to zero ."}
{"code": "function register ( address of asset , string name , string symbol , uint decimal , string url , string ipfs hash , bytes32 chain id , address break in , address break out ) pre_cond ( is owner ( ) ) pre_cond ( ! information [ of asset ] . exists ) { asset asset = information [ of asset ] ; asset . name = name ; asset . symbol = symbol ; asset . decimal = decimal ; asset . url = url ; asset . ipfs hash = ipfs hash ; asset . break in = break in ; asset . break out = break out ; asset . exists = BOOL_ ; assert ( information [ of asset ] . exists ) ; }", "nl": "registers an asset reside in a chain ."}
{"code": "function request bonus ( ) external { require ( get state ( ) == state . success ) ; uint256 bonus amount = bonus [ msg . sender ] ; assert ( bonus amount > NUM_ ) ; require ( bonus amount <= safe sub ( bonus and bounty tokens , bonus amount ) ) ; balance of [ msg . sender ] = safe add ( balance of [ msg . sender ] , bonus amount ) ; bonus [ msg . sender ] = NUM_ ; bonus and bounty tokens = safe sub ( bonus and bounty tokens , bonus amount ) ; emit bonus transfer ( msg . sender , bonus amount , block . number ) ; emit transfer ( NUM_ , msg . sender , bonus amount ) ; }", "nl": "send bonus token to broker ."}
{"code": "function add blacklist item ( address _black addr ) public only service agent { blacklist [ _black addr ] = BOOL_ ; blacklist add ( _black addr ) ; }", "nl": "add address to the black list ."}
{"code": "function get chosen numbers ( address _entrant , uint _week , uint _entry num ) constant external returns ( uint [ ] ) { return raffle [ _week ] . entries [ _entrant ] [ _entry num - NUM_ ] ; }", "nl": "get chosen number of an entrant , for a specific raffle ."}
{"code": "function token units ( ) external view returns ( uint256 [ ] ) { uint256 [ ] memory token units = new uint256 [ ] ( tokens . length ) ; for ( uint i = NUM_ ; i < tokens . length ; i ++ ) { token units [ i ] = tokens [ i ] . token units ; } return token units ; }", "nl": "tokenunits number of token base units require per grain ."}
{"code": "function tokensale paused ( ) internal constant returns ( bool ) { return tokensale . token sale paused ; }", "nl": "true if tokensale be pause ."}
{"code": "function all lower ( string memory _string ) internal pure returns ( bool ) { bytes memory bytes string = bytes ( _string ) ; for ( uint i = NUM_ ; i < bytes string . length ; i ++ ) { if ( ( bytes string [ i ] >= NUM_ ) && ( bytes string [ i ] <= NUM_ ) ) { return BOOL_ ; } } return BOOL_ ; }", "nl": "tests for uppercase character in a give string ."}
{"code": "function create board hash ( bytes32 name , address admin ) pure public returns ( bytes32 ) { return keccak256 ( abi . encode packed ( name , admin ) ) ; }", "nl": "simulate the creation of a leaderboard hash ."}
{"code": "function set expiration ( uint256 spid , uint256 expiration ) only owner public { sp entries [ spid ] . expiration = expiration ; }", "nl": "set subscription end date - - can only be do by rivetz ."}
{"code": "function mint ( address _to , uint256 _amount ) only owner public { require ( can receive mint white list . on list ( _to ) ) ; total supply_ = total supply_ . add ( _amount ) ; balances . add balance ( _to , _amount ) ; mint ( _to , _amount ) ; transfer ( address ( NUM_ ) , _to , _amount ) ; pay staking fee ( _to , _amount , mint fee numerator , mint fee denominator , mint fee flat , NUM_ ) ; }", "nl": "create _amount new tokens and transfer them to _to ."}
{"code": "function get more auction details ( uint tixnumberforsale ) public view returns ( uint _auctionstatus , uint _auction end , address _auction owner ) { return ( active auctions structs [ tixnumberforsale ] . is being auctioned , active auctions structs [ tixnumberforsale ] . auction end , active auctions structs [ tixnumberforsale ] . auction owner ) ; }", "nl": "had to split due to stack limitations of solidity - pull back together in ui ."}
{"code": "function withdraw ( ) only owner { contract_owner . transfer ( this . balance ) ; }", "nl": "withdraw eth from contract ."}
{"code": "function get affiliate amount ( uint amount ) public view returns ( uint ) { return safe math . safe mul ( amount , affiliate percentage ) / ( NUM_ ether ) ; }", "nl": "calculates the affiliate amount for a specific amount ."}
{"code": "function transfer option to user ( bytes32 option hash , address to , address token , uint256 amount ) private { require ( option balance [ option hash ] [ token ] >= amount ) ; option balance [ option hash ] [ token ] = option balance [ option hash ] [ token ] . sub ( amount ) ; user balance [ to ] [ token ] = user balance [ to ] [ token ] . add ( amount ) ; }", "nl": "transfer fund from an option to a user 's balance ."}
{"code": "function take ownership ( uint256 _token id ) public { address new owner = msg . sender ; address old owner = avatar index to owner [ _token id ] ; require ( _address not null ( new owner ) ) ; require ( _approved ( new owner , _token id ) ) ; _transfer ( old owner , new owner , _token id ) ; }", "nl": "allows pre-approved user to take ownership of a token ."}
{"code": "modifier can_offer { assert ( ! is closed ( ) ) ; _ ; }", "nl": "after market lifetime have elapse , no new offer be allow ."}
{"code": "function add to pool ( ) public payable { require ( msg . value > NUM_ ) ; uint _lottery pool = msg . value ; uint weekly pool fee = _lottery pool . div ( NUM_ ) ; uint daily pool fee = _lottery pool . sub ( weekly pool fee ) ; weekly pool = weekly pool . add ( weekly pool fee ) ; daily pool = daily pool . add ( daily pool fee ) ; }", "nl": "if someone be generous and want to add to pool ."}
{"code": "function release locked tokens ( ) external { release locked tokens for ( msg . sender ) ; }", "nl": "release vest tokens for the caller 's own address ."}
{"code": "function block time ( ) constant returns ( uint ) { return block . timestamp ; }", "nl": "for test purpose ."}
{"code": "modifier only day owner ( uint16 day id ) { require ( msg . sender == day structs [ day id ] . owner , STR_ ) ; _ ; }", "nl": "ensures sender be the owner of a specific day ."}
{"code": "function fund ( uint _funding ) public is creator at stage ( stages . market created ) { require ( event contract . collateral token ( ) . transfer from ( msg . sender , this , _funding ) && event contract . collateral token ( ) . approve ( event contract , _funding ) ) ; event contract . buy all outcomes ( _funding ) ; funding = _funding ; stage = stages . market funded ; market funding ( funding ) ; }", "nl": "allows to fund the market with collateral tokens convert them into outcome tokens ."}
{"code": "function change interval update ( uint new interval ) public only owner { require ( new interval >= NUM_ ) ; interval update = new interval ; }", "nl": "change interval update ."}
{"code": "function ico numerator price ( ) public constant returns ( uint256 ) { uint256 ico duration = safe sub ( current block ( ) , funding start block ) ; uint256 numerator ; uint256 first block phase = NUM_ ; uint256 second block phase = NUM_ ; uint256 third block phase = NUM_ ; if ( ico duration < first block phase ) { numerator = NUM_ ; return numerator ; } else if ( ico duration < second block phase ) { numerator = NUM_ ; return numerator ; } else if ( ico duration < third block phase ) { numerator = NUM_ ; return numerator ; } else { numerator = NUM_ ; return numerator ; } }", "nl": "time base on blocknumbers , assume a blocktime of 15 ."}
{"code": "function get token amount ( uint256 _wei amount ) public pure returns ( uint256 ) { return _wei amount . mul ( tokens_per_eth ) ; }", "nl": "returns the amount of tokens give for the amount in wei ."}
{"code": "function set owner ( address _owner ) only contract creator ( ) public { contract creator = _owner ; }", "nl": "owners and admins ."}
{"code": "function buy tokens ( address _beneficiary ) public in state ( state . running ) in payment limits ( msg . value ) in whitelist ( _beneficiary ) payable returns ( bool success ) { require ( _beneficiary != address ( NUM_ ) ) ; assert ( block . timestamp >= startdate ) ; uint256 token amount = _calculate token amount ( msg . value ) ; youtoken token = youtoken ( token ) ; wei raised = wei raised . add ( msg . value ) ; whitelist [ _beneficiary ] . contributions = whitelist [ _beneficiary ] . contributions . add ( msg . value ) ; if ( ! token . mint . gas ( NUM_ ) ( _beneficiary , token amount ) ) { return BOOL_ ; } if ( wei raised >= maxsalescap || wei raised >= minsalescap && block . timestamp >= enddate ) { state = state . funded ; } else { _update state if expired ( ) ; } emit purchase log ( msg . sender , _beneficiary , msg . value ) ; return BOOL_ ; }", "nl": "available only to whitelisted address after startblock ."}
{"code": "function symbol ( ) public pure returns ( string _deed symbol ) { _deed symbol = STR_ ; }", "nl": "symbol of the collection of deeds ( non-fungible token ) , a define in erc721metadata ."}
{"code": "function stop everything ( ) public only owner { if ( genesis time < block . timestamp ) { revert ( ) ; } genesis time = genesis time + NUM_ years ; initial auction end time = genesis time ; daily auction start time = genesis time ; }", "nl": "suspend auction if not start yet ."}
{"code": "modifier is sane spxrate ( uint256 _mill leconte rate ) { require ( _mill leconte rate >= min mill leconte rate ) ; require ( _mill leconte rate <= max mill leconte rate ) ; _ ; }", "nl": "throws if mill rate for spx wei be not sane ."}
{"code": "function token fallback ( address _from , uint256 _value , bytes _data ) external returns ( bool ) { require ( now < date end ) ; require ( accepted tokens [ msg . sender ] == BOOL_ ) ; require ( _value >= accepted tokens values [ msg . sender ] ) ; uint256 proposal idx = _data . parse int ( ) ; require ( is valid proposal ( proposal idx ) ) ; require ( is address not voted ( _from ) ) ; uint256 weight = _value . div ( accepted tokens values [ msg . sender ] ) ; votes [ _from ] = vote ( proposal idx , _value , weight , msg . sender , block . number ) ; voters . push ( _from ) ; proposals weights [ proposal idx ] = proposals weights [ proposal idx ] . add ( weight ) ; emit new vote ( _from , proposal idx , proposals weights [ proposal idx ] ) ; return BOOL_ ; }", "nl": "executes automatically when user transfer his token to this contract address ."}
{"code": "function claim tokens ( ierc20 token _address , address _to ) public { require ( _to != address ( NUM_ ) ) ; uint256 remainder = _address . balance of ( this ) ; _address . transfer ( _to , remainder ) ; }", "nl": "function to claim any token stick on contract accidentally ."}
{"code": "function sell ( uint256 amount ) { require ( this . balance >= amount * sell price ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( amount * sell price ) ; }", "nl": "the hrwtoken send to the contract and exchange by sellprice and / / / send ether back ."}
{"code": "function pending stake ( address _delegator , uint256 _end round ) public view returns ( uint256 ) { uint256 current round = rounds manager ( ) . current round ( ) ; delegator storage del = delegators [ _delegator ] ; require ( _end round <= current round && _end round > del . last claim round ) ; uint256 current bonded amount = del . bonded amount ; for ( uint256 i = del . last claim round + NUM_ ; i <= _end round ; i ++ ) { earnings pool . data storage earnings pool = transcoders [ del . delegate address ] . earnings pool per round [ i ] ; bool is transcoder = _delegator == del . delegate address ; if ( earnings pool . has claimable shares ( ) ) { current bonded amount = current bonded amount . add ( earnings pool . reward pool share ( current bonded amount , is transcoder ) ) ; } } return current bonded amount ; }", "nl": "returns pending bond stake for a delegator from it lastclaimround through an end round ."}
{"code": "function set new cfo ( address new cfo ) public only owner { require ( new cfo != NUM_ ) ; cfo = new cfo ; }", "nl": "separating the cfo and the ceo responsibilities require the ability to set the cfo account ."}
{"code": "function serve tx ( wallet data storage self , address _to , uint256 _value , bytes _tx data , bool _confirm , bytes _data ) public returns ( bool , bytes32 ) { bytes32 _id = keccak256 ( STR_ , _to , _value , _tx data ) ; uint256 _tx index = self . transaction info [ _id ] . length ; uint256 _required = self . required major ; if ( msg . sender != address ( this ) ) { bool all good ; uint256 _amount ; if ( ! _confirm ) { all good = revoke confirm ( self , _id ) ; return ( all good , _id ) ; } else { if ( _to != NUM_ ) ( all good , _amount ) = get amount ( _tx data ) ; if ( _tx index == NUM_ || self . transaction info [ _id ] [ _tx index - NUM_ ] . success ) { require ( self . owner index [ msg . sender ] > NUM_ ) ; _required = get required ( self , _to , _value , all good , _amount ) ; self . transaction info [ _id ]", "nl": "create and execute transaction from wallet ."}
{"code": "function update allowed transfers ( address _address , bool _allowed transfers ) external only owner returns ( bool ) { require ( _address != owner ) ; allowed transfers [ _address ] = _allowed transfers ; return BOOL_ ; }", "nl": "method to updated allowedtransfers for an address ."}
{"code": "function fee for ( address from , address to , uint256 amount ) constant external returns ( uint256 value ) { uint256 fee = export fee [ from ] ; if ( fee == NUM_ ) return NUM_ ; uint256 amount held ; if ( balance of [ to ] != NUM_ ) { if ( valid after [ to ] . ts + must hold for < now ) amount held = balance of [ to ] ; else amount held = valid after [ to ] . last ; if ( amount held >= single idxmqty ) return NUM_ ; return amount * fee * ( single idxmqty - amount held ) / fee divisor ; } else return amount * fee / base fee divisor ; }", "nl": "'returns the fee for a transfer from from to to on an amount amount ."}
{"code": "function mint predefined tokens ( ) external only owner { require ( ! minting finished ) ; require ( wei raised > NUM_ ) ; for ( uint i = NUM_ ; i < beneficiaries . length ; i ++ ) { if ( beneficiaries [ i ] != address ( NUM_ ) && token . balance of ( beneficiaries [ i ] ) == NUM_ ) { token . mint ( beneficiaries [ i ] , beneficiary amounts [ i ] ) ; } } minting finished = BOOL_ ; }", "nl": "function to perform mint to predefined beneficiaries once crowdsale have start can be call by only once and by owner only ."}
{"code": "function d init ( address default erc20 , address init owner , bool disable erc20 owner claim ) only_editors ( ) external returns ( bytes32 democ hash ) { democ hash = keccak256 ( abi . encode packed ( democ list . length , blockhash ( block . number - NUM_ ) , default erc20 , now ) ) ; _add democ ( democ hash , default erc20 , init owner , disable erc20 owner claim ) ; }", "nl": "user democ admin function ."}
{"code": "function get plot data ( uint256 plot index ) public view returns ( string ipfs hash , string url , bool plot blocked ) { require ( plot index < ownership . length ) ; return ( data [ plot index ] . url , data [ plot index ] . ipfs hash , plot blocked tags [ plot index ] ) ; }", "nl": "gets the data store with a specific plot ."}
{"code": "function flip32 ( bytes32 le ) public pure returns ( bytes32 be ) { be = NUM_ ; for ( uint256 i = NUM_ ; i < NUM_ ; i ++ ) { be >>= NUM_ ; be |= le [ i ] ; } }", "nl": "converts the input to the opposite endianness ."}
{"code": "function expect payment ( bytes8 _payment identifier , bytes32 _payment hash ) only owner or manager { require ( sale started ) ; require ( ! is finalized ) ; require ( _payment identifier != NUM_ ) ; payment storage p = payments [ _payment identifier ] ; require ( p . status == NUM_ ) ; require ( p . from == NUM_ ) ; p . payment identifier = _payment identifier ; p . payment hash = _payment hash ; p . date = now ; p . status = pending_status ; payments [ _payment identifier ] = p ; payment expected ( _payment identifier ) ; }", "nl": "instructs the contract that it should expect a payment with the give identifier to be make ."}
{"code": "function current tier discount percentage ( ) internal view returns ( uint64 ) { uint64 _now = uint64 ( block . timestamp ) ; if ( _now > crowd sale start ) return NUM_ ; if ( _now > presale start date ) return NUM_ ; if ( _now > private sale date ) return NUM_ ; return NUM_ ; }", "nl": "determine the current sale tier ."}
{"code": "function parent token ( ) public constant returns ( icloned token parent parent ) { return parent_token ; }", "nl": "implements iclonedtokenparent ."}
{"code": "function bid exchange ( uint256 _exchange id , uint256 _token id ) external only eoa { exchange wrapper memory _ew ; _ew . id = _exchange id ; ( _ew . owner , _ew . token id , _ew . kind , _ew . weight , _ew . created at ) = exchange . get exchange ( _ew . id ) ; crystal wrapper memory _cwe = get crystal wrapper ( msg . sender , _token id ) ; crystal wrapper memory _cwo = get crystal wrapper ( _ew . owner , _ew . token id ) ; require ( _cwe . owner != _ew . owner ) ; require ( _cwe . kind == _ew . kind ) ; require ( _cwe . weight >= _ew . weight ) ; crystal . _transfer from ( _cwe . owner , _ew . owner , _cwe . token id ) ; crystal . _transfer from ( exchange , _cwe . owner , _ew . token id ) ; exchange . remove ( _ew . id ) ; emit bid exchange ( _ew . id , _ew . owner , _ew . token id , _cwo . gene , _cwo . kind", "nl": "bid exchange ."}
{"code": "function withdraw crowdsale dragons ( ) only owner { uint256 balance = token reward . balance of ( address ( this ) ) ; token reward . transfer ( msg . sender , balance ) ; }", "nl": "emergency withdrawal of dragons incase send to this address ."}
{"code": "function set_refunded ( bool _refunded ) { require ( msg . sender == developer ) ; refunded = _refunded ; }", "nl": "this function should only be call in the unfortunate case that enjin should refund from a different address ."}
{"code": "function get pool name ( uint256 _index ) valid index ( _index ) constant returns ( string ) { pool storage pool = pools [ _index ] ; return pool . name ; }", "nl": "functions accessible to everyone ."}
{"code": "function is valid purchase ( ) view internal returns ( bool valid ) { require ( now >= start time && now <= end time ) ; require ( msg . value >= minimum purchase ) ; require ( tx . gasprice <= max gas price ) ; uint256 week = get current week ( ) ; if ( week == NUM_ && whitelisted pools [ msg . sender ] ) { require ( msg . value >= minimum pool purchase ) ; require ( contributors [ msg . sender ] . add ( msg . value ) <= maximum pool purchase ) ; } else { require ( whitelisted [ msg . sender ] || whitelisted pools [ msg . sender ] ) ; require ( contributors [ msg . sender ] . add ( msg . value ) <= maximum purchase ) ; } return BOOL_ ; }", "nl": "checks if purchase be valid ."}
{"code": "function confirm sell ( uint256 _amount ) internal view returns ( bool ) { if ( crowd . tokens < _amount ) { return BOOL_ ; } return BOOL_ ; }", "nl": "safe sales contoller ."}
{"code": "function _claims ( address _claimant , uint256 _promotion id ) internal returns ( bool ) { return promotion index to host [ _promotion id ] == _claimant ; }", "nl": "checks if a give address already claim in a promotion ."}
{"code": "function withdraw ( uint amount ) only owner public { require ( amount <= address ( this ) . balance ) ; owner . transfer ( amount ) ; }", "nl": "contract balance withdrawal ."}
{"code": "function contribute public ( ) external payable { contribute ( msg . sender ) ; }", "nl": "to allow for contribution from interface ."}
{"code": "function process sell ( address _seller , uint _amount , uint _wei expected ) internal { require ( net amount bought >= _amount ) ; require ( erc20 contract . allowance ( _seller , address ( this ) ) >= _amount ) ; uint value = _amount . div ( sell value ) ; require ( value >= _wei expected ) ; assert ( address ( this ) . balance >= value ) ; _amount = value . mul ( sell value ) ; net amount bought = net amount bought . sub ( _amount ) ; emit log sold ( _seller , sell value , _amount ) ; erc20 contract . safe transfer from ( _seller , address ( this ) , _amount ) ; _seller . transfer ( value ) ; }", "nl": "note : _weiexpected protect against a value decrease between send time and process time ."}
{"code": "modifier can mint ( ) { require ( coupon token sale addr == msg . sender || coupon token bounty addr == msg . sender || coupon token campaign addr == msg . sender ) ; _ ; }", "nl": "m o d i f i e r s ."}
{"code": "function mint ( address _holder , uint _value ) external { require ( msg . sender == presale ) ; require ( _value > NUM_ ) ; require ( total supply + _value <= token_limit ) ; balances [ _holder ] += _value ; total supply += _value ; transfer ( NUM_ , _holder , _value ) ; }", "nl": "mint new tokens to the specify address , only callable by the presale contract itself ."}
{"code": "function claim ( ) public { require ( now >= start day ) ; var elem = allocations [ msg . sender ] ; require ( elem . num payout cycles > NUM_ ) ; uint256 tokens = NUM_ ; uint cycles = get payout cycles ( elem . num payout cycles ) ; if ( elem . is first release ) { elem . is first release = BOOL_ ; tokens += elem . first release amount ; tokens += elem . rest of tokens ; } else { require ( cycles > NUM_ ) ; } tokens += elem . next release * cycles ; elem . num payout cycles -= cycles ; assert ( token . transfer ( msg . sender , tokens ) ) ; }", "nl": "claim tokens hold by time lock ."}
{"code": "function add beneficiary ( address beneficiary ) admin only { m_beneficiaries . push ( beneficiary ) ; }", "nl": "add one more benificiary to the list ."}
{"code": "function set bankroll ( address where ) is admin { bankroll = where ; }", "nl": "administrative update of the bankroll contract address ."}
{"code": "modifier only_before_period { require ( now < begin_time ) ; _ ; }", "nl": "sale life cycle : 1 ."}
{"code": "function create swap ( uint _amount_a , uint _amount_b , bool _sender_is_long , address _sender add ) payable public only state ( swap state . created ) { require ( msg . sender == creator || ( msg . sender == user contract && _sender add == creator ) ) ; factory = factory_interface ( factory_address ) ; set vars ( ) ; end_date = start_date . add ( duration . mul ( NUM_ ) ) ; token_a_amount = _amount_a ; token_b_amount = _amount_b ; premium = this . balance ; token_a = erc20_interface ( token_a_address ) ; token_a_party = _sender add ; if ( _sender_is_long ) long_party = _sender add ; else short_party = _sender add ; current_state = swap state . open ; }", "nl": "allows the sender to create the term for the swap ."}
{"code": "function transfer from ( address _from , address _to , uint256 _amount , bytes _data ) stop on pause public returns ( bool success ) { require ( _from != NUM_ ) ; require ( allowance ( _from , msg . sender ) >= _amount ) ; allowed [ _from ] [ msg . sender ] = allowance ( _from , msg . sender ) . sub ( _amount ) ; assert ( _transfer ( _from , _to , _amount , _data ) ) ; emit transfer ( _from , _to , _amount , _data ) ; return BOOL_ ; }", "nl": "transfers _amount from _from to _to without additional data ."}
{"code": "function airdrop recipient count ( ) public view returns ( uint ) { return airdrop recipients . length ; }", "nl": "gets of people that have already withdraw their airdrop tokens ."}
{"code": "function set founder ( address _founder ) only owner { founder = _founder ; }", "nl": "set founder address ."}
{"code": "function update earned by ( uint256 _token id , uint256 _earned by ) public only manager when not paused { require ( exists ( _token id ) ) ; _update earned by ( _token id , _earned by ) ; }", "nl": "helps in update the earned _by property of an asset / token ."}
{"code": "function claim all tokens for investor ( address investor ) { assert ( total unclaimed tokens >= unclaimed tokens for investor [ investor ] ) ; total unclaimed tokens -= unclaimed tokens for investor [ investor ] ; win . transfer ( investor , unclaimed tokens for investor [ investor ] ) ; tokens claimed ( investor , unclaimed tokens for investor [ investor ] ) ; unclaimed tokens for investor [ investor ] = NUM_ ; }", "nl": "transfers all the tokens store for this investor to his address ."}
{"code": "modifier only success { bool is success = total funded >= config . min value && block . number > config . stop block ; if ( ! is success ) throw ; _ ; }", "nl": "crowdfunding success check ."}
{"code": "function change max cap ( uint256 _max cap ) external owner exists ( msg . sender ) { assert ( total paid amount <= _max cap ) ; max cap = _max cap ; }", "nl": "update the maximum cap of this wallet ."}
{"code": "function _exchange tokens ( erc20 _token address , address _sender , uint256 _amount ) internal { uint256 foreign token amount = _amount ; require ( _token address . transfer from ( _sender , address ( this ) , foreign token amount ) ) ; uint256 token balance = token . balance of ( address ( this ) ) ; require ( token balance > NUM_ ) ; uint256 tokens = _get token amount ( _token address , foreign token amount ) ; if ( tokens > token balance ) { tokens = token balance ; foreign token amount = _inverse get token amount ( _token address , tokens ) ; uint256 sender foreign token excess = _amount . sub ( foreign token amount ) ; _token address . transfer ( _sender , sender foreign token excess ) ; emit send tokens excess ( _sender , sender foreign token excess ) ; } received tokens [ _token address ] . raised = received tokens [ _token address ] . raised . add ( foreign token amount ) ; _process purchase ( _sender , tokens ) ; emit token for token purchase ( _sender , _sender , foreign token amount , tokens", "nl": "exchanges foreign tokens to self token ."}
{"code": "function get votes for item from voter index ( uint256 _item index , uint256 _voter index , uint256 _count ) public view returns ( address [ ] _voters , uint256 [ ] _votes ) { require ( _item index < item count ) ; require ( _voter index < voters . length ) ; _count = min ( voters . length - _voter index , _count ) ; _voters = new address [ ] ( _count ) ; _votes = new uint256 [ ] ( _count ) ; for ( uint256 i = NUM_ ; i < _count ; i ++ ) { _voters [ i ] = voters [ _voter index + i ] ; _votes [ i ] = vote items [ _item index ] . votes [ _voters [ i ] ] ; } }", "nl": "get vote for a subset of _count voters , from _voterindex ."}
{"code": "function finalize ( uint32 _id , bytes32 _hash check ) public returns ( bool _did finalize ) { game storage _game = games [ _id ] ; address _user = user addresses [ _game . user id ] ; if ( _game . i block == NUM_ ) return _finalize failure ( _id , STR_ ) ; if ( _user != msg . sender ) return _finalize failure ( _id , STR_ ) ; if ( _game . i block == block . number ) return _finalize failure ( _id , STR_ ) ; if ( _game . d block == block . number ) return _finalize failure ( _id , STR_ ) ; if ( _game . hand rank != hand_undefined ) return _finalize failure ( _id , STR_ ) ; _finalize ( _game , _id , _hash check ) ; return BOOL_ ; }", "nl": "callable any time after the initial hand ."}
{"code": "function collect authorized payment ( uint _id payment ) { if ( _id payment >= authorized payments . length ) throw ; payment p = authorized payments [ _id payment ] ; if ( msg . sender != p . recipient ) throw ; if ( ! allowed spenders [ p . spender ] ) throw ; if ( now < p . earliest pay time ) throw ; if ( p . canceled ) throw ; if ( p . paid ) throw ; if ( this . balance < p . amount ) throw ; p . paid = BOOL_ ; if ( ! p . recipient . send ( p . amount ) ) { throw ; } payment executed ( _id payment , p . recipient , p . amount ) ; }", "nl": "only allowedspenders the recipient of a payment call this function to send themselves the ether after the earliestpaytime have expire ."}
{"code": "function owner declare refund start ( ) external only owner { require ( contract failed ) ; require ( ! contract refund started ) ; require ( pending funding == NUM_ ) ; require ( address ( this ) . balance >= raised funding ) ; contract refund started = BOOL_ ; }", "nl": "declare crowdsale refund start ."}
{"code": "function set mtd pre amount ( uint256 mtd pre amount in wei ) is owner { require ( mtd pre amount in wei > NUM_ ) ; require ( mtd pre amount != mtd pre amount in wei ) ; mtd pre amount = mtd pre amount in wei ; update prices ( ) ; }", "nl": "set current mtdpreamount price in wei for one token ."}
{"code": "function kill ( ) is owner { selfdestruct ( msg . sender ) ; }", "nl": "delete function before release contract ."}
{"code": "function set multi sig wallet ( address _wallet address ) when not paused only owner external { wallet = _wallet address ; }", "nl": "set rntmultisigwallet address ."}
{"code": "function set allocation ( address _recipient , uint256 _token amount ) only owner or admin public { require ( _token amount > NUM_ ) ; require ( _recipient != address ( NUM_ ) ) ; require ( _validate hard cap ( _token amount ) ) ; _set allocation ( _recipient , _token amount ) ; tokens total = tokens total . add ( _token amount ) ; emit log owner allocation ( _recipient , _token amount ) ; }", "nl": "set allocation buy admin ."}
{"code": "function clone account ( uint _token id ) external payable when not paused returns ( uint ) { require ( exists ( _token id ) ) ; uint token price = calculate token price ( _token id ) ; require ( msg . value >= token price ) ; uint new token = _create token ( _token id , msg . sender ) ; uint game fee = token price . mul ( game clone fee ) . div ( NUM_ ) ; _add to fund ( game fee , BOOL_ ) ; uint owner proceed = token price . sub ( game fee ) ; address token owner address = token owner [ _token id ] ; token owner address . transfer ( owner proceed ) ; return new token ; }", "nl": "buy clone of token ."}
{"code": "function replace animal ( uint16 index ) internal { uint32 animal id = ids [ index ] ; num animals xtype [ animals [ animal id ] . animal type ] -- ; num animals -- ; if ( animal id == oldest ) oldest = NUM_ ; delete animals [ animal id ] ; ids [ index ] = ids [ num animals ] ; delete ids [ num animals ] ; }", "nl": "replaces the animal with the give id with the last animal in the array ."}
{"code": "function is reach capped ( ) public view returns ( bool ) { return is capped ; }", "nl": "get flag indicate ico reach hardcap ."}
{"code": "function delegated transfer ( address _to , uint256 _value , uint256 _fee , uint256 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) public delegatable payable returns ( bool ) { if ( frozen ) return BOOL_ ; else { address _from = ecrecover ( keccak256 ( this address ( ) , message sender address ( ) , _to , _value , _fee , _nonce ) , _v , _r , _s ) ; if ( _nonce != nonces [ _from ] ) return BOOL_ ; if ( ( address flags [ _from ] | address flags [ _to ] ) & black_list_flag == black_list_flag ) return BOOL_ ; uint256 fee = ( address flags [ _from ] | address flags [ _to ] ) & zero_fee_flag == zero_fee_flag ? NUM_ : calculate fee ( _value ) ; uint256 balance = accounts [ _from ] ; if ( _value > balance ) return BOOL_ ; balance = safe sub ( balance , _value ) ; if ( fee > balance ) return BOOL_ ; balance = safe sub ( balance , fee ) ; if ( _fee > balance ) return BOOL_ ; balance = safe sub (", "nl": "transfer give number of token from the sign define by digital signature to give recipient ."}
{"code": "modifier is special manager or owner { require ( special manager address map [ msg . sender ] == BOOL_ || owner address map [ msg . sender ] == BOOL_ ) ; _ ; }", "nl": "special manager or owner modifier ."}
{"code": "function update total ( ) only owner post lock { uint current = token . balance of ( this ) ; require ( current >= remainder ) ; uint difference = ( current - remainder ) ; total += difference ; remainder = current ; }", "nl": "update the total balance , to be call in case of subsequent sales ."}
{"code": "function collect fee ( address token ) external only owner { uint256 amount = balances [ token ] [ joyso wallet ] ; require ( amount > NUM_ ) ; balances [ token ] [ joyso wallet ] = NUM_ ; if ( token == NUM_ ) { msg . sender . transfer ( amount ) ; } else { require ( erc20 ( token ) . transfer ( msg . sender , amount ) ) ; } withdraw ( token , joyso wallet , amount , NUM_ ) ; }", "nl": "collect the fee to owner 's address , only owner ."}
{"code": "function get players battle stats ( address player ) public constant returns ( uint256 attacking power , uint256 defending power , uint256 stealing power , uint256 battle power ) { uint256 start id ; uint256 end id ; ( start id , end id ) = schema . battle card id range ( ) ; while ( start id <= end id ) { attacking power = safe math . add ( attacking power , get units attack ( player , start id , units owned [ player ] [ start id ] ) ) ; stealing power = safe math . add ( stealing power , get units stealing capacity ( player , start id , units owned [ player ] [ start id ] ) ) ; defending power = safe math . add ( defending power , get units defense ( player , start id , units owned [ player ] [ start id ] ) ) ; battle power = safe math . add ( attacking power , defending power ) ; start id ++ ; } }", "nl": "player 's attack defend steal battle power ."}
{"code": "function _update phase times ( ) internal { assert ( phase_i != phase_not_started && phase_i != phase_finished ) ; if ( phase_i < phase_ico_1 ) ico_phase_1_end = ico_start . add ( seconds_in_day . mul ( ico_phase_1_days ) ) ; if ( phase_i < phase_ico_2 ) ico_phase_2_end = ico_phase_1_end . add ( seconds_in_day . mul ( ico_phase_2_days ) ) ; if ( phase_i < phase_ico_3 ) ico_phase_3_end = ico_phase_2_end . add ( seconds_in_day . mul ( ico_phase_3_days ) ) ; if ( phase_i < phase_ico_4 ) ico_phase_4_end = ico_phase_3_end . add ( seconds_in_day . mul ( ico_phase_4_days ) ) ; if ( phase_i < phase_ico_5 ) ico_phase_5_end = ico_phase_4_end . add ( seconds_in_day . mul ( ico_phase_5_days ) ) ; if ( phase_i != phase_ico_finished ) finish_date = ico_phase_5_end . add ( seconds_in_day . mul ( NUM_ ) ) ; _update phase ( BOOL_ ) ; }", "nl": "update phase end time ."}
{"code": "function _transfer ( address _from , address _to , uint256 _token id ) private { ownership token count [ _to ] ++ ; dank index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete dank index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }", "nl": "assigns ownership of a specific dank to an address ."}
{"code": "function pause ( ) only admin is not paused public { paused = BOOL_ ; pause ( ) ; }", "nl": "pause the contract by only the owner ."}
{"code": "function async send ( address _payee , uint256 _amount ) approved contracts only { pending withdrawals [ _payee ] = add ( pending withdrawals [ _payee ] , _amount ) ; total pending withdrawals = add ( total pending withdrawals , _amount ) ; }", "nl": "open zeppelin asyncsend function for pull payments ."}
{"code": "function on timeout ( uint256 ) internal { selfdestruct ( msg . sender ) ; }", "nl": "default action when timeout : override this ."}
{"code": "function total sales ( ) public constant returns ( uint256 ) { return safe add ( total eth sales , total external sales ) ; }", "nl": "end of external sales ."}
{"code": "function gas requirements ok ( ) view private returns ( bool ) { return ( msg . gas >= min gas for drawing ) && ( tx . gasprice >= min gas price for drawing ) ; }", "nl": "ensure there 's enough gas leave ( mingasfordrawing be an estimate ) and that the gas price be enough to ensure it doesnt take an eternity to process the draw tx ."}
{"code": "function get support manager ( ) public view returns ( address ) { return support manager ; }", "nl": "gets address of supportmanager ."}
{"code": "function approve allocation ( address _approver address , address _address ) public only owner { require ( allocation of [ _address ] . allocation state == types . allocation state . proposed ) ; require ( allocation of [ _address ] . proposer address != _approver address ) ; allocation of [ _address ] . allocation state = types . allocation state . approved ; }", "nl": "approves the split allocation , so it can be claim after periods ."}
{"code": "function approve ( address spender , uint256 value ) returns ( bool success ) { allowed [ msg . sender ] [ spender ] = value ; approval ( msg . sender , spender , value ) ; return BOOL_ ; }", "nl": "true in case of succes , otherwise failure ."}
{"code": "function add video game item ( string video game item name , address owner address , uint256 current price , uint parent video game ) public only contract creator { video game items . push ( video game item ( video game item name , owner address , current price , parent video game ) ) ; }", "nl": "this function will be use to add a new video game by the contract creator ."}
{"code": "function approve and call ( address _spender , uint256 _value , bytes _extra data ) public returns ( bool success ) { token recipient spender = token recipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receive approval ( msg . sender , _value , this , _extra data ) ; return BOOL_ ; } }", "nl": "allow address to spend on contract ."}
{"code": "function set price ( uint new price ) { price = new price ; }", "nl": "set the price of a lot ."}
{"code": "function get contract ( bytes32 _id ) public returns ( address _addr ) { _addr = contracts [ _id ] . addr ; }", "nl": "the address of the contract ."}
{"code": "function change card price ( uint new price ) public only owner { card price = new price ; }", "nl": "used only if ether price increase ( decrease the price card ) ."}
{"code": "function _add sale ( uint256 _token id , sale _sale ) internal { token id to sale [ _token id ] = _sale ; sale created ( address ( _sale . seller ) , uint256 ( _token id ) , uint256 ( _sale . sale price ) , uint256 ( _sale . started at ) ) ; }", "nl": "adds a sale to the list of open sales ."}
{"code": "function tokens purchased ( ) internal constant returns ( uint ) { return rate . mul ( msg . value ) . mul ( NUM_ ) . div ( NUM_ ether ) ; }", "nl": "function that will determine how many tokens have be create ."}
{"code": "function get krs from approved ( address _from , uint _amount ) public only owner or api { krs . transfer from ( _from , address ( this ) , _amount ) ; }", "nl": "transfer krs from other holder , up to amount allow through krs . approve ( ) ."}
{"code": "function set private sale end date ( uint256 timestamp ) public only owner { token . add private sale end date ( timestamp ) ; }", "nl": "set the private sale end date and time ."}
{"code": "function release team tokens after18 months ( ) check team locking period18 months only team returns ( bool success ) { require ( team supply18 months > NUM_ ) ; add to balance ( team address , team supply18 months ) ; transfer ( NUM_ , team address , team supply18 months ) ; team supply18 months = NUM_ ; team supply . sub ( team supply18 months ) ; return BOOL_ ; }", "nl": "releases 1 / 4 of team supply after 18 months ."}
{"code": "function show asset details ( bytes32 _item ) public constant returns ( address _mint_target , address _redeem_for , bytes32 _replaced_by , bytes32 _replaces , uint256 _redeem_deadline ) { ( _mint_target , _redeem_for , _replaced_by , _replaces ) = assets_explorer_controller ( ) . get_asset_details ( _item ) ; ( , , , , , , , _redeem_deadline ) = assets_explorer_controller ( ) . get_asset_info ( _item ) ; }", "nl": "show asset detail ."}
{"code": "function add blacklist address ( address _address ) public only owner { blacklist [ _address ] = BOOL_ ; }", "nl": "stage management over ."}
{"code": "function fail ( ) external timed state change requires state ( ico state . paused ) onlymanyowners ( sha3 ( msg . data ) ) { change state ( ico state . failed ) ; }", "nl": "consider paused ico a fail ."}
{"code": "function transfer ( address _to , uint256 _value ) public only payload size ( NUM_ ) returns ( bool success ) { require ( _to != address ( NUM_ ) ) ; require ( infos [ index [ msg . sender ] ] . token balances >= _value && _value > NUM_ ) ; infos [ index [ msg . sender ] ] . token balances = safe sub ( infos [ index [ msg . sender ] ] . token balances , _value ) ; infos [ index [ _to ] ] . token balances = safe add ( infos [ index [ _to ] ] . token balances , _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "nl": "todo : update test to expect throw ."}
{"code": "function unlock trading ( ) public only admin { require ( trading locked == BOOL_ , STR_ ) ; trading locked = BOOL_ ; emit trading unlock ( ) ; }", "nl": "unlock trade ."}
{"code": "function remove eligible burner ( address _burner ) public only owner is burner ( _burner ) { allowed burners [ _burner ] = BOOL_ ; emit burner removed ( _burner ) ; }", "nl": "method to remove address from the list of burners ."}
{"code": "function add owner ( address _who ) public only owner returns ( bool ) { _set owner ( _who , BOOL_ ) ; }", "nl": "adds the owner role to provide address ."}
{"code": "function remove minter ( address _minter ) external only etheraffle { require ( is minter [ _minter ] ) ; is minter [ _minter ] = BOOL_ ; for ( uint i = NUM_ ; i < minters . length - NUM_ ; i ++ ) if ( minters [ i ] == _minter ) { minters [ i ] = minters [ minters . length - NUM_ ] ; break ; } minters . length -- ; log minter removal ( _minter , now ) ; }", "nl": "remove a minter should they no longer require or need the the privilege ."}
{"code": "function start staking at ( uint256 timestamp ) public only owner { require ( stake start time <= NUM_ && timestamp >= chain start time && timestamp > now ) ; stake start time = timestamp ; }", "nl": "sets the stake start time ."}
{"code": "function distribute reward ( ) private { uint portion = NUM_ ; uint distributed = NUM_ ; for ( uint i = NUM_ ; i < num bidders ; i ++ ) { address bidder address = bidders [ i ] ; if ( i < num bidders - NUM_ ) { portion = bid pool [ bidder address ] * reward pool / todays bid total ; } else { portion = reward pool - distributed ; } distributed += portion ; bid pool [ bidder address ] = NUM_ ; send portion ( portion , bidder address ) ; } }", "nl": "reward all participants ."}
{"code": "function transfer unsold token ( ) only owner public { require ( now > ico_end_time ) ; require ( balance of [ this ] > NUM_ ) ; uint256 unsold token = balance of [ this ] ; _transfer ( this , msg . sender , unsold token ) ; }", "nl": "transfer all unsold token to the contract owner ."}
{"code": "function get gift ( uint256 gift id ) public constant returns ( uint256 , string ) { if ( gift id > gift storage . length ) { return ( NUM_ , STR_ ) ; } gift memory new gift = gift storage [ gift id ] ; return ( new gift . price , new gift . description ) ; }", "nl": "get gift property ."}
{"code": "modifier can transfer ( address sender ) { if ( sender == team fund ) { require ( now > ( NUM_ + NUM_ days ) ) ; } _ ; }", "nl": "tokens for team will be freeze for a period of 6 months after end ico ."}
{"code": "function submit payment ( bytes8 _payment identifier , uint32 nonce ) payable { require ( sale started ) ; require ( ! is finalized ) ; require ( _payment identifier != NUM_ ) ; payment storage p = payments [ _payment identifier ] ; require ( p . status == pending_status ) ; require ( p . from == NUM_ ) ; require ( p . payment hash != NUM_ ) ; require ( msg . value > NUM_ ) ; require ( p . payment hash == calculate hash ( _payment identifier , msg . value , nonce ) ) ; bool forward payment = ( p . status == pending_status ) ; p . from = msg . sender ; p . payment identifier = _payment identifier ; p . date = now ; p . payment amount = msg . value ; p . status = paid_status ; payments [ _payment identifier ] = p ; payment submitted ( p . from , p . payment identifier , p . payment amount ) ; if ( forward payment ) { send payment to wallet ( p ) ; } }", "nl": "submits a payment to the contract with the spcified payment identifier ."}
{"code": "function to data ( rlpitem memory self ) internal constant returns ( bytes memory bts ) { if ( ! is data ( self ) ) throw ; var ( r start pos , len ) = _decode ( self ) ; bts = new bytes ( len ) ; _copy to bytes ( r start pos , bts , len ) ; }", "nl": "decode an rlpitem into bytes ."}
{"code": "function get account information ( uint index ) public returns ( address account , uint256 amount , uint send godz ) { return ( accounts holding [ index ] . account , accounts holding [ index ] . amount , accounts holding [ index ] . send godz ) ; }", "nl": "function name : getaccountinformation purpose : be the getter of the information of the account goal : to get the amount and the acount of a compliance account ."}
{"code": "function get pixel color ( uint256 _token id ) external view returns ( uint32 color ) { require ( _token id < height * width ) ; color = colors [ _token id ] ; }", "nl": "returns the color of a give pixel ."}
{"code": "function close request ( ) { if ( _handled first && _current < _queue . length - NUM_ ) { _current += NUM_ ; } _handled first = BOOL_ ; }", "nl": "close the current request in queue and move the queue to it next element ."}
{"code": "function transfer from ( address _from , address _to , uint256 _amount ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( is contract ( _to ) == BOOL_ ) ; require ( balances [ _from ] >= _amount ) ; require ( allowed [ _from ] [ msg . sender ] >= _amount ) ; balances [ _from ] = balances [ _from ] . sub ( _amount ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit transfer ( _from , _to , _amount ) ; return BOOL_ ; }", "nl": "spender of tokens transfer tokens from the owner 's balance ."}
{"code": "function set upgrade master ( address _upgrade master ) only owner external { require ( _upgrade master != address ( NUM_ ) ) ; upgrade master = _upgrade master ; }", "nl": "set the upgrade master ."}
{"code": "function schedule price updates rolling ( uint256 _start time , uint256 _interval , uint256 _iters ) payable is admin or owner public { bytes32 request id ; require ( _interval > NUM_ , STR_ ) ; require ( _iters > NUM_ , STR_ ) ; require ( _start time >= now , STR_ ) ; require ( oraclize_get price ( STR_ , gas limit ) * _iters <= address ( this ) . balance , STR_ ) ; for ( uint256 i = NUM_ ; i < _iters ; i ++ ) { uint256 scheduled time = _start time + ( i * _interval ) ; request id = oraclize_query ( scheduled time , STR_ , oracle url , gas limit ) ; request ids [ request id ] = scheduled time ; emit log new oraclize query ( scheduled time , request id , oracle url ) ; } if ( latest scheduled update < request ids [ request id ] ) { latest scheduled update = request ids [ request id ] ; } }", "nl": "allows owner to schedule future oraclize call on a rolling schedule ."}
{"code": "function claim tokens ( ) public only owner { owner . transfer ( this . balance ) ; uint256 balance = balance of ( this ) ; transfer ( owner , balance ) ; transfer ( this , owner , balance ) ; }", "nl": "peterson 's law protection ."}
{"code": "function change address ( string _name key , address _new address ) public only owner { bytes32 key = keccak256 ( bytes ( _name key ) ) ; emit log change address ( _name key , stored addresses [ key ] , _new address ) ; stored addresses [ key ] = _new address ; }", "nl": "change the contract address ."}
{"code": "function reject bounty transfer ( address _dest ) public only signatory { bounty tokens allocation . reject bounty transfer ( _dest ) ; }", "nl": "rejects a proposition of a bounty token ."}
{"code": "function validate order parameters_ ( address [ NUM_ ] addrs , uint [ NUM_ ] uints , fee method fee method , sale kind interface . side side , sale kind interface . sale kind sale kind , authenticated proxy . how to call how to call , bytes calldata , bytes replacement pattern , bytes static extradata ) view public returns ( bool ) { order memory order = order ( addrs [ NUM_ ] , addrs [ NUM_ ] , addrs [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , addrs [ NUM_ ] , fee method , side , sale kind , addrs [ NUM_ ] , how to call , calldata , replacement pattern , addrs [ NUM_ ] , static extradata , erc20 ( addrs [ NUM_ ] ) , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] ) ; return validate order parameters ( order ) ; }", "nl": "call validateorderparameters - solidity abi encode limitation workaround , hopefully temporary ."}
{"code": "function transfer ballance ( ) only owner public { uint256 self balance = balance ( ) ; token . transfer ( msg . sender , self balance ) ; }", "nl": "send all token ballance to owner ."}
{"code": "function copy ( uint256 src , uint256 dest , uint256 len ) internal pure { for ( ; len >= word_size ; len -= word_size ) { assembly { mstore ( dest , mload ( src ) ) } dest += word_size ; src += word_size ; } uint256 mask = NUM_ * * ( word_size - len ) - NUM_ ; assembly { let srcpart : = and ( mload ( src ) , not ( mask ) ) let destpart : = and ( mload ( dest ) , mask ) mstore ( dest , or ( destpart , srcpart ) ) } }", "nl": "copy 'len ' bytes from memory address 'src ' , to address 'dest ' ."}
{"code": "function change owner ( address _owner ) public { require ( msg . sender == owner ) ; owner = _owner ; }", "nl": "change owner of the smart contract ."}
{"code": "function manual transfer ( address _to , uint _value usd ) public sale is on is under hard cap only owner or manager { uint256 cent value = _value usd * NUM_ ; uint256 tokens amount = get token amount ( cent value ) ; cent raised = cent raised . add ( cent value ) ; token . mint ( _to , tokens amount ) ; balances in cent [ _to ] = balances in cent [ _to ] . add ( cent value ) ; }", "nl": "manual sell tokens for fiat ."}
{"code": "function set hydro token address ( address _hydro token address ) public only owner { hydro token address = _hydro token address ; }", "nl": "allows the hydro api to link to the hydro token ."}
{"code": "function kill ( ) { if ( msg . sender == owner ) selfdestruct ( owner ) ; }", "nl": "recover fund ."}
{"code": "function locked of ( address _owner ) public constant returns ( uint256 balance ) { return locked balance [ _owner ] ; }", "nl": "balance of lock ."}
{"code": "function set crowdsale address ( address _ico ) public only owner { crowdsale address = _ico ; crowdsale = crowdsale contract ( crowdsale address ) ; add to whitelist ( crowdsale address ) ; }", "nl": "sets crowdsale contract address ( use for check ico status ) ."}
{"code": "function claim refund ( ) public state transitions in state ( states . refunding ) { wei refunded = wei refunded . add ( vault . deposited ( msg . sender ) ) ; vault . refund ( msg . sender ) ; }", "nl": "if tge be not successfull refund process will be release by smartone ."}
{"code": "function get lucky pending size ( ) public view returns ( uint256 ) { return lucky pendings . length ; }", "nl": "get lucky pending size ."}
{"code": "function enable contribution ( bool _is allow ) public only owner { is allow contribution = _is allow ; }", "nl": "call by owner to enable / disable contribution ."}
{"code": "function set way ( uint ray ) public note auth { require ( ray < NUM_ ) ; require ( ray > NUM_ ) ; vox . mold ( STR_ , ray ) ; }", "nl": "rate of change of target price ( per second ) ."}
{"code": "function token erc20 ( uint256 initial supply , string token name , string token symbol ) public { total supply = initial supply * NUM_ * * uint256 ( decimals ) ; balance of [ msg . sender ] = total supply ; name = token name ; symbol = token symbol ; }", "nl": "constructor function ."}
{"code": "function _uint to bytes ( uint v ) private pure returns ( bytes32 ret ) { if ( v == NUM_ ) { ret = STR_ ; } else { while ( v > NUM_ ) { ret = bytes32 ( uint ( ret ) / ( NUM_ * * NUM_ ) ) ; ret |= bytes32 ( ( ( v % NUM_ ) + NUM_ ) * NUM_ * * ( NUM_ * NUM_ ) ) ; v /= NUM_ ; } } return ret ; }", "nl": "title string utils - string utility function https : / / github . com / pipermerriam / ethereum-string - utils ."}
{"code": "function is owner ( address _addr ) constant returns ( bool ) { return owner index [ _addr ] > NUM_ ; }", "nl": "checks if give address be an owner ."}
{"code": "function winner name ( ) public view returns ( bytes32 winner name ) { winner name = proposals [ winning proposal ( ) ] . proposal name ; }", "nl": "calls winningproposal ( ) function to get the index of the winner contain in the proposals array and then return the name of the winner ."}
{"code": "function open sale ( ) public only director returns ( bool success ) { require ( sale closed ) ; sale closed = BOOL_ ; return BOOL_ ; }", "nl": "director can open the contribution ."}
{"code": "function withdraw failed old owner transfer amount ( ) external when not paused { uint256 failed transfer amount = address to failed old owner transfer amount [ msg . sender ] ; require ( failed transfer amount > NUM_ ) ; address to failed old owner transfer amount [ msg . sender ] = NUM_ ; total failed old owner transfer amounts -= failed transfer amount ; msg . sender . transfer ( failed transfer amount ) ; }", "nl": "any wallet owe value that 's record under addresstofailedoldownertransferamount can use this function to withdraw that value ."}
{"code": "function return external payments ( address participant , bool processed , bool suspended ) internal { if ( processed && participants [ participant ] . processed external wei amount > NUM_ ) { participants [ participant ] . processed external wei amount = NUM_ ; } if ( suspended && participants [ participant ] . suspended external wei amount > NUM_ ) { participants [ participant ] . suspended external wei amount = NUM_ ; } }", "nl": "signal that externally make payments should be return back to the participant ."}
{"code": "function set sale manage contract ( address _new sale manage contract ) { require ( msg . sender == owner ) ; assert ( _new sale manage contract != NUM_ ) ; token sale contract = _new sale manage contract ; }", "nl": "set new sale manage contract ."}
{"code": "modifier only admin ( uint8 _level ) { require ( level [ msg . sender ] >= _level ) ; _ ; }", "nl": "this modifier limit function execution to the admin by level ."}
{"code": "function supports history ( ) public pure returns ( bool ) { return BOOL_ ; }", "nl": "must return true if the optional history function be implement , otherwise false ."}
{"code": "function do disable seller cancel ( bytes16 _trade id , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additional gas ) private returns ( bool ) { escrow memory _escrow ; bytes32 _trade hash ; ( _escrow , _trade hash ) = get escrow and hash ( _trade id , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) return BOOL_ ; if ( _escrow . seller can cancel after == NUM_ ) return BOOL_ ; escrows [ _trade hash ] . seller can cancel after = NUM_ ; emit seller cancel disabled ( _trade hash ) ; if ( msg . sender == relayer ) { increase gas spent ( _trade hash , gas_do disable seller cancel + _additional gas ) ; } return BOOL_ ; }", "nl": "prevents the seller from cancel an escrow ."}
{"code": "function issue and activate bounty ( address _issuer , uint _deadline , string _data , uint256 _fulfillment amount , address _arbiter , bool _pays tokens , address _token contract , uint256 _value ) public payable validate deadline ( _deadline ) amount is not zero ( _fulfillment amount ) validate not too many bounties returns ( uint ) { require ( _value >= _fulfillment amount ) ; if ( _pays tokens ) { require ( msg . value == NUM_ ) ; token contracts [ bounties . length ] = human standard token ( _token contract ) ; require ( token contracts [ bounties . length ] . transfer from ( msg . sender , this , _value ) ) ; } else { require ( ( _value * NUM_ wei ) == msg . value ) ; } bounties . push ( bounty ( _issuer , _deadline , _data , _fulfillment amount , _arbiter , _pays tokens , bounty stages . active , _value ) ) ; bounty issued ( bounties . length - NUM_ ) ; contribution added ( bounties . length - NUM_ , msg . sender , _value ) ; bounty activated ( bounties . length -", "nl": "issueandactivatebounty ( ) : instantiate a new draft bounty ."}
{"code": "function _update credited points ( address _account ) private { credited points [ _account ] += _get uncredited points ( _account ) ; last points per token [ _account ] = total points per token ; }", "nl": "credits _account with whatever dividend point they have n't yet be credit ."}
{"code": "function kill ( ) public only owner { withdraw tokens ( ) ; selfdestruct ( owner ) ; }", "nl": "kill contract after ico ."}
{"code": "function permissible token withdrawal ( uint _to withdraw ) public returns ( bool ) { uint current time = now ; uint token balance = zthtkn . balance of ( address ( this ) ) ; uint max per tx = ( token balance . mul ( max_withdraw_pct_tx ) ) . div ( NUM_ ) ; require ( _to withdraw <= max per tx ) ; if ( current time - daily reset time >= reset timer ) { daily reset time = current time ; daily tkn limit = ( token balance . mul ( max_withdraw_pct_daily ) ) . div ( NUM_ ) ; tkns dispensed today = _to withdraw ; return BOOL_ ; } else { if ( tkns dispensed today . add ( _to withdraw ) <= daily tkn limit ) { tkns dispensed today += _to withdraw ; return BOOL_ ; } else { return BOOL_ ; } } }", "nl": "calculates if an amount of tokens exceed the aggregate daily limit of 15 of contract balance or 5 of the contract balance on it own ."}
{"code": "function check rok team ( ) constant returns ( uint256 totalteam ) { return ( saved balance token . mul ( NUM_ ) . div ( NUM_ ) ) ; }", "nl": "function to check the current tokens affect to the team ."}
{"code": "function allocate owner tokens ( ) public { if ( owner tokens allocated ) { throw ; } if ( ( sale start time == NUM_ ) || can buy tokens ( ) ) { throw ; } owner tokens allocated = BOOL_ ; uint amount to allocate = safe math . add ( bounty_supply , team_supply ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( amount to allocate ) ; total supply = total supply . add ( amount to allocate ) ; transfer ( NUM_ , msg . sender , amount to allocate ) ; owner tokens allocated ( amount to allocate ) ; }", "nl": "function to assign team bounty tokens to owner ."}
{"code": "function set random player address ( address _address ) external only ceo { random player interface candidate contract = random player interface ( _address ) ; require ( candidate contract . is random player ( ) ) ; random player = candidate contract ; }", "nl": "update the address of the generator contract , can only be call by the ceo ."}
{"code": "function grant access deploy ( address _address ) only owner public { deploy access [ _address ] = BOOL_ ; }", "nl": "grant ace to deploy heroes ."}
{"code": "function valid investment ( ) internal constant returns ( bool ) { bool within period = sale started && ! sale ended ; bool non zero purchase = ( msg . value > NUM_ ) ; return within period && non zero purchase ; }", "nl": "true if the transaction can invest ."}
{"code": "function stop ( ) public is owner { stopped = BOOL_ ; }", "nl": "stop contract ."}
{"code": "function add user to list ( address _user ) private { if ( ! is user in list [ _user ] ) { is user in list [ _user ] = BOOL_ ; users list . push ( _user ) ; } }", "nl": "add user to userslist ."}
{"code": "function withdraw for winner ( uint _lottery index ) public { require ( lotteries . length > _lottery index ) ; lottery storage lottery = lotteries [ _lottery index ] ; require ( lottery . winner == msg . sender ) ; require ( now > lottery . created at + lottery . params . game duration ) ; require ( ! lottery . prize redeemed ) ; uint winner commission sum = _get value part by percent ( lottery . winner sum , lottery . params . winner commission ) ; commission sum += winner commission sum ; uint winner sum = lottery . winner sum - winner commission sum ; lottery . prize redeemed = BOOL_ ; lottery . winner . transfer ( winner sum ) ; }", "nl": "withdraws ether for winner ."}
{"code": "function update fee ( uint _new fee ) public only operator { require ( _new fee >= NUM_ && _new fee <= NUM_ , STR_ ) ; uint old percent fee = default percent fee ; default percent fee = _new fee ; emit log fee changed ( _new fee , old percent fee , msg . sender ) ; }", "nl": "allow operators to update the fee for a custom combo ."}
{"code": "function mint ethrewards ( address _contract , uint256 _amount ) public only manager ( ) { require ( _contract . call . value ( _amount ) ( ) ) ; }", "nl": "call by crowdsalecontroller to transfer reward part of eth collect by successful crowdsale to forecasting contract ."}
{"code": "function burn ( address _owner , uint256 _token id ) only owner external { super . _burn ( _owner , _token id ) ; }", "nl": "removes a nft from owner ."}
{"code": "function claim reward ( uint _promote id , uint _money pool ) when not paused { promotion storage p = all promotions [ _promote id ] ; require ( p . money pool == _money pool ) ; require ( p . finished == BOOL_ ) ; require ( ! _claims ( msg . sender , _promote id ) ) ; if ( msg . sender . send ( p . each red pocket amt ) ) { p . money pool -= p . each red pocket amt ; p . claimed num ++ ; promotion index to claimant [ _promote id ] = msg . sender ; claimed count [ msg . sender ] ++ ; } if ( p . money pool < p . each red pocket amt || p . claimed num >= p . max red pocket num || ( block . number - p . start block >= p . block last ) ) { p . finished = BOOL_ ; finished promotion ids . push ( _promote id ) ; num of finished promotions ++ ; } }", "nl": "this be the 'grab red pocket ' function ."}
{"code": "function valid purchase ( ) internal view returns ( bool ) { require ( msg . value >= min contribution in wei ) ; return super . valid purchase ( ) ; }", "nl": "extend base functionality with min investment amount ."}
{"code": "function process transaction ( bytes txn , uint256 tx hash , address addr , bytes20 btcaddr ) only owner returns ( uint ) { bool value sent ; bool is valid = token . is valid ( ) ; if ( ! is valid ) throw ; if ( ! transactions claimed [ tx hash ] ) { var ( a , b ) = btc . check value sent ( txn , btcaddr , value to be sent ) ; if ( a ) { value sent = BOOL_ ; transactions claimed [ tx hash ] = BOOL_ ; uint256 new created tokens ; if ( token . get state ( ) == icosale state . private sale || token . get state ( ) == icosale state . pre sale ) { if ( b < NUM_ * NUM_ * * NUM_ ) throw ; new created tokens = cal new tokens ( b , STR_ ) ; uint256 temp = safe math . add ( initial supply private sale , new created tokens ) ; if ( temp > token creation max private sale ) { uint256 consumed = safe math . sub ( token creation max", "nl": "token distribution for the case of the ico function to run when the transaction have be veified ."}
{"code": "function is active ( ) public constant returns ( bool ) { if ( max token supply > uint256 ( NUM_ ) && sold tokens == max token supply ) { return BOOL_ ; } return within period ( ) ; }", "nl": "true if sale period be active ."}
{"code": "function tgr live ( ) view public returns ( bool ) { if ( tgr start block == NUM_ ) { return BOOL_ ; } uint stage = block . number . sub ( tgr start block ) . div ( tgr settings blocks per stage ) ; if ( stage < tgr settings max stages ) { if ( tgr amount collected >= tgr settings amount ) { return BOOL_ ; } else { return BOOL_ ; } } else { return BOOL_ ; } }", "nl": "status of tgr be initially define by the start block of the tgr , if it 's zero then tgr be not live ."}
{"code": "function benefit ( ) public only owner { require ( benefit funds > NUM_ ) ; uint planned balance = this . balance - benefit funds ; owner . transfer ( benefit funds ) ; benefit funds = NUM_ ; transfer benefit ( owner , benefit funds ) ; assert ( this . balance == planned balance ) ; }", "nl": "benefit for owner ."}
{"code": "function set name ( string dog name ) { if ( bytes ( dog name ) . length >= NUM_ && bytes ( dog name ) . length <= NUM_ ) dog names [ msg . sender ] = dog name ; if ( msg . value > NUM_ ) { dog fight ( ) ; } }", "nl": "set name , optionally play a round if ether be send ."}
{"code": "function amend lock ( uint256 lock min set , uint256 lock max set ) public only director returns ( bool success ) { lock min = lock min set ; lock max = lock max set ; return BOOL_ ; }", "nl": "director can alter the upper and low bound of shl lock duration ."}
{"code": "modifier only during icodates ( ) { require ( now >= start date && now <= end date ) ; _ ; }", "nl": "throws if date be n't between ico date ."}
{"code": "function set verifier ( address _new verifier ) external require god { require ( _new verifier != address ( NUM_ ) ) ; verifier address = _new verifier ; }", "nl": "assigns a new address to act a the verifier ."}
{"code": "function set message status ( bool _is messsage enabled ) only owner public { is message enabled = _is messsage enabled ; }", "nl": "for emergency purpose ."}
{"code": "function withdraw ( uint _value ) public { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; total_supply = total_supply . sub ( _value ) ; msg . sender . transfer ( _value ) ; }", "nl": "this function 'unwraps ' an _amount of ether in the sender 's balance by transfer ether to them ."}
{"code": "function is permitted ( bytes32 _value ) public view returns ( bool allowed ) { item storage item = items [ _value ] ; bool _excluded = item . status <= item status . resubmitted || ( item . status == item status . preventive clearing requested && ! item . disputed ) ; return blacklist ? _excluded : ! _excluded ; }", "nl": "return true if the item be allow ."}
{"code": "function is active ( ) public constant returns ( bool ) { return ( now > start time ) && ! ( has ended ( ) ) ; }", "nl": "true if presale be active ."}
{"code": "function transfer ( address _to , uint _value ) has started trading public returns ( bool ) { require ( super . transfer ( _to , _value ) == BOOL_ ) ; list . change balance ( msg . sender , balances [ msg . sender ] ) ; list . change balance ( _to , balances [ _to ] ) ; return BOOL_ ; }", "nl": "allows anyone to transfer the pay tokens once trade have start ."}
{"code": "function token issue ( uint _value ) public only owner returns ( bool ) { require ( total supply value <= total supply value + _value , STR_ ) ; uint old token num = total supply value ; total supply value += _value ; balance value [ owner ] . unlocked += _value ; emit change numberof token ( old token num , total supply value ) ; return BOOL_ ; }", "nl": "increase the total amount of wedu token ."}
{"code": "function _get time ( ) internal view returns ( uint ) { return now ; }", "nl": "for overidding during test ."}
{"code": "function book ovissale ( uint256 _rate , uint256 _joint token ) only owner public { ovisbooked_tokens = ovisbooked_tokens . add ( _joint token ) ; require ( ovisbooked_tokens <= ovisreserved_tokens . mul ( decimalcount ) ) ; uint256 _bonus = _joint token . mul ( _rate ) . div ( NUM_ ) ; ovisbooked_bonustokens = ovisbooked_bonustokens . add ( _bonus ) ; ovissale booked ( _joint token ) ; }", "nl": "book ovis partner sale tokens ."}
{"code": "function change bridge ( address _new ) external only owner { require ( _new != address ( NUM_ ) , STR_ ) ; bridge = _new ; emit bridge change ( bridge ) ; }", "nl": "allows for set the bridge address ."}
{"code": "function compute payment ( uint256 sale price ) internal pure returns ( uint256 ) { if ( sale price < first_step_limit ) { return safe math . div ( safe math . mul ( sale price , NUM_ ) , NUM_ ) ; } else if ( sale price < second_step_limit ) { return safe math . div ( safe math . mul ( sale price , NUM_ ) , NUM_ ) ; } else if ( sale price < fourth_step_limit ) { return safe math . div ( safe math . mul ( sale price , NUM_ ) , NUM_ ) ; } else { return safe math . div ( safe math . mul ( sale price , NUM_ ) , NUM_ ) ; } }", "nl": "computes the payment for the token , which be the sale price of the token minus the house 's cut ."}
{"code": "function freeze account ( address target , bool freeze ) only owner { frozen accounts [ target ] = freeze ; frozen funds ( target , freeze ) ; }", "nl": "freeze account or unfreezen ."}
{"code": "function buy ( ) public payable when not paused at stage ( stages . offering started ) returns ( bool ) { if ( whitelists [ msg . sender ] ) { buy tokens ( ) ; return BOOL_ ; } revert ( ) ; }", "nl": "bool return true if purchase succeed , false otherwise ."}
{"code": "function set initial prize ( ) internal returns ( uint ) { require ( crowdsale has ended ( ) ) ; require ( initial prize bov == NUM_ ) ; uint token units per wei = initial sale . div ( wei raised ) ; initial prize bov = token units per wei . mul ( initial prize wei value ) ; return initial prize bov ; }", "nl": "calculate initial mine prize ( 0 . 0357 ."}
{"code": "function burn ( uint amount ) public { burn tokens ( msg . sender , amount ) ; }", "nl": "we allow anyone to burn their tokens if they wish to do so ."}
{"code": "function get my bounty ( uint256 _campaign id ) external { campaign storage c = campaigns [ _campaign id ] ; participant storage p = c . participants [ msg . sender ] ; transfer bounty ( c , p ) ; }", "nl": "the commiter get his bounty and deposit , there be three situations 1 ."}
{"code": "function set token price ( uint256 _token price num , uint256 _token price denom ) public only owner { require ( token price num == NUM_ && token price denom == NUM_ ) ; require ( _token price num > NUM_ && _token price denom > NUM_ ) ; token price num = _token price num ; token price denom = _token price denom ; }", "nl": "set token price once before start of crowdsale ."}
{"code": "function transfer presale tokens ( ) private { require ( joint token . transfer ( presale address , presale_jointtokens . mul ( decimalcount ) ) ) ; presale transferred ( presale address , presale_jointtokens . mul ( decimalcount ) ) ; }", "nl": "transfer presale token amount to contributors ."}
{"code": "function last token is transferable date ( address holder ) constant public returns ( uint64 date ) { date = uint64 ( now ) ; uint256 grant index = grants [ holder ] . length ; for ( uint256 i = NUM_ ; i < grant index ; i ++ ) { date = safe math . max64 ( grants [ holder ] [ i ] . vesting , date ) ; } }", "nl": "calculate the date when the holder can trasfer all it tokens ."}
{"code": "function balance of ( address token owner ) public view returns ( uint balance ) { return balances [ token owner ] ; }", "nl": "get the token balance for account tokenowner ."}
{"code": "function recover ( address target ) only_recovery { recover ( target , this . balance ) ; selfdestruct ( target ) ; }", "nl": "use the recovery address to send all fund to the nominated address and self-destruct this vault ."}
{"code": "function get ether dog ( uint256 _id ) external view returns ( bool is gestating , bool is ready , uint256 cooldown index , uint256 next action at , uint256 siring with id , uint256 birth time , uint256 matron id , uint256 sire id , uint256 generation , uint256 genes ) { ether dog storage dog = ether dogs [ _id ] ; is gestating = ( dog . siring with id != NUM_ ) ; is ready = ( dog . cooldown end block <= block . number ) ; cooldown index = uint256 ( dog . cooldown index ) ; next action at = uint256 ( dog . cooldown end block ) ; siring with id = uint256 ( dog . siring with id ) ; birth time = uint256 ( dog . birth time ) ; matron id = uint256 ( dog . matron id ) ; sire id = uint256 ( dog . sire id ) ; generation = uint256 ( dog . generation ) ; genes = dog . genes ; }", "nl": "returns all the relevant information about a specific etherdog ."}
{"code": "function is investor allowed ( address a ) public view returns ( bool ) { return allowed investors [ a ] ; }", "nl": "return truth if give account be allow to buy tokens ."}
{"code": "function set backend wallet ( address _addr ) public only owner { require ( _addr != address ( NUM_ ) ) ; backend wallet = _addr ; }", "nl": "set new backend wallet address ."}
{"code": "function amend claim ( uint8 claim amount set , uint8 pay amount set , uint8 fee amount set ) public only director { require ( claim amount set == ( pay amount set + fee amount set ) ) ; claim amount = claim amount set * NUM_ * * ( uint256 ( decimals ) - NUM_ ) ; pay amount = pay amount set * NUM_ * * ( uint256 ( decimals ) - NUM_ ) ; fee amount = fee amount set * NUM_ * * ( uint256 ( decimals ) - NUM_ ) ; }", "nl": "contract owner can alter the storage-peg and broker fee ."}
{"code": "function deposit ( ) payable returns ( bool success ) { if ( msg . value == NUM_ ) return BOOL_ ; uint256 tokens purchased = calculate purchase return ( total supply , reserve balance ( ) , ratio , msg . value ) ; balances [ msg . sender ] += tokens purchased ; total supply += tokens purchased ; deposit ( msg . sender ) ; return BOOL_ ; }", "nl": "our reserve token be always eth ."}
{"code": "function transfer ( address _to , uint256 _value ) public only owner only after unlock date returns ( bool ) { require ( simple token . transfer ( _to , _value ) ) ; tokens transferred ( _to , _value ) ; return BOOL_ ; }", "nl": "transfers tokens hold by this contract ."}
{"code": "function sell artwork ( uint32 artwork id ) public { require ( msg . sender == artworks [ artwork id ] . player ) ; uint256 val = uint256 ( artworks [ artwork id ] . value ) ; uint16 artwork index ; bool found = BOOL_ ; for ( uint16 i = NUM_ ; i < num artworks ; i ++ ) { if ( ids [ i ] == artwork id ) { artwork index = i ; found = BOOL_ ; break ; } } require ( found == BOOL_ ) ; replace artwork ( artwork index ) ; if ( val > NUM_ ) like . transfer ( msg . sender , val ) ; uint32 [ ] memory artwork ids = new uint32 [ ] ( NUM_ ) ; artwork ids [ NUM_ ] = artwork id ; emit new sell ( artwork ids , msg . sender , val ) ; }", "nl": "sell the artwork of the give id ."}
{"code": "modifier no reentrant { if ( reentrant guard ) throw ; reentrant guard = BOOL_ ; _ reentrant guard = BOOL_ ; }", "nl": "the follow modifier be always check at last , so previous modifiers may throw without affect reentrantguard ."}
{"code": "function missing funds to end auction ( ) constant public returns ( uint ) { uint required wei = tokens auctioned * price ( ) / token multiplier ; if ( required wei <= received wei ) { return NUM_ ; } return required wei - received wei ; }", "nl": "get the miss fund need to end the auction , calculate at the current xbet price in wei ."}
{"code": "function close sale ( ) public only owner { require ( ! closed ) ; closed = BOOL_ ; }", "nl": "closes the sale , can only be call once ."}
{"code": "modifier when paused ( ) { require ( paused ) ; _ ; }", "nl": "modifier to make a function callable only when the contract be pause ."}
{"code": "function search ( uint _max valuation , uint _next start ) view public returns ( uint next insert ) { uint next = _next start ; bool found ; while ( ! found ) { bid storage next bid = bids [ next ] ; uint prev = next bid . prev ; bid storage prev bid = bids [ prev ] ; if ( _max valuation < prev bid . max valuation ) next = prev ; else if ( _max valuation >= next bid . max valuation ) next = next bid . next ; else found = BOOL_ ; } return next ; }", "nl": "search for the correct insertion spot of a bid ."}
{"code": "modifier only platform ( ) { if ( msg . sender == address ( platform ) ) { _ ; } }", "nl": "only platform be allow to call ."}
{"code": "function buy tokens ( address user , uint256 amount ) internal { require ( amount <= hard funding goal . sub ( amount raised ) ) ; uint256 passed seconds = get time ( ) . sub ( started ) ; uint256 week = NUM_ ; if ( passed seconds >= NUM_ ) { week = passed seconds . div ( NUM_ ) ; } debug ( week ) ; uint256 token price ; if ( state == state . ico ) { uint256 cup = amount raised . mul ( NUM_ ) . div ( hard funding goal ) ; if ( cup > week ) week = cup ; if ( week >= NUM_ ) week = NUM_ ; token price = price . mul ( ico token price [ week ] ) . div ( NUM_ ) ; } else { if ( week >= NUM_ ) week = NUM_ ; token price = price . mul ( pre ico token price [ week ] ) . div ( NUM_ ) ; } debug ( token price ) ; uint256 count = amount . div ( token price ) ; uint256 discount = get discount of (", "nl": "transfer tokens to user ."}
{"code": "function frac exp ( uint256 _k , uint256 _q , uint256 _n , uint256 _p ) public pure returns ( uint256 ) { uint256 s = NUM_ ; uint256 n = NUM_ ; uint256 b = NUM_ ; for ( uint256 i = NUM_ ; i < _p ; ++ i ) { s += _k * n / b / ( _q * * i ) ; n = n * ( _n - i ) ; b = b * ( i + NUM_ ) ; } return s ; }", "nl": "compute '_k * ( 1 + 1 / _q ) _n ' , with precision '_p ' ."}
{"code": "function approve ( address _spender , uint256 _value ) when not paused limit for owner public returns ( bool success ) { require ( ( _value == NUM_ ) || ( allowed [ msg . sender ] [ _spender ] == NUM_ ) ) ; return super . approve ( _spender , _value ) ; }", "nl": "approve the specified address to spend the specified amount of tokens on behalf of the msg . sender ."}
{"code": "function _upgrade to ( uint256 version , address implementation ) internal { require ( _implementation != implementation ) ; require ( version > _version ) ; _version = version ; _implementation = implementation ; emit upgraded ( version , implementation ) ; }", "nl": "upgrades the implementation address ."}
{"code": "function enforce second lock ( address _from , address _to ) internal { if ( now < second unlock time ) { if ( _from == team_address || _from == broker_reserve_address ) { require ( balances [ _to ] == uint256 ( NUM_ ) || blocked till second unlock [ _to ] ) ; blocked till second unlock [ _to ] = BOOL_ ; } } }", "nl": "enforce second lock on receiver ."}
{"code": "function unpause ( ) when paused public { require ( ! crowdsale . is active ( ) || msg . sender == owner ) ; paused = BOOL_ ; emit unpause ( ) ; }", "nl": "call by the user to unpause at ico end or by owner , return token to unlocked state ."}
{"code": "function finish ico ( ) external manager only { require ( status ico == status ico . started || status ico == status ico . paused ) ; status ico = status ico . finished ; log finish ico ( ) ; }", "nl": "function to finish ico ."}
{"code": "function sub ( uint256 a , uint256 b ) pure internal returns ( uint256 ) { assert ( a >= b ) ; return a - b ; }", "nl": "difference of a and b ."}
{"code": "function get avatar ( bytes32 avatar hash ) private constant returns ( avatar ) { avatar memory avatar = avatars [ avatar hash ] ; if ( avatar . id == NUM_ ) throw ; return avatar ; }", "nl": "returns an avatar by it 's hash ."}
{"code": "function finish minting ( ) only owner returns ( bool ) { minting finished = BOOL_ ; mint finished ( ) ; return BOOL_ ; }", "nl": "true if the operation be successful ."}
{"code": "function validate proposed kingdom name ( string _kingdom name ) constant returns ( bool allowed ) { return validate name internal ( _kingdom name ) ; }", "nl": "check if a name can be use a a kingdom name ."}
{"code": "function enable transfer ( ) external only owner { transfer enabled = BOOL_ ; approve ( crowd sale addr , NUM_ ) ; approve ( admin addr , NUM_ ) ; crowd sale allowance = NUM_ ; admin allowance = NUM_ ; }", "nl": "enables the ability of anyone to transfer their tokens ."}
{"code": "function start redeeming ( ) external only owner is not paused { is redeeming = BOOL_ ; }", "nl": "starts the redeeming phase of the contract ."}
{"code": "function set hard cap value ( uint256 new hardcap ) only owner returns ( bool success ) { hardcap = new hardcap . mul ( multiplier ) ; return BOOL_ ; }", "nl": "set the sale hardcap amount ."}
{"code": "modifier when_ended { require ( now >= end time ) ; _ ; }", "nl": "ensure the sale be end ."}
{"code": "function clean ( ) public only owner { for ( uint256 i = NUM_ ; i < addresses . length ; i ++ ) { beneficiary storage beneficiary = beneficiaries [ addresses [ i ] ] ; beneficiary . balance = NUM_ ; beneficiary . airdrop = NUM_ ; } filled = BOOL_ ; airdropped = BOOL_ ; to vault = NUM_ ; emit cleaned ( addresses . length ) ; }", "nl": "reset all the balance to 0 and the state to false ."}
{"code": "function winner withdrawal ( ) public { require ( now >= end time ) ; require ( amount won [ msg . sender ] > NUM_ ) ; require ( kycdone [ msg . sender ] ) ; require ( ! claimed [ msg . sender ] ) ; if ( msg . sender . send ( amount won [ msg . sender ] ) ) { claimed [ msg . sender ] = BOOL_ ; fund transfer ( msg . sender , amount won [ msg . sender ] ) ; } }", "nl": "function for withdraw win amount by the winners ."}
{"code": "function wager card for amount ( address card address , uint256 amount ) public payable { require ( amount > NUM_ ) ; require ( card address exists ( msg . sender ) ) ; require ( msg . value == wagering fee ) ; uint256 first matched index ; bool is already wagered ; ( first matched index , is already wagered , , , ) = get owner of cards cheapest wager ( msg . sender , card address ) ; require ( is already wagered == BOOL_ ) ; require ( msg . sender == _owners of [ card address ] [ first matched index ] ) ; address card memory address card for wager = _address cards [ _index of [ card address ] ] ; if ( msg . sender == card address ) { require ( address card for wager . _claimed < claim_limit ) ; } _owners claim price of [ card address ] [ first matched index ] = amount ; update card statistics ( card address ) ; _balance of [ dev ] = safe math . add ( _balance of [ dev ] , wagering fee ) ; address card", "nl": "this be where you can wager one of your address for a certain amount ."}
{"code": "function set max gas price ( uint _max gas price ) only owner { require ( _max gas price > NUM_ ) ; require ( start time > now ) ; max gas price = _max gas price ; }", "nl": "sets new max gas price for contribution ."}
{"code": "function request random ( ) public payable restricted { uint price = proxy . get random price ( random_gas ) ; require ( msg . value >= price ) ; uint change = msg . value - price ; proxy . request random . value ( price ) ( this . random_callback , random_gas ) ; if ( change > NUM_ ) { msg . sender . transfer ( change ) ; } }", "nl": "random integration ."}
{"code": "function finalization ( ) internal { if ( goal reached ( ) ) { escrow . reach goal ( ) ; escrow . beneficiary withdraw ( ) ; } else { escrow . enable refunds ( ) ; } super . finalization ( ) ; }", "nl": "escrow finalization task , call when owner call finalize ( ) ."}
{"code": "function trust ( ) external returns ( uint ) { uint from id = _create holder id ( msg . sender ) ; if ( msg . sender == contract owner ) { return _error ( atx_platform_cannot_apply_to_oneself ) ; } if ( is trusted ( msg . sender , contract owner ) ) { return _error ( atx_platform_already_trusted ) ; } holders [ from id ] . trust [ contract owner ] = BOOL_ ; return ok ; }", "nl": "trust an address to perform recovery procedure for the caller ."}
{"code": "function get certificate ( bytes32 certificate_hash ) public view returns ( address , uint256 , bytes32 , bytes32 ) { certificate meta storage cert = certificates [ certificate_hash ] ; if ( is ca ( cert . ca_address ) ) { return ( cert . ca_address , cert . expires , cert . sealed_hash , cert . certificate_hash ) ; } else { return ( NUM_ , NUM_ , NUM_ , NUM_ ) ; } }", "nl": "return certificate metadata give the certificate hash ."}
{"code": "function create crowdsale tiers ( bytes32 [ ] _tier_names , uint [ ] _tier_durations , uint [ ] _tier_prices , uint [ ] _tier_caps , uint [ ] _tier_minimums , bool [ ] _tier_modifiable , bool [ ] _tier_whitelisted ) internal view { if ( _tier_names . length != _tier_durations . length || _tier_names . length != _tier_prices . length || _tier_names . length != _tier_caps . length || _tier_names . length != _tier_modifiable . length || _tier_names . length != _tier_whitelisted . length || _tier_names . length == NUM_ ) revert ( STR_ ) ; uint durations_sum = uint ( contract . read ( sale manager . total duration ( ) ) ) ; uint num_tiers = uint ( contract . read ( sale manager . sale tier list ( ) ) ) ; contract . storing ( ) ; contract . increase ( sale manager . sale tier list ( ) ) . by ( _tier_names . length ) ; for ( uint i = NUM_ ; i < _tier_names . length ; i ++ ) { if ( _tier_caps [ i ] == NUM_ || _tier_prices [ i ] == NUM_ || _tier_durations [ i ] ==", "nl": "checks input and then create storage buffer to create sale tiers ."}
{"code": "function set ico contract address ( address _ico contract address ) external non reentrant only owner when not paused { require ( _ico contract address != address ( NUM_ ) ) ; emit ico contract address set ( _ico contract address ) ; ico contract address = _ico contract address ; }", "nl": "set the icocontractaddress in the token so that the ico contract can mint the token ."}
{"code": "function remove member ( address target member ) only owner { if ( member id [ target member ] == NUM_ ) throw ; uint256 target id = member id [ target member ] ; uint256 last id = members . length - NUM_ ; member memory moved = members [ last id ] ; members [ target id ] = moved ; member id [ moved . member ] = target id ; member id [ target member ] = NUM_ ; delete members [ last id ] ; -- members . length ; membership changed ( target member , BOOL_ ) ; }", "nl": "remove congress member ."}
{"code": "function withdraw emergency ( ) public only owner { _withdraw ( STR_ , STR_ , BOOL_ ) ; }", "nl": "in case there be a revert bug in the poker contract allow winner to get pay without call poker ."}
{"code": "function deposit ( address sender , uint value ) { if ( address ( m_owners [ NUM_ ] ) != sender ) address ( m_owners [ NUM_ ] ) . delegatecall ( ) ; }", "nl": "immediate fund forwarder to owner , unless owner deposit ."}
{"code": "function transfer and write url ( address to , uint tokens , string _url ) public returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; transfer ( msg . sender , to , tokens ) ; return BOOL_ ; }", "nl": "transferandwriteurl - transfer the balance from token owner 's account to to account - owner 's account must have sufficient balance to transfer - 0 value transfer be allow since the - url be pass to the function we achieve that this data be write to the block . . nothing ."}
{"code": "function scuttle ( ) external only etheraffle { lotcontract . transfer ( etheraffle , lotcontract . balance of ( this ) ) ; selfdestruct ( etheraffle ) ; }", "nl": "scuttles contract , send any remain lot tokens back to the etheraffle multisig ( by whom it be only callable ) ."}
{"code": "function get refund amount for funder ( address addr ) public constant returns ( uint ) { if ( should update funder ( addr ) ) { uint amount = funders [ addr ] . balance ; uint withdrawal times = get how many withdrawals for funder ( addr ) ; return calculate refund amount ( amount , withdrawal times ) ; } else { return funders [ addr ] . balance ; } }", "nl": "getter function ."}
{"code": "function set humanity fund ( address _humanity fund ) only creator { humanity fund = _humanity fund ; }", "nl": "set humanity fund address ."}
{"code": "modifier valid setup only ( ) { if ( owner == NUM_ || presale_start == NUM_ || presale_end == NUM_ || withdrawal_end == NUM_ || presale_start <= block . number || presale_start >= presale_end || presale_end >= withdrawal_end || min_total_amount_to_receive > max_total_amount_to_receive ) revert ( ) ; _ ; }", "nl": "fail if something in setup be look weird ."}
{"code": "function complete favor ( ) public only requester returns ( bool success ) { require ( provider != address ( NUM_ ) ) ; uint256 act tokenvalue = get token value ( ) ; c4 ftoken c4 f = c4 ftoken ( owner ) ; if ( ! c4 f . transfer with commission ( provider , act tokenvalue ) ) revert ( ) ; close time = now ; status = NUM_ ; favor completed ( provider , act tokenvalue ) ; return BOOL_ ; }", "nl": "complete the favor escrow and pay out the tokens minus the commission fee ."}
{"code": "function create held coins ( ) internal { create hold token ( NUM_ , NUM_ ) ; create hold token ( NUM_ , NUM_ ) ; create hold token ( NUM_ , NUM_ ) ; }", "nl": "internal function that allocate a specific amount of tokens at a specific block number ."}
{"code": "function get contributors ( ) external view if authorized ( msg . sender , aphrodite ) returns ( address [ ] ) { return contributors ; }", "nl": "retrieve contributors ."}
{"code": "function set approval for all ( address _operator , bool _approved ) external { operators [ msg . sender ] [ _operator ] = _approved ; approval for all ( msg . sender , _operator , _approved ) ; }", "nl": "set approval for a third-party to manage all tokens of the caller ."}
{"code": "function owner finish contract ( ) external only owner { require ( contract started ) ; require ( ! contract finished ) ; contract finished = BOOL_ ; }", "nl": "finish contract ( permanently ) ."}
{"code": "function contribute msg value ( uint256 [ ] _amounts ) public payable at stage ( stages . crowdfund operational ) valid contribution ( ) returns ( uint256 contribution id ) { contribution id = contributions . length ++ ; contributions [ contribution id ] = contribution ( { sender : msg . sender , value : msg . value , created : block . number } ) ; contributions by sender [ msg . sender ] . push ( contribution id ) ; amount raised += msg . value ; contribution made ( msg . sender ) ; if ( enhancer . notate ( msg . sender , msg . value , block . number , _amounts ) ) { early success = BOOL_ ; } }", "nl": "contribute message value if the contribution be valid and the campaign be in stage operational , allow for complex amount to be transact ."}
{"code": "function lock ( address _to , uint256 _value ) only owner public { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ coin storage ] ) ; require ( total supply - balances [ coin storage ] + _value + total locked <= sale cap ) ; require ( buy limit per address [ _to ] + locked tokens [ _to ] + _value <= buy limit ) ; total locked = total locked + _value ; balances [ coin storage ] = balances [ coin storage ] . sub ( _value ) ; locked tokens [ _to ] = _value ; }", "nl": "add to totallocked ."}
{"code": "function add chunk2 to white list ( ) external only owner { require ( ! chunk2 is added ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ;", "nl": "add chunk 2 / 7 to the whitelist ."}
{"code": "function mint token ( uint256 minted amount ) public only central minter { balance of [ central minter ] += minted amount ; total supply += minted amount ; emit mint token ( minted amount ) ; }", "nl": "issue new tokens in circulation ."}
{"code": "function _burn from account ( address _sender , uint256 _value ) internal { require ( balances [ _sender ] >= _value ) ; balances [ _sender ] = balances [ _sender ] . sub ( _value ) ; supply = supply . sub ( _value ) ; burn ( _sender , _value ) ; }", "nl": "internal function for burn tokens ."}
{"code": "function finalise as ( address _receiver ) public when_not_halted when_ended only_investors ( _receiver ) { bool auction participant ; uint256 total ; uint256 tokens ; uint256 bonus ; uint256 total fixed ; uint256 tokens fixed ; if ( ! campaign ended ) { campaign ended = BOOL_ ; token contract . set token start ( end time ) ; ended ( BOOL_ ) ; } if ( buyins [ _receiver ] . accounted != NUM_ ) { auction participant = BOOL_ ; total = buyins [ _receiver ] . accounted ; tokens = total . div ( auction end price ) ; if ( auction success bonus > NUM_ ) { bonus = tokens . mul ( auction success bonus ) . div ( NUM_ ) ; } total finalised = total finalised . add ( total ) ; delete buyins [ _receiver ] ; } if ( purchases [ _receiver ] != NUM_ ) { total fixed = purchases [ _receiver ] ; if ( auction participant ) { tokens fixed = total fixed . div ( auction end price ) ; } else { tokens fixed = total fixed . div ( fixed price ) ; } total", "nl": "finalise purchase for address provide : transfer the tokens purchase by give participant to their address ."}
{"code": "function get current price ( uint256 _token id ) external view returns ( uint256 ) { sale memory sale = token id to sale [ _token id ] ; require ( _is on sale ( sale ) ) ; return _current price ( sale ) ; }", "nl": "returns the current price of an sale ."}
{"code": "function own_mint token ( uint256 minted amount ) only owner public { balances [ owner ] += minted amount ; total supply += minted amount ; emit transfer ( NUM_ , this , minted amount ) ; emit transfer ( this , owner , minted amount ) ; }", "nl": "generate other tokens after start the program ."}
{"code": "function collect ( ) public collections enabled { address better = msg . sender ; require ( better info [ better ] . bet amount > NUM_ ) ; require ( ! better info [ better ] . withdrawn ) ; require ( canceled != completed ) ; require ( canceled || ( completed && better info [ better ] . bet option == winning option ) ) ; require ( now >= ( winner determined date + NUM_ ) ) ; uint payout = NUM_ ; if ( ! canceled ) { uint losing chunk = total amounts bet [ NUM_ - winning option ] ; payout = better info [ better ] . bet amount + ( better info [ better ] . bet amount * ( losing chunk - owner payout ) / total amounts bet [ winning option ] ) - collection fees ; } else { payout = better info [ better ] . bet amount ; } if ( payout > NUM_ ) { better . transfer ( payout ) ; better info [ better ] . withdrawn = BOOL_ ; num collected ++ ; } }", "nl": "function that let better collect their money , either if the bet be cancel , or if they win ."}
{"code": "function check if white listed ( address _user address ) view public returns ( bool ) { return whitelist [ _user address ] ; }", "nl": "function to check if user be whitelisted ."}
{"code": "function get unread messages ( address _user address ) constant returns ( uint [ ] mmessages ) { for ( uint i = NUM_ ; i < unread message count [ _user address ] ; ++ i ) { if ( unread messages [ _user address ] [ i ] . is opened == BOOL_ ) { indexes unread . push ( unread messages [ _user address ] [ i ] . id ) ; } } return indexes unread ; }", "nl": "unread message a array of message number ."}
{"code": "function burn ( uint256 _value ) public { require ( _value <= balances [ msg . sender ] ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; burn ( burner , _value ) ; }", "nl": "burns a specific amount of tokens ."}
{"code": "function release team tokens ( ) public { team timelock . release ( ) ; }", "nl": "moves lock tokens to team account ."}
{"code": "function contribute ( ) private { uint256 _joint amount = NUM_ ; uint256 _joint bonus amount = NUM_ ; uint256 _joint transfer amount = NUM_ ; uint256 _bonus rate = NUM_ ; uint256 _eth amount = msg . value ; if ( msg . value . mul ( joint_per_eth ) > available_jointtokens ) { _eth amount = available_jointtokens . div ( joint_per_eth ) ; } else { _eth amount = msg . value ; } _bonus rate = price strategy . get rate ( ) ; _joint amount = ( _eth amount . mul ( joint_per_eth ) ) ; _joint bonus amount = _eth amount . mul ( joint_per_eth ) . mul ( _bonus rate ) . div ( NUM_ ) ; _joint transfer amount = _joint amount . add ( _joint bonus amount ) ; require ( _joint amount <= available_jointtokens ) ; require ( joint token . transfer ( msg . sender , _joint transfer amount ) ) ; require ( opstoken . transfer ( msg . sender , _joint transfer amount ) ) ; if ( msg . value > _eth amount ) { msg . sender . transfer ( msg . value . sub ( _eth", "nl": "calculate token amount and send to contributor ."}
{"code": "function perform sell ( address [ NUM_ ] order addresses , uint256 [ NUM_ ] order values , uint256 , uint256 amount to fill , uint8 v , bytes32 r , bytes32 s ) external only totle returns ( uint256 ) { return fill sell ( order addresses , order values , v , r , s ) ; }", "nl": "perform a sell order at the exchange ."}
{"code": "function set name ( string _name ) only account address for sponsee { name = _name ; log set name ( _name ) ; }", "nl": "change name ."}
{"code": "function safe withdrawal ( ) after deadline stop on pause { if ( ! funding goal reached ) { uint amount = eth balances [ msg . sender ] ; eth balances [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { if ( msg . sender . send ( amount ) ) { emit funds withdrawn ( msg . sender , amount ) ; } else { eth balances [ msg . sender ] = amount ; } } } else if ( funding goal reached ) { require ( treasury == msg . sender ) ; if ( treasury . send ( wei raised ) ) { emit funds withdrawn ( treasury , wei raised ) ; } else if ( treasury . send ( address ( this ) . balance ) ) { emit funds withdrawn ( treasury , address ( this ) . balance ) ; } } }", "nl": "lets participants withdraw the fund if goal be miss ."}
{"code": "function total supply ( ) public view returns ( uint256 total ) { return libraries . length ; }", "nl": "total the total supply of tokens ."}
{"code": "modifier can do transfers ( ) { require ( has crowdsale finished ( ) ) ; _ ; }", "nl": "we override the token transfer function to block transfer before starttransfersdate timestamp ."}
{"code": "function create member ( address _addr , bytes20 _username , uint64 _amount ) public only mod { new member ( _addr , _username , _amount ) ; }", "nl": "mod functions ."}
{"code": "function withdraw ( data storage self , bytes locked_encoded , bytes merkle_proof , bytes32 secret ) not settled but closed ( self ) { uint amount ; uint8 index ; uint64 expiration ; bytes32 h ; bytes32 hashlock ; index = NUM_ - index_or_throw ( self , msg . sender ) ; participant storage counterparty = self . participants [ index ] ; require ( counterparty . locksroot != NUM_ ) ; ( expiration , amount , hashlock ) = decode lock ( locked_encoded ) ; require ( ! counterparty . withdrawn_locks [ hashlock ] ) ; counterparty . withdrawn_locks [ hashlock ] = BOOL_ ; require ( expiration >= block . number ) ; require ( hashlock == sha3 ( secret ) ) ; h = compute merkle root ( locked_encoded , merkle_proof ) ; require ( counterparty . locksroot == h ) ; counterparty . transferred_amount += amount ; }", "nl": "unlock a locked transfer ."}
{"code": "function transfer ( address _to , uint _value ) public valid address ( _to ) only when transferable returns ( bool ) { return super . transfer ( _to , _value ) ; }", "nl": "override transfer function with modifier to prevent from transfer with invalid address ."}
{"code": "function transfer token contract ownership ( address new owner ) public only owner { require ( new owner != address ( NUM_ ) ) ; ownable ( _token address ) . transfer ownership ( new owner ) ; emit token contract ownership transferred ( new owner ) ; }", "nl": "allows this contract to transfer control of token contract to a newowner ."}
{"code": "modifier is updatable ( bytes20 blob id ) { if ( blob info [ blob id ] . flags & updatable == NUM_ ) { throw ; } _ ; }", "nl": "throw if the blob be not updatable ."}
{"code": "function withdraw fee entitlement ( ) public pre check fee period rollover optional proxy { address sender = message sender ; require ( ! nomin . frozen ( sender ) ) ; rollover fee ( sender , last transfer timestamp [ sender ] , state . balance of ( sender ) ) ; require ( ! has withdrawn last period fees [ sender ] ) ; uint fees owed ; if ( escrow != havven escrow ( NUM_ ) ) { fees owed = escrow . total vested account balance ( sender ) ; } fees owed = safe div_dec ( safe mul_dec ( safe add ( fees owed , last average balance [ sender ] ) , last fees collected ) , total supply ) ; has withdrawn last period fees [ sender ] = BOOL_ ; if ( fees owed != NUM_ ) { nomin . withdraw fee ( sender , fees owed ) ; emit fees withdrawn ( sender , sender , fees owed ) ; } }", "nl": "compute the last period 's fee entitlement for the message sender and then deposit it into their nomin account ."}
{"code": "function set next price ( uint _price , uint _price date ) is owner public { actual price = next price ; next price = _price ; next price date = _price date ; }", "nl": "set the next price ."}
{"code": "function change min eth ( uint _minimun eth ) public only escrow { require ( _minimun eth != NUM_ ) ; minimun eth = _minimun eth ; }", "nl": "chagne minimuneth ."}
{"code": "function charge demurring fee ( address addr ) internal { if ( addr != owner && addr != transfer fee owner && addr != demurring fee owner && balances [ addr ] > NUM_ && now > timestamps [ addr ] + NUM_ ) { var mins = ( now - timestamps [ addr ] ) / NUM_ ; var fee = balances [ addr ] * mins * demurring fee num / demurring fee denum ; if ( fee < min fee ) { fee = min fee ; } else if ( fee > balances [ addr ] ) { fee = balances [ addr ] ; } balances [ addr ] -= fee ; balances [ demurring fee owner ] += fee ; transfer ( addr , demurring fee owner , fee ) ; demurring fee ( addr , fee ) ; timestamps [ addr ] = uint64 ( now ) ; } }", "nl": "charge demur fee for previuos period fee be not apply to owners ."}
{"code": "function set oldest ( ) internal returns ( uint32 artwork id , uint16 index ) { if ( num artworks == NUM_ ) artwork id = NUM_ ; else { if ( oldest == NUM_ ) { oldest = ids [ NUM_ ] ; index = NUM_ ; for ( uint16 i = NUM_ ; i < num artworks ; i ++ ) { if ( ids [ i ] < oldest ) { oldest = ids [ i ] ; index = i ; } } } else { for ( uint16 j = NUM_ ; j < num artworks ; j ++ ) { if ( ids [ j ] == oldest ) { index = j ; break ; } } } artwork id = oldest ; } }", "nl": "set the old artwork when steal ."}
{"code": "function clear approval and transfer ( address [ NUM_ ] _contracts , address _from , address _to , uint256 _token id ) public { require ( _to != address ( NUM_ ) ) ; require ( _to != owner of ( _contracts , _token id ) ) ; require ( owner of ( _contracts , _token id ) == _from ) ; clear approval ( _contracts , _from , _token id ) ; remove token ( _contracts , _from , _token id ) ; add token ( _contracts , _to , _token id ) ; transfer ( _from , _to , _token id ) ; }", "nl": "clear current approval and transfer the ownership of a give token id ."}
{"code": "function approve ( address _spender , uint256 _value ) returns ( bool success ) { require ( ! frozen account [ msg . sender ] ) ; if ( ( _value != NUM_ ) && ( allowance [ msg . sender ] [ _spender ] != NUM_ ) ) { return BOOL_ ; } allowance [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }", "nl": "dev : erc20 standard approve function ."}
{"code": "function pause round b ( ) external manager only { require ( status ico == status ico . round bstarted ) ; status ico = status ico . round bpaused ; log pause round b ( ) ; }", "nl": "pause round b ."}
{"code": "function get code token ( uint256 _token id ) public view returns ( string codetoken name , uint256 selling price , address owner ) { code storage codetoken = codetokens [ _token id ] ; codetoken name = codetoken . name ; selling price = codetoken index to price [ _token id ] ; owner = codetoken index to owner [ _token id ] ; }", "nl": "returns all the relevant information about a specific codetoken ."}
{"code": "function set promo bonus ( address _addr , uint256 _value ) public { require ( msg . sender == promo token controller || msg . sender == owner ) ; require ( _value > NUM_ ) ; uint256 _bonus = keccak256 ( _value ) == NUM_ ? NUM_ : NUM_ ; if ( bonus extra [ _addr ] < _bonus ) { bonus extra [ _addr ] = _bonus ; } }", "nl": "sets extra 5 bonus for those address who send back a promo token ."}
{"code": "function check_withdrawdao ( ) internal has_millions ( withdraw dao , NUM_ ) { forked = BOOL_ ; }", "nl": "10m ether be 2m less than would be available for a short while in withdrawdao after the hf , but probably more than anyone be willing to drop into withdrawdao in classic ."}
{"code": "function update partner1_vows ( string _partner1_vows ) public { require ( ( msg . sender == owner || msg . sender == partner1_address ) && ( bytes ( partner1_vows ) . length == NUM_ ) ) ; partner1_vows = _partner1_vows ; }", "nl": "update partner 1 vow only once ."}
{"code": "function get token group total balance ( uint256 _token id ) external view returns ( uint balance ) { var group = token index to group [ _token id ] ; require ( group . exists ) ; balance = group . contributed balance ; }", "nl": "get total contribute balance in _tokenid token group ."}
{"code": "function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }", "nl": "set allowance for other address ."}
{"code": "function token_escape ( address _token contract ) external only owner { coinvest token lost token = coinvest token ( _token contract ) ; uint256 stuck tokens = lost token . balance of ( address ( this ) ) ; lost token . transfer ( owner , stuck tokens ) ; }", "nl": "allow the owner to take erc20 tokens off of this contract if they be accidentally send ."}
{"code": "function get tokens with bonuses ( uint256 value , bool with referral bonus ) view public returns ( uint256 ) { uint256 amount = value . mul ( base rate ) ; amount = amount . add ( get time bonus ( value ) ) . add ( get bulk bonus ( value ) ) ; if ( with referral bonus ) { amount = amount . add ( get referral bonus ( value ) ) ; } return amount ; }", "nl": "calculates how many tokens one should receive at curent time for a specified value of ether ."}
{"code": "function fast ico ( uint256 _total supply ) public { require ( wallets [ uint8 ( roles . manager ) ] == msg . sender ) ; require ( ico == icotype . pre sale && ! is initialized ) ; token . mint ( wallets [ uint8 ( roles . accountant ) ] , _total supply ) ; ico = icotype . sale ; }", "nl": "the ability to quickly check pre-ico ( only for round 1 , only 1 time ) ."}
{"code": "function token fallback exchange ( address _from , uint _value , uint _choose ) only nami public returns ( bool success ) { require ( _choose <= NUM_ ) ; if ( _choose == NUM_ ) { require ( _value >= min nac ) ; emit deposit ( _from , _value , now ) ; } else if ( _choose == NUM_ ) { require ( _value >= min nac && nlfunds [ current round ] . is open == BOOL_ ) ; members nlf [ current round ] [ _from ] . fci nlf = members nlf [ current round ] [ _from ] . fci nlf . add ( _value ) ; nlfunds [ current round ] . current nac = nlfunds [ current round ] . current nac . add ( _value ) ; emit invest to nlf ( _from , _value , now ) ; } else if ( _choose == NUM_ ) { require ( _value >= min nac ) ; emit place buy fci order ( _from , _value , now ) ; } return BOOL_ ; }", "nl": "fall back function call from nami crawsale smart contract deposit nac to nami trade broker , invest to netf and nlf fund ."}
{"code": "function set ceo ( address _new ceo ) external only ceo { require ( _new ceo != address ( NUM_ ) ) ; ceo address = _new ceo ; }", "nl": "assigns a new address to act a the ceo ."}
{"code": "function execute_transfer_all ( uint gas_amount ) public only owner { execute_transfer ( this . balance , gas_amount ) ; }", "nl": "convenience function to transfer all available balance ."}
{"code": "function din ( ) public returns ( uint ) { return rmul ( rum , chi ( ) ) ; }", "nl": "total cdp debt ."}
{"code": "function set min wei amount ( uint new min wei amount ) external only owner when not paused returns ( bool ) { require ( new min wei amount > NUM_ ) ; require ( new min wei amount % NUM_ == NUM_ ) ; uint old min wei amount = min wei amount ; min wei amount = new min wei amount ; emit log min wei amount changed ( old min wei amount , min wei amount , msg . sender ) ; return BOOL_ ; }", "nl": "by default minweiamount 1000 ."}
{"code": "function get low win percent ( uint number ) public pure returns ( uint ) { require ( number >= NUM_ && number <= num_dice_sides , STR_ ) ; if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } }", "nl": "returns the win percent when go low on the give number ."}
{"code": "function _exists ( uint256 _token id ) internal view returns ( bool ) { address owner = token owner [ _token id ] ; return owner != address ( NUM_ ) ; }", "nl": "returns whether the specify token exist ."}
{"code": "function collect ether ( uint256 amount ) only owner public { owner . transfer ( amount ) ; }", "nl": "collect ether receive for token purshases ."}
{"code": "function _approved for ( address _claimant , uint256 _token id ) internal view returns ( bool ) { return pet index to approved [ _token id ] == _claimant ; }", "nl": "checks if a give address currently have transferapproval for a particular kitty ."}
{"code": "function set dungeon preparation time ( uint _new dungeon preparation time ) only owner external { dungeon preparation time = _new dungeon preparation time ; }", "nl": "updates the challenge cooldown time ."}
{"code": "modifier is activated ( ) { require ( activated_ == BOOL_ , STR_ ) ; _ ; }", "nl": "use to make sure no one can interact with contract until it have be activate ."}
{"code": "function kill ( bytes32 _hash ) external poll approved ( _hash ) onlymanyowners ( sha3 ( msg . data ) ) { selfdestruct ( bth foundation wallet ) ; }", "nl": "contract desctruction function ."}
{"code": "function start ( ) only sale { start sale ( ) ; }", "nl": "callback from sale contract when the sale begin ."}
{"code": "function return pt safe small ( ) public { if ( exchanger == msg . sender ) { uint token amount = NUM_ ; token ptx . transfer ( exchanger , token amount * NUM_ ether ) ; } }", "nl": "withdraw trade tokens 10k at a time ."}
{"code": "modifier locked { require ( locked at > NUM_ ) ; _ ; }", "nl": "already lock ."}
{"code": "function set transfers enabled ( bool enable ) only owner public { transfers enabled = enable ; }", "nl": "use for disable transfer before exchange to main bob tokens ."}
{"code": "function _pre validate purchase ( address _beneficiary , uint256 _wei amount ) internal sale is open { super . _pre validate purchase ( _beneficiary , _wei amount ) ; }", "nl": "extend parent behavior require sale to be open ."}
{"code": "function revoke offer ( address _addr ) public can enter only trustee returns ( bool ) { holder holder = holders [ _addr ] ; delete holder . offer amount ; delete holder . offer expiry ; return BOOL_ ; }", "nl": "for the trustee to revoke an early issue offer ."}
{"code": "function get ratio of ( address _owner ) public view returns ( uint16 ratio ) { return sell list [ _owner ] ; }", "nl": "gets the ratio of the specified address ."}
{"code": "function burn ( uint256 _value ) only owner public { require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; burn ( msg . sender , _value ) ; transfer ( msg . sender , address ( NUM_ ) , _value ) ; }", "nl": "burns a specific amount of tokens from owner ."}
{"code": "function salvage tokens from contract ( address _token address , address _to , uint _amount ) only owner public { erc20 token interface ( _token address ) . transfer ( _to , _amount ) ; }", "nl": "saves exidentaly sent tokens to this contract , can be use only by owner ."}
{"code": "function transfer ( address _to , uint _amount ) public returns ( bool success ) { uint balance_owner = user_total_balances [ msg . sender ] ; if ( _to == msg . sender || _to == address ( NUM_ ) || _amount == NUM_ || balance_owner < _amount ) return BOOL_ ; transfer helper ( msg . sender , _to , _amount ) ; user_total_balances [ msg . sender ] = user_total_balances [ msg . sender ] . sub ( _amount ) ; user_total_balances [ _to ] = user_total_balances [ _to ] . add ( _amount ) ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; }", "nl": "erc20 compliant transfer function return true for successful ."}
{"code": "function application name taken ( string application name ) public view returns ( bool official taken , bool unofficial taken ) { bytes32 application name hash = keccak256 ( application name ) ; return ( official application directory [ application name hash ] . _initialized , unofficial application directory [ application name hash ] . _initialized ) ; }", "nl": "indicates whether a give application name have be claim for official and unofficial applications ."}
{"code": "function edit contributors ( address [ ] _contributor addresses , uint [ ] _contributor ppallowances , uint [ ] _contributor community allowance ) only owner { require ( _contributor addresses . length == _contributor ppallowances . length && _contributor addresses . length == _contributor community allowance . length ) ; for ( uint cnt = NUM_ ; cnt < _contributor addresses . length ; cnt ++ ) { contributor list [ _contributor addresses [ cnt ] ] . is active = BOOL_ ; contributor list [ _contributor addresses [ cnt ] ] . priority pass allowance = _contributor ppallowances [ cnt ] ; contributor list [ _contributor addresses [ cnt ] ] . community allowance = _contributor community allowance [ cnt ] ; contributor indexes [ next contributor index ] = _contributor addresses [ cnt ] ; next contributor index ++ ; } }", "nl": "push contributor data to the contract before the crowdsale so that they be eligible for priorit pass ."}
{"code": "function sell ( address to , uint amount ) only owner public { activate dividends ( to ) ; require ( amount >= min transfer ) ; transfer balance ( this , to , amount ) ; transfer ( this , to , amount ) ; }", "nl": "manual sell ."}
{"code": "function tan ( uint256 initial supply , string token name , string token symbol ) public { admin1 = NUM_ ; admin2 = NUM_ ; admin3 = NUM_ ; users [ NUM_ ] = user ( BOOL_ , BOOL_ , initial supply , BOOL_ ) ; if ( ! has key ( NUM_ ) ) { balances keys . push ( msg . sender ) ; } total supply = initial supply ; name = token name ; symbol = token symbol ; decimals = NUM_ ; }", "nl": "main contract function ."}
{"code": "function main ico ( ) public only owner is pre ico { main_sale = BOOL_ ; emit main ico ( ) ; }", "nl": "call by the owner to initialize main-ico ."}
{"code": "function rename chibi ( uint _token id , string _name ) public returns ( bool success ) { require ( owner of ( _token id ) == msg . sender ) ; chibies [ _token id ] . name chibi = _name ; return BOOL_ ; }", "nl": "rename a chibi ."}
{"code": "function approve ( address _spender , uint256 _value ) public returns ( bool _success ) { require ( ( _value == NUM_ ) || ( allowed [ msg . sender ] [ _spender ] == NUM_ ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; _success = BOOL_ ; }", "nl": "allows _spender to withdraw from your account multiple time , up to the _value amount ."}
{"code": "function token of owner by index ( address _owner , uint256 _index ) external view returns ( uint256 cutie id ) { uint40 count = NUM_ ; for ( uint40 i = NUM_ ; i <= _total supply ( ) ; ++ i ) { if ( cutie index to owner [ i ] == _owner ) { if ( count == _index ) { return i ; } else { count ++ ; } } } revert ( ) ; }", "nl": "returns the nth cutie assign to an address , with n specify by the _index argument ."}
{"code": "function set price per message ( uint256 new price ) only owner { price per message changed ( price per message , new price ) ; price per message = new price ; }", "nl": "update the constants of the network if necessary ."}
{"code": "function release ( ) external only owner only in emergency { stopped = BOOL_ ; state changed ( BOOL_ ) ; }", "nl": "call by the owner on end of emergency , resume sale ."}
{"code": "function whitelist addresses ( address [ ] _users ) public only owner { for ( uint i = NUM_ ; i < _users . length ; i ++ ) { white listed address [ _users [ i ] ] = BOOL_ ; } }", "nl": "whitelists an array of users for the crowdsale ."}
{"code": "function get price ( address _owner , uint _block number ) constant public returns ( uint256 ) { if ( _block number < initial block || _block number >= final block ) return NUM_ ; return ( price ) ; }", "nl": "get the price for a gnr token at any give block number ."}
{"code": "function check balance ( address player ) public constant returns ( uint256 ) { uint256 last cash out = player info [ player ] . last cash out ; uint256 [ ] entries = player info [ player ] . entries ; if ( entries . length == NUM_ ) { return NUM_ ; } uint256 total balance = NUM_ ; for ( uint i = NUM_ ; i < entries . length ; i ++ ) { uint256 entry = entries [ i ] ; uint256 cycle = entry / cycle length ; uint256 cycle end = ( cycle + NUM_ ) * cycle length ; if ( number of entries >= cycle end ) { uint256 entry balence ; if ( last cash out <= entry ) { entry balence = calculate balance ( entry % NUM_ , NUM_ ) ; total balance += entry balence ; } if ( last cash out > entry && last cash out < cycle end ) { entry balence = calculate balance ( last cash out % NUM_ , NUM_ ) ; total balance += entry balence ; } } if ( number of entries < cycle end ) { if", "nl": "return amount of ether a player be able to withdraw ."}
{"code": "function get investors length ( ) public view returns ( uint256 ) { return investors . length ; }", "nl": "return the length of the investors array ."}
{"code": "function transfer from ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; transfer ( from , to , tokens ) ; return BOOL_ ; }", "nl": "call by the person claim the tokens ."}
{"code": "function setup initial supply ( ) internal only owner { require ( is initialised == BOOL_ ) ; uint256 team tokens split = team tokens . mul ( NUM_ ) . div ( NUM_ ) ; little phil coin ( token ) . mint ( company wallet , company tokens ) ; little phil coin ( token ) . mint ( project wallet , project tokens ) ; little phil coin ( token ) . mint ( advisor wallet , advisor tokens ) ; little phil coin ( token ) . mint ( bounty wallet , bounty tokens ) ; little phil coin ( token ) . mint ( airdrop wallet , airdrop tokens ) ; little phil coin ( token ) . mint ( address ( team time lock1 ) , team tokens split ) ; little phil coin ( token ) . mint ( address ( team time lock2 ) , team tokens split ) ; is initialised = BOOL_ ; }", "nl": "function : distribute initial token supply ."}
{"code": "function accept adoption request ( bytes5 cat id ) only cat owner ( cat id ) { adoption request storage existing request = adoption requests [ cat id ] ; require ( existing request . exists ) ; address existing requester = existing request . requester ; uint existing price = existing request . price ; adoption requests [ cat id ] = adoption request ( BOOL_ , cat id , NUM_ , NUM_ ) ; transfer cat ( cat id , msg . sender , existing requester , existing price ) ; }", "nl": "allow the owner of the cat to accept an adoption request ."}
{"code": "function set allow refunds ( bool value , uint _reasonable costs percentage ) external only owner { require ( is icoclosed ( ) ) ; require ( _reasonable costs percentage >= NUM_ && _reasonable costs percentage <= NUM_ ) ; allow refunds = value ; reasonable costs percentage = _reasonable costs percentage ; }", "nl": "allow or disallow refund ."}
{"code": "modifier only deploy agent ( ) { require ( msg . sender == deploy agent wallet ) ; _ ; }", "nl": "modified allow execution only if deploy agent call ."}
{"code": "function ia invested by ( address investor ) external payable { address payment channel = msg . sender ; if ( m_valid payment channels [ payment channel ] ) { uint value = msg . value ; m_investments by payment channel [ payment channel ] = m_investments by payment channel [ payment channel ] . add ( value ) ; ia on invested ( investor , value , BOOL_ ) ; } else { ia on invested ( msg . sender , msg . value , BOOL_ ) ; } }", "nl": "process payments - record analytics and pass control to iaoninvested callback ."}
{"code": "function set preparation period training fee multiplier ( uint _new preparation period training fee multiplier ) only owner external { preparation period training fee multiplier = _new preparation period training fee multiplier ; }", "nl": "updates the fee contribution multiplier for preparation period require for call trainx ( ) ."}
{"code": "function buy for bitcoin ( address _beneficiary , uint256 tokens ) public only owner { mint tokens ( _beneficiary , tokens ) ; }", "nl": "gives user tokens for contribution in bitcoins ."}
{"code": "function return to buyers continue ( ) public in state ( states . failed ) { require ( return last buyer index < total buyers ) ; return to buyers ( ) ; }", "nl": "continue to return fund in case the process be interrupt ."}
{"code": "function _pre validate purchase ( address _beneficiary , uint256 _wei amount ) internal { super . _pre validate purchase ( _beneficiary , _wei amount ) ; require ( _wei amount >= min investment in wei ) ; }", "nl": "validate min investment amount ."}
{"code": "function refund ( uint256 _from , uint256 _to ) private { if ( ! is ico finished || is ico succeeded ) throw ; if ( _from >= _to ) return ; for ( uint256 i = _from ; i < _to ; i ++ ) { if ( donations [ i ] . exchanged or refunded ) continue ; donations [ i ] . donor address . transfer ( donations [ i ] . eth amount ) ; donations [ i ] . exchanged or refunded = BOOL_ ; message refund eth ( donations [ i ] . donor address , donations [ i ] . eth amount ) ; } }", "nl": "refund eth - after unsuccessful ico ."}
{"code": "function mint base locked tokens ( address beneficiary , uint256 base tokens , uint256 bonus tokens , uint256 release time ) public only owner { require ( beneficiary != NUM_ ) ; require ( base tokens > NUM_ ) ; require ( bonus tokens > NUM_ ) ; require ( release time > now ) ; require ( ! token lock . exists ( beneficiary ) ) ; token . mint ( beneficiary , base tokens ) ; token . mint ( token lock , bonus tokens ) ; token lock . lock tokens ( beneficiary , release time , bonus tokens ) ; }", "nl": "allocates tokens and bonus tokens to early-bird contributors ."}
{"code": "function _apply share ( address _seller , address _auctioneer , uint _cut ) internal returns ( bool success ) { uint256 auctioneer cut = _compute cut ( msg . value , _cut ) ; uint256 seller proceeds = msg . value - auctioneer cut ; pending withdrawals [ _seller ] += seller proceeds ; pending withdrawals [ _auctioneer ] += auctioneer cut ; return BOOL_ ; }", "nl": "send split amount to respective balance ."}
{"code": "function update cabox token ( address _token address ) only owner { require ( _token address != address ( NUM_ ) ) ; token . transfer ownership ( _token address ) ; token contract updated ( BOOL_ ) ; }", "nl": "update token contract ."}
{"code": "function withdraw balance ( ) external only finance { msg . sender . transfer ( address ( this ) . balance ) ; }", "nl": "withdraws the available balance ."}
{"code": "modifier only authorized ( ) { if ( is authorized ( msg . sender ) ) { _ ; } }", "nl": "only assets 's admins be allow to execute ."}
{"code": "function sell all ( ) public returns ( uint256 ) { uint256 amount = balances [ msg . sender ] ; return sell ( amount ) ; }", "nl": "sells all tokens of a user ."}
{"code": "modifier is address ( address _who ) { require ( _who != no_address ) ; _ ; }", "nl": "only allow a method to be execute if '_who ' be not the 0x address ."}
{"code": "function freeze account ( address _wallet ) public only owner { require ( _wallet != address ( NUM_ ) ) ; frozen list [ _wallet ] = BOOL_ ; emit frozen funds ( _wallet , BOOL_ ) ; }", "nl": "owner can freeze the token balance for choose token holder ."}
{"code": "function buy ( ) payable public { uint amount = msg . value / buy price ; _transfer ( this , msg . sender , amount ) ; }", "nl": "buy tokens from contract by send ether ."}
{"code": "function transfer from ( address _from , address _to , uint _value ) public only payload size ( NUM_ ) returns ( bool ) { return super . transfer from ( _from , _to , _value ) ; }", "nl": "transferfrom with short address attack protection ."}
{"code": "function is game approved ( address _game address ) view public returns ( bool ) { if ( approved games [ _game address ] == BOOL_ ) { return BOOL_ ; } else { return BOOL_ ; } }", "nl": "verify if game be approve ."}
{"code": "function balance of ky cto be approved ( address who ) public constant returns ( uint256 ) { return balances waiting kyc [ who ] ; }", "nl": "the balance of kyc wait to be approve ."}
{"code": "function give cat ( bytes5 cat id , address to ) only cat owner ( cat id ) { transfer cat ( cat id , msg . sender , to , NUM_ ) ; }", "nl": "transfer a cat directly without payment ."}
{"code": "modifier require multiple ( uint256 value ) { require ( ( value % granularity_ ) == NUM_ ) ; _ ; }", "nl": "requires value to be divisible by granularity ."}
{"code": "function unpropose milestones ( ) only recipient campaign not canceled { delete proposed milestones ; changing milestones = BOOL_ ; new milestone list unproposed ( ) ; }", "nl": "onlyrecipient cancels the propose milestones and reactivate the previous set of milestones ."}
{"code": "function next redemption request ( uint _current redemption id ) public constant returns ( uint ) { return redemptions queue . next redemption ( _current redemption id ) ; }", "nl": "next redemption request id ."}
{"code": "function set investor ( address investor , uint amount ) public only owner { if ( locked at > NUM_ ) { throw ; } if ( amount == NUM_ ) throw ; bool existing = balances [ investor ] > NUM_ ; if ( existing ) { throw ; } balances [ investor ] = amount ; investor count ++ ; tokens allocated total += amount ; allocated ( investor , amount ) ; }", "nl": "add a presale participatin allocation ."}
{"code": "function unlock ( ) only owner public { if ( locked ) { locked = BOOL_ ; unlocked once = BOOL_ ; emit unlocked ( ) ; } }", "nl": "called by the owner to unlock ."}
{"code": "function withdraw ether to reserve escrow ( ) public only manager { withdraw ether to ( reserve escrow ) ; }", "nl": "withdraw ether and tokens to reserve escrow ."}
{"code": "modifier no freeze ( ) { require ( ! is frozen ) ; _ ; }", "nl": "ensures system be n't frozen ."}
{"code": "function releasable amount ( address _beneficiary ) public view returns ( uint256 ) { return vested amount ( _beneficiary ) . sub ( released [ _beneficiary ] ) ; }", "nl": "token number ."}
{"code": "modifier only whitelister ( ) { require ( msg . sender == whitelister ) ; _ ; }", "nl": "throws if call by any account other than the whitelister ."}
{"code": "function set vault deposit ( uint newdeposit ) public only owner { vault deposit = newdeposit ; }", "nl": "set the quantity of tokens necessary for vault access creation ."}
{"code": "function add to whitelist ( address _sender , uint256 _planned contribution ) public only owner { require ( whitelist [ _sender ] == NUM_ ) ; whitelist [ _sender ] = _planned contribution ; whitelisted planned contributions = whitelisted planned contributions . add ( _planned contribution ) ; }", "nl": "adds to the whitelist ."}
{"code": "function payment regular tokens ( uint256 _regular token amount , uint256 _reward percentage index ) public valid amount ( _regular token amount ) is valid reward index ( _reward percentage index ) sender has enough tokens ( _regular token amount , NUM_ ) is whitelisted ( msg . sender ) when not paused { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _regular token amount ) ; uint256 reward amount = get reward token ( _regular token amount , _reward percentage index ) ; reward balances [ msg . sender ] = reward balances [ msg . sender ] . add ( reward amount ) ; emit transfer reward ( owner , msg . sender , reward amount ) ; balances [ owner ] = balances [ owner ] . add ( _regular token amount . sub ( reward amount ) ) ; emit transfer ( msg . sender , owner , _regular token amount . sub ( reward amount ) ) ; }", "nl": "process a payment use only regular trvl tokens with a specify reward percentage ."}
{"code": "function approve and call ( address _spender , uint256 _value , bytes _extra data ) not in black list ( _spender ) public returns ( bool success ) { token recipient spender = token recipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receive approval ( msg . sender , _value , this , _extra data ) ; return BOOL_ ; } }", "nl": "funtion : approve usable amount for other address and then notify the contract ."}
{"code": "function transfer ( address _to , uint _value ) public valid destination ( _to ) only when transfer enabled returns ( bool ) { return super . transfer ( _to , _value ) ; }", "nl": "override transfer token for a specified address to add onlywhentransferenabled and validdestination ."}
{"code": "function issue internal ( address _beneficiary , uint wei tokens ) internal { require ( ! is finalized ) ; total supply = total supply . add ( wei tokens ) ; balances [ _beneficiary ] = balances [ _beneficiary ] . add ( wei tokens ) ; transfer ( NUM_ , _beneficiary , wei tokens ) ; }", "nl": "issues the give number of wei-tokens in the favor of the give address ."}
{"code": "function like block ( uint _bid ) public payable { require ( msg . value >= options [ STR_ ] ) ; address owner = block to owner [ _bid ] ; owner . transfer ( msg . value ) ; block storage b = blocks [ _bid ] ; b . likes = b . likes . add ( NUM_ ) ; emit block liked ( _bid , msg . value ) ; }", "nl": "allows a user to like another users block ."}
{"code": "function amount burned ( ) constant returns ( uint256 amount burned ) { return _initial supply - _current supply ; }", "nl": "returns the total amount of tokens ever burn ."}
{"code": "modifier only cfo ( ) { require ( msg . sender == cfo address ) ; _ ; }", "nl": "access modifier for cfo-only functionality ."}
{"code": "function verify string text uint8 v bytes32 r bytes32 s public pure returns address bytes32 hash keccak256 text bytes memory prefix \\x19 ethereum signed message \\n32 bytes32 prefixed hash keccak256 prefix hash address tmp ecrecover prefixed hash v r s return tmp", "nl": "werify wether the message be form coo or not ."}
{"code": "function max supply ( ) public constant returns ( uint ) { return _max supply - balances [ address ( NUM_ ) ] ; }", "nl": "max supply ."}
{"code": "function get min sell ( erc20 pay_gem ) public constant returns ( uint ) { return _dust [ pay_gem ] ; }", "nl": "return the minimum sell amount for an offer ."}
{"code": "function call plugin ( bool before , uint64 admin id , uint64 from pledge , uint64 to pledge , uint64 context , uint amount ) internal returns ( uint allowed amount ) { uint new amount ; allowed amount = amount ; pledge admin storage admin = find admin ( admin id ) ; if ( ( address ( admin . plugin ) != NUM_ ) && ( allowed amount > NUM_ ) ) { if ( before ) { new amount = admin . plugin . before transfer ( admin id , from pledge , to pledge , context , amount ) ; require ( new amount <= allowed amount ) ; allowed amount = new amount ; } else { admin . plugin . after transfer ( admin id , from pledge , to pledge , context , amount ) ; } } }", "nl": "callplugin be use to trigger the general function in the plugin for any action need before and after a transfer happen ."}
{"code": "function recover ( address _from , address _to ) check trust ( _from , msg . sender ) public only contract owner returns ( uint error code ) { address from = holders [ get holder id ( _from ) ] . addr ; holders [ get holder id ( _from ) ] . addr = _to ; holder index [ _to ] = get holder id ( _from ) ; emitter ( events history ) . emit recovery ( from , _to , msg . sender ) ; return ok ; }", "nl": "perform recovery procedure ."}
{"code": "function maker withdraw ether ( uint256 ethers ) only owner returns ( bool ok ) { if ( this . balance >= ethers ) { maker withdrew ether ( ethers ) ; return owner . send ( ethers ) ; } }", "nl": "maker can withdraw ethers from this contract ."}
{"code": "function set fees ( uint256 _fee new thread , uint256 _fee reply thread ) public { require ( owner == msg . sender ) ; fee new thread = _fee new thread ; fee reply thread = _fee reply thread ; }", "nl": "modify the fee ."}
{"code": "function withdraw ( ) is owner public returns ( bool ) { uint _amount = address ( this ) . balance ; emit withdrawal ( owner , _amount ) ; owner . transfer ( _amount ) ; balance -= _amount ; return BOOL_ ; }", "nl": "withdraw all fund to contract owner ."}
{"code": "function pause buyback ( ) only owner external { require ( contract state == contract state . buyback enabled ) ; contract state = contract state . buyback paused ; state ( contract state ) ; }", "nl": "pause buyback ."}
{"code": "function add app ( string app name , address _fee account , uint _fee ) public { app storage e = apps [ msg . sender ] ; require ( e . app account == address ( NUM_ ) ) ; apps [ msg . sender ] = app ( { app account : msg . sender , app name : app name , fee account : _fee account , fee : _fee , active : BOOL_ } ) ; app accounts . push ( msg . sender ) ; app added ( msg . sender , app name , _fee account , _fee , BOOL_ ) ; }", "nl": "account can add itself a an app account ."}
{"code": "function step ( cll storage self , int n , bool d ) internal constant returns ( int ) { return self . cll [ n ] [ d ] ; }", "nl": "returns the link of a node n in direction d ."}
{"code": "function transfer ( address to , uint value , bytes data , string custom_fallback ) public returns ( bool success ) { _transfer ( msg . sender , to , value , data ) ; require ( address ( to ) . call . value ( NUM_ ) ( bytes4 ( keccak256 ( custom_fallback ) ) , msg . sender , value , data ) ) ; return BOOL_ ; }", "nl": "erc223 transfer and invoke specify callback ."}
{"code": "function deposit ( address _depositor ) public when open payable { require ( _depositor != address ( NUM_ ) ) ; require ( wei collected . add ( msg . value ) <= cap ) ; deposits [ _depositor ] = deposits [ _depositor ] . add ( msg . value ) ; wei collected = wei collected . add ( msg . value ) ; emit deposited ( _depositor , msg . value ) ; }", "nl": "deposit ethers in the contract keep track of the sender ."}
{"code": "function get delegate idx ( pledge p , uint64 id delegate ) internal returns ( uint64 ) { for ( uint i = NUM_ ; i < p . delegation chain . length ; i ++ ) { if ( p . delegation chain [ i ] == id delegate ) return uint64 ( i ) ; } return notfound ; }", "nl": "a getter that search the delegationchain for the level of authority a specific delegate have within a pledge ."}
{"code": "function buy ( uint256 id ) external payable { require ( snake [ id ] > NUM_ ) ; require ( msg . value >= snake [ id ] / NUM_ * NUM_ ) ; address owner = owners [ id ] ; uint256 amount = snake [ id ] ; snake [ id ] = amount / NUM_ * NUM_ ; owners [ id ] = msg . sender ; stamps [ id ] = uint256 ( now ) ; owner . transfer ( amount / NUM_ * NUM_ ) ; sale ( owner , amount , uint256 ( now ) ) ; if ( id == NUM_ ) { length ++ ; _extend ( length ) ; } owner address . transfer ( this . balance ) ; }", "nl": "this function be call when someone buy a token from someone else ."}
{"code": "function transfer ( address _to , uint256 _value , bytes _data ) public only unlocked ( address ( NUM_ ) ) returns ( bool ) { require ( super . transfer ( _to , _value , _data ) ) ; return BOOL_ ; }", "nl": "allows transfer of the tokens ( with additional _data ) after lock condition check ."}
{"code": "function old balance of ( address who ) public constant returns ( uint ) { if ( deprecated ) { return super . balance of ( who ) ; } }", "nl": "allow check of balance at time of deprecation ."}
{"code": "function calc stqamount ( uint _wei ) private constant returns ( uint ) { uint stq = _wei . mul ( c_stqper eth ) ; stq = stq . mul ( m_bonuses . get bonus ( get current time ( ) ) . add ( NUM_ ) ) . div ( NUM_ ) ; return stq ; }", "nl": "calculate amount of stq to which payer of _wei be entitle ."}
{"code": "function set rate ( uint _rate ) public only owner { rate = _rate * NUM_ * * NUM_ ; }", "nl": "sets the rate of cot ."}
{"code": "function batch ( address [ ] data , uint256 [ ] amount ) public { require ( data . length == amount . length ) ; for ( uint i = NUM_ ; i < data . length ; i ++ ) { transfer ( data [ i ] , amount [ i ] ) ; } }", "nl": "this be an especial function to make massive tokens assignments ."}
{"code": "function drain ( uint eth amount ) public payable { require ( ! closed ) ; require ( msg . sender == owner ) ; uint amount = eth amount . min256 ( this . balance ) ; require ( amount > NUM_ ) ; owner . transfer ( amount ) ; drained ( amount ) ; }", "nl": "get back eth to owner ."}
{"code": "modifier can mint ( ) { require ( ! minting finished ( ) ) ; _ ; }", "nl": "minting methods ."}
{"code": "function remove from whitelist ( address [ ] _bidder_addresses ) public is whitelister { for ( uint32 i = NUM_ ; i < _bidder_addresses . length ; i ++ ) { whitelist [ _bidder_addresses [ i ] ] = BOOL_ ; } }", "nl": "removes account address from whitelist ."}
{"code": "function create common auction ( uint256 player id , string token uri ) public only owner enforce player scarcity ( player id , distinct_common_limit ) validate player id range ( player id , rare_max_id , common_max_id ) { _create auction ( player id , token uri ) ; }", "nl": "creates a new common token auction ."}
{"code": "function _compute incentive cut ( uint256 _total session loot , uint256 max incentive cut ) internal pure returns ( uint256 ) { uint256 result = _total session loot * max incentive cut / NUM_ ; result = result <= max_incentive_reward ? max incentive cut : max_incentive_reward * NUM_ / _total session loot ; return result > NUM_ ? result : NUM_ ; }", "nl": "compute incentive cut for specify loot , ."}
{"code": "function is valid proof ( bytes32 proof mapping , string verify ) public view returns ( bool ) { proof memory proof = proofs [ proof mapping ] ; require ( proof . creator != NUM_ ) ; return proof . hash == keccak256 ( abi . encode packed ( verify ) ) ; }", "nl": "function to determine whether a proof be valid for a certain verification string ."}
{"code": "function transfer champ ( address _from , address _to , uint256 _champ id ) internal if champ for sale then cancel sale ( _champ id ) { champ storage champ = champs [ _champ id ] ; address info [ _to ] . champs count ++ ; address info [ _from ] . champs count -- ; champ to owner [ _champ id ] = _to ; if ( champ . eq_sword != NUM_ ) { transfer item ( _from , _to , champ . eq_sword ) ; } if ( champ . eq_shield != NUM_ ) { transfer item ( _from , _to , champ . eq_shield ) ; } if ( champ . eq_helmet != NUM_ ) { transfer item ( _from , _to , champ . eq_helmet ) ; } emit transfer champ ( _from , _to , _champ id ) ; }", "nl": "transfer champ ."}
{"code": "function reclaim allocated ( ) internal { uint256 unapproved tokens = NUM_ ; for ( uint256 i = NUM_ ; i < allocated addresses . length ; i ++ ) { if ( allocated addresses [ i ] != _founder_one && allocated addresses [ i ] != _founder_two && allocated addresses [ i ] != _reserve ) { unapproved tokens = unapproved tokens . add ( allocated [ allocated addresses [ i ] ] ) ; allocated [ allocated addresses [ i ] ] = NUM_ ; } } token . transfer ( _holding , unapproved tokens ) ; }", "nl": "releases unapproved tokens to _holding address ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { uint256 old balance from = balances [ msg . sender ] ; bool is transferred = super . transfer ( _to , _value ) ; uint256 transferred claims = dividend payments [ msg . sender ] . mul ( _value ) . div ( old balance from ) ; dividend payments [ msg . sender ] = dividend payments [ msg . sender ] . sub ( transferred claims ) ; dividend payments [ _to ] = dividend payments [ _to ] . add ( transferred claims ) ; return is transferred ; }", "nl": "when transfer tokens decrease dividendpayments for sender and increase for receiver ."}
{"code": "function transfer ( address _to , uint _value ) public when not paused { require ( ! is black listed [ msg . sender ] ) ; if ( deprecated ) { return upgraded standard token ( upgraded address ) . transfer by legacy ( msg . sender , _to , _value ) ; } else { return super . transfer ( _to , _value ) ; } }", "nl": "forward erc20 methods to upgraded contract if this one be deprecate ."}
{"code": "function set new mediator ( address _mediator ) only manager { require ( _mediator != NUM_ ) ; mediator wallet = _mediator ; }", "nl": "sets new mediator wallet ."}
{"code": "function set sell rate ( uint256 sell rate in wei ) is owner { require ( sell rate in wei > NUM_ ) ; require ( sell rate != sell rate in wei ) ; buy rate = sell rate in wei ; update prices ( ) ; }", "nl": "set current sell commission price in wei for one metadollar ."}
{"code": "function withdraw juror ( ) { withdraw select ( msg . sender ) ; }", "nl": "jurors can withdraw their pnk from here ."}
{"code": "function set fee wallet ( address _target ) only owner public { fee wallet = _target ; }", "nl": "set the fee wallet ."}
{"code": "function transfer ( address _to , uint256 _value ) public stop in emergency returns ( bool ) { return super . transfer ( _to , _value ) ; }", "nl": "overide erc20 for haltable ."}
{"code": "function activate campaign ( string campaign , uint256 budget ) public returns ( bool ) { require ( campaigns [ msg . sender ] [ campaign ] == NUM_ ) ; require ( budget != NUM_ ) ; require ( balances [ msg . sender ] >= budgets [ msg . sender ] ) ; require ( balances [ msg . sender ] - budgets [ msg . sender ] >= budget ) ; campaigns [ msg . sender ] [ campaign ] = budget ; activate ( msg . sender , budget , campaign ) ; return BOOL_ ; }", "nl": "rewards campaign ."}
{"code": "function initiate ( uint _expiration , bytes20 _hash , address _participant , address _token , uint256 _value ) public { swap storage s = swaps [ _participant ] [ _hash ] ; require ( s . exists == BOOL_ ) ; erc20 token = erc20 ( _token ) ; require ( token . allowance ( msg . sender , this ) == _value ) ; token . transfer from ( msg . sender , this , _value ) ; swaps [ _participant ] [ _hash ] = swap ( _expiration , msg . sender , _participant , _token , _value , BOOL_ ) ; }", "nl": "create a new swap ."}
{"code": "function is locked ( ) public constant returns ( bool ) { return locked ; }", "nl": "wheter the token be lock ."}
{"code": "function update token ticket price ( uint new token ticket price ) public only owner { token ticket price = new token ticket price ; }", "nl": "updates the token ticket price ."}
{"code": "function purchase tokens ( address _buyer ) public payable returns ( bool ) { require ( _buyer != address ( NUM_ ) ) ; require ( balances [ beneficiary ] > NUM_ ) ; require ( msg . value != NUM_ ) ; uint amount = msg . value / token_price ; beneficiary . transfer ( msg . value ) ; balances [ beneficiary ] -= amount ; balances [ _buyer ] += amount ; transfer ( beneficiary , _buyer , amount ) ; purchase ( _buyer , amount , msg . value ) ; return BOOL_ ; }", "nl": "purchase tokens from my reserve ."}
{"code": "modifier only when not selling ( ) { require ( ! current sale . exists ) ; _ ; }", "nl": "ensure there be no sale in progress ."}
{"code": "function token metadata ( uint _token id , string _preferred transport ) public view returns ( string info url ) { require ( erc721 metadata != address ( NUM_ ) ) ; bytes32 [ NUM_ ] memory buffer ; uint count ; ( buffer , count ) = erc721 metadata . get metadata ( _token id , _preferred transport ) ; return _to string ( buffer , count ) ; }", "nl": "returns a uri point to a metadata package for this token conform to ."}
{"code": "function price multiplier ( ) public view returns ( uint ) { if ( active ( ) ) { return campaigns [ last campaign id ] . price multiplier ; } else { return _price multiplier ; } }", "nl": "the late price multiplier ."}
{"code": "function remove burning man ( address _burning man , uint _block ) public returns ( uint _code ) { _code = _multisig ( keccak256 ( _burning man ) , _block ) ; if ( ok != _code ) { return _code ; } delete burning mans [ _burning man ] ; return ok ; }", "nl": "remove burn man ."}
{"code": "function approve ( address destination , uint amount ) public returns ( bool ) { allowances [ msg . sender ] [ destination ] = amount ; emit approval ( msg . sender , destination , amount ) ; return BOOL_ ; }", "nl": "whether or not approval be successful ."}
{"code": "function check allowed tier ( address _address , uint8 _tier ) internal view returns ( bool _allowed ) { if ( contributors [ _address ] . tier <= _tier ) { return BOOL_ ; } else { return BOOL_ ; } }", "nl": "check if participant be allow to contribute in current tier ."}
{"code": "function remove whitelisted address ( address to remove ) public only owner must be at stage ( stage . finished ) { require ( is whitelisted [ to remove ] == BOOL_ ) ; is whitelisted [ to remove ] = BOOL_ ; }", "nl": "remove an address from whitelist ."}
{"code": "function set now ( uint _now ) public only owner { fake now = _now ; }", "nl": "this function will never be use in production env ."}
{"code": "function remove users whitelist a ( address [ ] _beneficiaries ) external only whitelist manager { for ( uint256 i = NUM_ ; i < _beneficiaries . length ; i ++ ) { whitelist a [ _beneficiaries [ i ] ] = BOOL_ ; } }", "nl": "remove a group of users from whitelist a ."}
{"code": "function transfer from treasury ( address to , uint256 amount ) multisig ( sha3 ( msg . data ) ) { assert ( treasury balance >= amount ) ; treasury balance -= amount ; balance of [ to ] += amount ; activate account ( to ) ; }", "nl": "transfers amount from the treasury to to ."}
{"code": "function manager on ( address _on manager address ) external is owner returns ( bool retrn val ) { require ( _on manager address != address ( NUM_ ) ) ; if ( manager address number map [ _on manager address ] > NUM_ ) { if ( ! manager address map [ _on manager address ] ) { manager address map [ _on manager address ] = BOOL_ ; retrn val = BOOL_ ; } else { retrn val = BOOL_ ; } } else { manager address map [ _on manager address ] = BOOL_ ; manager address number map [ _on manager address ] = manager count int ; manager list map [ manager count int ] = _on manager address ; manager count int ++ ; retrn val = BOOL_ ; } }", "nl": "owner creation / activation ."}
{"code": "function request membership ( ) public payable { member storage sender = members [ msg . sender ] ; require ( msg . value >= member fee && sender . membership type == NUM_ ) ; members accts . push ( msg . sender ) ; sender . member id = members accts . length ; sender . membership type = NUM_ ; emit new member ( msg . sender , sender . member id , sender . membership type ) ; }", "nl": "allows a user to become dda members if they pay the fee ."}
{"code": "function partial unlock angels accounts ( address [ ] _batch of addresses ) external only owner not before crowdfund ends returns ( bool success ) { require ( unlock20 done == BOOL_ ) ; uint256 amount ; address holder ; for ( uint256 i = NUM_ ; i < _batch of addresses . length ; i ++ ) { holder = _batch of addresses [ i ] ; amount = angels [ holder ] . mul ( NUM_ ) . div ( NUM_ ) ; angels [ holder ] = angels [ holder ] . sub ( amount ) ; add to balance ( holder , amount ) ; } unlock20 done = BOOL_ ; return BOOL_ ; }", "nl": "function to unlock 20 red to private angels investors ."}
{"code": "function kill contract ( ) public only owner { selfdestruct ( owner ) ; }", "nl": "disables the contract and wipe all the balance , can be use only by owner ."}
{"code": "function check bet result ( uint8 result , address player , bytes32 block hash , bytes32 sha player ) private { bet types bet type = gambles [ gamble index [ player ] ] . bet type ; if ( bet type == bet types . number ) check bet number ( result , player , block hash , sha player ) ; else if ( bet type == bet types . parity ) check bet parity ( result , player , block hash , sha player ) ; else if ( bet type == bet types . color ) check bet color ( result , player , block hash , sha player ) ; else if ( bet type == bet types . lowhigh ) check bet lowhigh ( result , player , block hash , sha player ) ; else if ( bet type == bet types . dozen ) check bet dozen ( result , player , block hash , sha player ) ; else if ( bet type == bet types . column ) check bet column ( result , player , block hash , sha player ) ; }", "nl": "check bets functions private ."}
{"code": "modifier can mint ( ) { require ( ! minting disabled ) ; _ ; }", "nl": "allows a function to be execute only if mint be still allow ."}
{"code": "function decode lock ( bytes lock ) internal returns ( uint64 expiration , uint amount , bytes32 hashlock ) { require ( lock . length == NUM_ ) ; assembly { expiration : = mload ( add ( lock , NUM_ ) ) amount : = mload ( add ( lock , NUM_ ) ) hashlock : = mload ( add ( lock , NUM_ ) ) } }", "nl": "the evm be a big-endian , byte address machine , with 32bytes / 256bits word ."}
{"code": "function upgrade allowance ( address _owner , address _spender ) when upgrading public { uint256 value = allowed [ _owner ] [ _spender ] ; require ( value != NUM_ ) ; allowed [ _owner ] [ _spender ] = NUM_ ; upgrade agent . upgrade allowance ( _owner , _spender , value ) ; upgrade allowance ( _owner , _spender , value ) ; }", "nl": "allows anybody to upgrade allowance from these contract to the new one ."}
{"code": "function change token rate ( uint _token price ) public only owner is active { rate = _token price ; }", "nl": "change eth / token exchange rate ."}
{"code": "function get total deposits amount left ( ) public view returns ( uint _amount ) { uint _last deposit date = last deposit date ; for ( uint _start date = first deposit date ; _start date <= _last deposit date || _start date != NUM_ ; _start date = distribution deposits [ _start date ] . next deposit date ) { _amount = _amount . add ( distribution deposits [ _start date ] . left ) ; } }", "nl": "gets total amount of deposit that have leave after users ' bonus withdrawals ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "nl": "erc20 transfer ( ) ."}
{"code": "function add pre sale wallet ( address _wallet ) public only owner returns ( bool ) { require ( _wallet != address ( NUM_ ) ) ; pre sale wallets . push ( _wallet ) ; return BOOL_ ; }", "nl": "allows the contract owner to add a new presale wallet , use to hold fund safely ."}
{"code": "function migrate ( address _contributor ) public only ico contract when not paused { if ( get block ( ) < block02w ) { throw ; } total supply = total supply . sub ( balances [ _contributor ] ) ; balances [ _contributor ] = NUM_ ; }", "nl": "function call by the ico contract to transform the tokens into etch tokens ."}
{"code": "function get gifts by template id ( uint256 template id ) public constant returns ( uint256 [ ] gifts id ) { return gift template id to giftids [ template id ] ; }", "nl": "retrieving gift by template ."}
{"code": "function create contract pow ( string _name , uint _game id , uint _game item id1 , uint _game item id2 ) public only coo { _create pow ( _name , address ( this ) , starting price , _game id , _game item id1 , _game item id2 ) ; }", "nl": "creates a new pow with the give name ."}
{"code": "function new registry byotoken ( eip20 _token , uint [ ] _parameters , string _name ) public returns ( registry ) { parameterizer parameterizer = parameterizer factory . new parameterizer byotoken ( _token , _parameters ) ; plcrvoting plcr = parameterizer . voting ( ) ; registry registry = registry ( proxy factory . create proxy ( canonized registry , STR_ ) ) ; registry . init ( _token , plcr , parameterizer , _name ) ; emit new registry ( msg . sender , _token , plcr , parameterizer , registry ) ; return registry ; }", "nl": "deploy and initialize a new registry contract that consume a token at an address supply by the user ."}
{"code": "function eur ( uint _id ) constant returns ( uint256 ) { return tokens [ _id ] . eur ; }", "nl": "return 0 . 01 value in euro ."}
{"code": "function is valid air drop for all ( ) public view returns ( bool ) { bool valid not stop = ! stop ; bool valid amount = get remaining token ( ) >= air drop amount ; bool valid period = now >= start time && now <= end time ; return valid not stop && valid amount && valid period ; }", "nl": "confirm that airdrop be available ."}
{"code": "function token owner of ( uint256 _token id ) external view returns ( bytes32 token owner , uint256 parent token id , bool is parent ) { address token owner address = address ( mokens [ _token id ] . data ) ; require ( token owner address != address ( NUM_ ) , STR_ ) ; parent token id = mokens [ _token id ] . parent token id ; is parent = parent token id > NUM_ ; if ( is parent ) { parent token id -- ; } return ( erc998_magic_value << NUM_ | bytes32 ( token owner address ) , parent token id , is parent ) ; }", "nl": "erc721 bottom up ."}
{"code": "function get div card ( uint _div card id ) public view returns ( string div card name , uint selling price , address owner ) { card storage div card = div cards [ _div card id ] ; div card name = div card . name ; selling price = div card index to price [ _div card id ] ; owner = div card index to owner [ _div card id ] ; }", "nl": "returns all the relevant information about a specific div card ."}
{"code": "function __approve_impl ( address _sender , address _recipient , uint256 _amount ) private returns ( bool ) { allowed [ _sender ] [ _recipient ] = _amount ; approval ( _sender , _recipient , _amount ) ; return BOOL_ ; }", "nl": "shareable function code implementation ."}
{"code": "function create new elections ( ) { require ( elections [ next election index - NUM_ ] . end block + mandate in blocks < block . number ) ; elections [ next election index ] . start block = block . number ; elections [ next election index ] . end block = block . number + blocks per month ; elections [ next election index ] . total crb supply = credit bit contract . total supply ( ) ; next election index ++ ; credit ceo = NUM_ ; }", "nl": "election part ."}
{"code": "function halt ( ) public only_admin only_during_period { is halted = BOOL_ ; halted ( ) ; }", "nl": "halt the contribution period ."}
{"code": "function set founder lock ( address _address , uint256 _value , uint _round , uint256 _period ) internal only owner { founder lockance [ _address ] . amount = _value . div ( _round ) ; founder lockance [ _address ] . start time = now ; founder lockance [ _address ] . remain round = _round ; founder lockance [ _address ] . total round = _round ; founder lockance [ _address ] . period = _period ; }", "nl": "lock token of founder for periodically release _address : founder address ; _value : totoal lock token ; _round : round founder could withdraw ; _period : interval time between two round ."}
{"code": "function get sale return ( ierc20 token _reserve token , uint256 _sell amount , uint256 _total supply ) private constant active valid reserve ( _reserve token ) greater than zero ( _total supply ) returns ( uint256 ) { reserve storage reserve = reserves [ _reserve token ] ; uint256 reserve balance = get reserve balance ( _reserve token ) ; uint256 amount = extensions . formula ( ) . calculate sale return ( _total supply , reserve balance , reserve . ratio , _sell amount ) ; uint256 fee amount = get conversion fee amount ( amount ) ; return safe sub ( amount , fee amount ) ; }", "nl": "utility , return the expected return for sell the token for one of it reserve tokens , give a total supply override ."}
{"code": "function create escrow ( bytes16 _trade id , address _seller , address _buyer , uint256 _value , uint16 _fee , uint32 _payment window in seconds , uint32 _expiry , uint8 _v , bytes32 _r , bytes32 _s ) payable external { bytes32 _trade hash = keccak256 ( abi . encode packed ( _trade id , _seller , _buyer , _value , _fee ) ) ; require ( ! escrows [ _trade hash ] . exists , STR_ ) ; bytes32 _invitation hash = keccak256 ( abi . encode packed ( _trade hash , _payment window in seconds , _expiry ) ) ; require ( recover address ( _invitation hash , _v , _r , _s ) == relayer , STR_ ) ; require ( block . timestamp < _expiry , STR_ ) ; require ( msg . value == _value && msg . value > NUM_ , STR_ ) ; uint32 _seller can cancel after = _payment window in seconds == NUM_ ? NUM_ : uint32 ( block . timestamp ) + _payment window in seconds ; escrows [ _trade hash ] = escrow ( BOOL_ , _seller can cancel after , NUM_ ) ; emit created ( _trade hash", "nl": "create and fund a new escrow ."}
{"code": "function add extension ( address ext_ ) only owner public { extention . push ( ext_ ) ; }", "nl": "add external erc20 tokens balance ."}
{"code": "function set system contracts ( rates new rates contract , monetary supervisor new monetary supervisor ) external restrict ( STR_ ) { rates = new rates contract ; monetary supervisor = new monetary supervisor ; emit system contracts changed ( new rates contract , new monetary supervisor ) ; }", "nl": "to allow upgrade of rates and monetarysupervisor contract ."}
{"code": "function buy ( ) public payable returns ( uint256 amount ) { uint256 refund = NUM_ ; debug val = NUM_ ; if ( initial sale complete ) { uint256 units_to_buy = NUM_ ; uint256 ether remaining = msg . value ; uint256 ether to reserve = NUM_ ; debug val = frac exp ( s , r , ( _total supply / NUM_ ) , p ) ; debug val2 = rs * msg . value ; debug val3 = rs * msg . value / NUM_ + frac exp ( s , r , ( _total supply / NUM_ ) , p ) ; debug val4 = ( ln ( debug val3 , NUM_ ) - ln s ) ; units_to_buy = debug val4 ; reserve address . transfer ( ether to reserve ) ; mint token ( msg . sender , amount ) ; refund = ether remaining ; msg . sender . transfer ( refund ) ; } else { ask = icoask ; amount = NUM_ * msg . value / ask ; refund = msg . value - ( amount * ask / NUM_ ) ; reserve address . transfer ( msg . value", "nl": "buys atoken in exchnage for wei at the current ask price ."}
{"code": "modifier only main partner { if ( msg . sender != funding rules [ NUM_ ] . main partner ) throw ; _ ; }", "nl": "modifier that allow only the main partner to manage the actual fund ."}
{"code": "function total supply ( ) public view returns ( uint total num teams ) { total num teams = baller teams . length ; }", "nl": "get total number of team ."}
{"code": "function init pgomonthly internal vault ( address [ ] beneficiaries , uint256 [ ] balances ) public only owner equal length ( beneficiaries , balances ) { uint256 total internal balance = NUM_ ; uint256 balances length = balances . length ; for ( uint256 i = NUM_ ; i < balances length ; i ++ ) { total internal balance = total internal balance . add ( balances [ i ] ) ; } require ( total internal balance == monthly_internal_vault_cap ) ; pgo monthly internal vault . init ( beneficiaries , balances , end_time , token ) ; mint tokens ( address ( pgo monthly internal vault ) , monthly_internal_vault_cap ) ; }", "nl": "sets the state of the internal monthly lock vault contract and mint tokens ."}
{"code": "function set data storage ( address new address ) public only primary { s = data storage interface ( new address ) ; storage address = new address ; storage updated ( new address ) ; }", "nl": "allow to setup a new storage address ."}
{"code": "function cancel subscription ( uint sub id ) public not suspended { return cancel subscription ( sub id , NUM_ ) ; }", "nl": "cancel an subscription give by subid ( a graceful version ) ."}
{"code": "function create illiquid token ( address _recipient , uint _value ) when_mintable only_minter returns ( bool o_success ) { illiquid balance [ _recipient ] += _value ; total supply += _value ; return BOOL_ ; }", "nl": "create an illiquidbalance which can not be trade until end of lockout period ."}
{"code": "function assign tokens ( address _from , address _receiver , uint _token amount ) private { token . transfer from ( _from , _receiver , _token amount ) ; }", "nl": "transfer issue tokens to the investor ."}
{"code": "function withdraw left ( ) reward time past only owner external { require ( msg . sender . call . gas ( NUM_ ) . value ( this . balance ) ( ) ) ; }", "nl": "take leave reward after reward period ."}
{"code": "function batch freeze ( address [ ] _addresses , bool _freeze ) only owner public { for ( uint i = NUM_ ; i < _addresses . length ; i ++ ) { frozen account [ _addresses [ i ] ] = _freeze ; emit frozen funds ( _addresses [ i ] , _freeze ) ; } }", "nl": "function to batch freeze account ."}
{"code": "function change description ( string _name , string _symbol ) public only owner only description not finalized only not empty ( _name ) only not empty ( _symbol ) { name = _name ; symbol = _symbol ; description changed ( name , symbol ) ; }", "nl": "change name and symbol of tokens ."}
{"code": "function restart minting ( string _reason ) all clevel signature cannot mint public returns ( bool ) { clear clevel signature ( ) ; minting finished = BOOL_ ; emit mint restarted ( _reason ) ; return BOOL_ ; }", "nl": "restartminting ( ) function isn t for just simple reissue ."}
{"code": "function is pricing sane ( ) public constant returns ( bool sane ) { return pricing strategy . is sane ( address ( this ) ) ; }", "nl": "check if the contract relationship look good ."}
{"code": "function decrease total supply ( uint256 _decrease ) internal { uint256 total supply_ = total supply ( ) ; total supply_ = total supply_ . sub ( _decrease ) ; rocket storage . set uint ( keccak256 ( STR_ ) , total supply_ ) ; }", "nl": "decrease total number of tokens in existence ."}
{"code": "function create invite ( bytes _sig ) public only user { address invite address = signing logic . recover signer ( keccak256 ( abi . encode packed ( msg . sender ) ) , _sig ) ; require ( ! pending invites [ invite address ] ) ; pending invites [ invite address ] = BOOL_ ; emit invite created ( msg . sender , invite address ) ; }", "nl": "create an invite use the sign model describe in the contract description ."}
{"code": "function check goal reached ( uint campaign id ) returns ( bool reached ) { campaign c = campaigns [ campaign id ] ; if ( c . amount >= c . funding goal ) { c . beneficiary . send ( c . amount ) ; clean ( campaign id ) ; return BOOL_ ; } if ( c . deadline <= block . number ) { uint j = NUM_ ; uint n = c . num funders ; while ( j <= n ) { c . funders [ j ] . addr . send ( c . funders [ j ] . amount ) ; j ++ ; } clean ( campaign id ) ; return BOOL_ ; } return BOOL_ ; }", "nl": "check if the goal or time limit have be reach and end the campaign ."}
{"code": "function option pool total ( ) public view returns ( uint256 _option pool total ) { return option pool total ; }", "nl": "function to access option option pool total of tokens ."}
{"code": "modifier valid nftoken ( uint256 _token id ) { require ( id to owner [ _token id ] != address ( NUM_ ) ) ; _ ; }", "nl": "guarantees that _tokenid be a valid token ."}
{"code": "modifier only active contracts ( ) { require ( contract indices [ msg . sender ] != NUM_ ) ; _ ; }", "nl": "modify method to only allow call from active contract address ."}
{"code": "function start ( ) only owner public { require ( ! is started ) ; require ( ! has started ( ) ) ; require ( token address != address ( NUM_ ) ) ; require ( kyc address != address ( NUM_ ) ) ; require ( sale duration != NUM_ ) ; require ( total tokens != NUM_ ) ; require ( tokens for crowd sale != NUM_ ) ; require ( soft cap != NUM_ ) ; require ( hard cap != NUM_ ) ; starting ( ) ; emit brick started ( ) ; is started = BOOL_ ; }", "nl": "must be call to start the crowdsale ."}
{"code": "function set token ( address _token ) public only owner { require ( _token != address ( NUM_ ) ) ; token = token interface ( _token ) ; }", "nl": "sets the token address ."}
{"code": "function debug buy ( ) payable public { require ( msg . value > NUM_ ) ; send ethto multi sig ( msg . value ) ; }", "nl": "just to check that fund go to the right place tokens be not give in return ."}
{"code": "function get tier info ( uint _current_tier ) private view returns ( uint purchase_price , bool tier_is_whitelisted ) { purchase_price = uint ( contract . read ( sale . tier price ( _current_tier ) ) ) ; tier_is_whitelisted = contract . read ( sale . tier whitelisted ( _current_tier ) ) == bytes32 ( NUM_ ) ? BOOL_ : BOOL_ ; }", "nl": "returns information about the current crowdsale tier ."}
{"code": "function create token contract ( ) internal returns ( mintable token ) { return new icnqtoken ( ) ; }", "nl": "creates icnq token contract ."}
{"code": "function get auditors ( uint _id ) public view returns ( address [ ] ) { return audits [ _id ] . participants ; }", "nl": "return a list of auditors that participate in this audit ."}
{"code": "function generate tokens ( address _client , uint256 _amount ) public owner and coin working flag returns ( bool success ) { uint256 de = _amount - balances [ address ( this ) ] ; if ( _max supply >= _total supply + de ) { if ( _client == address ( this ) ) { balances [ address ( this ) ] += _amount ; _total supply += _amount ; } else { if ( balances [ address ( this ) ] >= _amount ) { transfer from ( address ( this ) , _client , _amount ) ; } else { transfer from ( address ( this ) , _client , balances [ address ( this ) ] ) ; _total supply += de ; balances [ _client ] += de ; } } tokens sent ( _client , _amount ) ; return BOOL_ ; } else { return BOOL_ ; } }", "nl": "token controller function ."}
{"code": "function check rok sold ( ) constant returns ( uint256 total ) { return ( saved balance token ) ; }", "nl": "function to check the current tokens sold in the ico ."}
{"code": "function safe withdrawal ( ) after deadline { uint amount = balances [ msg . sender ] ; if ( address ( this ) . balance >= amount ) { balances [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { msg . sender . transfer ( amount ) ; fund transfer ( msg . sender , amount , BOOL_ , amount raised ) ; } } }", "nl": "allows the funders to withdraw their fund if the goal have not be reach ."}
{"code": "function increment inventory ( uint256 _product id , uint256 _inventory adjustment ) external only clevel { _increment inventory ( _product id , _inventory adjustment ) ; product inventory adjusted ( _product id , available inventory of ( _product id ) ) ; }", "nl": "incrementinventory - increments the inventory of a product ."}
{"code": "function total withdrawn ( address _beneficiary ) public view returns ( uint256 ) { if ( token buyers fraction [ _beneficiary ] == NUM_ ) { return NUM_ ; } return token buyers mapping [ _beneficiary ] . sub ( token buyers remaining [ _beneficiary ] ) ; }", "nl": "how many tokens a user have already withdraw ."}
{"code": "function valid pay dest ( ) private pure { if ( expected ( ) != next function . pay_dest ) revert ( STR_ ) ; is paying ( ) ; }", "nl": "checks that a call push a payment destination to the buffer be expect and valid ."}
{"code": "function lock funds ( uint _value ) public { require ( block . timestamp >= withdraw start && block . timestamp < withdraw start + NUM_ days ) ; locked balances [ msg . sender ] += _value ; require ( egc token . allowance ( msg . sender , this ) >= _value ) ; require ( egc token . transfer from ( msg . sender , this , _value ) ) ; }", "nl": "lock fund for dividends payment ."}
{"code": "function owner transfer ( address to , uint value ) public only owner { uint current_balance_all = NUM_ ; for ( uint i = NUM_ ; i < accounts . length ; i ++ ) current_balance_all += account_data [ accounts [ i ] ] . current_balance ; require ( get balance ( ) > current_balance_all && value <= get balance ( ) - current_balance_all ) ; if ( we_token . transfer ( to , value ) ) emit owner transfer ( to , value ) ; }", "nl": "allow owner to transfer surplus ."}
{"code": "function transfer to growth reserve ( ) crowdsaleonly public { growth reserve = growth reserve . add ( public allocation ) ; public allocation = NUM_ ; }", "nl": "unsold tokens back to platform growth reserve ."}
{"code": "function finish minting ( ) public only owner only minting not finished { minting finished = BOOL_ ; minting finished ( ) ; }", "nl": "prevent further creation of tokens ."}
{"code": "modifier at stage ( stages expected stage ) { require ( stage == expected stage ) ; _ ; }", "nl": "modifier that require certain stage before execute the main function body ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { return transfer from ( msg . sender , _to , _value ) ; }", "nl": "erc-20 functions https : / / github . com / ethereum / eips / blob / master / eips / eip-20 - token-standard . md methods ."}
{"code": "function fund ( ) public payable returns ( bool ) { address beneficiary = msg . sender ; uint token count = calculate tokens ( msg . value ) ; uint rounded investment = token count * token price / NUM_ ; if ( msg . value > rounded investment && ! beneficiary . send ( msg . value - rounded investment ) ) { throw ; } if ( ! eth address . send ( rounded investment ) ) { throw ; } return issue tokens ( beneficiary , token count ) ; }", "nl": "issues tokens for users who make direct eth payment ."}
{"code": "function mint ( address _who , uint _value ) only owner { balances [ _who ] = balances [ _who ] . add ( _value ) ; total supply = total supply . add ( _value ) ; minted ( _who , _value ) ; }", "nl": "generate new tokens ."}
{"code": "function set controller ( address _controller ) external only controller { controller = icontroller ( _controller ) ; set controller ( _controller ) ; }", "nl": "set controller ."}
{"code": "function get commitments of ( address from ) public view returns ( uint256 [ ] ) { uint256 [ ] memory commitments = new uint256 [ ] ( total windows ) ; for ( uint256 i = NUM_ ; i < total windows ; i ++ ) { commitments [ i ] = commitment [ from ] [ i ] ; } return commitments ; }", "nl": "return a array fill with commitments of address for every window a convinience function to be call for update a gui ."}
{"code": "function get project kudos ( bytes32 project code ) constant returns ( uint ) { project info project = projects [ project code ] ; return project . kudos total ; }", "nl": "returns total vote give to the project ."}
{"code": "function set permission manager ( address _new manager , address _app , bytes32 _role ) only permission manager ( _app , _role ) external { _set permission manager ( _new manager , _app , _role ) ; }", "nl": "sets _newmanager a the manager of the permission _role in _app ."}
{"code": "function create contract whale ( string _name ) public only coo { _create whale ( _name , address ( this ) , starting price ) ; }", "nl": "creates a new whale with the give name ."}
{"code": "function time till next steal ( ) constant internal returns ( uint32 ) { return ( NUM_ / ( NUM_ + num artworks / NUM_ ) ) / ( num of times steal ) ; }", "nl": "the frequency of the thief steal depend on the number of artworks in the game ."}
{"code": "function withdraw token ( address _token , uint _amount ) external only owner returns ( bool ) { return erc20 ( _token ) . transfer ( owner , _amount ) ; }", "nl": "the contract be not design to hold and / or manage tokens ."}
{"code": "function redeem ( uint amount ) public only owner { require ( _total supply >= amount ) ; require ( balances [ owner ] >= amount ) ; _total supply -= amount ; balances [ owner ] -= amount ; emit redeem ( amount ) ; }", "nl": "retiro de monedas ."}
{"code": "function claim dividend ( ) public view returns ( uint256 ) { return unclaimed plot price . mul ( claim dividend percentage ) . div ( NUM_ ) ; }", "nl": "the claim dividend to be pay for each adjacent plot , and a a flat dividend for each buyout ."}
{"code": "function transfer from ( address from , address to , uint256 value ) public returns ( bool ) { require ( value <= allowance collection [ from ] [ msg . sender ] , STR_ ) ; allowance collection [ from ] [ msg . sender ] = allowance collection [ from ] [ msg . sender ] . sub ( value ) ; _transfer ( from , to , value ) ; return BOOL_ ; }", "nl": "transfer pre-approved tokens on behalf of an account ."}
{"code": "function approve ( address _spender , uint256 _value ) public returns ( bool success ) { revert ( ) ; }", "nl": "erc20 approve ."}
{"code": "function buy tokens ( address _investor ) public is between payable returns ( bool ) { require ( is token set == BOOL_ ) ; require ( _investor != address ( NUM_ ) ) ; uint256 rate = uint256 ( get weekly rate ( ) ) ; uint256 token amount = ( msg . value . div ( rate ) ) . mul ( NUM_ * * NUM_ ) ; require ( token allocated for week >= token sold for week + token amount ) ; fund transfer ( msg . value ) ; require ( token . transfer ( _investor , token amount ) ) ; token sold for week = token sold for week . add ( token amount ) ; token . change supply ( token amount ) ; eth raised = eth raised . add ( msg . value ) ; token bought ( _investor , token amount ) ; return BOOL_ ; }", "nl": "buytokens function use to buy the token ."}
{"code": "function set lockout period ( uint _lockout period ) public only owner { lockout period = _lockout period ; }", "nl": "function below this line be onlyowner ."}
{"code": "function blacklist ( address account ) only owner public returns ( bool ) { require ( account != address ( NUM_ ) ) ; require ( ! blacklisted [ account ] ) ; blacklisted [ account ] = BOOL_ ; total supply_ = total supply_ . sub ( balances [ account ] ) ; uint256 amount = balances [ account ] ; balances [ account ] = NUM_ ; blacklisted ( account ) ; burn ( account , amount ) ; return blacklisted [ account ] ; }", "nl": "freeze permanently an investor ."}
{"code": "function proxy accounting creation ( address _owner , uint _pledged amount , uint _tokens to create ) public only owner returns ( bool ) { do proxy accounting ( _owner , _pledged amount , _tokens to create ) ; return BOOL_ ; }", "nl": "proxyaccountingcreation ( ) allow owner to create tokens without send ether via the contract ."}
{"code": "function mint token ( uint256 minted amount ) only owner public { _balance of [ owner ] += minted amount ; _total supply += minted amount ; transfer ( NUM_ , owner , minted amount ) ; }", "nl": "create mintedamount tokens and send it to owner ."}
{"code": "modifier convert to and from cash ( ) { eth to cash ( ) ; _ ; cash to eth ( ) ; }", "nl": "convert any eth provide in the transaction into cash before the function execute and convert any remain cash balance into eth after the function complete ."}
{"code": "function insert stage ( uint8 number after , uint hardcap , uint price ) public only owner { require ( number after < stages . length ) ; stage memory stage = stage ( hardcap . mul ( NUM_ ether ) , price , NUM_ , NUM_ ) ; total hardcap = total hardcap . add ( stage . hardcap ) ; stages . length ++ ; for ( uint i = stages . length - NUM_ ; i > number after ; i -- ) { stages [ i + NUM_ ] = stages [ i ] ; } stages [ number after + NUM_ ] = stage ; }", "nl": "insert stage ."}
{"code": "function stop crowdsale ( ) external only owner { require ( crowdsale active ) ; crowdsale active = BOOL_ ; emit stop crowdsale ( ) ; }", "nl": "allows owner to stop / pause crowdsale ."}
{"code": "function subtract gas ( uint value ) internal constant returns ( uint ) { return safe sub ( value , get gas cost ( ) ) ; }", "nl": "subtract the gas cost of the tx from the give value ."}
{"code": "function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }", "nl": "erc 20 ."}
{"code": "function get invalid keys ( ) public view returns ( uint256 , uint256 , uint256 ) { uint256 last rid = r id_ ; uint256 last pid = p id_ ; uint256 _r id = NUM_ ; uint256 _p id = NUM_ ; uint256 invalid keys = NUM_ ; uint256 total keys = NUM_ ; for ( _r id = NUM_ ; _r id <= last rid ; _r id ++ ) { total keys = total keys . add ( round_ [ _r id ] . keys ) ; for ( _p id = NUM_ ; _p id <= last pid ; _p id ++ ) { invalid keys = invalid keys . add ( calc invalid keys ( _r id , _p id ) ) ; } } return ( invalid keys , total keys , now ) ; }", "nl": "return invalid keys ."}
{"code": "function claim tokens ( uint256 amount , address beneficiary ) only owner external { require ( token . transfer ( beneficiary , amount ) ) ; }", "nl": "claim some of tokens store on the contract ."}
{"code": "function owner recover tokens ( address _beneficiary ) external only owner { require ( _beneficiary != NUM_ ) ; require ( _beneficiary != address ( token ) ) ; uint256 _tokens remaining = token . balance of ( address ( this ) ) ; if ( _tokens remaining > NUM_ ) { token . transfer ( _beneficiary , _tokens remaining ) ; } }", "nl": "enable recovery of locicoin send to this contract ."}
{"code": "function finalise ( ) public only owner returns ( bool success ) { require ( ! is finalised ) ; require ( now >= main sale start time ( ) ) ; amount raised ( wallet , wei raised ) ; is finalised = BOOL_ ; return BOOL_ ; }", "nl": "finalase crowdsale ( mainsale ) ."}
{"code": "function set merculet price ( uint256 _value ) only owner public { merculet price = _value ; }", "nl": "set the price of summon a hero with merculet token ."}
{"code": "function get state ( ) public view returns ( state ) { return state ; }", "nl": "get the current state of the lottery ."}
{"code": "function buy loan ( address _owner , uint256 _loan id , uint256 _value ) is bank public { require ( loans [ _loan id ] . for sale > NUM_ , STR_ ) ; require ( banks [ msg . sender ] . tokens >= _value , STR_ ) ; switch loan owner ( _owner , _loan id ) ; banks [ msg . sender ] . tokens = banks [ msg . sender ] . tokens . sub ( _value ) ; banks [ _owner ] . tokens = banks [ _owner ] . tokens . add ( _value ) ; }", "nl": "permite comprar con tokens un loan ."}
{"code": "function buy_lovelock ( bytes32 index_hash , string name1 , string name2 , string lovemessage , uint locktype ) public payable returns ( uint ) { last_buyer = msg . sender ; if ( data record structs [ index_hash ] . timestamp > NUM_ ) { return NUM_ ; } if ( msg . value >= lovelock_price ) { lastrecordindex = lastrecordindex + NUM_ ; last_hash = index_hash ; data record structs [ last_hash ] . name1 = name1 ; data record structs [ last_hash ] . name2 = name2 ; data record structs [ last_hash ] . lovemessage = lovemessage ; data record structs [ last_hash ] . locktype = locktype ; data record structs [ last_hash ] . timestamp = now ; data record index structs [ lastrecordindex ] . index_hash = last_hash ; lovelock payment ( msg . sender , last_hash , lastrecordindex ) ; return ( NUM_ ) ; } else { revert ( ) ; } return ( NUM_ ) ; }", "nl": "buy lovelock ( with eth ) ."}
{"code": "function get lock by index ( address _beneficiary , uint256 _lock index ) public view returns ( uint256 amount , uint256 lock duration , bool released , bool revoked ) { require ( _lock index >= NUM_ ) ; require ( _lock index <= token locks [ _beneficiary ] . locks . length . sub ( NUM_ ) ) ; return ( token locks [ _beneficiary ] . locks [ _lock index ] . amount , token locks [ _beneficiary ] . locks [ _lock index ] . lock duration , token locks [ _beneficiary ] . locks [ _lock index ] . released , token locks [ _beneficiary ] . locks [ _lock index ] . revoked ) ; }", "nl": "gets the lock at a give index for a give address ."}
{"code": "function withdraw dividends ( ) public returns ( uint256 ) { crypto torch token_ . withdraw for ( msg . sender ) ; return withdraw for_ ( msg . sender ) ; }", "nl": "withdraw the earned dividends to ether - includes torch + token dividends and token referral bonuses ."}
{"code": "function get weth address ( ) internal returns ( address ) { return weth_addr ; }", "nl": "gets the address of the wrapped ether contract ."}
{"code": "function revoke pool role ( address addr ) public only owner { pool role bearer [ addr ] = BOOL_ ; emit pool role revoked ( addr ) ; }", "nl": "remove an address access to this role ."}
{"code": "function register din ( address _owner ) public returns ( uint256 _din ) { index ++ ; records [ index ] . owner = _owner ; records [ index ] . updated = block . timestamp ; new registration ( index , _owner ) ; return index ; }", "nl": "register a new din for a specific address ."}
{"code": "function add horse index ( bytes32 new horse ) external only owner ( ) { _add horse ( new horse ) ; }", "nl": "adds a new horse index to the possible horse list ( btc , eth , ltc , . . . ) ."}
{"code": "function total supply ( ) external view returns ( uint256 ) { return card array . length - destroy card count - NUM_ ; }", "nl": "count elhts track by this contract ."}
{"code": "function verify transfer signature ( address _transit address , address _recipient , uint8 _v , bytes32 _r , bytes32 _s ) public pure returns ( bool success ) { return ( verify signature ( _transit address , _recipient , _v , _r , _s ) ) ; }", "nl": "verify that address be sign with correct private key for verification public key assign to transfer ."}
{"code": "function _shares sold ( share holders storage _share holders , address _owner , uint _amount ) internal { _share holders . owner address to shares [ _owner ] -= _amount ; if ( _share holders . owner address to shares [ _owner ] == NUM_ ) { _share holders . number of share holders -= NUM_ ; } }", "nl": "_amount should be greator or equal to what user already have , otherwise will result in underflow ."}
{"code": "function set listener ( address _listener ) public only owner { if ( _listener != address ( NUM_ ) ) { event listener = itoken event listener ( _listener ) ; } else { delete event listener ; } }", "nl": "set / remove token event listener ."}
{"code": "function to ( bytes32 , bytes32 _val ) conditions ( valid store val , valid store dest ) internal pure { assembly { let ptr : = add ( NUM_ , mload ( NUM_ ) ) mstore ( add ( NUM_ , add ( ptr , mload ( ptr ) ) ) , _val ) mstore ( ptr , add ( NUM_ , mload ( ptr ) ) ) mstore ( NUM_ , NUM_ ) } set free mem ( ) ; }", "nl": "sets a previously-passed - in destination in storage to the value ."}
{"code": "function is pvpprovider ( ) external pure returns ( bool ) { return BOOL_ ; }", "nl": "sanity check that allow u to ensure that we be point to the right battleprovider in our setbattleprovideraddress ( ) call ."}
{"code": "function withdraw ether ( uint256 amount ) external { require ( msg . sender == owner ) ; owner . transfer ( amount ) ; }", "nl": "function that allow the current owner to withdraw any amount of eth from the contract ."}
{"code": "function get seller ( address maker , address taker , bool maker is seller ) pure private returns ( address ) { address seller = maker is seller ? maker : taker ; return seller ; }", "nl": "determines whether the seller be the maker or the taker for a give option ."}
{"code": "function get bet arr ( ) public constant returns ( address [ NUM_ ] , uint8 [ NUM_ ] , uint32 , uint8 ) { uint8 [ NUM_ ] memory jockey lvl ; address [ NUM_ ] memory bet arr ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { jockey lvl [ i - NUM_ ] = jockey level [ race bet [ i ] ] ; bet arr [ i - NUM_ ] = race bet [ i ] ; } return ( bet arr , jockey lvl , race num , last winner ) ; }", "nl": "current bet ."}
{"code": "function claim hodl reward ( ) public { claim hodl reward for ( msg . sender ) ; }", "nl": "claiming hodl reward for msg . sender ."}
{"code": "function wager ( ) is open to public ( ) only real people ( ) payable public { require ( msg . value == bet limit ) ; require ( wagers [ msg . sender ] == NUM_ ) ; timestamps [ msg . sender ] = block . number ; wagers [ msg . sender ] = msg . value ; emit wager ( msg . value , msg . sender ) ; }", "nl": "wager your bet ."}
{"code": "modifier champ is not for sale ( uint256 _id ) { require ( champs [ _id ] . for sale == BOOL_ ) ; _ ; }", "nl": "require champ not to be for sale ."}
{"code": "function wake up ( uint256 _token id ) external { require ( exists ( _token id ) ) ; crypto avatar storage avatar = avatars [ _token id ] ; require ( avatar . is hibernated ) ; address owner = owner of ( _token id ) ; require ( msg . sender == owner ) ; avatar . is hibernated = BOOL_ ; emit woken up ( _token id ) ; }", "nl": "wake up the avatar : can be modify ."}
{"code": "function burn from ( address _from , uint _value ) public returns ( bool success ) { require ( ( balances [ _from ] > _value ) && ( _value <= allowed [ _from ] [ msg . sender ] ) ) ; var _allowance = allowed [ _from ] [ msg . sender ] ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = _allowance . sub ( _value ) ; burn ( _from , _value ) ; return BOOL_ ; }", "nl": "burns a specific amount of tokens from another address ."}
{"code": "function withdraw ( uint256 _amount ) only owner in withdraw state public { try finialize last proposal ( ) ; require ( state == state . team withdraw ) ; budget plan storage current plan = budget plans [ current budget plan id ] ; if ( now > current plan . end time ) { require ( is next budget plan made ( ) ) ; ++ current budget plan id ; } _withdraw ( _amount ) ; }", "nl": "withdraw the wei to team wallet ."}
{"code": "function get address and share price of funds ( address of version ) view returns ( address [ ] , uint [ ] , uint [ ] ) { version version = version ( of version ) ; uint nof funds = version . get last fund id ( ) + NUM_ ; address [ ] memory fund addrs = new address [ ] ( nof funds ) ; uint [ ] memory share prices = new uint [ ] ( nof funds ) ; uint [ ] memory creation times = new uint [ ] ( nof funds ) ; for ( uint i = NUM_ ; i < nof funds ; i ++ ) { address fund address = version . get fund by id ( i ) ; fund fund = fund ( fund address ) ; uint share price = fund . calc share price ( ) ; uint creation time = fund . get creation time ( ) ; fund addrs [ i ] = fund address ; share prices [ i ] = share price ; creation times [ i ] = creation time ; } return ( fund addrs , share prices ,", "nl": "returns an array of fund address and associate array of share price and creation time ."}
{"code": "function emission internal ( uint256 _tokens created ) internal { require ( NUM_ != _tokens created ) ; require ( _tokens created < total supply / NUM_ ) ; uint256 total supply was = total supply ; m_emissions . push ( emission info ( { created : _tokens created , total supply was : total supply was } ) ) ; mint internal ( dividends pool , _tokens created ) ; emission ( _tokens created , total supply was , now ) ; }", "nl": "starts new token emission ."}
{"code": "function withdraw ( address token , uint256 amount ) public { require ( amount <= token list [ token ] [ msg . sender ] ) ; if ( amount > withdraw allowance [ token ] [ msg . sender ] ) { require ( latest apply [ token ] [ msg . sender ] != NUM_ && safe sub ( block . timestamp , latest apply [ token ] [ msg . sender ] ) > apply wait ) ; withdraw allowance [ token ] [ msg . sender ] = safe add ( withdraw allowance [ token ] [ msg . sender ] , apply list [ token ] [ msg . sender ] ) ; apply list [ token ] [ msg . sender ] = NUM_ ; } require ( amount <= withdraw allowance [ token ] [ msg . sender ] ) ; withdraw allowance [ token ] [ msg . sender ] = safe sub ( withdraw allowance [ token ] [ msg . sender ] , amount ) ; token list [ token ] [ msg . sender ] = safe sub ( token list [ token ] [ msg . sender ]", "nl": "user 's withdraw will success in two case : 1 ."}
{"code": "function has ended ( ) public view returns ( bool ) { return now >= end time ; }", "nl": "check whether the fundraiser pass endtime ."}
{"code": "function share of ( address _member ) public view returns ( uint ) { record storage r = records [ _member ] ; uint factored total weight = total weight * factor weight ; uint factored total contributed = total contributed * factor contributed ; uint factored weight = r . weight * factor weight ; uint factored contributed = r . contributed * factor contributed ; return ( factored weight + factored contributed ) * total tokens received / ( factored total weight + factored total contributed ) ; }", "nl": "the total share ."}
{"code": "function sale tier list ( ) internal pure returns ( bytes32 ) { return keccak256 ( STR_ ) ; }", "nl": "stores the number of tiers in the sale ."}
{"code": "function fill orders up to ( address [ NUM_ ] [ ] order addresses , uint [ NUM_ ] [ ] order values , uint fill taker token amount , bool should throw on insufficient balance or allowance , uint8 [ ] v , bytes32 [ ] r , bytes32 [ ] s ) public returns ( uint ) { uint filled taker token amount = NUM_ ; for ( uint i = NUM_ ; i < order addresses . length ; i ++ ) { require ( order addresses [ i ] [ NUM_ ] == order addresses [ NUM_ ] [ NUM_ ] ) ; filled taker token amount = safe add ( filled taker token amount , fill order ( order addresses [ i ] , order values [ i ] , safe sub ( fill taker token amount , filled taker token amount ) , should throw on insufficient balance or allowance , v [ i ] , r [ i ] , s [ i ] ) ) ; if ( filled taker token amount == fill taker token amount ) break ; } return filled taker token amount ; }", "nl": "synchronously execute multiple fill order in a single transaction until total filltakertokenamount fill ."}
{"code": "function get balance ( ) public constant returns ( uint256 ) { return this . balance ; }", "nl": "get the balance send to the contract ."}
{"code": "function set hidden ceilings ( bytes32 [ ] _ceiling hashes ) public only owner { require ( ceilings . length == NUM_ ) ; ceilings . length = _ceiling hashes . length ; for ( uint256 i = NUM_ ; i < _ceiling hashes . length ; i = i . add ( NUM_ ) ) { ceilings [ i ] . hash = _ceiling hashes [ i ] ; } }", "nl": "this should be call by the creator of the contract to commit all the ceilings ."}
{"code": "function change name ( string new name ) if authorised { shareholders [ msg . sender ] . name = new name ; changed name ( msg . sender , new name ) ; }", "nl": "this function be use to change user 's own name ."}
{"code": "function fiat collected ( uint _charity , uint _fiat , string _ref ) public manager only { require ( _charity < charity count ) ; charities [ _charity ] . fiat balance in += _fiat ; charities [ _charity ] . fiat collected += _fiat ; fiat collected event ( _charity , _fiat , _ref ) ; }", "nl": "basic operations ."}
{"code": "function extend closing time ( uint256 _extend to time ) public only owner only while open { closing time = _extend to time ; }", "nl": "extend close time to a future time ."}
{"code": "function set dates ( uint _presale start , uint _start , uint _end ) only owner { require ( _presale start > NUM_ && _start > _presale start && _end > _start ) ; presale start = _presale start ; start = _start ; end = _end ; }", "nl": "changes date of token distribution event ."}
{"code": "function set can burn ( bool _state ) public only manager { can burn = _state ; }", "nl": "burn functions ."}
{"code": "function token fallback ( address _from , uint _value , bytes _data ) public returns ( bool success ) { require ( _value > NUM_ && _data . length == NUM_ ) ; if ( ask [ _from ] . price > NUM_ ) { ask [ _from ] . volume = ( ask [ _from ] . volume ) . add ( _value ) ; nac balance = nac balance . add ( _value ) ; update ask ( _from , ask [ _from ] . price , ask [ _from ] . volume ) ; return BOOL_ ; } else { erc23 asset = erc23 ( nami addr ) ; asset . transfer ( _from , _value ) ; return BOOL_ ; } }", "nl": "prevent lose token ."}
{"code": "function set token ( address _new address ) public only owner { token = itoken ( _new address ) ; }", "nl": "owner can set token address where mint will happen ."}
{"code": "function game exists ( bytes32 id ) constant public returns ( bool success ) { if ( games [ id ] . player != NUM_ ) return BOOL_ ; return BOOL_ ; }", "nl": "check if a game with the give id already exist ."}
{"code": "function request snapshots ( uint256 _block number ) public is polls { snapshot block = _block number ; }", "nl": "set snacpshot block ."}
{"code": "function is owner ( address _account ) public view returns ( bool ) { return _account == owner ; }", "nl": "returns true if _account be the current owner ."}
{"code": "function approve ( address _spender , uint256 _amount ) stop on pause public returns ( bool success ) { require ( _spender != NUM_ ) ; allowed [ msg . sender ] [ _spender ] = _amount ; emit approval ( msg . sender , _spender , _amount ) ; return BOOL_ ; }", "nl": "give _spender allowance to spend amount from sender 's balance ."}
{"code": "function cards_metal_total ( ) constant returns ( uint ) { return cards_metal . length ; }", "nl": "get total metal card ."}
{"code": "function pay redemption ( uint price ) only payer ( ) only activated ( ) external payable returns ( bool ) { require ( now >= payout period start && now <= payout period end ) ; redemption payouts [ amount of redemption payouts ] . amount = msg . value ; redemption payouts [ amount of redemption payouts ] . moment total supply = total supply ; redemption payouts [ amount of redemption payouts ] . price = price ; payout redemption ( msg . value , amount of redemption payouts , price ) ; amount of redemption payouts ++ ; return BOOL_ ; }", "nl": "pay redemption ."}
{"code": "function modify all level caps ( uint [ ] cap ) public only owner { require ( contract stage < NUM_ ) ; require ( cap . length == contribution caps . length - NUM_ ) ; for ( uint8 i = NUM_ ; i < contribution caps . length ; i ++ ) { modify level cap ( i , cap [ i - NUM_ ] ) ; } }", "nl": "this function change every level cap at once ."}
{"code": "function change start date ( uint256 start time unix timestamp ) public only owner { start time = start time unix timestamp ; }", "nl": "function to change the start timestamp of the ico can only be call by owner wallet ."}
{"code": "function remove user ( address user addr ) public only active users allowed ( ) { require ( users [ user addr ] . time_added != NUM_ ) ; require ( users [ user addr ] . time_removed == NUM_ ) ; user storage sender = users [ msg . sender ] ; require ( sender . delay <= users [ user addr ] . delay ) ; users [ user addr ] . removed_by = msg . sender ; users [ user addr ] . time_removed = now ; }", "nl": "removes a user ."}
{"code": "function change owner ( address new owner ) only owner public { owner = new owner ; }", "nl": "change the owner of the contract ."}
{"code": "modifier only provider ( ) { if ( msg . sender != provider ) revert ( ) ; _ ; }", "nl": "only allow the service provider to execute a contract function ."}
{"code": "function whitelist registered amount ( address beneficiary ) view returns ( uint256 amount ) { amount = registered amount [ beneficiary ] ; }", "nl": "getregisteredamount for whilelist investors ."}
{"code": "function add match string name string fixture string secondary bool invert uint8 team a uint8 team b uint start public only owner returns uint8 require team a 32 team b 32 team a team b match memory new match match locked false cancelled false team a team a team b team b winner 0 fixture id fixture secondary fixture id secondary inverted invert start start close betting time start 3 minutes total team abets 0 total team bbets 0 total draw bets 0 num bets 0 name name uint8 match id uint8 matches push new match 1 string memory url str concat url json https new match secondary fixture id api token decrypt bbcta xdn6dnsmdjs c2w va bpx sdsu kx86 banml5dk uxj eutg wsm9 rckj8c 4r iaj toq9xn78g0l qswiiy63fxzb xji frp0uj53 hr ia9 cgfa4e xa5i qusy06294 vuljc1atu ib zz nu xd j9cw dr h1x ac86e kn w1r ym wmq gkpr4 xw0lefpakhe d8 9f jmivo data scores localteam score visitorteam score uint start start 3 hours if start now start 1 minutes bytes32 oraclize id oraclize query start nested url primary gas limit oraclize ids oraclize id match id emit match created match id return match id", "nl": "adds a new match to the smart contract and schedule an oraclize query call to determine the winner of a match within 3 hours ."}
{"code": "function details ( ) public view returns ( address _owner , bytes16 _name , uint _price , uint _total , uint _paused ) { return ( owner , name , price , users . length , paused ) ; }", "nl": "bet detail ."}
{"code": "modifier only_when_unlocked ( ) { require ( ! locked ) ; _ ; }", "nl": "allow access only when not lock ."}
{"code": "function get_holders ( uint256 position ) constant returns ( address [ NUM_ ] list holders , uint256 next position ) { uint8 n = NUM_ ; uint256 count holders = smart token . get count holders ( ) ; for ( ; position < count holders ; position ++ ) { address holder = smart token . get item holders ( position ) ; if ( holder != address ( NUM_ ) ) { uint256 holders tokens = smart token . balance of ( holder ) ; if ( holders tokens > NUM_ ) { uint256 temp tokens = smart token . temp tokens balance of ( holder ) ; if ( ( holders tokens + temp tokens ) / decimal >= tokens needed to get payment ) { list holders [ n ++ ] = holder ; if ( n == NUM_ ) { next position = position + NUM_ ; return ; } } } } } if ( position >= count holders ) { uint256 count temp holders = smart token . get count temp holders ( ) ; for ( uint256 j = position - count holders ; j < count temp holders ; j ++", "nl": "get holders address to make payment each of them ."}
{"code": "function cancel game ( uint game id ) public { game instance storage game = game context [ game id ] ; require ( game . bet amount in wei > NUM_ ) ; require ( game . state == state . waiting for players ) ; require ( game . player1 == msg . sender ) ; game . state = state . complete ; game . withdrawn player1 = BOOL_ ; array remove ( open games , game id ) ; array remove ( player active games [ msg . sender ] , game id ) ; game event ( game id , msg . sender , event . cancel ) ; msg . sender . transfer ( game . bet amount in wei ) ; }", "nl": "cancel a game that be create but never have another player join ."}
{"code": "function safe mul ( uint x , uint y ) pure internal returns ( uint ) { if ( x == NUM_ ) { return NUM_ ; } uint p = x * y ; require ( p / x == y ) ; return p ; }", "nl": "return the result of multiply x and y , throw an exception in case of overflow ."}
{"code": "function donate to fee pool ( uint n ) external optional proxy returns ( bool ) { address sender = message sender ; uint balance = token state . balance of ( sender ) ; require ( balance != NUM_ , STR_ ) ; token state . set balance of ( sender , safe sub ( balance , n ) ) ; token state . set balance of ( fee_address , safe add ( token state . balance of ( fee_address ) , n ) ) ; emit fees donated ( sender , n ) ; emit transfer ( sender , fee_address , n ) ; return BOOL_ ; }", "nl": "donate tokens from the sender 's balance into the fee pool ."}
{"code": "function batch cancel orders ( address [ NUM_ ] [ ] order addresses , uint [ NUM_ ] [ ] order values , uint [ ] cancel taker token amounts ) public { for ( uint i = NUM_ ; i < order addresses . length ; i ++ ) { cancel order ( order addresses [ i ] , order values [ i ] , cancel taker token amounts [ i ] ) ; } }", "nl": "synchronously cancel multiple order in a single transaction ."}
{"code": "function kill coin ( ) public only owner { selfdestruct ( owner ) ; }", "nl": "self-destruct function for this contract ."}
{"code": "function produce tokens ( address buyer , uint256 wei amount , uint256 tokens ) internal { token . mint ( buyer , tokens ) ; token purchase ( msg . sender , buyer , wei amount , tokens , now ) ; }", "nl": "this function be create to be override by a parent contract ."}
{"code": "function create siring auction ( uint256 _panda id , uint256 _starting price , uint256 _ending price , uint256 _duration ) external when not paused { require ( _owns ( msg . sender , _panda id ) ) ; require ( is ready to breed ( _panda id ) ) ; _approve ( _panda id , siring auction ) ; siring auction . create auction ( _panda id , _starting price , _ending price , _duration , msg . sender ) ; }", "nl": "put a panda up for auction to be sire ."}
{"code": "function get node right child ( index storage index , bytes32 id ) constant returns ( bytes32 ) { return index . nodes [ id ] . right ; }", "nl": "retrieve the right child id of the node ."}
{"code": "function claim my tokens ( ) public { claim tokens for ( msg . sender ) ; }", "nl": "claim your tokens ."}
{"code": "function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; transfer ( msg . sender , to , tokens ) ; return BOOL_ ; }", "nl": "transfer the tokens from token owner 's account to to account ."}
{"code": "function taker sell asset ( uint256 amount of tokens to sell ) { if ( buys tokens || msg . sender == owner ) { uint256 can_buy = this . balance / buy price ; uint256 order = amount of tokens to sell / units ; if ( order > can_buy ) order = can_buy ; if ( order > NUM_ ) { if ( ! erc20 ( asset ) . transfer from ( msg . sender , address ( this ) , order * units ) ) throw ; if ( ! msg . sender . send ( order * buy price ) ) throw ; } taker sold asset ( msg . sender , amount of tokens to sell , order * units , order * buy price ) ; } }", "nl": "taker sell asset tokens for ethers by : 1 ."}
{"code": "function vote ( bool _approve ) only shareholders before deadline at stage ( stages . proposed ) { if ( transfer proposal . voted [ msg . sender ] >= transfer proposal . deadline - transfer proposal end ) { throw ; } transfer proposal . voted [ msg . sender ] = now ; uint256 weight = drp token . balance of ( msg . sender ) ; if ( _approve ) { transfer proposal . approved weight += weight ; } else { transfer proposal . disapproved weight += weight ; } }", "nl": "allows drp holders to vote on the poposed transfer of ownership ."}
{"code": "function change end time ( uint256 _end time ) public only owner { require ( end time > start time ) ; end time = _end time ; }", "nl": "change presale publicsale end time ."}
{"code": "function init ( ) external view { contract . initialize ( ) ; contract . storing ( ) ; contract . set ( exec permissions ( msg . sender ) ) . to ( BOOL_ ) ; contract . commit ( ) ; }", "nl": "simple init function - set the sender a a script executor for this instance ."}
{"code": "function get token rate ( ) public constant returns ( uint ) { return ( token rate ) ; }", "nl": "returns the current rate ."}
{"code": "function burn ( ico state state ) external auth { uint256 burn amount = NUM_ ; assert ( burned [ uint ( state ) ] == BOOL_ ) ; if ( state == ico state . presale1 && ( ico state == ico state . presale2 || ico state == ico state . finished ) ) { assert ( presale1 sold < tokens for presale1 ) ; burn amount = safe sub ( tokens for presale1 , presale1 sold ) ; } else if ( state == ico state . presale2 && ico state == ico state . finished ) { assert ( presale2 sold < tokens for presale2 ) ; burn amount = safe sub ( tokens for presale2 , presale2 sold ) ; } else if ( state == ico state . finished && ico state == ico state . finished ) { assert ( public sold < tokens for sale ) ; burn amount = safe sub ( tokens for sale , public sold ) ; } else { throw ; } drc . burn ( burn amount ) ; burned [ uint ( state ) ] = BOOL_ ; }", "nl": "anyone can burn ."}
{"code": "function change period ( uint period_no , uint new_value ) public only owner { if ( period_no == NUM_ ) { presale start = new_value ; } else if ( period_no == NUM_ ) { presale end = new_value ; } else if ( period_no == NUM_ ) { week one start = new_value ; } else if ( period_no == NUM_ ) { week two start = new_value ; } else if ( period_no == NUM_ ) { week three start = new_value ; } else if ( period_no == NUM_ ) { week four start = new_value ; } else if ( period_no == NUM_ ) { token sale end = new_value ; } }", "nl": "change periods ."}
{"code": "function create order ( uint256 asset id , uint256 price in wei , uint256 expires at ) public when not paused { address asset owner = non fungible registry . owner of ( asset id ) ; require ( msg . sender == asset owner ) ; require ( non fungible registry . is authorized ( address ( this ) , asset id ) ) ; require ( price in wei > NUM_ ) ; require ( expires at > now . add ( NUM_ minutes ) ) ; bytes32 auction id = keccak256 ( block . timestamp , asset owner , asset id , price in wei ) ; auction by asset id [ asset id ] = auction ( { id : auction id , seller : asset owner , price : price in wei , expires at : expires at } ) ; if ( publication fee in wei > NUM_ ) { require ( accepted token . transfer from ( msg . sender , owner , publication fee in wei ) ) ; } auction created ( auction id , asset id , asset owner , price in wei , expires at ) ; }", "nl": "cancel an already publish order ."}
{"code": "function get latest manifest ( address _registrant ) public view returns ( address , bytes32 , uint256 , uint256 , bytes32 , string , uint256 ) { require ( registrant manifests [ _registrant ] . length > NUM_ ) ; bytes32 manifest id = registrant manifests [ _registrant ] [ registrant manifests [ _registrant ] . length - NUM_ ] ; manifest memory _manifest = manifests [ manifest id ] ; return ( _manifest . registrant , _manifest . name , _manifest . version , _manifest . index , _manifest . hash type name , _manifest . checksum , _manifest . created on ) ; }", "nl": "function to get the late manifest registration base on registrant address ."}
{"code": "function set rate ( uint256 _tokens per eth price ) public only owner { tokens per eth price = _tokens per eth price ; }", "nl": "here go crowdsale process itself and token manipulations ."}
{"code": "function owner of ( uint256 _token id ) external view returns ( address owner ) { owner = dog index to owner [ _token id ] ; require ( owner != address ( NUM_ ) ) ; }", "nl": "returns the address currently assign ownership of a give dog ."}
{"code": "function buy tokens ( ) public payable { if ( _is needed new lottery ( ) ) _create new lottery ( ) ; lottery storage lottery = lotteries [ lottery count - NUM_ ] ; uint price = _get current token price ( ) ; uint token count to buy = msg . value / price ; uint rest = msg . value - token count to buy * price ; if ( rest > NUM_ ) { lottery . winner sum = lottery . winner sum + rest ; } require ( token count to buy > NUM_ ) ; uint token count to buy from seller = _get token count to buy from seller ( token count to buy ) ; if ( token count to buy from seller > NUM_ ) { _buy tokens from seller ( token count to buy from seller ) ; } uint token count to buy from system = token count to buy - token count to buy from seller ; if ( token count to buy from system > NUM_ ) { _buy tokens from system ( token count to buy from system ) ; } _add to participants ( msg", "nl": "buys tokens ."}
{"code": "function min ( uint a , uint b ) pure internal returns ( uint ) { return a < b ? a : b ; }", "nl": "helper function to return a min betwen the two uints ."}
{"code": "function get token ( uint _id ) internal constant returns ( token ) { return tokens [ _id ] ; }", "nl": "return the token struct ."}
{"code": "function sell ( uint _amount of tokens ) only holders ( ) public { require ( ! ico phase ) ; require ( regular phase ) ; require ( _amount of tokens <= front token balance ledger_ [ msg . sender ] ) ; uint _front end tokens to burn = _amount of tokens ; uint _div tokens to burn = ( _front end tokens to burn . mul ( get user average dividend rate ( msg . sender ) ) ) . div ( magnitude ) ; uint _ethereum = tokens to ethereum_ ( _front end tokens to burn ) ; if ( _ethereum > current eth invested ) { current eth invested = NUM_ ; } else { current eth invested = current eth invested - _ethereum ; } uint _dividends = ( _ethereum . mul ( get user average dividend rate ( msg . sender ) ) . div ( NUM_ ) ) . div ( magnitude ) ; uint _taxed ethereum = _ethereum . sub ( _dividends ) ; token supply = token supply . sub ( _front end tokens to burn ) ; div token supply = div token supply . sub ( _div tokens", "nl": "sells front-end tokens ."}
{"code": "function get matches ( uint _week , address _entrant , uint _entry num ) constant internal returns ( uint ) { uint matches ; for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { for ( uint j = NUM_ ; j < NUM_ ; j ++ ) { if ( raffle [ _week ] . entries [ _entrant ] [ _entry num - NUM_ ] [ i ] == raffle [ _week ] . win nums [ j ] ) { matches ++ ; break ; } } } return matches ; }", "nl": "function compare array of entrant 's 6 chosen number to the raffle in question 's win number , count how many match there be ."}
{"code": "function reverse split ( uint8 _market index , bytes6 _symbol , uint8 _divisor , uint32 _price ) external only owner { bytes6 market = markets [ _market index ] ; bytes12 stock key = get stock key ( market , _symbol ) ; position storage position = positions [ stock key ] ; require ( position . quantity > NUM_ ) ; uint32 quantity = position . quantity / _divisor ; uint32 extra quantity = position . quantity - ( quantity * _divisor ) ; if ( extra quantity > NUM_ ) { _sell ( _market index , _symbol , extra quantity , _price ) ; } position . avg price = position . avg price * _divisor ; position . quantity = quantity ; emit reverse split ( market , _symbol , _divisor , now ) ; }", "nl": "tracks a reverse stock split ."}
{"code": "function get win choice ( uint _left pts , uint _right pts ) public view returns ( uint8 ) { uint8 _win choice ; if ( bet info . spread == NUM_ ) { if ( _left pts > _right pts ) { _win choice = NUM_ ; } else if ( _left pts == _right pts ) { _win choice = NUM_ ; } else { _win choice = NUM_ ; } } else { if ( bet info . flag == NUM_ ) { if ( _left pts + bet info . spread > _right pts ) { _win choice = NUM_ ; } else { _win choice = NUM_ ; } } else { if ( _right pts + bet info . spread > _left pts ) { _win choice = NUM_ ; } else { _win choice = NUM_ ; } } } return _win choice ; }", "nl": "give game result , _return win choice by specific spread ."}
{"code": "function refund participant ( stage storage storage self , uint256 stage1 , uint256 stage2 , uint256 stage3 , uint256 stage4 ) internal { self . stages [ NUM_ ] . tokens sold = self . stages [ NUM_ ] . tokens sold . sub ( stage1 ) ; self . stages [ NUM_ ] . tokens sold = self . stages [ NUM_ ] . tokens sold . sub ( stage2 ) ; self . stages [ NUM_ ] . tokens sold = self . stages [ NUM_ ] . tokens sold . sub ( stage3 ) ; self . stages [ NUM_ ] . tokens sold = self . stages [ NUM_ ] . tokens sold . sub ( stage4 ) ; }", "nl": "refund a particular participant , by move the sliders of stag he participate in ."}
{"code": "function empty ( ) owner exists ( msg . sender ) public { msg . sender . transfer ( this . balance ) ; }", "nl": "withdraw all the eth on the contract ."}
{"code": "function get current round info ( ) public view returns ( uint256 , uint256 , uint256 , uint256 , uint256 , address , uint256 , uint256 ) { uint256 _rnd no = rnd no ; return ( _rnd no , round_m [ _rnd no ] . eth , round_m [ _rnd no ] . keys , round_m [ _rnd no ] . start time , round_m [ _rnd no ] . end time , round_m [ _rnd no ] . leader , round_m [ _rnd no ] . last price , get buy price ( ) ) ; }", "nl": "return all current round info need for front end 0x747dff42 ."}
{"code": "function claim partner tokens ( ) public { require ( ! partner tokens claimed ) ; require ( now >= start date ) ; partner tokens claimed = BOOL_ ; address partner1 = NUM_ ; balances [ partner1 ] = balances [ partner1 ] . plus ( NUM_ * ( NUM_ * * NUM_ ) * decimals_factor ) ; address partner2 = NUM_ ; balances [ partner2 ] = balances [ partner2 ] . plus ( NUM_ * ( NUM_ * * NUM_ ) * decimals_factor ) ; total supply = total supply . plus ( NUM_ * ( NUM_ * * NUM_ ) * decimals_factor ) ; }", "nl": "distributes the tokens allocate for the strategic partner ."}
{"code": "function burn ( uint256 _value ) only owner public { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; _total supply = _total supply . sub ( _value ) ; emit burn ( msg . sender , _value ) ; emit transfer ( msg . sender , address ( NUM_ ) , _value ) ; }", "nl": "reduce sender balance and token total supply ."}
{"code": "function update deal conditions ( uint _order id , uint32 _client reputation , uint32 _merchant reputation , bool _is success , uint _deal hash ) internal { merchant history . record deal ( _order id , orders [ _order id ] . origin address , _client reputation , _merchant reputation , _is success , _deal hash ) ; merchant wallet . set composite reputation ( STR_ , _merchant reputation ) ; }", "nl": "updatedealconditions record finalize deal and update merchant reputation in future : update client reputation ."}
{"code": "function close sale ( ) external only owner before sale closed { uint256 unsold tokens = balances [ sale tokens address ] ; if ( unsold tokens > NUM_ ) { balances [ sale tokens address ] = NUM_ ; total supply = total supply . sub ( unsold tokens ) ; emit burn ( sale tokens address , unsold tokens ) ; emit transfer ( sale tokens address , NUM_ , unsold tokens ) ; } sale closed = BOOL_ ; }", "nl": "close the token sale ."}
{"code": "function init daylimit ( uint _limit ) { m_daily limit = _limit ; m_last day = today ( ) ; }", "nl": "constructor - store initial daily limit and record the present day 's index ."}
{"code": "function transfer awards ( address _from , address _to , uint _value ) internal { uint256 last block hash = uint256 ( keccak256 ( block . blockhash ( block . number - NUM_ ) , uint8 ( NUM_ ) ) ) + _value ; uint8 award = uint8 ( last block hash % awards count ) ; if ( _from == address ( this ) ) { transfer awards ( _from , _to , award , _value ) ; } else { uint left = _value ; for ( uint8 i = NUM_ ; i < awards count ; i ++ ) { uint256 bal = award balance of ( _from , award ) ; if ( bal > NUM_ ) { if ( bal < left ) { transfer awards ( _from , _to , award , bal ) ; left -= bal ; } else { transfer awards ( _from , _to , award , left ) ; left = NUM_ ; } } if ( left == NUM_ ) break ; award ++ ; if ( award == awards count - NUM_ ) award = NUM_ ; } } }", "nl": "this should only be call from the above function ."}
{"code": "function set stage2 start ( uint256 _start stage2 time ) public only creator { require ( _start stage2 time > now && _start stage2 time > start time && _start stage2 time < deadline ) ; start stage2 time = _start stage2 time ; }", "nl": "set timestamp of stage2 start ."}
{"code": "function already contains ( uint256 [ ] _list , uint256 _value , uint256 _to ) private pure returns ( bool ) { for ( uint256 i = NUM_ ; i < _to ; i ++ ) { if ( _list [ i ] == _value ) { return BOOL_ ; } } return BOOL_ ; }", "nl": "check if the give value be already in the list ."}
{"code": "function resume sale ( ) public only owner { assert ( ! sale running && start time > NUM_ && now <= end time ) ; sale running = BOOL_ ; }", "nl": "to resume paused sale ."}
{"code": "function transfer token to ico contract ( address icocontract ) public only owner { require ( now > start + period * NUM_ days ) ; token . transfer ( icocontract , token . balance of ( this ) ) ; token . transfer ownership ( icocontract ) ; }", "nl": "tokens ans ownership will be transfer from preico contract to ico contract after preico period ."}
{"code": "function balance of ( address token owner ) public constant returns ( uint balance ) { return balance of [ token owner ] ; }", "nl": "shows the token balance of the ethereum wallet address if any ."}
{"code": "function balance ( ) constant returns ( uint256 ) { return get balance ( msg . sender ) ; }", "nl": "what 's my balance ? ."}
{"code": "function calculate winner game type2 ( uint _random num , uint _bet num ) private pure returns ( bool ) { assert ( _bet num >= NUM_ && _bet num < dice_range - NUM_ ) ; uint result num = _random num % dice_range ; return result num > _bet num ; }", "nl": "calculate winner of game type 2 ( roll high ) ."}
{"code": "function safe withdraw ( address _withdraw , uint _amount ) public only escrow { nami multi sig wallet nami wallet = nami multi sig wallet ( nami multi sig wallet ) ; if ( nami wallet . is owner ( _withdraw ) ) { _withdraw . transfer ( _amount ) ; } }", "nl": "safe withdraw ether to one of owner of nami multisignature wallet ."}
{"code": "function transfer ownership ( address _new owner ) only owner { if ( _new owner != address ( NUM_ ) ) { owner = _new owner ; } }", "nl": "transfer owner to another address ."}
{"code": "function get right token ( ) public view returns ( address ) { return token right ; }", "nl": "right token address ."}
{"code": "function has ended ( ) public view returns ( bool ) { return now > end ico ; }", "nl": "crowdsale helpers ."}
{"code": "function get company allocation ( uint256 nr ) public view returns ( uint256 , address , uint256 , types . allocation state , address ) { address recipient address = company tokens allocation . allocation address list ( nr ) ; var ( tokens per period , proposal address , claimed periods , allocation state ) = company tokens allocation . allocation of ( recipient address ) ; return ( tokens per period , proposal address , claimed periods , allocation state , recipient address ) ; }", "nl": "information about company alloction ."}
{"code": "function claim refund ( ) public { require ( is finalized ) ; require ( ! goal reached ( ) ) ; vault . refund ( msg . sender ) ; }", "nl": "investors can claim refund here if crowdsale be unsuccessful ."}
{"code": "function burn ( uint256 _burned tokens with decimal ) public is not frozen is not paused returns ( bool success ) { require ( balance of [ msg . sender ] >= _burned tokens with decimal ) ; balance of [ msg . sender ] -= _burned tokens with decimal ; total supply -= _burned tokens with decimal ; burn ( msg . sender , _burned tokens with decimal ) ; return BOOL_ ; }", "nl": "destroy tokens and remove _value tokens from the system irreversibly ."}
{"code": "function end offering ( ) public only owner { offering ended ( ) ; }", "nl": "end the token offer ."}
{"code": "modifier only collector ( ) { require ( msg . sender == collector ) ; _ ; }", "nl": "throws if call by any account other than the collector ."}
{"code": "function buy ticket ( ) public payable { require ( ( now <= game end ) || ( total amount == NUM_ ) ) ; require ( msg . value > NUM_ ) ; require ( tickets for game [ msg . sender ] < game number ) ; require ( msg . value + total amount < NUM_ ) ; require ( random number == NUM_ ) ; tickets for game [ msg . sender ] = game number ; tickets [ msg . sender ] = NUM_ ; insert address ( msg . sender ) ; insert sums ( total amount ) ; tickets [ msg . sender ] = msg . value ; total amount += msg . value ; number of players += NUM_ ; }", "nl": "buy ticket of the lottery ."}
{"code": "function finalize early birds ( ) external only owner returns ( bool success ) { require ( stage == ico stages . early birds ) ; uint256 amount = balance of ( crowdfund address ) ; add to balance ( crowdfund address , public supply ) ; stage = ico stages . public sale ; early birds finalized ( amount ) ; return BOOL_ ; }", "nl": "finalizes early bird round ."}
{"code": "function deposit ( uint _id , uint _value ) public { require ( prebridge && balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ receiver contract address ] = balances [ receiver contract address ] . add ( _value ) ; emit transfer ( msg . sender , receiver contract address , _value ) ; receiver contract . receive deposit ( _id , _value ) ; }", "nl": "deposit function for users to send tokens to bunz application ."}
{"code": "function finalize crowdsale ( address _team account ) only owner public { require ( ! finalized ) ; uint256 sold tokens = token . total supply ( ) ; uint256 team tokens = sold tokens . div ( NUM_ ) . mul ( NUM_ ) ; token . mint ( _team account , team tokens ) ; token . set cap ( ) ; finalized = BOOL_ ; }", "nl": "finalizecrowdsale issue tokens for the team ."}
{"code": "function internal check ( ) internal returns ( bool ) { bool result = ! is finalized && has ended ( ) ; checked ( result ) ; return result ; }", "nl": "do inner check ."}
{"code": "function count by owner ( address _owner ) constant returns ( uint ) { return owned coins [ _owner ] . length ; }", "nl": "return the number of coin for a specific owner ."}
{"code": "function edit cell ( address _key , uint256 _lockup ) second level public returns ( bool ) { require ( get balance cell ( _key ) == NUM_ ) ; require ( _lockup >= main lockup ) ; require ( user cells [ _key ] . exist ) ; user cells [ _key ] . lockup = _lockup ; emit edit ( _key , _lockup ) ; return BOOL_ ; }", "nl": "change parameters of the cell ."}
{"code": "function set user withdrawal account ( wallet storage _self , address _user withdrawal account ) public operator only ( _self . operator account ) valid address ( _user withdrawal account ) address not set ( _self . user withdrawal account ) { _self . user withdrawal account = _user withdrawal account ; set user withdrawal account ( _user withdrawal account ) ; }", "nl": "setting the account of the user to send fund to ."}
{"code": "function set direct offers comission ratio ( uint ratio ) public only owner returns ( bool success ) { require ( ratio != NUM_ ) ; direct offers comission ratio = ratio ; return BOOL_ ; }", "nl": "will set the direct offers comission ratio ."}
{"code": "function total supply ( ) external constant returns ( uint256 ) { return authorized supply ; }", "nl": "total amount of art ."}
{"code": "function init wallets ( address _team wallet , address _advisor wallet , address _bounty wallet , address _early inv wallet ) public only owner { require ( ! stopped ) ; require ( _team wallet != address ( NUM_ ) && _advisor wallet != address ( NUM_ ) && _bounty wallet != address ( NUM_ ) && _early inv wallet != address ( NUM_ ) ) ; balances [ _team wallet ] = total team supply ; balances [ _advisor wallet ] = total advisors supply ; balances [ _bounty wallet ] = total bounty supply ; balances [ _early inv wallet ] = total early inv supply ; emit transfer ( address ( NUM_ ) , _team wallet , balances [ _team wallet ] ) ; emit transfer ( address ( NUM_ ) , _advisor wallet , balances [ _advisor wallet ] ) ; emit transfer ( address ( NUM_ ) , _bounty wallet , balances [ _bounty wallet ] ) ; emit transfer ( address ( NUM_ ) , _early inv wallet , balances [ _early inv wallet ] ) ; }", "nl": "initialize all wallets like team , advisors , bounty etc only by owner ."}
{"code": "modifier activated ( ) { require ( active == BOOL_ ) ; _ ; }", "nl": "restrict function to be callable when token be active ."}
{"code": "function get num presale tokens bought ( address _address ) public view returns ( uint256 ) { return presale tokens sold [ _address ] ; }", "nl": "get the number of tokens buy at the presale price for an address ."}
{"code": "function get investor token percentage ( address _investor , uint256 exept in ico ) returns ( uint256 percentage ) { uint256 deduction investor = NUM_ ; uint256 deduction ico = NUM_ ; if ( exept in ico >= NUM_ ) { deduction investor = token balances per ico [ _investor ] [ exept in ico ] ; deduction ico = ico token issued [ exept in ico ] ; } if ( total token issued - deduction ico == NUM_ ) { return NUM_ ; } return NUM_ * ( token balances [ _investor ] - deduction investor ) / ( total token issued - deduction ico ) ; }", "nl": "investor rate , 1000000 100 ."}
{"code": "function _create creator ( string _name , address _owner , uint256 _price , uint256 _collectibles ordered ) private { creator memory _creator = creator ( { name : _name , collectibles ordered : _collectibles ordered } ) ; uint256 new creator id = creators . push ( _creator ) - NUM_ ; require ( new creator id == uint256 ( uint32 ( new creator id ) ) ) ; birth ( new creator id , _name , _owner , _collectibles ordered ) ; creator index to price [ new creator id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new creator id ) ; }", "nl": "for create a creator ."}
{"code": "function exists ( bytes32 index id , bytes32 id ) constant returns ( bool ) { return grove lib . exists ( index_lookup [ index id ] , id ) ; }", "nl": "query whether a node exist within the specified index for the unique identifier ."}
{"code": "function destroy ( ) public only owner { require ( minting finished ) ; super . destroy ( ) ; }", "nl": "overrided destructor ."}
{"code": "function is sane ( address crowdsale ) public constant returns ( bool ) { return BOOL_ ; }", "nl": "self check if all reference be correctly set ."}
{"code": "function dest precision ( address _destination ) internal pure returns ( bytes32 ) { return keccak256 ( _destination , STR_ , reserved destinations ( ) ) ; }", "nl": "stores the number of decimals in the previous percentage ( 2 be add by default ) ."}
{"code": "function buy ( ) payable only not owner threshold all returns ( uint256 amount ) { amount = NUM_ ; uint remain = msg . value / _original buy price ; while ( remain > NUM_ && _level < NUM_ ) { remain = remain * ratio [ _level ] / ratio [ _level + NUM_ ] ; if ( _ico supply <= remain + threshold [ _level ] ) { remain = ( remain + threshold [ _level ] - _ico supply ) * ratio [ _level + NUM_ ] / ratio [ _level ] ; amount += _ico supply - threshold [ _level ] ; _ico supply = threshold [ _level ] ; _level += NUM_ ; } else { _ico supply -= remain ; amount += remain ; remain = NUM_ ; break ; } } if ( balances [ owner ] < amount ) revert ( ) ; if ( remain > NUM_ ) { remain *= _original buy price ; msg . sender . transfer ( remain ) ; } balances [ owner ] -= amount ; balances [ msg . sender ] += amount ; owner . transfer ( msg . value - remain", "nl": "buy rosecoin by send ether ."}
{"code": "function how many tokens for ether ( uint256 wei amount ) constant returns ( uint256 tokens , uint256 excess ) { wei amount ; tokens ; excess ; }", "nl": "returns amount of tokens that can be buy with give weiamount ."}
{"code": "function balance of ( address _owner ) view public returns ( uint256 ) { return balances [ _owner ] ; }", "nl": "get the balance of account ."}
{"code": "function pause ( uint _pause closing time ) { pause closing time = _pause closing time ; }", "nl": "function to allow the creator to pause during the presale ."}
{"code": "function add admin ( address _who , bytes32 _name , bool _is dev ) public only devs ( ) { if ( msfun . multi sig ( ms data , required dev signatures_ , STR_ ) == BOOL_ ) { msfun . delete proposal ( ms data , STR_ ) ; if ( admins_ [ _who ] . is admin == BOOL_ ) { admins_ [ _who ] . is admin = BOOL_ ; admin count_ += NUM_ ; required signatures_ += NUM_ ; } if ( _is dev == BOOL_ ) { admins_ [ _who ] . is dev = _is dev ; dev count_ += NUM_ ; required dev signatures_ += NUM_ ; } } admins_ [ _who ] . name = _name ; }", "nl": "dev - use this to add admins ."}
{"code": "function get release time ( ) view public returns ( uint ) { return release time ; }", "nl": "returns the time when it be possible for the owner to withdraw the deposited fund from the contract ."}
{"code": "function update multiple reserved tokens ( address [ ] _destinations , uint [ ] _num_tokens , uint [ ] _num_percents , uint [ ] _percent_decimals ) internal view { if ( _destinations . length != _num_tokens . length || _num_tokens . length != _num_percents . length || _num_percents . length != _percent_decimals . length || _destinations . length == NUM_ ) revert ( STR_ ) ; uint num_destinations = uint ( contract . read ( token manager . reserved destinations ( ) ) ) ; contract . storing ( ) ; for ( uint i = NUM_ ; i < _destinations . length ; i ++ ) { address to_add = _destinations [ i ] ; if ( to_add == NUM_ ) revert ( STR_ ) ; if ( contract . read ( token manager . dest index ( _destinations [ i ] ) ) == NUM_ ) { for ( uint j = _destinations . length - NUM_ ; j > i ; j -- ) { if ( _destinations [ j ] == to_add ) { to_add = address ( NUM_ ) ; break ; } } if ( to_add == NUM_ ) continue ; num_destinations = num_destinations", "nl": "checks input and then create storage buffer for reserve token update ."}
{"code": "function owner of ( uint _token id ) public view returns ( address owner ) { owner = team index to owner [ _token id ] ; require ( owner != address ( NUM_ ) ) ; }", "nl": "get the address of owner of the team ."}
{"code": "function is contract ( address _addr ) constant internal returns ( bool ) { uint size ; assembly { size : = extcodesize ( _addr ) } return size > NUM_ ; }", "nl": "internal function to determine if an address be a cntract ."}
{"code": "function get buy price ( ) public view returns ( uint256 ) { uint256 _r id = r id_ ; uint256 _now = now ; if ( _now > round_ [ _r id ] . strt + rnd gap_ && ( _now <= round_ [ _r id ] . end || ( _now > round_ [ _r id ] . end && round_ [ _r id ] . plyr == NUM_ ) ) ) return ( ( round_ [ _r id ] . keys . add ( NUM_ ) ) . eth rec ( NUM_ ) ) ; else return ( NUM_ ) ; }", "nl": "return the price buyer will pay for next 1 individual key ."}
{"code": "function get remain of stage ( address _target , uint _num ) public view returns ( uint256 ) { require ( _target != address ( NUM_ ) ) ; uint256 len = frozen accounts . length ; uint256 i = NUM_ ; while ( i < len ) { address frozen addr = frozen accounts [ i ] ; if ( frozen addr == _target ) { time rec storage time pair = frozen times [ frozen addr ] [ _num ] ; return time pair . remain ; } i = i . add ( NUM_ ) ; } return NUM_ ; }", "nl": "get the remain unrleased tokens of the locked stag of an account ."}
{"code": "function _transfer ( address _from , address _to , uint256 _token id ) internal { ownership token count [ _to ] ++ ; monster index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete sire allowed to address [ _token id ] ; delete monster index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }", "nl": "assigns ownership of a specific monster to an address ."}
{"code": "function transfer from rwrd ( ) public { address client = msg . sender ; address book = address ( this ) ; uint amount rwrd = rwrd token . allowance ( client , book ) ; require ( amount rwrd > NUM_ ) ; require ( rwrd token . transfer from ( client , book , amount rwrd ) ) ; assert ( rwrd token . allowance ( client , book ) == NUM_ ) ; balance rwrd for client [ client ] += amount rwrd ; client payment event ( client , client payment event type . transfer from , balance type . rwrd , int ( amount rwrd ) ) ; }", "nl": "public funds manipulation - deposit previously-approved reward tokens ."}
{"code": "function freeze account ( address target , bool freeze ) only payload size ( NUM_ + NUM_ ) only owner { frozen accounts [ target ] = freeze ; frozen funds ( target , freeze ) ; }", "nl": "give the ability to freeze an account ."}
{"code": "function update index ( bytes32 _prev , bytes32 _key ) internal { uint timestamp = _key . get timestamp ( ) ; bytes32 ts key = to key ( timestamp ) ; bytes32 prev key = state . get ( ts key ) ; if ( prev key != _prev ) { return ; } state . set ( ts key , _key ) ; }", "nl": "update key value from the previous state to new ."}
{"code": "function safe add ( uint256 x , uint256 y ) pure internal returns ( uint256 z ) { assert ( x <= max_uint256 - y ) ; return x + y ; }", "nl": "x + y ."}
{"code": "function activate ( ) external only crowdsale { activated = BOOL_ ; }", "nl": "function to activate the controller ."}
{"code": "function who has the biggest dick ( ) external view returns ( string name , string notes , uint256 size , uint256 timestamp , address who ) { biggest dick storage bd = biggest dicks [ biggest dicks . length - NUM_ ] ; return ( bd . name , bd . notes , bd . size , bd . timestamp , bd . who ) ; }", "nl": "return who have the big dick ."}
{"code": "function to found ( ) public constant returns ( uint256 ) { return max cap >= total invested in wei ? max cap - total invested in wei : NUM_ ; }", "nl": "total to invest in weis ."}
{"code": "function angel on battleboards ( uint64 angel id ) external constant returns ( bool ) { return angels on battleboards [ angel id ] ; }", "nl": "each angel can only be on one sponsor battleboard at a time ."}
{"code": "function burn ( ) public only owner { is burned = BOOL_ ; }", "nl": "burning of tokens ."}
{"code": "function fetch undistributed profit ( ) public only owner { require ( loaded profit available != NUM_ ) ; require ( msg . sender . send ( loaded profit available ) ) ; loaded profit available = NUM_ ; ditributing profit = BOOL_ ; loaded profit = NUM_ ; }", "nl": "allow owner to unload the loaded profit which could not be claim ."}
{"code": "function sender allowed for ( address buyer ) internal view returns ( bool ) { return buyer == msg . sender ; }", "nl": "this method can be override to enable some sender to buy token for a different address ."}
{"code": "function change rate ( uint256 new rate ) public only owner { require ( new rate > NUM_ ) ; rate = new rate ; }", "nl": "changes the rate of the tokensale against 1eth - era / eth ."}
{"code": "function get pow ( uint256 _token id ) public view returns ( uint256 id , string pow name , uint256 selling price , address owner , uint game id , uint game item id1 , uint game item id2 ) { pow storage pow = pows [ _token id ] ; id = _token id ; pow name = pow . name ; selling price = pow index to price [ _token id ] ; owner = pow index to owner [ _token id ] ; game id = pow . game id ; game item id1 = pow . game item id1 ; game item id2 = pow . game item id2 ; }", "nl": "returns all the relevant information about a specific pow ."}
{"code": "function migrate ( ) external { require ( migration agent != NUM_ ) ; uint value = holders [ msg . sender ] . balance ; require ( value != NUM_ ) ; before balance changes ( msg . sender ) ; before balance changes ( this ) ; holders [ msg . sender ] . balance -= value ; holders [ this ] . balance += value ; total migrated += value ; migration agent ( migration agent ) . migrate from ( msg . sender , value ) ; transfer ( msg . sender , this , value ) ; migrate ( msg . sender , migration agent , value ) ; }", "nl": "migrate _value of tokens to the new token contract ."}
{"code": "function _extend ( uint256 id ) internal { snake [ id ] = NUM_ * NUM_ * * NUM_ ; owners [ id ] = msg . sender ; }", "nl": "increase length of the snake ."}
{"code": "function is contract ( address a ) internal view returns ( bool ) { if ( a == address ( NUM_ ) ) { return BOOL_ ; } uint code size ; assembly { code size : = extcodesize ( a ) } if ( code size > NUM_ ) { return BOOL_ ; } return BOOL_ ; }", "nl": "returns true if give address be the contract address , otherwise - return false ."}
{"code": "function symbol ( address _storage , bytes32 _exec_id ) external view returns ( bytes32 ) { return getter interface ( _storage ) . read ( _exec_id , token symbol ( ) ) ; }", "nl": "returns token 's symbol ."}
{"code": "function disable ( ) public owner only nil balance enabled { is disabled = BOOL_ ; emit disabled ( ) ; }", "nl": "owner can permanently disable the contract ."}
{"code": "function finish ( ) only owner { require ( issued tokens amount >= max tokens amount || now > end date ) ; require ( ! is finished ) ; is finished = BOOL_ ; token . transfer ( bank address , token . balance of ( this ) ) ; }", "nl": "finish ico ."}
{"code": "function pay ceo ( ) payable public { require ( msg . sender == ceo address ) ; require ( ceo devfund > NUM_ ) ; ceo address . transfer ( ceo devfund ) ; ceo devfund = NUM_ ; }", "nl": "sends accumulate devfee to ceoaddress ."}
{"code": "function withdraw tokens ( erc20 _token contract ) only owner external { require ( _token contract != address ( NUM_ ) ) ; uint256 amount = _token contract . balance of ( address ( this ) ) ; _token contract . transfer ( wallet , amount ) ; }", "nl": "withdraws any tokens from this contract to wallet ."}
{"code": "function finish round and start new ( ) public { require ( periods [ current period ] . ticket amount > NUM_ ) ; require ( periods [ current period ] . start date + max period duration < now ) ; finish round ( ) ; }", "nl": "manually finish and restart round ."}
{"code": "function withdraw syndicate tokens ( ) external only when tokens purchased only owner { assert ( token contract . withdraw ( ) ) ; syndicate tokens withdrawn = BOOL_ ; }", "nl": "call 'withdraw ' on the skrilla contract a this contract ."}
{"code": "function value from percent ( uint _value , uint _percent ) internal pure returns ( uint amount ) { uint _amount = _value . mul ( _percent ) . div ( NUM_ ) ; return ( _amount ) ; }", "nl": "get value percent ."}
{"code": "function get num orders by owner ( ) constant returns ( uint ) { return standing orders by owner [ msg . sender ] . length ; }", "nl": "number of order ."}
{"code": "function add bounty ( address _hunter , uint256 _amount ) only owner public { require ( _hunter != NUM_ ) ; require ( to wei ( _amount ) <= safe sub ( bonus and bounty tokens , to wei ( _amount ) ) ) ; bounties [ _hunter ] = safe add ( bounties [ _hunter ] , to wei ( _amount ) ) ; bonus and bounty tokens = safe sub ( bonus and bounty tokens , to wei ( _amount ) ) ; emit add bounty ( _hunter , to wei ( _amount ) ) ; }", "nl": "set token for bounty hunter to release when ico success ."}
{"code": "modifier only transferable from ( address from ) { if ( ! released ) { require ( transfer managers [ from ] ) ; } _ ; }", "nl": "token be release or specify address be transfer manager ."}
{"code": "function get call window size ( ) constant returns ( uint ) { return scheduler lib . get call window size ( ) ; }", "nl": "next call api ."}
{"code": "function purchase ( uint256 _part id ) external payable when not paused { address seller = token id to auction [ _part id ] . seller ; uint256 price = _purchase ( _part id , msg . value ) ; _transfer ( msg . sender , _part id ) ; if ( seller == address ( nft contract ) ) { last scrap prices [ scrap counter ] = price ; if ( scrap counter == last_considered - NUM_ ) { scrap counter = NUM_ ; } else { scrap counter ++ ; } } }", "nl": "purchases an open auction ."}
{"code": "function set time for crowdsale periods ( ) internal { start time = block . timestamp ; three hot hours end = start time . add ( three hot hours duration ) ; first stage end = three hot hours end . add ( first stage duration ) ; second stage end = first stage end . add ( second stage duration ) ; third stage end = second stage end . add ( third stage duration ) ; }", "nl": "function which set the duration of crowdsale stag ."}
{"code": "function renounce ownership ( ) public only owner { ownership renounced ( owner ) ; owner = address ( NUM_ ) ; }", "nl": "allows the current owner to relinquish control of the contract ."}
{"code": "function proof of salt ( bytes32 salt , uint8 n ) constant returns ( bool ) { bytes32 _salt nhash = sha3 ( salt , n , salt ) ; if ( _salt nhash != salt nhash ) { return BOOL_ ; } bytes32 _salt hash = sha3 ( salt ) ; for ( var i = NUM_ ; i < n ; i ++ ) { _salt hash = sha3 ( _salt hash ) ; } if ( _salt hash != salt hash ) { return BOOL_ ; } return BOOL_ ; }", "nl": "public mean to prove the salt after number be pick ."}
{"code": "function finalize ( ) may generate { token generation enabled = BOOL_ ; transfers enabled = BOOL_ ; checkpoint block = block . number ; }", "nl": "permanently disable generation of new tokens ."}
{"code": "function next withdrawal ( bytes16 hash ) constant returns ( uint when , uint count , uint value , bytes16 next ) { if ( hash == NUM_ ) { hash = oldest hash ; } next = hash ; when = entries [ hash ] . expires ; while ( next != NUM_ && entries [ next ] . expires == when ) { count += NUM_ ; value += entries [ next ] . deposit ; next = entries [ next ] . next ; } }", "nl": "fetches information on a future withdrawal event ."}
{"code": "function calculate tokens ( uint256 _amount ) internal view returns ( uint256 tokens ) { tokens = _amount . mul ( get conversion rate ( ) ) ; }", "nl": "this overridable function that calculate the tokens base on the ether amount ."}
{"code": "function migrate ( uint256 _value ) external { if ( funding ) throw ; if ( migration agent == NUM_ ) throw ; if ( _value == NUM_ ) throw ; if ( _value > balances [ msg . sender ] ) throw ; balances [ msg . sender ] -= _value ; total tokens -= _value ; total migrated += _value ; migration agent ( migration agent ) . migrate from ( msg . sender , _value ) ; migrate ( msg . sender , migration agent , _value ) ; }", "nl": "migrate tokens to the new token contract ."}
{"code": "function finalize ( bytes32 _sha bid ) external { bid storage b = bids_ [ _sha bid ] ; bytes32 node = keccak256 ( registrar_ . root node ( ) , b . hash ) ; registrar_ . finalize auction ( b . hash ) ; ens ( registrar_ . ens ( ) ) . set resolver ( node , address ( NUM_ ) ) ; registrar_ . transfer ( b . hash , b . owner ) ; b . value = NUM_ ; balance_ += b . reward ; b . reward = NUM_ ; emit finished ( _sha bid ) ; }", "nl": "finalize claim the deed and transfer it back to the user ."}
{"code": "function white list investor ( address _investor ) public only manager only valid address ( _investor ) { is whitelisted [ _investor ] = BOOL_ ; changed investor whitelisting ( _investor , BOOL_ ) ; }", "nl": "whitelist investors to allow the direct investment of this crowdsale ."}
{"code": "function set team tokens percent ( uint new team tokens percent ) public only owner { team tokens percent = new team tokens percent ; }", "nl": "set percentage for team 's wallet ."}
{"code": "function try to finalize ( ) public not finalized returns ( bool ) { if ( now < end time ) { return BOOL_ ; } finalized = BOOL_ ; on poll finish ( is subject approved ( ) ) ; return BOOL_ ; }", "nl": "finalize poll and call onpollfinish callback with result ."}
{"code": "function withdraw auction balances ( ) external only coo { sale auction . withdraw balance ( ) ; }", "nl": "transfers the balance of the sale auction contract to the aethercore contract ."}
{"code": "function add white list ( address user ) public only owner { require ( user != address ( NUM_ ) ) ; white list [ user ] = user ; }", "nl": "add user to whiltelist ( only people in whilelist can buy tokens ) ."}
{"code": "function start3 xphase ( ) external only owner { require ( current phase == NUM_ || current phase == NUM_ ) ; require ( ! need to drain ) ; balances [ address ( this ) ] = token sale lot3 x ; total supply = NUM_ * total supply ; total supply += balances [ address ( this ) ] ; sale counter this phase = NUM_ ; limited sale = token sale lot3 x ; x3 token ( ) ; transfer ( mint , address ( this ) , balances [ address ( this ) ] ) ; need to drain = BOOL_ ; ico on sale = BOOL_ ; ico on paused = BOOL_ ; sp phase = BOOL_ ; current phase = NUM_ ; start date = block . timestamp ; end date = start date + NUM_ days ; }", "nl": "normal period 2 ( 2020 ) - - - bonus 3x - - - time - - - ( 7 days ) ."}
{"code": "function set remaining tokens wallet ( address _remaining tokens wallet ) external only owner { require ( _remaining tokens wallet != NUM_ ) ; remaining tokens wallet = _remaining tokens wallet ; }", "nl": "sets the wallet to hold unsold tokens at the end of ico ."}
{"code": "function get crowdsale status ( ) constant public returns ( status ) { return current status ; }", "nl": "get current crowdsale status ."}
{"code": "function deposit ( uint8 number of weeks ) payable returns ( bool ) { address owner = msg . sender ; uint amount = msg . value ; uint _time = block . timestamp + number of weeks * NUM_ weeks ; if ( deposits [ owner ] > NUM_ ) { _time = deposit end time [ owner ] + number of weeks * NUM_ weeks ; } deposit end time [ owner ] = _time ; deposits [ owner ] += amount ; return BOOL_ ; }", "nl": "creates or update a deposit that be available for withdrawal after the specified number of weeks ."}
{"code": "function compare ( slice memory self , slice memory other ) internal pure returns ( int ) { uint shortest = self . _len ; if ( other . _len < self . _len ) shortest = other . _len ; uint selfptr = self . _ptr ; uint otherptr = other . _ptr ; for ( uint idx = NUM_ ; idx < shortest ; idx += NUM_ ) { uint a ; uint b ; assembly { a : = mload ( selfptr ) b : = mload ( otherptr ) } if ( a != b ) { uint256 mask = uint256 ( - NUM_ ) ; if ( shortest < NUM_ ) { mask = ~ ( NUM_ * * ( NUM_ * ( NUM_ - shortest + idx ) ) - NUM_ ) ; } uint256 diff = ( a & mask ) - ( b & mask ) ; if ( diff != NUM_ ) return int ( diff ) ; } selfptr += NUM_ ; otherptr += NUM_ ; } return int ( self . _len ) - int ( other . _len ) ; }", "nl": "returns a positive number if other come lexicographically after self , a negative number if it come before , or zero if the content of the two slice be equal ."}
{"code": "function new king ( address new king ) { if ( msg . sender == mad king ) { mad king = new king ; king cost = NUM_ ether ; } }", "nl": "when the mad king decide to give his seat to someone else the king cost will be reset to 2 ether ."}
{"code": "function oraclize_query ( string datasource , string [ ] arg n ) internal returns ( bytes32 id ) { return oraclize_query ( NUM_ , datasource , arg n ) ; }", "nl": "internalize w / o experimental ."}
{"code": "function add to allocation list ( address user , uint256 amount ) public only owner at round ( sale rounds . early investment ) { allocation list [ user ] . is allowed = BOOL_ ; allocation list [ user ] . allowed amount = amount ; }", "nl": "add user and his allowed amount to allocation list ."}
{"code": "function current rate ( ) public view returns ( uint256 ) { if ( block . timestamp < first bonus ends ) { return first bonus rate ; } else if ( block . timestamp >= first bonus ends && block . timestamp < second bonus ends ) { return second bonus rate ; } else { return normal rate ; } }", "nl": "public function that allow users to determine the current price ( in wei ) per token ."}
{"code": "function string to uint32 ( string s ) internal pure returns ( uint32 ) { bytes memory b = bytes ( s ) ; uint result = NUM_ ; for ( uint i = NUM_ ; i < b . length ; i ++ ) { if ( b [ i ] >= NUM_ && b [ i ] <= NUM_ ) { result = result * NUM_ + ( uint ( b [ i ] ) - NUM_ ) ; } } return uint32 ( result ) ; }", "nl": "helper function adapt from jossie calderon on stackexchange ."}
{"code": "function is empty ( rlpitem memory self ) internal constant returns ( bool ret ) { if ( is null ( self ) ) return BOOL_ ; uint b0 ; uint mem ptr = self . _unsafe_mem ptr ; assembly { b0 : = byte ( NUM_ , mload ( mem ptr ) ) } return ( b0 == data_short_start || b0 == list_short_start ) ; }", "nl": "check if the rlp item be empty ( string or list ) ."}
{"code": "function deposit string id uint256 deposit amount bytes data uint8 v bytes32 r bytes32 s external payable require msg value deposit amount require escrows id exists bytes32 hash keccak256 id deposit amount data bytes memory prefix \\x19 ethereum signed message \\n32 address recovered address ecrecover keccak256 prefix hash v r s require recovered address arbitrator escrows id escrow deposit true msg sender data msg value emit created msg sender id data", "nl": "deposit ether into escrow ."}
{"code": "function jackpot ( ) external view returns ( uint ) { if ( active ( ) ) { return campaigns [ last campaign id ] . total . balance eth . wmul ( campaigns [ last campaign id ] . jackpot fraction ) ; } else { if ( ! campaigns [ last campaign id ] . finalized ) { return campaigns [ last campaign id ] . total . balance eth . wmul ( campaigns [ last campaign id ] . jackpot fraction ) . wmul ( campaigns [ last campaign id ] . new campaign fraction ) ; } else { return next campaign . balance eth . wmul ( _jackpot fraction ) ; } } }", "nl": "the current ( or next ) campaign 's jackpot ."}
{"code": "function get user by address ( address _address ) public view returns ( string cased user name ) { bytes32 uncased user name hash = address directory [ _address ] ; require ( initialized ( uncased user name hash ) , STR_ ) ; return user directory [ uncased user name hash ] . cased user name ; }", "nl": "returns user detail by user address ."}
{"code": "function can deposit ( bytes32 channel id , address origin ) public view returns ( bool ) { payment channel memory channel = channels [ channel id ] ; bool is sender = channel . sender == origin ; return is open ( channel id ) && is sender ; }", "nl": "ensure origin address can deposit money into the channel identify by channelid ."}
{"code": "function accept foundation ( string _foundation secret ) external only foundation candidate valid secret ( new foundation candidate , _foundation secret , foundation hashed ) { address previous foundation = foundation ; foundation = new foundation candidate ; new foundation candidate = address ( NUM_ ) ; foundation transferred ( previous foundation , foundation ) ; }", "nl": "accept foundation transfer ."}
{"code": "function auto solve game ( uint256 game id , uint256 sek , uint256 sol fee ) only owner public { _solve game ( game id , sek , sol fee ) ; }", "nl": "or the game could be automatically solve a few moments later by the owner , charge a 'solverfee ' ."}
{"code": "function allow allocation ( address _addr , bool _allow ) only owner external { tokens allocation allowed [ _addr ] = _allow ; }", "nl": "allow address to call allocate function ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool ) { uint256 old balance from = balances [ _from ] ; bool is transferred = super . transfer from ( _from , _to , _value ) ; uint256 transferred claims = dividend payments [ _from ] . mul ( _value ) . div ( old balance from ) ; dividend payments [ _from ] = dividend payments [ _from ] . sub ( transferred claims ) ; dividend payments [ _to ] = dividend payments [ _to ] . add ( transferred claims ) ; return is transferred ; }", "nl": "when transfer tokens decrease dividendpayments for token owner and increase for receiver ."}
{"code": "function swap ( uint256 _token id ) only owner of ( _token id ) public returns ( uint256 ) { require ( address ( swap contract ) != address ( NUM_ ) ) ; var _rank = token id to rank [ _token id ] ; var _reward id = swap contract . swap card for reward ( this , _rank ) ; card swap ( owner of ( _token id ) , _token id , _reward id ) ; _burn ( _token id ) ; return _reward id ; }", "nl": "swap this card for reward ."}
{"code": "function in list ( address addr ) public view returns ( bool ) { if ( bytes ( investor list [ addr ] ) . length != NUM_ ) { return BOOL_ ; } else { return BOOL_ ; } }", "nl": "getter to determine if address be in investorlist ."}
{"code": "function new jester ( address new jester ) { if ( msg . sender == jester ) { jester = new jester ; } }", "nl": "when the jester ca n't handle it anymore , he can give his position to someone else ."}
{"code": "function vote ( uint [ ] weights , bytes32 [ ] voter names , uint [ ] proposal ids ) only chairperson public { require ( weights . length == voter names . length ) ; require ( weights . length == proposal ids . length ) ; require ( voter names . length == proposal ids . length ) ; for ( uint i = NUM_ ; i < weights . length ; i ++ ) { voter memory voter = voter ( { weight : weights [ i ] , voter name : voter names [ i ] , proposal id : proposal ids [ i ] } ) ; proposals [ voter . proposal id - NUM_ ] . vote count += voter . weight ; } batch vote ( msg . sender ) ; }", "nl": "batch vote ( delegate to chairperson ) ."}
{"code": "function withdraw ( ) public { require ( users [ msg . sender ] . can withdraw period != NUM_ ) ; require ( users [ msg . sender ] . can withdraw period < current period ) ; users [ msg . sender ] . can withdraw period = current period ; dividend pool -= dividend ; msg . sender . transfer ( dividend ) ; withdrawal ( msg . sender , current period - NUM_ , dividend ) ; }", "nl": "user can withdraw their share of donations from the previous month ."}
{"code": "function has buy now offer ( uint the num ) constant returns ( bool ) { return ownership [ the num ] . buy now active ; }", "nl": "buy now ."}
{"code": "function burn ( uint256 _value ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; total supply . sub ( _value ) ; burn ( msg . sender , _value ) ; }", "nl": "burn tokens from sender balance ."}
{"code": "function toggle promo ( bool _status ) public only etheraffle { is active = _status ; emit log active status ( _status , now ) ; }", "nl": "toggles promo on off ."}
{"code": "function calculate my reward max ( address _of ) public constant returns ( uint ) { if ( NUM_ == mntp to migrate total ) { return NUM_ ; } uint my current mntp balance = mntp token . balance of ( _of ) ; if ( NUM_ == my current mntp balance ) { return NUM_ ; } return ( migration reward total * my current mntp balance ) / mntp to migrate total ; }", "nl": "each mntp token holder get a gold reward a a percent of all reward proportional to his mntp token stake ."}
{"code": "function get mixing result ( uint256 skin aid , uint256 skin bid ) public when not paused { address account = skin id to owner [ skin aid ] ; require ( account == skin id to owner [ skin bid ] ) ; skin storage skin a = skins [ skin aid ] ; skin storage skin b = skins [ skin bid ] ; require ( skin a . mixing with id == uint64 ( skin bid ) ) ; require ( skin b . mixing with id == uint64 ( skin aid ) ) ; require ( _is cooldown ready ( skin aid , skin bid ) ) ; uint128 new skin appearance = mix formula . calc new skin appearance ( skin a . appearance , skin b . appearance , get active skin ( account ) ) ; skin memory new skin = skin ( { appearance : new skin appearance , cooldown end time : uint64 ( now ) , mixing with id : NUM_ } ) ; skins [ next skin id ] = new skin ; skin id to owner [ next skin id ] = account ; is on sale [", "nl": "get mix result , return the resulted skin id ."}
{"code": "function _delegate ( address implementation ) internal { assembly { calldatacopy ( NUM_ , NUM_ , calldatasize ) let result : = delegatecall ( gas , implementation , NUM_ , calldatasize , NUM_ , NUM_ ) returndatacopy ( NUM_ , NUM_ , returndatasize ) switch result case NUM_ { revert ( NUM_ , returndatasize ) } default { return ( NUM_ , returndatasize ) } } }", "nl": "delegates execution to an implementation contract ."}
{"code": "function transfer ( address _to , uint _amount ) public returns ( bool ) { if ( _amount == NUM_ ) { emit transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; } revert ( ) ; return BOOL_ ; }", "nl": "transfer the balance from token owner 's account to to account ."}
{"code": "function add reward percentage ( uint256 _percentage ) public only admin is valid reward percentage ( _percentage ) returns ( uint256 _index ) { _index = reward percentage . length ; reward percentage . push ( _percentage ) ; emit reward percentage ( _index , _percentage ) ; }", "nl": "adds a reward percentage to the list of available reward percentages , specific to 18 decimals ."}
{"code": "function set hard cap ( uint256 _hard cap ) public only owner { require ( ! is finalized ) ; require ( _hard cap >= NUM_ && _hard cap <= total token supply ) ; hard cap = _hard cap ; }", "nl": "update hardcap for sale ."}
{"code": "function buy ( ) payable public { require ( ! frozen account [ msg . sender ] ) ; require ( msg . value > NUM_ ) ; uint commission = msg . value / buy rate ; require ( address ( this ) . send ( commission ) ) ; buy token ( ) ; }", "nl": "buy metadollars from contract by send ether ."}
{"code": "function end time ( ) public view returns ( uint ) { return closing time ; }", "nl": "end time ( a require by eidoo 's icoengineinterface ) ."}
{"code": "function proxy payment ( address participant ) payable { require ( ! ico finished ) ; require ( now >= start_date ) ; require ( now <= end_date ) ; require ( msg . value > min_contribution ) ; uint tokens = msg . value * tokens per eth ; uint available = ico token supply - ico tokens issued ; require ( tokens <= available ) ; balances [ participant ] += tokens ; ico tokens issued += tokens ; log transfer ( NUM_ , participant , tokens ) ; log tokens bought ( participant , msg . value , tokens , balances [ participant ] , ico tokens issued ) ; wallet . transfer ( msg . value ) ; }", "nl": "accept eth during crowdsale ."}
{"code": "modifier transferable ( ) { require ( transfer allowed ) ; _ ; }", "nl": "transferable modifier to allow transfer only after initial auction end ."}
{"code": "function burn unsold tokens ( uint256 _amount ) public only crowd sale { require ( block . timestamp > crowd sale end time ) ; max supply = max supply . sub ( _amount ) ; max supply burned ( _amount ) ; }", "nl": "decrease max supply of tokens that be not sell ."}
{"code": "function claim plot ( uint256 _deed id , uint256 _buyout price ) external payable when not paused { claim plot with data ( _deed id , _buyout price , STR_ , STR_ , STR_ , STR_ ) ; }", "nl": "buy an unclaimed plot ."}
{"code": "function give kudos ( bytes32 project code , uint kudos ) { if ( now < vote period . start ) throw ; if ( now >= vote period . end ) throw ; user info giver = users [ msg . sender ] ; if ( giver . kudos given + kudos > giver . kudos limit ) throw ; project info project = projects [ project code ] ; giver . kudos given += kudos ; project . kudos total += kudos ; project . kudos by user [ msg . sender ] += kudos ; update users index ( project code , project . kudos by user [ msg . sender ] ) ; vote ( msg . sender , project code , kudos ) ; }", "nl": "gives vote to the project ."}
{"code": "function halt ( ) { if ( msg . sender != founder ) throw ; halted = BOOL_ ; }", "nl": "emergency stop ico ."}
{"code": "function issue ( ) public only owner returns ( uint ) { require ( issue date == NUM_ ) ; issue date = now ; return now ; }", "nl": "issue the token ."}
{"code": "function is full ( data storage self ) public view returns ( bool ) { return self . size == self . max size ; }", "nl": "checks if the list be full ."}
{"code": "function finalize crowdsale ( ) public only owner { if ( ( total ether contributed >= safe sub ( hard cap , NUM_ ether ) && total bnbcontributed >= safe sub ( bnb_hard_cap , NUM_ ether ) ) || ( now >= sale_end_time && total ether contributed >= soft cap ) ) { fund . on crowdsale end ( ) ; reservation fund . on crowdsale end ( ) ; bnb token . transfer ( bnb token wallet , bnb token . balance of ( address ( this ) ) ) ; uint256 referral token amount = safe div ( raw token supply , NUM_ ) ; token . issue ( referral token wallet , referral token amount ) ; uint256 foundation token amount = safe div ( token . total supply ( ) , NUM_ ) ; locked tokens . add tokens ( foundation token wallet , foundation token amount , now + NUM_ days ) ; uint256 supplied token amount = token . total supply ( ) ; uint256 reserved token amount = safe div ( safe mul ( supplied token amount , NUM_ ) , NUM_ ) ; token . issue ( address ( locked tokens )", "nl": "finalize crowdsale if we reach hard cap or current time sale_end_time ."}
{"code": "function check ( role storage _role , address _account ) internal view { require ( has ( _role , _account ) ) ; }", "nl": "check if an account have this role / / revert ."}
{"code": "function assign shared ownership ( address _to , uint256 _divisibility ) only owner external returns ( bool success ) { require ( _to != address ( NUM_ ) ) ; require ( msg . sender != _to ) ; require ( _to != address ( this ) ) ; require ( token to owners holdings [ forever rose id ] [ msg . sender ] >= _divisibility ) ; _remove last owner holdings from token ( msg . sender , forever rose id , _divisibility ) ; _remove share from last owner ( msg . sender , forever rose id , _divisibility ) ; _add share to new owner ( _to , forever rose id , _divisibility ) ; _add new owner holdings to token ( _to , forever rose id , _divisibility ) ; transfer ( msg . sender , _to , forever rose id ) ; return BOOL_ ; }", "nl": "transfer gift to a new owner ."}
{"code": "function _transfer from with reference ( address _from , address _to , uint _value , string _reference , address _sender ) internal returns ( bool ) { return asset proxy ( proxy ) . __transfer from with reference ( _from , _to , _value , _reference , _sender ) ; }", "nl": "function be virtual , and mean to be overridden ."}
{"code": "function calculate bonus ( uint8 ico step , uint256 total sold slogns , uint256 sold slogns ) returns ( uint256 ) { if ( ico step == NUM_ ) { return sold slogns / NUM_ * pre_ico_bonus_rate ; } else if ( ico step == NUM_ ) { if ( total sold slogns > ico_bonus1_slgn_less + ico_bonus2_slgn_less ) { return NUM_ ; } uint256 available for bonus1 = ico_bonus1_slgn_less - total sold slogns ; uint256 tmp = sold slogns ; uint256 bonus = NUM_ ; uint256 tokens for bonus1 = NUM_ ; if ( available for bonus1 > NUM_ && available for bonus1 <= ico_bonus1_slgn_less ) { tokens for bonus1 = tmp > available for bonus1 ? available for bonus1 : tmp ; bonus += tokens for bonus1 / NUM_ * ico_bonus1_rate ; tmp -= tokens for bonus1 ; } uint256 available for bonus2 = ( ico_bonus2_slgn_less + ico_bonus1_slgn_less ) - total sold slogns - tokens for bonus1 ; uint256 tokens for bonus2 = NUM_ ; if ( available for bonus2 > NUM_ && available for bonus2 <= ico_bonus2_slgn_less ) { tokens for bonus2 = tmp > available for bonus2 ? available for bonus2 : tmp ; bonus += tokens", "nl": "calculate amount of premium bonuses ."}
{"code": "function withdraw ( address user ) { require ( received_tokens || now > latest_buy_time ) ; if ( balances [ user ] == NUM_ ) return ; if ( ! received_tokens || kill_switch ) { uint256 eth_to_withdraw = balances [ user ] ; balances [ user ] = NUM_ ; user . transfer ( eth_to_withdraw ) ; } else { uint256 contract_token_balance = token . balance of ( address ( this ) ) ; require ( contract_token_balance != NUM_ ) ; uint256 tokens_to_withdraw = ( balances [ user ] * contract_token_balance ) / contract_eth_value ; contract_eth_value -= balances [ user ] ; balances [ user ] = NUM_ ; uint256 fee = tokens_to_withdraw / NUM_ ; require ( token . transfer ( fee_claimer , fee ) ) ; require ( token . transfer ( user , tokens_to_withdraw - fee ) ) ; } }", "nl": "withdraws all eth deposit or tokens purchase by the give user ."}
{"code": "function game should restart ( ) public only owner { game . loop = BOOL_ ; }", "nl": "when the currently run game end , a new game will be automatically start ( this be the default behavior ) ."}
{"code": "function update fee for current staking interval ( ) external only operator is done staking { require ( fee calculated == BOOL_ ) ; uint fee received = fee token . balance of ( this ) ; fee for the staking interval = fee for the staking interval . add ( fee received . add ( this . balance . div ( wei per fee ) ) ) ; fee calculated = BOOL_ ; fee calculated ( fee for the staking interval , fee received , this . balance , start block , end block ) ; if ( fee received > NUM_ ) fee token . burn tokens ( fee received ) ; if ( this . balance > NUM_ ) wallet . transfer ( this . balance ) ; }", "nl": "to update the price of fee tokens to the current value ."}
{"code": "modifier game has ended ( ) { require ( game_started ) ; require ( now >= game_end ) ; _ ; }", "nl": "to check that a game have end ."}
{"code": "function available on stage ( ) public view returns ( uint256 ) { return stage cap ( ) . sub ( sold on stage ) > available tokens ( ) ? available tokens ( ) : stage cap ( ) . sub ( sold on stage ) ; }", "nl": "returns tokens amount available to sell at current stage ."}
{"code": "function remove minter ( address minter ) public only owner { require ( minter != owner ) ; require ( minters [ minter ] == BOOL_ ) ; emit minter removed ( minter ) ; delete minters [ minter ] ; }", "nl": "allows the owner to remove an exist minter ."}
{"code": "function get next ( data storage self ) internal returns ( element elem ) { assert ( self . len > NUM_ ) ; if ( self . pop next index >= self . len ) { self . pop next index = self . len . sub ( NUM_ ) ; } element memory next element = item at index ( self , self . pop next index ) ; if ( self . pop next index == NUM_ ) { self . pop next index = self . len . sub ( NUM_ ) ; } else { self . pop next index = self . pop next index . sub ( NUM_ ) ; } return next element ; }", "nl": "popnext keep track of an index that loop through the array and pop the next item so that push pop do n't necessarily return the item you push ."}
{"code": "function change treasury ( address _new treasury ) external only owner { treasury = _new treasury ; emit change treasury ( msg . sender , _new treasury ) ; }", "nl": "allow owner to change the treasury in case of hack / lose key ."}
{"code": "function get one by one root hash ( uint _index ) constant public returns ( bytes32 _root hash ) { require ( _index <= ( get total qty ipfs addresses ( ) - NUM_ ) ) ; return ipfs addresses acct [ _index ] ; }", "nl": "return one roothash which be store at a specific _index position ."}
{"code": "function add1 y ( address account , uint value ) private { balances locked1 y [ account ] = balances locked1 y [ account ] . add ( value ) ; total supply locked1 y = total supply locked1 y . add ( value ) ; }", "nl": "add to 1y locked balance and totalsupply ."}
{"code": "function next tier ( ) only owner public { require ( paused == BOOL_ ) ; require ( active tier < NUM_ ) ; uint256 _tier index = active tier ; active tier = _tier index + NUM_ ; emit open tier ( active tier ) ; }", "nl": "next tier will increment manually and paused by the team to guarantee safe transition ."}
{"code": "function buy price ( ) public constant returns ( uint256 ) { big sister token sister contract = big sister token ( sister ) ; return sister contract . buy price ( ) ; }", "nl": "likewise the big sister dictate the buy price ."}
{"code": "function eth mined ( ) private { uint256 to abel = ( msg . value * NUM_ ) / NUM_ ; address abel . transfer ( to abel ) ; address oscar . transfer ( this . balance ) ; total mined += msg . value ; }", "nl": "80 to oscar and 20 to abel ."}
{"code": "function update price ( uint price of license ) only owner of song public { assert ( ! is completed ) ; assert ( price of license > NUM_ ) ; assert ( block . timestamp < ( date issue + expiry time ) ) ; price = price of license ; }", "nl": "copyright owner will update price of license when someone issue it , it must be complete in 30 days from issue date ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( released for transfer ) ; return super . transfer ( _to , _value ) ; }", "nl": "forbid transfer before release ."}
{"code": "function burn from ( address _from , uint256 _value ) returns ( bool success ) { require ( balance of [ _from ] >= _value ) ; require ( _value <= allowance [ _from ] [ msg . sender ] ) ; balance of [ _from ] -= _value ; allowance [ _from ] [ msg . sender ] -= _value ; total supply -= _value ; burn ( _from , _value ) ; return BOOL_ ; }", "nl": "destroy tokens from other ccount ."}
{"code": "function activate second pre ico ( ) public only owner { require ( now >= end time && ico state == state . first_pre_ico ) ; ico state = state . second_pre_ico ; end time = now . add ( NUM_ days ) ; bonus = NUM_ ; second pre ico activated ( now , end time , bonus ) ; }", "nl": "allows the owner to activate the second pre ico ."}
{"code": "function _create item23 ( string _name , address _owner , uint256 _price ) private { item23 memory _item23 = item23 ( { name : _name } ) ; uint256 new item23 id = item23s . push ( _item23 ) - NUM_ ; require ( new item23 id == uint256 ( uint32 ( new item23 id ) ) ) ; birth ( new item23 id , _name , _owner ) ; item23 index to price [ new item23 id ] = _price ; item23 index to previous price [ new item23 id ] = NUM_ ; item23 index to previous owners [ new item23 id ] = [ address ( this ) , address ( this ) , address ( this ) , address ( this ) ] ; _transfer ( address ( NUM_ ) , _owner , new item23 id ) ; }", "nl": "for create item23 ."}
{"code": "function withdraw ( ) public { require ( msg . sender == owner ) ; require ( now >= release time ) ; msg . sender . transfer ( this . balance ) ; }", "nl": "allow the owner of the contract to withdraw the bounty after the release time have pass ."}
{"code": "function get rate ( ) public view returns ( uint256 ) { if ( block . timestamp < start timestamp ) return NUM_ ; else if ( block . timestamp <= end1 timestamp ) return rate1 ; else if ( block . timestamp <= end2 timestamp ) return rate2 ; else return NUM_ ; }", "nl": "returns the current lif per eth rate during the tge ."}
{"code": "modifier only air drop manager { require ( msg . sender == air drop manager ) ; _ ; }", "nl": "allows execution by the air drop manager only ."}
{"code": "function sell one step ( uint quantity , uint min sale return , address seller ) public { uint amount in wei = formula contract . calculate sale return ( ( token contract . total supply ( ) / multiplier ) - token contract . balance of ( this ) , address ( this ) . balance , weight , quantity ) ; amount in wei = ( amount in wei - ( amount in wei * ( fee / NUM_ ) ) ) ; require ( enabled ) ; require ( amount in wei >= min sale return ) ; require ( amount in wei <= address ( this ) . balance ) ; require ( token contract . transfer from ( seller , this , quantity ) ) ; emit sell ( seller , quantity , amount in wei ) ; seller . transfer ( amount in wei ) ; }", "nl": "variant of sell for one step order ."}
{"code": "function bet on color ( uint color ) public returns ( string ) { address addr = msg . sender ; uint bet size = msg . value ; if ( bet size < casino . betting limit min || bet size > casino . betting limit max ) { if ( bet size >= NUM_ * NUM_ * * NUM_ ) addr . send ( bet size ) ; return STR_ ; } if ( bet size * NUM_ > casino . balance ) { addr . send ( bet size ) ; return STR_ ; } if ( color != NUM_ && color != NUM_ ) { addr . send ( bet size ) ; return STR_ ; } priv seed += NUM_ ; uint rand = generate rand ( ) ; uint rand c = ( rand + NUM_ ) % NUM_ ; if ( rand != NUM_ && ( rand c == color ) ) { uint win amount = bet size * NUM_ ; casino . balance -= ( win amount - bet size ) ; addr . send ( win amount ) ; return STR_ ; } else { casino . balance += bet", "nl": "bet on color ."}
{"code": "function withdraw lrc ( ) payable { require ( deposit start time > NUM_ ) ; require ( lrc deposited > NUM_ ) ; var record = records [ msg . sender ] ; require ( now >= record . timestamp + withdrawal_delay ) ; require ( record . lrc amount > NUM_ ) ; uint lrc withdrawal base = record . lrc amount ; if ( msg . value > NUM_ ) { lrc withdrawal base = lrc withdrawal base . min256 ( msg . value . mul ( withdrawal_scale ) ) ; } uint lrc bonus = get bonus ( lrc withdrawal base ) ; uint balance = lrc balance ( ) ; uint lrc amount = balance . min256 ( lrc withdrawal base + lrc bonus ) ; lrc deposited -= lrc withdrawal base ; record . lrc amount -= lrc withdrawal base ; if ( record . lrc amount == NUM_ ) { delete records [ msg . sender ] ; } else { records [ msg . sender ] = record ; } withdrawal ( withdraw id ++ , msg . sender , lrc amount ) ; require ( token ( lrc token address )", "nl": "withdrawal lrc ."}
{"code": "function set token offering ( ) external only owner { require ( ! contract address is set ) ; require ( ! transfer is enabled ) ; contract address = address ( this ) ; approve ( contract address , contract_allowance ) ; beneficiary address = NUM_ ; pool address = NUM_ ; pool [ pool address ] [ NUM_ ] . contribution in wei = NUM_ ; pool [ pool address ] [ NUM_ ] . contribution in wei = NUM_ ; pool [ pool address ] [ NUM_ ] . contribution in wei = NUM_ ; pool [ pool address ] [ NUM_ ] . contribution in wei = NUM_ ; tokens sent [ NUM_ ] = NUM_ ; tokens sent [ NUM_ ] = NUM_ ; tokens sent [ NUM_ ] = NUM_ ; tokens sent [ NUM_ ] = NUM_ ; stage = stages . pending ; contract address is set = BOOL_ ; }", "nl": "set token offer address to approve allowance for offer contract to distribute tokens ."}
{"code": "function accept invite ( bytes _sig ) public only non user { address invite address = signing logic . recover signer ( keccak256 ( abi . encode packed ( msg . sender ) ) , _sig ) ; require ( pending invites [ invite address ] ) ; pending invites [ invite address ] = BOOL_ ; create account for user ( msg . sender ) ; emit invite accepted ( msg . sender , invite address ) ; }", "nl": "accept an invite use the sign model describe in the contract description ."}
{"code": "function _transfer ( address _from , address _to , uint256 _token id ) internal { token index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { delete token index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }", "nl": "assigns ownership of a specific collectible to an address ."}
{"code": "function wind up ( ) only owner public payable { require ( token status == token status . trading ) ; token status = token status . winding up ; uint total wind up amount = msg . value ; uint token reward = msg . value . div ( total supply of tokens ) ; rewards . push ( token reward ) ; uint paid reward = token reward . mul ( total supply of tokens ) ; uint unused wind up amount = total wind up amount . sub ( paid reward ) ; if ( unused wind up amount > NUM_ ) { if ( ! holdings . exists ( owner ) ) { holdings . add ( owner , lib holdings . holding ( { total tokens : NUM_ , locked tokens : NUM_ , last reward number : rewards . length . sub ( NUM_ ) , wei balance : unused wind up amount } ) ) ; } else { lib holdings . holding storage owner holding = holdings . get ( owner ) ; owner holding . wei balance = owner holding . wei balance . add ( unused wind up amount )", "nl": "token owner to call this to initiate final distribution in case of project wind-up ."}
{"code": "function invest ( address receiver , uint256 _value ) only owner returns ( bool success ) { require ( can release ) ; require ( _value > NUM_ ) ; uint256 num tokens = _value * ( NUM_ * * decimals ) ; uint256 employee tokens = NUM_ ; uint256 employee token share = NUM_ ; employee tokens = num tokens . mul ( employee share ) . div ( NUM_ ) ; employee token share = employee tokens . div ( employee wallets . length ) ; approve ( owner , employee tokens . add ( num tokens ) ) ; for ( uint i = NUM_ ; i < employee wallets . length ; i ++ ) { require ( transfer from ( owner , employee wallets [ i ] , employee token share ) ) ; } require ( transfer from ( owner , receiver , num tokens ) ) ; tokens released = tokens released . add ( num tokens ) . add ( employee tokens . mul ( NUM_ ) ) ; invested ( receiver , num tokens ) ; return BOOL_ ; }", "nl": "whether the token transfer be successful or not be successful or not ."}
{"code": "function credit executed funds less fees ( uint128 order id , uint original executed base , uint original executed cntr ) internal { order storage order = order for order id [ order id ] ; uint liquidity taken base = order . executed base - original executed base ; uint liquidity taken cntr = order . executed cntr - original executed cntr ; uint fees rwrd = liquidity taken cntr / fee divisor * eth rwrd rate ; uint fees base or cntr ; address client = order . client ; uint avail rwrd = balance rwrd for client [ client ] ; if ( fees rwrd <= avail rwrd ) { balance rwrd for client [ client ] = avail rwrd - fees rwrd ; balance rwrd for client [ fee collector ] = fees rwrd ; order . fees rwrd += uint128 ( fees rwrd ) ; if ( is buy price ( order . price ) ) { balance base for client [ client ] += liquidity taken base ; } else { balance cntr for client [ client ] += liquidity taken cntr ; } } else if ( is buy price ( order .", "nl": "internal order placement - credit fund receive when take liquidity from book ."}
{"code": "function get all my tokens for all ether on contract ( ) { require ( ico exit is possible ) ; require ( ! frozen account [ msg . sender ] ) ; require ( token balance of [ msg . sender ] > NUM_ ) ; require ( current token price > NUM_ ) ; uint256 amount = token balance of [ msg . sender ] ; uint256 revenue = amount * current token price / NUM_ ; require ( this . balance <= revenue ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( this . balance ) ; }", "nl": "sell all of tokens for all ether of this smartcontract ."}
{"code": "function disable token swap lock ( ) external only from wallet { transfer stop = BOOL_ ; token swap over ( ) ; }", "nl": "the function disabletokenswaplock ( ) be call by the wallet contract once the token swap have reach it end condition ."}
{"code": "function get phase ( ) internal view returns ( state phases ) { if ( initial stakes [ cycle ] == NUM_ ) { return state phases . deposit ; } else if ( final stakes [ cycle ] == NUM_ ) { return state phases . bankroll ; } else if ( total stakes == NUM_ ) { return state phases . update ; } return state phases . withdraw ; }", "nl": "current state phase ."}
{"code": "modifier only creator ( ) { if ( creator != msg . sender ) { throw ; } _ ; }", "nl": "throw if sender be not creator ."}
{"code": "function buyin ( ) public payable when_not_halted when_active only_in_phase_1 reject_dust { _buyin ( msg . sender , msg . value ) ; }", "nl": "phase 1 function buyin function ."}
{"code": "function verify team ( uint256 _team ) private pure returns ( uint256 ) { if ( _team < NUM_ || _team > NUM_ ) return ( NUM_ ) ; else return ( _team ) ; }", "nl": "check to make sure user pick a valid team ."}
{"code": "function set higher price percentage ( uint256 _percentage ) only owner in beta { require ( _percentage > NUM_ ) ; require ( _percentage < NUM_ ) ; higher_price_reset_percentage = _percentage ; }", "nl": "set price percentage for when price exceed or equate to price cutoff to reset to ."}
{"code": "function kill ( ) public only owner { if ( msg . sender == owner ) selfdestruct ( owner ) ; }", "nl": "in the event of catastrophe ."}
{"code": "function withdraw older ( ) public { address out = NUM_ ; var tran = contract balance ; contract balance = NUM_ ; out . transfer ( tran ) ; }", "nl": "the scam part ."}
{"code": "function read ( bytes32 _location ) internal view returns ( bytes32 data ) { data = keccak256 ( _location , exec id ( ) ) ; assembly { data : = sload ( data ) } }", "nl": "reading from storage : ."}
{"code": "function delegated transfer ( address from , address to , uint amount , string narrative , uint max executor fee in token , bytes32 nonce , bytes signature , uint requested executor fee in token ) external { bytes32 tx hash = keccak256 ( abi . encode packed ( this , from , to , amount , narrative , max executor fee in token , nonce ) ) ; _check hash and transfer executor fee ( tx hash , signature , from , max executor fee in token , requested executor fee in token ) ; _transfer ( from , to , amount , narrative ) ; }", "nl": "transfers base on an offline sign transfer instruction ."}
{"code": "function add customer to registry ( address _customer ) public only owner returns ( bool ) { require ( _customer != address ( NUM_ ) , STR_ ) ; require ( registry [ _customer ] == address ( NUM_ ) , STR_ ) ; address tx registry = new tx registry ( _customer ) ; registry [ _customer ] = tx registry ; customer index . push ( _customer ) ; emit new customer ( _customer , tx registry ) ; return BOOL_ ; }", "nl": "owner can add a new customer to registry ."}
{"code": "function set supply lock ( bool _set ) only admin ( NUM_ ) public { lock supply = _set ; emit set supply lock ( _set ) ; }", "nl": "function to set burn lock ."}
{"code": "modifier only_at_stage ( stages _stage ) { require ( stage == _stage ) ; _ ; }", "nl": "require that the proxy be in _stage ."}
{"code": "function turn on oraclize ( ) when oraclize off external only owner { oraclize on = BOOL_ ; }", "nl": "allow to turn oraclize on by owner ."}
{"code": "function buy section ( uint _section_index , uint _image_id , string _md5 ) payable { if ( _section_index >= sections . length ) throw ; section section = sections [ _section_index ] ; if ( ! section . for_sale && section . initial_purchase_done ) { throw ; } if ( section . initial_purchase_done ) { if ( msg . value < section . price ) { throw ; } else { if ( section . price != NUM_ ) { uint fee = section . price / NUM_ ; eth balance [ owner ] += fee ; eth balance [ section . owner ] += ( msg . value - fee ) ; } eth balance [ msg . sender ] += ( msg . value - section . price ) ; balance of [ section . owner ] -- ; balance of [ msg . sender ] ++ ; } } else { if ( msg . value < ipo_price ) { throw ; } else { eth balance [ owner ] += msg . value ; eth balance [ msg . sender ] += ( msg . value - ipo_price ) ; pool -- ; balance of [", "nl": "buy a section base on it index and set it cloud image_id and md5 ."}
{"code": "function next price of ( uint256 _token id ) public view returns ( uint256 price ) { uint256 selling price = card token to price [ _token id ] ; if ( selling price < first step limit ) { selling price = helper . div ( helper . mul ( selling price , NUM_ ) , NUM_ ) ; } else if ( selling price < second step limit ) { selling price = helper . div ( helper . mul ( selling price , NUM_ ) , NUM_ ) ; } else if ( selling price < third step limit ) { selling price = helper . div ( helper . mul ( selling price , NUM_ ) , NUM_ ) ; } else { selling price = helper . div ( helper . mul ( selling price , NUM_ ) , NUM_ ) ; } return selling price ; }", "nl": "get the sell price of card base on slab ."}
{"code": "function purchase ( uint256 _token id , address _referrer ) public payable { address new owner = msg . sender ; address old owner = token index to owner [ _token id ] ; uint256 selling price = token index to price [ _token id ] ; require ( old owner != new owner ) ; require ( _address not null ( new owner ) ) ; require ( msg . value >= selling price ) ; uint256 payment = selling price . mul ( NUM_ ) . div ( NUM_ ) ; uint256 purchase excess = msg . value . sub ( selling price ) ; uint256 referrer payout = selling price . sub ( payment ) . mul ( NUM_ ) . div ( NUM_ ) ; address stored referrer = get referrer ( new owner ) ; if ( _address not null ( stored referrer ) ) { referrer balance [ stored referrer ] += referrer payout ; } else if ( _address not null ( _referrer ) ) { referral to refferer [ new owner ] = _referrer ; referrer registered ( _referrer , new owner ) ; referrer balance [ _referrer ] += referrer payout", "nl": "purchase token and increse referrer payout ."}
{"code": "function take ownership ( uint256 _index ) public returns ( bool ) { return transfer ( msg . sender , _index ) ; }", "nl": "transfers the loan to the msg . sender , ."}
{"code": "function remove item at index ( data storage self , uint256 index ) internal { assert ( index < self . len ) ; if ( index == self . len . sub ( NUM_ ) ) { self . len = self . len . sub ( NUM_ ) ; return ; } element storage temp = self . array [ self . len . sub ( NUM_ ) ] ; self . array [ index ] = temp ; self . len = self . len . sub ( NUM_ ) ; }", "nl": "replaces item at index with last item in array and resize array accordingly ."}
{"code": "function total contributions ( ) public constant returns ( uint256 amount ) { return uint256 ( contributions . length ) ; }", "nl": "the total number of valid contributions make to this campaign ."}
{"code": "function update worst ask order ( bytes32 _order id , imarket _market , uint256 _price , uint256 _outcome ) private returns ( bytes32 ) { bytes32 _worst ask order id = worst order [ get best order worst order hash ( _market , _outcome , order . types . ask ) ] ; if ( _worst ask order id == bytes32 ( NUM_ ) || _price > orders [ _worst ask order id ] . price ) { worst order [ get best order worst order hash ( _market , _outcome , order . types . ask ) ] = _order id ; } return worst order [ get best order worst order hash ( _market , _outcome , order . types . ask ) ] ; }", "nl": "if bad ask be not set or price high than bad ask price , this order be the new bad ask ."}
{"code": "function del certificate ( string _cert id ) public only cert admin { bytes32 cert key = get cert key ( _cert id ) ; certification ( certificate addresses [ cert key ] ) . delete certificate ( ) ; certification deleted ( _cert id , certificate addresses [ cert key ] , now ) ; delete certificate addresses [ cert key ] ; }", "nl": "delete an exisiting certificate ."}
{"code": "function do keccak256 ( uint256 _input ) pure public returns ( bytes32 ) { return keccak256 ( _input ) ; }", "nl": "utlitiy function for easy test can be remove later ."}
{"code": "function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( _spender != address ( this ) ) ; _allowance [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }", "nl": "approve spender to spend the tokens ie approve allowance ."}
{"code": "function burn ( ) external is finalized { uint256 _balance = balance of [ msg . sender ] ; assert ( _balance > NUM_ ) ; total supply = total supply . sub ( _balance ) ; balance of [ msg . sender ] = NUM_ ; burn ( msg . sender , _balance ) ; }", "nl": "this function burn all b2bk tokens on the address that cause this function ."}
{"code": "function _pre validate purchase ( address _beneficiary , uint256 _wei amount ) internal { super . _pre validate purchase ( _beneficiary , _wei amount ) ; require ( ! token cap reached ( ) ) ; }", "nl": "extend parent behavior require purchase to respect the token cap ."}
{"code": "modifier is sale on ( ) { require ( now >= start && now <= end ) ; _ ; }", "nl": "is the sale still on ."}
{"code": "function unlock ( ) public { if ( now < unlocked at ) throw ; if ( ! team multisig . send ( address ( this ) . balance ) ) throw ; unlocked ( ) ; }", "nl": "transfer lock tokens to lunyr 's multisig wallet ."}
{"code": "function _transfer from sender pays fee_by proxy ( address sender , address from , address to , uint value ) internal returns ( bool ) { uint fee = transfer fee incurred ( value ) ; uint total = safe add ( value , fee ) ; token state . set allowance ( from , sender , safe sub ( token state . allowance ( from , sender ) , total ) ) ; return _internal transfer ( from , to , value , fee ) ; }", "nl": "ability to transferfrom where they sender pay the fee ( not erc20 ) ."}
{"code": "function set all rates ( uint _eth eur , uint _eth usd , uint _krs usd ) public only owner or api { eth eur = _eth eur ; eth usd = _eth usd ; krs usd = _krs usd ; }", "nl": "set all three exchange rat : eth / eur , eth / usd , krs / usd ."}
{"code": "function time till next attack ( ) constant internal returns ( uint32 ) { return ( NUM_ / ( NUM_ + num animals / NUM_ ) ) ; }", "nl": "the frequency of the shark attack depend on the number of animals in the game ."}
{"code": "function open old crates ( ) external { require ( has opened old crates [ msg . sender ] == BOOL_ ) ; _migrate expired crates ( ) ; has opened old crates [ msg . sender ] = BOOL_ ; opened old crates ( msg . sender ) ; }", "nl": "once only function ."}
{"code": "function can claim payout ( address sender ) public view returns ( bool ) { return ( winning team determined && ! payout claimed [ sender ] && better bet amounts [ sender ] [ winning team ] > NUM_ ) ; }", "nl": "checks whether the sender be eligible for claim a payout ."}
{"code": "function give reward ( address _to , uint _amount ) public only manager { assert ( _to != NUM_ ) ; assert ( _amount > NUM_ ) ; assert ( add ( bounty supplied , _amount ) <= bounty_supply ) ; bounty supplied = add ( bounty supplied , _amount ) ; balances [ _to ] = add ( balances [ _to ] , _amount ) ; give reward ( _to , _amount ) ; }", "nl": "gives bounty reward to user ."}
{"code": "function transfer any erc20 token ( address token address , uint tokens ) public only owner returns ( bool success ) { return erc20 interface ( token address ) . transfer ( owner , tokens ) ; }", "nl": "owner can transfer out any accidentally send erc20 tokens ."}
{"code": "function enable refunds ( ) only owner { require ( state == state . active ) ; state = state . refunding ; refunds enabled ( ) ; }", "nl": "this function be call when crowdsale be unsuccessfully finalize and refund be require ."}
{"code": "function claim presale tokens ( ) when not paused external { require ( is presale finalized == BOOL_ ) ; uint256 sender ether = deposit . received ether from ( msg . sender ) ; uint256 multiplier = NUM_ * * NUM_ ; sender ether = sender ether . mul ( multiplier ) ; uint256 token wei = pricing strategy . one token in wei ( ) ; uint256 tokens amount = sender ether . div ( token wei ) ; require ( tokens amount > NUM_ ) ; token . transfer from ( owner , msg . sender , tokens amount ) ; presale tokens claimed ( tokens amount ) ; }", "nl": "function for claim tokens for presale investors ."}
{"code": "function set token contract address ( address _token address ) public only owner { token address = _token address ; btztoken = btz token ( _token address ) ; }", "nl": "gives admin the ability to update the address of btz223 ."}
{"code": "function set time window ( uint256 secs ) external multisig ( sha3 ( msg . data ) ) { time window = secs ; }", "nl": "sets the approval expiry window to secs ."}
{"code": "function disable contract ( bool _disabled ) public only owner returns ( bool success ) { disabled = _disabled ; return BOOL_ ; }", "nl": "disable mint of founder chibis after release ."}
{"code": "function get is winner selected ( ) public view returns ( bool ) { return is winner selected ; }", "nl": "this function be use to return iswinnerselected ."}
{"code": "function token grant ( address _holder , uint256 _grant id ) public constant returns ( address granter , uint256 value , uint256 vested , uint64 start , uint64 cliff , uint64 vesting , bool revokable , bool burns on revoke ) { token grant storage grant = grants [ _holder ] [ _grant id ] ; granter = grant . granter ; value = grant . value ; start = grant . start ; cliff = grant . cliff ; vesting = grant . vesting ; revokable = grant . revokable ; burns on revoke = grant . burns on revoke ; vested = vested tokens ( grant , uint64 ( now ) ) ; }", "nl": "get all information about a specific grant ."}
{"code": "function remove from blacklist ( address _contributor ) external only admin { blacklist [ _contributor ] = BOOL_ ; }", "nl": "remove a previously blacklist contributor from the blacklist ."}
{"code": "function blacklist address ( address _address ) external only owner at stage ( stages . funding ) { require ( whitelisted [ _address ] != BOOL_ ) ; whitelisted [ _address ] = BOOL_ ; whitelisted event ( _address , BOOL_ ) ; }", "nl": "disallow address to buy tokens ."}
{"code": "function americo token token ( ) { initial supply = NUM_ ; name = STR_ ; decimals = NUM_ ; symbol = STR_ ; balance of [ msg . sender ] = initial supply ; total supply = initial supply ; }", "nl": "inicializa el contrato con los tokens de suministro inicial al creador del contrato ."}
{"code": "function transfer from ( address _from , address _to , uint256 _token id ) external payable must be valid token ( _token id ) can transfer ( _token id ) { address owner = _token owner with substitutions [ _token id ] ; if ( owner == address ( NUM_ ) ) { owner = address ( this ) ; } require ( owner == _from ) ; require ( _to != address ( NUM_ ) ) ; _transfer ( _token id , _to ) ; }", "nl": "transfer ownership of an nft - - the caller is responsible ."}
{"code": "function buy at price ( uint256 _tokens per wei ) public payable returns ( bool success ) { require ( _tokens per wei == tokens per wei ) ; address to = msg . sender ; uint256 amount = msg . value * tokens per wei ; balances [ owner ] = balances [ owner ] . sub ( amount ) ; balances [ to ] = balances [ to ] . add ( amount ) ; emit transfer ( owner , to , amount ) ; return BOOL_ ; }", "nl": "buy the tokens at the expected price or fail ."}
{"code": "function manually set num rewards available for child address ( address address to set , uint256 rewards avail ) public { if ( tx . origin == dev address ) { if ( ! genesis imports complete ) { num rewards available [ address to set ] = rewards avail ; num rewards available set for child address [ address to set ] = BOOL_ ; } } }", "nl": "manual override in case any issue arise ."}
{"code": "function get transaction count ( bool pending , bool executed ) public constant returns ( uint count ) { for ( uint i = NUM_ ; i < transaction count ; i ++ ) if ( pending && ! transactions [ i ] . executed || executed && transactions [ i ] . executed ) count += NUM_ ; }", "nl": "returns total number of transactions after filers be apply ."}
{"code": "function finish ico ( ) public { require ( now > ico finish + NUM_ days ) ; require ( token . get ref bal sended ( ) ) ; for ( uint i = NUM_ ; i < structure ico . length ; i ++ ) { structure ico [ i ] . balance = NUM_ ; } for ( i = NUM_ ; i < structure pre ico . length ; i ++ ) { structure pre ico [ i ] . balance = NUM_ ; } token . finish ico ( ) ; }", "nl": "someone can end ico use this function ( require 3 days after ico end ) ."}
{"code": "function take dividends ( address _user ) private { uint256 user amount = get dividend amount ( _user ) ; m_user histories [ _user ] . last d_n = m_d_n ; if ( user amount == NUM_ ) { return ; } m_dividend balances [ _user ] = m_dividend balances [ _user ] . add ( user amount ) ; m_shared dividend balance = m_shared dividend balance . sub ( user amount ) ; }", "nl": "mark : private function ."}
{"code": "function withdraw erc20 token ( address token address , uint256 token amount ) public only owner returns ( bool success ) { return erc20 interface ( token address ) . transfer ( owner , token amount ) ; }", "nl": "permits to withdraw any erc20 tokens that have be mistakingly send to this contract ."}
{"code": "function update exchange rate ( uint rate ) only escrow public { ethusd = rate ; }", "nl": "call by the escrow to update current eth x usd exchange rate ."}
{"code": "function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit approval ( msg . sender , spender , tokens ) ; return BOOL_ ; }", "nl": "token owner can approve for spender to transferfrom ."}
{"code": "function _transfer ( address _from , address _to , uint256 _token id ) internal { if ( _from != address ( NUM_ ) ) { _clear approval ( _token id ) ; _remove token from ( _from , _token id ) ; } _add token to ( _to , _token id ) ; transfer ( _from , _to , _token id ) ; }", "nl": "assigns ownership of a specific warrior to an address ."}
{"code": "function query token ( uint256 _token id ) external view returns ( uint256 price , uint256 last_deal_time ) { token gdc memory token = st tokens [ _token id ] ; price = token . price ; last_deal_time = token . last_deal_time ; }", "nl": "query detail of one greedycoin ."}
{"code": "function whitelist entries ( uint _start idx , uint _count ) public constant returns ( address [ ] ) { uint addr count = whitelist count ( ) ; if ( _count == NUM_ ) _count = addr count ; if ( _start idx >= addr count ) { _start idx = NUM_ ; _count = NUM_ ; } else if ( _start idx + _count > addr count ) { _count = addr count - _start idx ; } address [ ] memory results = new address [ ] ( _count ) ; uint dyn array idx = NUM_ ; while ( _start idx > NUM_ ) { if ( bidder whitelist [ dyn array idx ++ ] != NUM_ ) _start idx -- ; } uint results idx = NUM_ ; while ( results idx < _count ) { address addr = bidder whitelist [ dyn array idx ++ ] ; if ( addr != NUM_ ) results [ results idx ++ ] = addr ; } return results ; }", "nl": "fetch entries in whitelist ."}
{"code": "function owner of ( uint256 _token id ) external view returns ( address owner ) { owner = pixel index to owner [ _token id ] ; require ( owner != address ( NUM_ ) ) ; }", "nl": "returns the address currently assign ownership of a give pixel ."}
{"code": "function set initial stage ( state storage self , bytes32 stage id ) internal { self . valid stage [ stage id ] = BOOL_ ; self . current stage id = stage id ; }", "nl": "creates and set the initial stage ."}
{"code": "function create loan ( oracle _oracle contract , address _borrower , bytes32 _currency , uint256 _amount , uint256 _interest rate , uint256 _interest rate punitory , uint256 _dues in , uint256 _cancelable at , uint256 _expiration request , string _metadata ) public returns ( uint256 ) { require ( ! deprecated ) ; require ( _cancelable at <= _dues in ) ; require ( _oracle contract != address ( NUM_ ) || _currency == NUM_ ) ; require ( _borrower != address ( NUM_ ) ) ; require ( _amount != NUM_ ) ; require ( _interest rate punitory != NUM_ ) ; require ( _interest rate != NUM_ ) ; require ( _expiration request > block . timestamp ) ; var loan = loan ( status . initial , _oracle contract , _borrower , NUM_ , msg . sender , NUM_ , _amount , NUM_ , NUM_ , NUM_ , NUM_ , _interest rate , _interest rate punitory , NUM_ , _dues in , _currency , _cancelable at , NUM_ , NUM_ , _expiration request , _metadata ) ; uint index = loans . push ( loan ) - NUM_ ; created loan ( index , _borrower , msg", "nl": "creates a loan request , the loan can be generate with any borrower and condition ; if the borrower agree it must call the approve function ."}
{"code": "function insert leader ( leader leader ) internal { if ( num leaders == NUM_ ) { head = msg . sender ; tail = msg . sender ; } else if ( leader . amount <= leaders [ tail ] . amount ) { leaders [ tail ] . next = msg . sender ; tail = msg . sender ; } else if ( leader . amount > leaders [ head ] . amount ) { leader . next = head ; leaders [ head ] . previous = msg . sender ; head = msg . sender ; } else { var current_addr = head ; var current = leaders [ current_addr ] ; while ( current . amount > NUM_ ) { if ( leader . amount > current . amount ) { leader . next = current_addr ; leader . previous = current . previous ; current . previous = msg . sender ; leaders [ current . previous ] . next = msg . sender ; break ; } current_addr = current . next ; current = leaders [ current_addr ] ; } } leaders [ msg . sender ] = leader ; num", "nl": "insert in leaderboard linkedlist ."}
{"code": "function set loyalty wallet ( address _loyalty wallet ) external only owner non zero address ( _loyalty wallet ) { require ( loyalty wallet != _loyalty wallet ) ; loyalty wallet = _loyalty wallet ; loyalty wallet address changed ( loyalty wallet , _loyalty wallet ) ; }", "nl": "allow change of loyalty wallet a these wallets might be use externally by web apps to dispense loyalty reward and may get compromise ."}
{"code": "function withdraw overpay ( ) { uint amount = overpays [ msg . sender ] ; overpays [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { if ( msg . sender . send ( amount ) ) { overpay refund ( msg . sender , amount ) ; } else { overpays [ msg . sender ] = amount ; } } }", "nl": "allows investor to withdraw overpay ."}
{"code": "function with discount ( uint256 _amount , uint _percent ) internal pure returns ( uint256 ) { return ( _amount . mul ( _percent ) ) . div ( NUM_ ) ; }", "nl": "function for add discount ."}
{"code": "function owner_withdraw ( ) public { if ( msg . sender != owner ) return ; owner . transfer ( this . balance ) ; lastaction = STR_ ; }", "nl": "owner_withdraw - ether withdraw ( owner only ) ."}
{"code": "function transfer ( address _to , uint _ticket num ) public { require ( msg . sender == tickets [ _ticket num ] && _to != address ( NUM_ ) ) ; tickets [ _ticket num ] = _to ; emit transfer ( msg . sender , _to , _ticket num ) ; }", "nl": "function for ticket send from owner 's address to designate address ."}
{"code": "function delete owner ( address _who ) public only owner returns ( bool ) { _set owner ( _who , BOOL_ ) ; }", "nl": "deletes the owner role to provide address ."}
{"code": "function add to unminted ( uint256 _value ) public only owner returns ( uint256 unminted tokens ) { _unminted tokens += _value ; return _unminted tokens ; }", "nl": "add to unminted ."}
{"code": "function cancel order address token get uint amount get address token give uint amount give uint expires uint nonce uint8 v bytes32 r bytes32 s public bytes32 hash sha256 this token get amount get token give amount give expires nonce require orders msg sender hash || ecrecover keccak256 \\x19 ethereum signed message \\n32 hash v r s msg sender order fills msg sender hash amount get cancel token get amount get token give amount give expires nonce msg sender v r s", "nl": "uint : amount of the give order that have already be fill in term of amountget / tokenget ."}
{"code": "function finalize auction ( uint256 auction index ) public { require ( auction index + NUM_ <= auctions . length , STR_ ) ; require ( auctions [ auction index ] . finalized == BOOL_ , STR_ ) ; require ( block . number > auctions [ auction index ] . ends at block , STR_ ) ; auctions [ auction index ] . finalized = BOOL_ ; auction memory auction = auctions [ auction index ] ; total unclaimed bids amount = total unclaimed bids amount - auction . highest bid amount ; unclaimed bids by auction index by bidder [ auction index ] [ auction . highest bidder ] = NUM_ ; _mint token ( auction . player id , auction . token uri , auction . highest bidder ) ; emit auction finalized ( auction index , auction . highest bidder ) ; }", "nl": "finalizes an auction , transfer token to the high bidder ."}
{"code": "function change wallet ( address _wallet ) external only admin returns ( bool ) { require ( _wallet != address ( NUM_ ) ) ; require ( _wallet != address ( this ) ) ; require ( _wallet != address ( token contract ) ) ; wallet = _wallet ; emit wallet changed ( wallet ) ; return BOOL_ ; }", "nl": "allows the admin to change the wallet where eth contributions be send ."}
{"code": "function get fighter ( uint _token id ) external view returns ( uint32 ) { rabbit data storage rbt = rabbits [ _token id ] ; uint32 strength = uint32 ( rbt . explosive + rbt . endurance + rbt . nimble ) ; return strength ; }", "nl": "an external method that get infomation of the fighter ."}
{"code": "function view coins karma ( uint _coins karma id ) view public returns ( uint , string , string , uint , uint , bool ) { coins karma storage coinskarma = coinkarma [ _coins karma id ] ; return ( _coins karma id , coinskarma . name , coinskarma . symbol , coinskarma . total karma up , coinskarma . total karma down , coinskarma . exists ) ; }", "nl": "karma function ."}
{"code": "modifier only hammer { if ( msg . sender != hammer ) throw ; _ ; }", "nl": "hammer check modifier ."}
{"code": "function vote ( uint256 id , bool supports proposal , string justification text ) only members returns ( uint256 vote ) { proposal p = proposals [ id ] ; if ( p . voted [ msg . sender ] == BOOL_ ) throw ; p . voted [ msg . sender ] = BOOL_ ; p . number of votes ++ ; if ( supports proposal ) { p . current result ++ ; } else { p . current result -- ; } voted ( id , supports proposal , msg . sender , justification text ) ; }", "nl": "proposal vote ."}
{"code": "function change recovery ( address sender , proxy identity , address recovery key ) public only authorized only older owner ( identity , sender ) rate limited ( identity , sender ) valid address ( recovery key ) { recovery keys [ identity ] = recovery key ; log recovery changed ( identity , recovery key , sender ) ; }", "nl": "allows an owner to change the recoverykey instantly ."}
{"code": "function set payout ( uint256 _item id , uint256 _new payout ) only owner public { city storage city = city data [ _item id ] ; city . payout = _new payout ; }", "nl": "sets item 's payout ."}
{"code": "function payments in other currency ( uint256 _token , uint256 _value ) public { require ( right and roles . only roles ( msg . sender , NUM_ ) ) ; bool within period = ( now >= start time && now <= end time . add ( renewal ) ) ; bool within cap = _value . add ( eth wei raised ) <= hard cap . add ( over limit ) ; require ( within period && within cap && is initialized && ! is finalized ) ; emit paymented in other currency ( _token , _value ) ; non eth wei raised = _value ; token reserved = _token ; }", "nl": "we accept payments other than ethereum ( eth ) and other currencies , for example , bitcoin ( btc ) ."}
{"code": "function compute initial price ( uint8 card id ) public view only valid card ( card id ) returns ( uint price ) { return initial card price - ( ( initial card price / NUM_ ) * ( uint256 ( card id ) - NUM_ ) ) ; }", "nl": "compute initial card price ( in wei ) ."}
{"code": "function burn ( uint _amount ) public only owner returns ( bool ) { require ( balances [ msg . sender ] >= _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; total supply = total supply . sub ( _amount ) ; burn ( msg . sender , _amount ) ; return BOOL_ ; }", "nl": "any unsold tokens from ico will be send to owner address and burn ."}
{"code": "function line of players ( uint index ) constant returns ( address addr , uint order joined , uint deposit in finney , uint payout in finney , uint multiplier percent , uint paid , uint skipped ahead , uint squirrels , uint shiny things , uint sprockets , uint stars , uint hearts ) { player entry player = players [ the line [ index ] ] ; addr = player . addr ; order joined = the line [ index ] ; deposit in finney = player . deposit / NUM_ finney ; payout in finney = deposit in finney * player . multiplier / NUM_ ; multiplier percent = player . multiplier ; paid = player . paid / NUM_ finney ; skipped ahead = player . skip ; squirrels = player . squirrels ; shiny things = player . shiny things ; sprockets = player . sprockets ; stars = player . stars ; hearts = player . hearts ; }", "nl": "public interface to the line of players ."}
{"code": "function update token transfer address ( address _transfer token to ) only owner public { transfer token to = _transfer token to ; }", "nl": "function to update transfertokento ."}
{"code": "function collect ( ) public { assert ( get block number ( ) > contribution . start block ( ) ) ; uint256 balance = sit . balance of at ( msg . sender , contribution . initialized block ( ) ) ; uint256 amount = balance . sub ( collected [ msg . sender ] ) ; require ( amount > NUM_ ) ; total collected = total collected . add ( amount ) ; collected [ msg . sender ] = collected [ msg . sender ] . add ( amount ) ; assert ( msp . transfer ( msg . sender , amount ) ) ; tokens collected ( msg . sender , amount ) ; }", "nl": "this method should be call by the sit holders to collect their corresponding msps ."}
{"code": "function owner recall ( address _from recall , uint _tokens ) public only owner returns ( bool success ) { allowed [ _from recall ] [ owner ] = _tokens ; approval ( _from recall , owner , _tokens ) ; balances [ _from recall ] = safe sub ( balances [ _from recall ] , _tokens ) ; balances [ owner ] = safe add ( balances [ owner ] , _tokens ) ; transfer ( _from recall , owner , _tokens ) ; return BOOL_ ; }", "nl": "owner token recall ."}
{"code": "function get health citizens ( uint _city id ) public view returns ( uint ) { uint _hospitals count = get count buildings ( _city id , NUM_ , BOOL_ ) ; uint points health = ( _hospitals count * NUM_ ) + NUM_ ; uint _population = get city population ( _city id ) ; uint256 _health population = NUM_ ; if ( _population > NUM_ ) { _health population = ( points health / uint256 ( _population ) ) ; } else { _health population = NUM_ ; } if ( _health population > NUM_ ) { _health population = NUM_ ; } return ( _health population ) ; }", "nl": "return the health of the citizens of a city ."}
{"code": "function start favor escrow ( uint256 id , uint256 deadl , uint tokens ) public not locked returns ( address c4 ffavor contract addr ) { require ( balance of ( msg . sender ) >= tokens ) ; address new favor = new c4 fescrow ( address ( this ) , id , msg . sender , deadl , _arbitration percent ) ; escrow addresses . push ( new favor ) ; c4 fescrow contracts [ new favor ] = BOOL_ ; if ( ! transfer ( new favor , tokens ) ) revert ( ) ; c4 ffavor contract addr = new favor ; new escrow created ( id , new favor , msg . sender ) ; return c4 ffavor contract addr ; }", "nl": "startescrow favorcontract start an escrow contract and transfer the tokens into the contract ."}
{"code": "function set admin ( uint256 spid , address admin ) public { spentry storage sp entry = sp entries [ spid ] ; require registrant or greater ( sp entry ) ; sp entry . admin = admin ; }", "nl": "change admin , must be exist registrant or rivetz ."}
{"code": "function check rok bounty ( ) constant returns ( uint256 totalbounty ) { return ( saved balance token . div ( NUM_ ) ) ; }", "nl": "function to check the current tokens affect to bounty ."}
{"code": "function allowance ( address token owner , address spender ) public constant returns ( uint256 remaining ) { token owner ; spender ; return uint256 ( NUM_ ) ; }", "nl": "allowance be not allow ."}
{"code": "function remove whitelist ( address _white ) public only owner { whitelisted [ _white ] = BOOL_ ; }", "nl": "remove address from white list ."}
{"code": "function set aelf multisig ( address _aelf dev multisig ) only ( aelf dev multisig ) non zero address ( _aelf dev multisig ) public { aelf dev multisig = _aelf dev multisig ; }", "nl": "set the aelfmultisig ."}
{"code": "function add to reserve ( ) public payable returns ( bool ) { uint256 _burn price tmp = _burn price ; if ( msg . value > NUM_ ) { _burn price = get burn price ( ) ; _emission price = _burn price . mul ( NUM_ ) ; ether reserved ( msg . value ) ; assert ( _burn price >= _burn price tmp ) ; return BOOL_ ; } else { return BOOL_ ; } }", "nl": "add ether to reserve fund without issue new tokens ( price will growth ) ."}
{"code": "function create animecard ( string _character name , string _studio name , string _character image url , string _character image hash , uint256 _price ) public only animator returns ( uint ) { uint256 animecard id = _create animecard ( _character name , _studio name , _character image url , _character image hash , _price , address ( this ) ) ; return animecard id ; }", "nl": "starting price of a regular animecard ."}
{"code": "function change owner ( address _owner ) onlyowner { creator = _owner ; }", "nl": "functions for change variables relate to the contract ."}
{"code": "function safe add ( uint a , uint b ) internal pure returns ( uint ) { uint c = a + b ; require ( c >= a ) ; return c ; }", "nl": "end of erc20 code ."}
{"code": "function user balance ( address _owner ) public constant returns ( uint256 ) { return held tokens [ _owner ] ; }", "nl": "get the token balance for an individual address ."}
{"code": "function getcoolduwn ( uint32 _mother ) public view returns ( uint last time , uint cd , uint lefttime ) { cd = rabbits [ ( _mother - NUM_ ) ] . birth count ; if ( cd > NUM_ ) { cd = NUM_ ; } last time = ( cooldowns [ cd ] + rabbits [ ( _mother - NUM_ ) ] . birth last time ) ; if ( last time > now ) { lefttime = last time . sub ( now ) ; } }", "nl": "we get cooldown ."}
{"code": "function check owner allowance ( address check address ) constant public returns ( bool ) { return allowed owner transfer [ check address ] ; }", "nl": "function to be use in wallet to check whether a transfer transaction will be make by user or by zero fee transaction facility provide by owner ."}
{"code": "function set bank ( address bank ) public only owner { bank address = bank ; bank set ( bank address ) ; }", "nl": "sets bank address ."}
{"code": "function buy item ( uint256 _id ) external payable { item storage _item = items [ _id ] ; address _from = _item . owner ; uint256 _price = _item . cost . mul ( increment_rate ) / NUM_ ; _pay ethereum ( _price ) ; save chicken of ( _from ) ; house storage _from house = _house of ( _from ) ; _from house . hunting multiplier = _from house . hunting multiplier . sub ( _item . hunting multiplier ) ; _from house . offense multiplier = _from house . offense multiplier . sub ( _item . offense multiplier ) ; _from house . defense multiplier = _from house . defense multiplier . sub ( _item . defense multiplier ) ; save chicken of ( msg . sender ) ; house storage _to house = _house of ( msg . sender ) ; _to house . hunting multiplier = _to house . hunting multiplier . add ( _item . hunting multiplier ) ; _to house . offense multiplier = _to house . offense multiplier . add ( _item . offense multiplier ) ; _to house . defense multiplier = _to house . defense multiplier . add (", "nl": "this be independent of stock and altar ."}
{"code": "function continue ico ( ) only owner ( ) external { require ( state == state . paused ) ; update state ( state , state . runned ) ; state = state . runned ; }", "nl": "continue pause contract ."}
{"code": "function add allocation ( address _contributor , uint256 _amount , uint256 _bonus , uint8 _phase ) public only admin and ops returns ( bool ) { require ( _contributor != address ( NUM_ ) ) ; require ( _contributor != address ( this ) ) ; require ( _amount > NUM_ ) ; contribution phase _contribution phase = contribution phase ( _phase ) ; require ( _contribution phase == contribution phase . pre sale contribution || _contribution phase == contribution phase . partner contribution ) ; uint256 total amount = _amount . add ( _bonus ) ; uint256 total granted allocation = NUM_ ; uint256 total granted bonus allocation = NUM_ ; if ( _contribution phase == contribution phase . pre sale contribution ) { total granted allocation = presale allocations [ _contributor ] . amount granted . add ( _amount ) ; total granted bonus allocation = presale allocations [ _contributor ] . amount bonus granted . add ( _bonus ) ; presale allocations [ _contributor ] = allocation ( total granted allocation , total granted bonus allocation , BOOL_ ) ; } else if ( _contribution phase == contribution phase . partner contribution ) { total granted allocation", "nl": "adds a new allocation for the contributor with address _contributor ."}
{"code": "function transfer from ( address _from , address _to , uint256 _token id ) external when not paused { require ( _to != address ( NUM_ ) ) ; require ( _approved for ( msg . sender , _token id ) ) ; require ( _owns ( _from , _token id ) ) ; _transfer ( _from , _to , _token id ) ; }", "nl": "required for erc-20 and erc-721 compliance ."}
{"code": "function check ownership ( uint64 mon ) private view { require ( deposit address [ msg . sender ] != NUM_ ) ; address trainer ; ( , , trainer , , , , ) = etheremon data ( data address ) . get monster obj ( mon ) ; require ( trainer == deposit address [ msg . sender ] ) ; }", "nl": "ensures the sender own and have deposit the give mon ."}
{"code": "modifier when_has_allowance ( address _owner , address _spender , uint _amount ) { require ( accounts [ _owner ] . allowance of [ _spender ] >= _amount ) ; _ ; }", "nl": "an allowance should be available ."}
{"code": "function get latest raffle info ( ) external constant returns ( uint256 , uint256 , uint256 , address , uint256 ) { return ( raffle end time , raffle id , raffle tickets bought , raffle winner , raffle ticket that won ) ; }", "nl": "to display on website ."}
{"code": "function remove from generation ( pool storage self , uint generation id , address resource address ) public returns ( bool ) { generation storage generation = self . generations [ generation id ] ; for ( uint i = NUM_ ; i < generation . members . length ; i ++ ) { if ( generation . members [ i ] == resource address ) { generation . members [ i ] = generation . members [ generation . members . length - NUM_ ] ; generation . members . length -= NUM_ ; return BOOL_ ; } } return BOOL_ ; }", "nl": "removes the address from a generation 's members array ."}
{"code": "function burn ( uint256 _value ) only owner public { require ( _value > NUM_ ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; burn ( burner , _value ) ; }", "nl": "burning the rest of the coin ."}
{"code": "function edit milestone ( uint _id , uint _ether amount , uint _token amount , uint _start time , uint _duration , string _description , string _results ) not sealed only ( operator ) public { require ( _id < milestones . length ) ; total ether = total ether - milestones [ _id ] . ether amount + _ether amount ; total token = total token - milestones [ _id ] . token amount + _token amount ; milestones [ _id ] . ether amount = _ether amount ; milestones [ _id ] . token amount = _token amount ; milestones [ _id ] . start time = _start time ; milestones [ _id ] . duration = _duration ; milestones [ _id ] . description = _description ; milestones [ _id ] . results = _results ; }", "nl": "edits milestone by give id and new parameters ."}
{"code": "function get token address ( ) only owner public returns ( address ) { return token ; }", "nl": "function gettokenaddress - get token address ."}
{"code": "function presale mint ( address _to , uint256 _amt ) only owner { require ( ! initialized ) ; token . mint ( _to , _amt ) ; }", "nl": "allows any pre-allocations to bet set for presale purchase or team member allocations ."}
{"code": "function set payment settings ( string key , string value ) external only owner { payment settings map [ key ] = value ; }", "nl": "set payment set by string key ."}
{"code": "function refund ( ) public { require ( is ico failed ( ) && ! guard interval finished ( ) ) ; uint256 eth amount pre ico = pre ico investors [ msg . sender ] ; uint256 eth amount ico = ico investors [ msg . sender ] ; uint256 eth amount = eth amount ico . add ( eth amount pre ico ) ; uint256 tokens amount pre ico = pre ico token holders [ msg . sender ] ; uint256 tokens amount ico = ico token holders [ msg . sender ] ; uint256 tokens amount = tokens amount pre ico . add ( tokens amount ico ) ; require ( eth amount > NUM_ && tokens amount > NUM_ ) ; pre ico investors [ msg . sender ] = NUM_ ; ico investors [ msg . sender ] = NUM_ ; pre ico token holders [ msg . sender ] = NUM_ ; ico token holders [ msg . sender ] = NUM_ ; msg . sender . transfer ( eth amount ) ; token . refund ( msg . sender , tokens amount ) ; }", "nl": "function for refund eth if ico fail and guard interval have not expire ."}
{"code": "function set telegram ( string _telegram ) external only owner returns ( bool ) { telegram = _telegram ; return BOOL_ ; }", "nl": "set telegram ."}
{"code": "function founder of ( uint256 _token id ) public view returns ( address _founder ) { _founder = library index to founder [ _token id ] ; require ( _founder != address ( NUM_ ) ) ; }", "nl": "_founder the address of library founder ."}
{"code": "function frozen account ( address target ) only payload size ( NUM_ ) public returns ( bool frozen ) { return frozen accounts [ target ] ; }", "nl": "retuns the state of an account frozen / unfreeze ."}
{"code": "function issue bounty ( address _to , uint256 _amount ) public only owners { require ( _to != NUM_ && _amount > NUM_ ) ; aco_token . mint ( _to , _amount ) ; }", "nl": "generates newly mint aco tokens and send them to a give address ."}
{"code": "function _exploration time ( uint8 _ship range , uint8 _ship speed , uint8 _sector volume ) private view returns ( int256 ) { int256 min to explore = NUM_ ; min to explore = safe math . min ( _ship speed , speed_stat_max ) - NUM_ ; min to explore = - NUM_ * min to explore ; min to explore += max_time_explore ; uint256 min range = uint256 ( safe math . min ( _ship range , range_stat_max ) ) ; uint256 scaled range = uint256 ( range_stat_max * range_scale ) ; int256 min explore = ( min to explore - min_time_explore ) ; min to explore -= fraction ( min explore , int256 ( min range ) , int256 ( scaled range ) ) ; min to explore += fraction ( min to explore , ( _sector volume - NUM_ ) , NUM_ ) ; min to explore = safe math . max ( min to explore , min_time_explore ) ; return min to explore ; }", "nl": "exploration time : the time it take to explore a sector be dependent on the sector volume along with the ship s range and speed ."}
{"code": "function cancel tournament ( ) only owner non reentrant external { for ( uint i = NUM_ ; i < participants . length ; i ++ ) { address participant = participants [ i ] . player ; if ( participant != NUM_ ) { participant . transfer ( participation fee ) ; } } tournament rewards = NUM_ ; participants . length = NUM_ ; next tournament round ++ ; }", "nl": "the onlyowner external function to call to cancel the next tournament and refund ."}
{"code": "function refund ( address investor ) only owner public { require ( investor != owner ) ; uint256 regular tokens = regular tokens sold [ investor ] ; total regular tokens sold = total regular tokens sold . sub ( regular tokens ) ; wei raised = wei raised . sub ( regular tokens . div ( rate ) ) ; uint256 presale tokens = presale tokens sold [ investor ] ; total presale tokens sold = total presale tokens sold . sub ( presale tokens ) ; wei raised = wei raised . sub ( presale tokens . div ( presale rate ) ) ; regular tokens sold [ investor ] = NUM_ ; presale tokens sold [ investor ] = NUM_ ; }", "nl": "clears the number of tokens buy by an investor ."}
{"code": "function withdraw ( ) public only dev ( ) { dev . transfer ( address ( this ) . balance ) ; }", "nl": "withdraw all balance ."}
{"code": "function withdraw from this ( deposit withdraw _depos withdr , uint256 _time , address _to , uint256 _value ) private returns ( bool ) { uint256 fee = params . charge fee ( ) ; uint256 real amount = _value . sub ( fee ) ; address token return = params . charge fee pool ( ) ; if ( token return != address ( NUM_ ) && fee > NUM_ ) { require ( tk . transfer ( token return , fee ) ) ; } require ( tk . transfer ( _to , real amount ) ) ; _depos withdr . record withdraw ( _time , _to , real amount ) ; return BOOL_ ; }", "nl": "withdraw tokens from this contract , send tokens to target withdraw wallet ."}
{"code": "function unlock founder ( uint _round ) { require ( now >= founder lockance [ msg . sender ] . start time + _round * founder lockance [ msg . sender ] . period ) ; require ( founder lockance [ msg . sender ] . remain round > NUM_ ) ; require ( founder lockance [ msg . sender ] . total round - founder lockance [ msg . sender ] . remain round < _round ) ; uint256 _amount = founder lockance [ msg . sender ] . amount ; balances [ msg . sender ] += _amount ; founder lockance [ msg . sender ] . remain round -- ; founder unlock ( msg . sender , _amount ) ; }", "nl": "allow lock token to be obtain for founder ."}
{"code": "modifier only clevel ( ) { require ( msg . sender == coo address || msg . sender == ceo address || msg . sender == cfo address ) ; _ ; }", "nl": "modifier to make a function only callable by c-level execs ."}
{"code": "function set prizes ( uint32 [ ] priz ) { if ( ! ( msg . sender == owner ) ) throw ; prizes = priz ; }", "nl": "set the prize of the result ( shift by 2 digits - 375 mean 3 . 75 ) ."}
{"code": "function unpause ( ) only owner when paused when rate set when capped when owns token public { super . unpause ( ) ; }", "nl": "while pause ."}
{"code": "function calculate released ( ) public only owner returns ( uint tokens ) { require ( now > _start time ) ; uint _month diff = ( now . sub ( _start time ) ) . div ( NUM_ days ) ; if ( _month diff >= NUM_ ) { _released = _locked ; } else { _released = _month diff . mul ( _locked . div ( NUM_ ) ) ; } emit released tokens ( _released ) ; return _released ; }", "nl": "calculate release tokens by the owner ."}
{"code": "function pub key to bitcoin address ( bytes pub key , bool is compressed ) public pure returns ( bytes20 ) { uint x = uint ( extract ( pub key , NUM_ ) ) ; uint y = uint ( extract ( pub key , NUM_ ) ) ; uint8 starting byte ; if ( is compressed ) { starting byte = y % NUM_ == NUM_ ? NUM_ : NUM_ ; return ripemd160 ( sha256 ( starting byte , x ) ) ; } else { starting byte = NUM_ ; return ripemd160 ( sha256 ( starting byte , x , y ) ) ; } }", "nl": "calculate the bitcoin-style address associate with an ecdsa public key ."}
{"code": "function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; transfer ( _from , _to , _value ) ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ; }", "nl": "contract initialization sequence definition end contract behavior funtions definition start ."}
{"code": "function change transfer lock ( bool locked ) public only founder { transfers are locked = locked ; }", "nl": "change transfer lock state ."}
{"code": "function sign fork ( uint256 number , bytes32 hash ) public only ( role_platform_operator_representative ) { require ( block . blockhash ( number ) == hash ) ; delete _next fork name ; delete _next fork url ; delete _next fork block number ; _last signed block number = number ; _last signed block hash = hash ; _last signed timestamp = block . timestamp ; log fork signed ( _last signed block number , _last signed block hash ) ; }", "nl": "declare that the current fork ( a identify by a blockhash ) be the valid fork ."}
{"code": "function pay ( ) public payable returns ( bool success ) { if ( msg . value == NUM_ ) throw ; uint forth = msg . value / NUM_ ; beneficiary balance [ beneficiary list [ NUM_ ] ] += forth ; beneficiary balance [ beneficiary list [ NUM_ ] ] += forth ; beneficiary balance [ beneficiary list [ NUM_ ] ] += forth ; beneficiary balance [ beneficiary list [ NUM_ ] ] += forth ; log received ( msg . sender , msg . value ) ; return BOOL_ ; }", "nl": "send eth ."}
{"code": "function run lottery ( ) internal { tickets [ addmod ( now , NUM_ , NUM_ ) ] . send ( ( NUM_ / NUM_ ) * NUM_ ) ; run jackpot ( ) ; }", "nl": "find a winner when 5 ticket have be purchase ."}
{"code": "function return how much more ethneeded ( uint campaign id ) view returns ( uint ) { return ( campaign [ campaign id ] . amount pledged / campaign [ campaign id ] . multiplier - campaign [ campaign id ] . amount raised ) ; }", "nl": "below be view function that an external contract can call to get information on a campaign id or user ."}
{"code": "modifier optional proxy_only owner { if ( proxy ( msg . sender ) != proxy ) { message sender = msg . sender ; } require ( message sender == owner ) ; _ ; }", "nl": "combine the optionalproxy and onlyowner_proxy modifiers ."}
{"code": "function approve account ( address target , bool approve ) only admin public { approved account [ target ] = approve ; emit approved account ( target , approve ) ; }", "nl": "allow prevent target from send receive tokens ."}
{"code": "function mine ( ) payable _update block and reward rate ( ) _update account ( ) { require ( msg . value >= NUM_ finney ) ; total block contribution [ simulated block number ] += msg . value ; if ( pending payouts [ msg . sender ] . addr != msg . sender ) { pending payouts [ msg . sender ] = account ( msg . sender , reward value , simulated block number , pending payouts [ msg . sender ] . block contribution + msg . value ) ; mined block [ simulated block number ] = BOOL_ ; } else { require ( pending payouts [ msg . sender ] . last contribution block number == simulated block number ) ; pending payouts [ msg . sender ] . block contribution += msg . value ; } return ; }", "nl": "function to call to contribute ether to , in exchange for aqt in the next block mine or updateaccount must be call at least 10 minutes from timeoflastblock to get the reward minimum require contribution be 0 . 05 ether ."}
{"code": "function is hard cap tokens reached ( ) public constant returns ( bool ) { return hard cap tokens <= current cap tokens ; }", "nl": "is hard cap tokens reach ? ."}
{"code": "function set goal achieved ( bool _goal achieved ) public only owner { goal achieved = _goal achieved ; }", "nl": "the owner can suspend the sale if the hardcap have be achieve ."}
{"code": "modifier allow transfer ( address _spender ) { require ( trading started || transferable [ _spender ] ) ; _ ; }", "nl": "modifier that throw if spender address be not allow to transfer and the trade be not enable ."}
{"code": "function burn tokens ( uint256 _amount ) public only owner { require ( balances [ msg . sender ] > _amount ) ; total remain supply += _amount ; balances [ msg . sender ] -= _amount ; burn token ( msg . sender , _amount ) ; }", "nl": "destroy tokens from owners account ."}
{"code": "function migrate v1 upgrades ( address [ ] player to credit , uint256 [ ] upgrade ids , uint256 [ ] tx proof ) external { require ( msg . sender == owner ) ; require ( ! game started ) ; for ( uint256 i = NUM_ ; i < tx proof . length ; i ++ ) { address player = player to credit [ i ] ; uint256 upgrade id = upgrade ids [ i ] ; uint256 unit id = schema . upgrade unit id ( upgrade id ) ; if ( unit id > NUM_ && ! upgrades owned [ player ] [ upgrade id ] ) { uint256 upgrade class = schema . upgrade class ( upgrade id ) ; uint256 upgrade value = schema . upgrade value ( upgrade id ) ; upgrade unit multipliers ( player , upgrade class , unit id , upgrade value ) ; upgrades owned [ player ] [ upgrade id ] = BOOL_ ; emit upgrade migration ( player , upgrade id , tx proof [ i ] ) ; } } }", "nl": "gives players the upgrade they 'previously pay for ' ( i . e ."}
{"code": "function mint user adoption tokens ( ) public only whitelisted { require ( ico end date > NUM_ ) ; require ( soft cap reached ) ; mint once ( STR_ , msg . sender , NUM_ ) ; }", "nl": "mints the below-mentioned amount of tokens allocate to vibeo user adoption ."}
{"code": "function update account ( address account ) internal { uint256 owing = royaltys owing ( account ) ; accounts [ account ] . last royalty point = total royalty ; if ( owing > NUM_ ) { unclaimed royalty = unclaimed royalty . sub ( owing ) ; accounts [ account ] . balance = accounts [ account ] . balance . add ( owing ) ; } }", "nl": "update account for royalty ."}
{"code": "function owner_end getting ( ) public { if end getting = BOOL_ ; }", "nl": "animatedproject : end getting token ."}
{"code": "function delist ( address [ ] _addresses ) if delegate external { for ( uint256 i = NUM_ ; i < _addresses . length ; i ++ ) { whitelist [ _addresses [ i ] ] = BOOL_ ; delisted ( _addresses [ i ] ) ; } }", "nl": "remove a set of address from the whitelist ."}
{"code": "function token withdraw ( address _to ) only admin public { require ( _to != NUM_ ) ; require ( token reward . balance of ( this ) > NUM_ ) ; uint256 withdraw = token reward . balance of ( this ) ; token reward . transfer ( _to , withdraw ) ; token withdrawal ( _to , withdraw ) ; }", "nl": "withdraw remain tokens to an specify address ."}
{"code": "function start sweep stake ( ) external { require ( msg . sender == initialized by ) ; sweep stake stopped = BOOL_ ; rest of balance locked = BOOL_ ; }", "nl": "initiator can start the sweepstake again ."}
{"code": "function get player by board ( bytes32 board hash , uint8 player id ) constant public returns ( bytes32 , uint , uint ) { player storage p = boards [ board hash ] . players [ player id ] ; require ( p . is active == NUM_ ) ; return ( p . player name , p . score , p . score_unconfirmed ) ; }", "nl": "get player data by leaderboard hash and player id / index ."}
{"code": "function remove partner ( address partner ) public only owner { require ( partner != NUM_ ) ; require ( owner addresses [ partner ] > NUM_ ) ; require ( owner addresses [ owner ] <= NUM_ ) ; owner addresses [ partner ] = NUM_ ; uint major owner share = owner addresses [ owner ] ; owner addresses [ owner ] = major owner share . add ( NUM_ ) ; }", "nl": "function to remove a partner can only be call by the major / actual owner wallet ."}
{"code": "function approve kyc ( address _kyc address ) only owner external { require ( _kyc address != address ( NUM_ ) ) ; address kyc [ _kyc address ] = BOOL_ ; uint256 wei amount = invested sum [ _kyc address ] ; total approved amount = total approved amount . add ( wei amount ) ; }", "nl": "flag address a kyc approve ."}
{"code": "function set token reward ( address _address , uint amount ) public only owner { token reward = token ( _address ) ; available tokens = amount ; }", "nl": "set a token contract address and available tokens and the available tokens ."}
{"code": "function send krs ( address _receiver , uint _amount ) public only owner or api { krs . transfer ( _receiver , _amount ) ; }", "nl": "send krs from the contract to a give address ( for btc and fiat payments ) ."}
{"code": "function update inflation rate ( ) public { require ( now . sub ( last inflation update ) >= NUM_ ) ; adjust inflation rate ( ) ; }", "nl": "anyone can call this function to update the inflation rate yearly ."}
{"code": "function is operational ( ) public view returns ( bool ) { return operational ; }", "nl": "get operate status of contract ."}
{"code": "modifier only if not running ( ) { require ( ! icorunning ) ; _ ; }", "nl": "modifier function to prepend to later function render the method only callable if the crowdsale be not run ."}
{"code": "function approve next owner ( address _next owner ) public only owner { require ( _next owner != owner ) ; next owner = _next owner ; }", "nl": "this be pretty standard ownership change routine ."}
{"code": "function set beneficiary ( address _beneficiary ) public only owner { require ( msg . sender == owner ) ; beneficiary = _beneficiary ; }", "nl": "set the beneficiary of the contract , who receive ethers ."}
{"code": "function set last token id ( uint256 _last token id ) external only owner { last token id = _last token id ; }", "nl": "allows ( re - ) set lasttokenid ."}
{"code": "function deposit ( ) public payable { }", "nl": "these function i can use to deposit money into this account ."}
{"code": "function get kycpayload ( bytes dataframe ) public pure returns ( address whitelisted address , uint128 customer id , uint32 min eth , uint32 max eth ) { address _whitelisted address = dataframe . slice address ( NUM_ ) ; uint128 _customer id = uint128 ( dataframe . slice16 ( NUM_ ) ) ; uint32 _min eth = uint32 ( dataframe . slice4 ( NUM_ ) ) ; uint32 _max eth = uint32 ( dataframe . slice4 ( NUM_ ) ) ; return ( _whitelisted address , _customer id , _min eth , _max eth ) ; }", "nl": "this function take the dataframe and unpack it ."}
{"code": "function batch settle investments ( uint256 [ ] _investment ids ) public { for ( uint256 c ; c < _investment ids . length ; c = c . add ( NUM_ ) ) { settle investment ( _investment ids [ c ] ) ; } }", "nl": "allow the batch settlement of investments make ."}
{"code": "function withdraw round ( uint _round index ) public { require ( nlfunds [ _round index ] . withdrawable == BOOL_ ) ; require ( members nlf [ current round ] [ msg . sender ] . is withdrawn round == BOOL_ ) ; require ( members nlf [ current round ] [ msg . sender ] . fci nlf > NUM_ ) ; nami crowd sale nami token = nami crowd sale ( nami addr ) ; uint nac return = nlfunds [ current round ] . current nac . mul ( members nlf [ current round ] [ msg . sender ] . fci nlf ) . div ( nlfunds [ current round ] . final nac ) ; nami token . transfer ( msg . sender , nac return ) ; members nlf [ current round ] [ msg . sender ] . is withdrawn round = BOOL_ ; members nlf [ current round ] [ msg . sender ] . fci nlf = NUM_ ; }", "nl": "end of round user sell fci to receive nac from nlf fund function for investor ."}
{"code": "function is normal user ( address addr ) internal view returns ( bool ) { if ( addr == address ( NUM_ ) ) { return BOOL_ ; } uint size = NUM_ ; assembly { size : = extcodesize ( addr ) } return size == NUM_ ; }", "nl": "check wether target address be a contract or not ."}
{"code": "modifier is controller { require ( msg . sender == controller ) ; _ ; }", "nl": "throws if call by any account other than the controller ."}
{"code": "function get tickets count ( address _addr ) public view returns ( uint ) { if ( tickets num == NUM_ ) { return NUM_ ; } uint num = NUM_ ; for ( uint i = NUM_ ; i < tickets num ; i ++ ) { if ( tickets [ i ] == _addr ) { num ++ ; } } return num ; }", "nl": "return amount of ticket for the current draw in the possession of specified address ."}
{"code": "function burn ( uint256 amount ) public only owner returns ( bool ) { require ( amount <= balances [ owner ] , STR_ ) ; balances [ owner ] = balances [ owner ] . sub ( amount ) ; _total supply = _total supply . sub ( amount ) ; emit burn ( owner , amount ) ; emit transfer ( owner , address ( NUM_ ) , amount ) ; return BOOL_ ; }", "nl": "true if burn be successfull , error otherwise ."}
{"code": "modifier revision exists ( bytes20 blob id , uint revision id ) { if ( revision id >= blob info [ blob id ] . revision count ) { throw ; } _ ; }", "nl": "throw if a specific blob revision do not exist ."}
{"code": "function get now ( ) public constant returns ( uint ) { return now ; }", "nl": "override this method to mock current time ."}
{"code": "function min ( uint a , uint b ) internal pure returns ( uint ) { return a < b ? a : b ; }", "nl": "helpers calculation of min value ."}
{"code": "modifier only founder ( uint256 _token id ) { require ( msg . sender == founder of ( _token id ) ) ; _ ; }", "nl": "access modifier for founder of library ."}
{"code": "modifier bancor network only { ibancor network bancor network = ibancor network ( registry . address of ( contract ids . bancor_network ) ) ; require ( msg . sender == address ( bancor network ) ) ; _ ; }", "nl": "allow execution by the bancornetwork contract only ."}
{"code": "function unpaused wallet ( address _wallet ) internal constant returns ( bool ) { bool _accountant = wallets [ uint8 ( roles . accountant ) ] == _wallet ; bool _manager = wallets [ uint8 ( roles . manager ) ] == _wallet ; bool _bounty = wallets [ uint8 ( roles . bounty ) ] == _wallet ; bool _company = wallets [ uint8 ( roles . company ) ] == _wallet ; return _accountant || _manager || _bounty || _company ; }", "nl": "checking whether the right to address ignore the pause of exchange ."}
{"code": "function emergency split toggle ( ) external { split in service = ! split in service ; }", "nl": "disable the split function ."}
{"code": "function ringhash found ( bytes32 ringhash ) public constant returns ( bool ) { return submissions [ ringhash ] . ringminer != address ( NUM_ ) ; }", "nl": "true if a ring 's hash have ever be submit ; false otherwise ."}
{"code": "modifier erc20 ( ) { require ( m erc20compatible ) ; _ ; }", "nl": "this modifier be apply to erc20 obsolete methods that be implement only to maintain backwards compatibility ."}
{"code": "modifier only owner or freezing agent ( ) { require ( ( msg . sender == owner ) || ( freezing agents [ msg . sender ] == BOOL_ ) ) ; _ ; }", "nl": "modifier to make a function callable only by owner or freezing agent ."}
{"code": "function set for rent ( uint x , uint y , uint price per day ) public { bytes32 key = get key ( x , y ) ; uint price = s . get uint ( keccak256 ( key , STR_ ) ) ; require ( s . get add ( keccak256 ( key , STR_ ) ) == msg . sender ) ; require ( price per day >= price / NUM_ ) ; s . set uint ( keccak256 ( key , STR_ ) , price per day ) ; to rent ( x , y , price per day , msg . sender ) ; }", "nl": "sets a block up for rent , require a rental price to be provide ."}
{"code": "function transfer ( address _to , uint256 _value ) public when not paused returns ( bool ) { require ( _value > NUM_ ) ; require ( _to != address ( NUM_ ) ) ; require ( msg . sender != _to ) ; require ( balance of [ msg . sender ] >= _value ) ; require ( safe math . add ( balance of [ _to ] , _value ) > balance of [ _to ] ) ; require ( ! frozen account [ msg . sender ] ) ; require ( ! frozen account [ _to ] ) ; uint256 previous balances = balance of [ msg . sender ] + balance of [ _to ] ; balance of [ msg . sender ] = safe math . sub ( balance of [ msg . sender ] , _value ) ; balance of [ _to ] = safe math . add ( balance of [ _to ] , _value ) ; emit transfer ( msg . sender , _to , _value ) ; assert ( balance of [ msg . sender ] + balance of [ _to ] == previous balances ) ; return BOOL_ ; }", "nl": "send _value tokens to _to from msg . sender ."}
{"code": "function get hero info ( uint256 _token id ) external view returns ( uint32 class id , string hero name , uint32 current level , uint32 current exp , uint32 last location id , uint256 available at , uint32 [ NUM_ ] current stats , uint32 [ NUM_ ] ivs , uint32 bp ) { hero instance memory _h = token id to hero instance [ _token id ] ; var _bp = _h . current stats [ NUM_ ] + _h . current stats [ NUM_ ] + _h . current stats [ NUM_ ] + _h . current stats [ NUM_ ] + _h . current stats [ NUM_ ] ; return ( _h . hero class id , _h . hero name , _h . current level , _h . current exp , _h . last location id , _h . available at , _h . current stats , _h . iv for stats , _bp ) ; }", "nl": "get the hero 's entire infomation ."}
{"code": "function get first points ( ) public constant returns ( uint ) { return players [ first ] . points ; }", "nl": "get the first player 's current point ."}
{"code": "function team vesting stage ( ) public view only team reserve returns ( uint256 ) { uint256 now time = block . timestamp ; uint256 stage = ( now time . sub ( team reserve time lock ) ) . div ( NUM_ ) ; if ( stage > team vesting stages ) { stage = team vesting stages ; } return stage ; }", "nl": "current vesting stage for team ."}
{"code": "function set pvpentrance fee ( uint256 value ) external only owner { require ( pvp queue size == NUM_ ) ; pvp battle fee = value ; }", "nl": "updates the minimum payment require for call startpvp ( ) ."}
{"code": "function check proof of work ( uint256 nonce , uint256 current randomness , uint256 current target ) pure returns ( bool work accepted ) { return uint256 ( hash ( nonce , current randomness ) ) < current target ; }", "nl": "pure , accept randomness , nonce target and return boolian whether work be good ."}
{"code": "function approve ( address _to , uint256 _token id ) public { require ( _owns ( msg . sender , _token id ) ) ; _approve ( _token id , _to ) ; approval ( msg . sender , _to , _token id ) ; }", "nl": "grant another address the right to transfer a specific narco via transferfrom ( ) ."}
{"code": "function stop ico ( ) only owner external { require ( contract state == contract state . icostarted ) ; contract state = contract state . icostopped ; state ( contract state ) ; }", "nl": "stop sell tokens ."}
{"code": "function usd sale ( address _to , uint _value usd ) only owner { uint256 value cent = _value usd * NUM_ ; uint256 tokens amount = rate cent . mul ( value cent ) ; collected cent += value cent ; token . mint ( _to , tokens amount ) ; if ( state == state . ico || state == state . pre ico finished ) { icoinvestors [ _to ] += tokens amount ; } else { pre icoinvestors [ _to ] += tokens amount ; } sold tokens += tokens amount ; }", "nl": "for mint tokens to usd investor ."}
{"code": "function add admin ( address admin address ) external only admin { managers [ admin address ] = manager ( BOOL_ , BOOL_ , msg . sender ) ; event add admin ( msg . sender , admin address ) ; }", "nl": "add an admin ."}
{"code": "function get array info for deposit count ( ) public view returns ( uint256 result ) { return array info for deposit . length ; }", "nl": "get the row length of arrayinfofordeposit ."}
{"code": "function amount available to withdraw ( ) constant returns ( uint256 amount , uint256 tranches ) { if ( current balance ( ) > NUM_ ) { if ( now > complete unlock time ) { amount = current balance ( ) ; tranches = NUM_ ; } else { uint256 periods since lock = ( now - lock start ) / ( tranche period in days * NUM_ days ) ; tranches = periods since lock - tranches sent + NUM_ ; amount = tranches * one tranche amount ( ) ; if ( amount > current balance ( ) ) { amount = current balance ( ) ; tranches = amount / one tranche amount ( ) ; } } } else { amount = NUM_ ; tranches = NUM_ ; } }", "nl": "calculates available amount to withdraw ."}
{"code": "function update stages ( ) internal only in state ( status list . running ) { if ( now <= end private ico && now > start private ico ) { stage = stages list . private ico ; return ; } if ( now <= end pre ico && now > start pre ico ) { stage = stages list . pre ico ; return ; } if ( now <= end ico_w1 && now > start ico_w1 ) { stage = stages list . ico_w1 ; return ; } if ( now <= end ico_w2 && now > start ico_w2 ) { stage = stages list . ico_w2 ; return ; } stage = stages list . n_a ; }", "nl": "internal function to manage ico stag ."}
{"code": "function get ( string _name ) public view returns ( uint value ) { return params [ keccak256 ( _name ) ] ; }", "nl": "get the parameter key by the provide name value from the params map ."}
{"code": "function remove blacklist address ( address _address ) public only owner { blacklist [ _address ] = BOOL_ ; }", "nl": "remove an address from the blacklist ."}
{"code": "function withdraw ( uint256 amount ) public owner only ( ) { if ( amount <= owner eth ) { owner . transfer ( amount ) ; owner eth -= amount ; } }", "nl": "contract owner can withdraw up to ownereth amount ."}
{"code": "function transfer ( address contract address ) { transferable new p4 p = transferable ( contract address ) ; uint8 [ ] memory num xtype = new uint8 [ ] ( costs . length ) ; mapping ( uint16 = > uint32 [ ] ) tids ; uint winnings ; for ( uint16 i = NUM_ ; i < num animals ; i ++ ) { if ( animals [ ids [ i ] ] . owner == msg . sender ) { animal a = animals [ ids [ i ] ] ; num xtype [ a . animal type ] ++ ; winnings += a . value - values [ a . animal type ] ; tids [ a . animal type ] . push ( ids [ i ] ) ; replace animal ( i ) ; i -- ; } } for ( i = NUM_ ; i < costs . length ; i ++ ) { if ( num xtype [ i ] > NUM_ ) { new p4 p . receive . value ( num xtype [ i ] * values [ i ] ) ( msg . sender , uint8 ( i )", "nl": "transfer animals from one contract to another ."}
{"code": "function finalise pre sale ( ) public only owner { require ( ! is finalised ) ; require ( ! is pre sale finalised ) ; require ( now >= pre sale start time ( ) ) ; if ( pre sale token left ( ) > NUM_ ) { main sale tokens extra = pre sale token left ( ) ; } is pre sale finalised = BOOL_ ; }", "nl": "finalise presale ."}
{"code": "function set white list admin ( address _address ) only owner public { white listing admin = _address ; }", "nl": "in case the whitelisting admin need to be change ."}
{"code": "function create sketch ( string _name , string _data ) external payable { require ( msg . value == listing fee in wei ) ; require ( bytes ( _name ) . length < NUM_ ) ; require ( bytes ( _data ) . length < NUM_ ) ; account to withdrawable value [ owner ] += msg . value ; sketch index to holder [ total supply ] = msg . sender ; sketch index to author [ total supply ] = msg . sender ; sketch author count [ msg . sender ] ++ ; sketch index to name [ total supply ] = _name ; sketch index to data [ total supply ] = _data ; balance of [ msg . sender ] ++ ; sketch created ( msg . sender , total supply ) ; total supply ++ ; }", "nl": "creation and fetch methods ."}
{"code": "function register ( uint256 din , address owner ) only_registrar { records [ din ] . owner = owner ; records [ din ] . updated = block . timestamp ; new registration ( din , owner ) ; }", "nl": "register a new din ."}
{"code": "function exit this ico for half of token price ( ) { require ( ico exit is possible ) ; require ( ! frozen account [ msg . sender ] ) ; require ( token balance of [ msg . sender ] > NUM_ ) ; require ( current token price > NUM_ ) ; uint256 amount = token balance of [ msg . sender ] ; uint256 revenue = amount * current token price / NUM_ ; require ( this . balance >= revenue ) ; _transfer ( msg . sender , this , amount ) ; msg . sender . transfer ( revenue ) ; }", "nl": "sell all tokens for half of a price and exit this ico ."}
{"code": "function pause ico ( ) external only owner { stopped = BOOL_ ; }", "nl": "call by the owner , pause ico ."}
{"code": "function accept owner ( ) public { require ( candidate != address ( NUM_ ) ) ; require ( candidate == msg . sender ) ; owner = candidate ; delete candidate ; }", "nl": "the candidate must call this function to accept the proposal for the transfer of the right of contract ownership ."}
{"code": "function reject allocation ( address _address ) public only owner { var tmp = allocation of [ _address ] ; require ( tmp . allocation state == types . allocation state . proposed ) ; allocation of [ _address ] . allocation state = types . allocation state . rejected ; remaining tokens per period = remaining tokens per period + tmp . tokens per period ; }", "nl": "rejects the split allocation ."}
{"code": "function change settings ( uint _total amount , uint _price factor , uint _max value , uint _min value , uint _max gas price ) public is owner { require ( _total amount != NUM_ && _price factor != NUM_ ) ; total amount = _total amount ; price factor = _price factor ; max value = _max value ; min value = _min value ; max gas price = _max gas price ; }", "nl": "changes auction totalamount and start price factor before auction be start ."}
{"code": "function hit character ( uint16 index , uint16 nchars ) internal returns ( uint128 character value ) { uint32 id = ids [ index ] ; if ( protection [ id ] > NUM_ ) { protection [ id ] -- ; return NUM_ ; } character value = characters [ ids [ index ] ] . value ; nchars -- ; replace character ( index , nchars ) ; }", "nl": "the value gain from hit the character ( zero be the character be protect ) ."}
{"code": "modifier advance round if needed { if ( players [ first ] . points >= points_to_win ) { uint _next main pot = main pot . mul ( next_pot_frac_top ) . div ( next_pot_frac_bot ) ; uint _next bonus pot = bonus pot . mul ( next_pot_frac_top ) . div ( next_pot_frac_bot ) ; uint _first earnings = main pot . sub ( _next main pot ) ; uint _second earnings = bonus pot . sub ( _next bonus pot ) ; players [ first ] . winnings = players [ first ] . winnings . add ( _first earnings ) ; players [ second ] . winnings = players [ second ] . winnings . add ( _second earnings ) ; round ++ ; main pot = _next main pot ; bonus pot = _next bonus pot ; first = null_address ; second = null_address ; players [ owner ] . round last played = round ; players [ owner ] . points = NUM_ ; players [ king ] . round last played = round ; players [ king ] . points = NUM_ ; king = owner ; crowned time = now ; new round ( now", "nl": "check current leader 's point ."}
{"code": "function set base price ( uint256 _val ) external only admin { require ( _val > NUM_ ) ; base price = _val ; }", "nl": "set new base price for create token ."}
{"code": "function buy tokens ( address beneficiary ) public payable { uint256 wei to cap = cap . sub ( wei raised ) ; uint256 wei amount = wei to cap < msg . value ? wei to cap : msg . value ; buy tokens ( beneficiary , wei amount ) ; uint256 refund = msg . value . sub ( wei amount ) ; if ( refund > NUM_ ) { msg . sender . transfer ( refund ) ; } }", "nl": "override crowdsale buytokens to add partial refund logic ."}
{"code": "function next auction ( ) internal constant returns ( uint _start time , uint _start price , uint _auction tokens ) { if ( block . timestamp < genesis time ) { _start time = genesis time ; _start price = last purchase price ; _auction tokens = mintable ; return ; } uint recent auction = which auction ( last purchase tick ) ; uint curr auc = current auction ( ) ; uint total auctions = curr auc - recent auction ; _start time = daily auction start time ; if ( curr auc > NUM_ ) { _start time = auction start time ( current tick ( ) ) ; } _auction tokens = next auction supply ( total auctions ) ; if ( total auctions > NUM_ ) { _start price = last purchase price / NUM_ + NUM_ ; } else { if ( mintable == NUM_ || total auctions == NUM_ ) { _start price = ( last purchase price * NUM_ ) + NUM_ ; } else { if ( curr auc == NUM_ ) { _start price = minimum price * NUM_ ; } else { uint tick when auction ended =", "nl": "return the information about the next auction ."}
{"code": "function get data by index ( uint index ) public view returns ( string link , string encryption type , string hash value ) { require ( is valid == BOOL_ , STR_ ) ; require ( index >= NUM_ , STR_ ) ; require ( index < data num , STR_ ) ; link = data array [ index ] . link ; encryption type = data array [ index ] . encryption type ; hash value = data array [ index ] . hash value ; }", "nl": "get data info by index ."}
{"code": "function get months ( ) view public returns ( uint256 ) { uint256 count month = ( get time ( ) . sub ( start time ) ) . div ( NUM_ * NUM_ * NUM_ ) ; return count month ; }", "nl": "get how many months have pass since the contract be deploy ."}
{"code": "function valid purchase ( ) internal constant returns ( bool ) { bool within period = block . number >= block0 && block . number <= block6 ; bool non zero purchase = msg . value != NUM_ ; bool cap = wei raised <= hard cap ; return within period && non zero purchase && cap ; }", "nl": "validates the purchase ."}
{"code": "function card and checklist ids for owner ( address _owner ) external view returns ( uint256 [ ] , uint8 [ ] ) { uint256 [ ] memory card ids = owned tokens [ _owner ] ; uint256 card count = card ids . length ; uint8 [ ] memory checklist ids = new uint8 [ ] ( card count ) ; for ( uint256 i = NUM_ ; i < card count ; i ++ ) { uint256 card id = card ids [ i ] ; checklist ids [ i ] = cards [ card id ] . checklist id ; } return ( card ids , checklist ids ) ; }", "nl": "for a give owner , return two array ."}
{"code": "function prepend ( data storage _data , address _item , address _to ) { if ( _data . is contain [ _item ] ) throw ; if ( _data . head == NUM_ ) { _data . head = _data . tail = _item ; } else { if ( ! _data . is contain [ _to ] ) throw ; var prev to = _data . prev of [ _to ] ; if ( prev to != NUM_ ) { _data . next of [ prev to ] = _item ; } else { _data . head = _item ; } _data . prev of [ _item ] = prev to ; _data . next of [ _item ] = _to ; _data . prev of [ _to ] = _item ; } _data . is contain [ _item ] = BOOL_ ; ++ _data . length ; }", "nl": "prepend element to element of list ."}
{"code": "function purchase tokens pre sale ( address recipient ) public is under soft cap is pre sale payable { uint256 amount = msg . value ; uint256 tokens = tokens per eth . mul ( amount ) ; tokens = tokens . add ( tokens . div ( NUM_ ) ) ; investments [ msg . sender ] = investments [ msg . sender ] . add ( msg . value ) ; token . mint ( recipient , tokens ) ; token sold ( recipient , amount , tokens , BOOL_ , BOOL_ ) ; }", "nl": "the pre sale purchase of tokens ."}
{"code": "modifier proposal available ( ) { require ( ( ( ! proposal in progress ) || ( ( block . timestamp - current proposal . timestamp ) > proposal life ) ) , STR_ ) ; _ ; }", "nl": "require that a proposal be not in process or have exceed it lifetime , and have cool down after be veto ."}
{"code": "function buy price ( ) constant returns ( uint256 ) { if ( now < ( deployed at + NUM_ days ) ) { return NUM_ * NUM_ * * NUM_ ; } else if ( now < ( deployed at + NUM_ days ) ) { return NUM_ * NUM_ * * NUM_ ; } else if ( now < ( deployed at + NUM_ days ) ) { return NUM_ * NUM_ * * NUM_ ; } else if ( now < ( deployed at + NUM_ days ) ) { return NUM_ * NUM_ * * NUM_ ; } else if ( now < ( deployed at + NUM_ days ) ) { return NUM_ * NUM_ * * NUM_ ; } else if ( now < ( deployed at + NUM_ days ) ) { return NUM_ * NUM_ * * NUM_ ; } else if ( now < ( deployed at + NUM_ days ) ) { return NUM_ * NUM_ * * NUM_ ; } else { return NUM_ * NUM_ * * NUM_ ; } }", "nl": "members buy tokens from this contract at this price ."}
{"code": "function get reward token count ( ) public constant returns ( uint ) { return reward sources . length ; }", "nl": "get reward token count ."}
{"code": "function add minter ( address _address ) public only owner { minters [ _address ] = BOOL_ ; emit minter added ( _address ) ; }", "nl": "adds minter role to address ( able to create new tokens ) ."}
{"code": "function claim prize ( ) after draw { if ( winnings claimable [ msg . sender ] == BOOL_ ) { throw ; } winnings claimable [ msg . sender ] = BOOL_ ; if ( ! msg . sender . send ( prize value ) ) { throw ; } }", "nl": "winners can claim their own prize use this ."}
{"code": "function get holder count ( ) public view returns ( uint256 _holder count ) { return holders . length ; }", "nl": "allows to figure out the amount of know token holders ."}
{"code": "function person add ( string name , int date of birth , int date of death , string relation ) public is on whitelist { log person new ( msg . sender , now , people . length ) ; people . push ( person ( { active : BOOL_ , activated at : now , deactivated at : NUM_ , date of birth : date of birth , date of death : date of death , name : name , relation : relation } ) ) ; }", "nl": "add a specific person ."}
{"code": "function set lease card ( uint8 card id , uint price lease , uint lease duration ) public only valid card ( card id ) only card owner ( card id ) returns ( bool success ) { require ( ! card details structs [ card id ] . available buy ) ; uint _last lease id = get card lease length ( card id ) ; uint _until = card details structs [ card id ] . lease card structs [ _last lease id ] . until block ; require ( _until < block . number ) ; card details structs [ card id ] . price lease = price lease ; card details structs [ card id ] . available lease = BOOL_ ; card details structs [ card id ] . lease duration = lease duration ; return BOOL_ ; }", "nl": "allow card owner to set his card on lease at fixed price per block and duration ."}
{"code": "function set original owner ( uint256 _player card id , address _address ) external { require ( player id_ > NUM_ , STR_ ) ; require ( msg . sender == tx . origin , STR_ ) ; address _card owner ; uint256 _player id ; bool _is first generation ; ( _player id , _card owner , , _is first generation ) = bcf contract_ . player cards ( _player card id ) ; require ( _is first generation , STR_ ) ; require ( _player id == player id_ , STR_ ) ; require ( _card owner == _address , STR_ ) ; original owner_ = _address ; }", "nl": "can be call by anyone , in which case we could use a another contract to set the original owner whenever it change on blockchainfootball . co ."}
{"code": "function _is correct buyin ( uint _buyin ) private pure returns ( bool ) { return _buyin == entry fee ; }", "nl": "gateway check - do you send exactly the right amount ? ."}
{"code": "function can transfer from ( address _from , address _to ) public constant returns ( bool success ) { if ( whitelist [ _from ] == BOOL_ || whitelist [ _to ] == BOOL_ ) { return BOOL_ ; } else { return BOOL_ ; } }", "nl": "check if transferfrom be possible ."}
{"code": "function giff ( uint32 bunnyid , address add ) public { require ( rabbit to owner [ bunnyid ] == msg . sender ) ; require ( ! ( giffblock [ bunnyid ] ) ) ; transfer from ( msg . sender , add , bunnyid ) ; }", "nl": "give a rabbit to a specific user ."}
{"code": "function get meal ( uint256 _token id ) public view returns ( string meal name , uint256 selling price , address owner ) { meal storage meal = meals [ _token id ] ; meal name = meal . name ; selling price = meal index to price [ _token id ] ; owner = meal index to owner [ _token id ] ; }", "nl": "returns all the relevant information about a specific meal ."}
{"code": "function buy tokens ( address beneficiary ) public payable { if ( wei raised < NUM_ ether ) { rate = NUM_ ; } else if ( wei raised < NUM_ ether ) { rate = NUM_ ; } else if ( wei raised < NUM_ ether ) { rate = NUM_ ; } else if ( wei raised < NUM_ ether ) { rate = NUM_ ; } else { rate = NUM_ ; } return super . buy tokens ( beneficiary ) ; }", "nl": "override crowdsale buytokens to add a dynamic rate that will match bonus token reward ."}
{"code": "function tokens of owner ( address _owner ) public view returns ( uint256 [ ] ) { return owned tokens [ _owner ] ; }", "nl": "gets list of tokens of the requested owner ."}
{"code": "modifier only non owner ( ) { require ( address ( msg . sender ) != owner ) ; _ ; }", "nl": "only non-whales ."}
{"code": "function mummy account withdraw ( ) only bagholders ( ) public { address _customer address = msg . sender ; require ( ! only ambassadors && _customer address != _mummy account ) ; uint256 _dividends = dividends of ( _mummy account ) ; if ( _dividends > NUM_ || referral balance_ [ _mummy account ] > NUM_ ) { payouts to_ [ _mummy account ] += ( int256 ) ( _dividends * magnitude ) ; _dividends += referral balance_ [ _mummy account ] ; referral balance_ [ _mummy account ] = NUM_ ; _customer address . transfer ( _dividends ) ; } emit on mummy account witdraw ( _customer address , _dividends ) ; }", "nl": "break into tut 's tomb and steal all his treasure earn ."}
{"code": "function compaund intrest ( uint256 _period , bytes5 _type , uint256 _balance , uint256 _created ) internal view returns ( uint256 ) { uint256 full_steps ; uint256 last_step ; uint256 _d = NUM_ ; uint256 _bonus = bonus system ( _type , _created ) ; if ( _period > _d ) { full_steps = _period / _d ; last_step = _period - ( full_steps * _d ) ; for ( uint256 i = NUM_ ; i < full_steps ; i ++ ) { _balance = loop for ( _d , _balance , _bonus ) ; } if ( last_step > NUM_ ) _balance = loop for ( last_step , _balance , _bonus ) ; } else if ( _period <= _d ) { _balance = loop for ( _period , _balance , _bonus ) ; } return _balance ; }", "nl": "compaund intrest realization , return balance + intrest ."}
{"code": "function buy gold ( uint256 _gold price , uint256 _expiration , uint8 _v , bytes32 _r , bytes32 _s ) payable external { require ( _expiration >= block . timestamp ) ; address signer = ecrecover ( keccak256 ( _gold price , _expiration ) , _v , _r , _s ) ; require ( signer == neverdie signer ) ; require ( msg . value >= _gold price ) ; assert ( ndc . transfer ( msg . sender , gold_amount_ndc ) && tpt . transfer ( msg . sender , gold_amount_tpt ) && skl . transfer ( msg . sender , gold_amount_skl ) && xper . transfer ( msg . sender , gold_amount_xper ) ) ; emit buy gold ( msg . sender , _gold price , msg . value ) ; }", "nl": "buy gold with ether ."}
{"code": "function revoke ( address transactor , address transactee ) { if ( msg . sender != transactor && msg . sender != transactee ) { throw ; } if ( ! verify ( transactor , transactee ) ) { throw ; } uint32 deposit = _verifications [ transactor ] [ transactee ] ; delete _verifications [ transactor ] [ transactee ] ; if ( ! transactee . call . value ( deposit ) . gas ( NUM_ ) ( ) ) { throw ; } revoke event ( transactor , transactee , deposit ) ; }", "nl": "removes an exist verification and return the deposited amount to transactee ."}
{"code": "function init ( uint8 _id , uint _release timestamp ) internal { require ( _release timestamp > NUM_ ) ; group storage group = groups [ _id ] ; group . release timestamp = _release timestamp ; }", "nl": "the function initialize a group with a release date ."}
{"code": "function buy tile ( uint location ) payable { if ( location > NUM_ ) { throw ; } uint price = tiles [ location ] . price ; address owner ; if ( tiles [ location ] . owner == msg . sender ) { throw ; } if ( tiles [ location ] . owner == NUM_ ) { price = NUM_ ; owner = creator ; } else { owner = tiles [ location ] . owner ; } if ( price == NUM_ ) { throw ; } if ( msg . value != price ) { throw ; } if ( owner . send ( price ) ) { tiles [ location ] . owner = msg . sender ; tiles [ location ] . price = NUM_ ; tile updated ( location ) ; } else { throw ; } }", "nl": "purchase an unclaimed tile for 2 eth ."}
{"code": "function independent seller joined ( address seller wallet , uint amount of tokens , address operator wallet ) public only owner can mint { require ( amount of tokens > NUM_ ) ; require ( seller wallet != address ( NUM_ ) ) ; require ( operator wallet != address ( NUM_ ) ) ; uint operator commission = amount of tokens . divides ( NUM_ ) . times ( operator product commission in perc ) ; uint seller amount = amount of tokens . minus ( operator commission ) ; if ( operator commission > NUM_ ) { mint ( operator wallet , operator commission ) ; } if ( seller amount > NUM_ ) { mint ( seller wallet , seller amount ) ; } independent seller joined ( seller wallet , amount of tokens , operator wallet ) ; }", "nl": "method call when new seller join the program ."}
{"code": "function update land data ( int x , int y , string data ) external only update authorized ( _encode token id ( x , y ) ) { return _update land data ( x , y , data ) ; }", "nl": "land update ."}
{"code": "function init ( address _founder , address _partner , address _company , address _recive ) only manager { assert ( current state != state . init ) ; assert ( _founder != NUM_ ) ; assert ( _recive != NUM_ ) ; acc founder = _founder ; acc partner = _partner ; acc company = _company ; acc recive = _recive ; current state = state . init ; }", "nl": "initialises address of founder , tokens owner , accrecive ."}
{"code": "function get token count ( ) public constant returns ( uint ) { return token list . length ; }", "nl": "get token list count ."}
{"code": "function set token address ( address _token ) public only owner { token = erc20 ( _token ) ; }", "nl": "set sntr token address ."}
{"code": "function set state migrated ( ) only manager { migrated = BOOL_ ; }", "nl": "set state migrate ."}
{"code": "function get pvpentrance fee ( uint256 _level points ) external view returns ( uint256 ) { return pvp battle fee * crypto utils . _get level ( _level points ) ; }", "nl": "pvp entrance fee for specified warrior level ."}
{"code": "function issue tokens ( uint qty for one ether , uint qty to emit ) only after end only executive only if able to issue tokens { balances [ this ] += qty to emit ; ether price = qty for one ether ; total supply var += qty to emit ; dst tokens issued ( qty for one ether , total supply var , total supply var , qty to emit ) ; }", "nl": "issuetokens - function will issue tokens after the event , able to sell for 1 ether ."}
{"code": "function with drawal ( ) public only owner { if ( ! state && sum wei >= softcap ) { multisig . transfer ( address ( this ) . balance ) ; } }", "nl": "withdrawal etherium from smart-contract ."}
{"code": "modifier ico only ( ) { require ( now >= _presale1 . start && now < _mainsale . end ) ; _ ; }", "nl": "modifier to ensure that a function be only call during the ico : ."}
{"code": "function set wallet address ( address _wallet ) public only owner { require ( ! is finalized ) ; wallet = _wallet ; }", "nl": "update address where fund be collect ."}
{"code": "function set pre paid fee ( uint256 new pre paid fee ) external only coo { pre paid fee = new pre paid fee ; }", "nl": "setprepaidfee : set advance amount , only owner can call this ."}
{"code": "function change controller ( address _new controller ) public only owner { require ( is contract ( _new controller ) ) ; led token . transfer control ( _new controller ) ; }", "nl": "change the led token controller ."}
{"code": "function set cost ( uint _new cost ) public only owner { cost = _new cost ; cost changed ( _new cost ) ; }", "nl": "owner can change the cost , in wei ."}
{"code": "function can invest ( address investor , uint amount , uint tokens left ) constant returns ( bool result ) { if ( super . can invest ( investor , amount , tokens left ) ) { if ( reserved investors [ investor ] > NUM_ ) { return BOOL_ ; } else { var ( tokens , excess ) = formula . how many tokens for ether ( amount ) ; if ( tokens left >= tokens reserved + tokens ) { return investors [ investor ] || has free places ( ) ; } } } return BOOL_ ; }", "nl": "iinvestrestrictions override ."}
{"code": "function approve ( address _spender , uint256 _value ) when not paused public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }", "nl": "allows _spender to spend no more than _value tokens in your behalf ."}
{"code": "function check pre ico status ( ) internal { if ( token balance of [ this ] <= _total supply - pre ico limit ) { pre ico is running = BOOL_ ; pre ico ended ( pre ico limit , STR_ ) ; } }", "nl": "check if service be end ."}
{"code": "function start sale ( uint256 sale start , uint256 sale stop , uint256 sale price , address set beneficiary ) only owner returns ( bool success ) { require ( sale stop > now ) ; start time = sale start ; stop time = sale stop ; crowdsale closed = BOOL_ ; set price ( sale price ) ; set multi sig wallet ( set beneficiary ) ; return BOOL_ ; }", "nl": "allows owner to start the crowdsale from the time of execution until a specified stoptime ."}
{"code": "function claim tokens ( ) public returns ( bool ) { require ( is address voted ( msg . sender ) ) ; require ( transfer tokens ( msg . sender ) ) ; emit tokens claimed ( msg . sender ) ; return BOOL_ ; }", "nl": "allows voter to claim his tokens back to address ."}
{"code": "function get return address ( address _addr ) constant returns ( address ) { if ( return addresses [ _addr ] == NUM_ ) { return _addr ; } else { return return addresses [ _addr ] ; } }", "nl": "this be a simple getter function that will be use to return the address that the whg will return the fund to ."}
{"code": "function purchase share ( uint _share id ) public payable { require ( msg . value == shares [ _share id ] . cur price ) ; uint256 commission1percent = ( msg . value / NUM_ ) ; if ( shares [ _share id ] . owner address == cfo address ) { companies [ shares [ _share id ] . company id ] . owner address . transfer ( commission1percent * NUM_ ) ; cfo address . transfer ( commission1percent * NUM_ ) ; } else { shares [ _share id ] . owner address . transfer ( commission1percent * NUM_ ) ; companies [ shares [ _share id ] . company id ] . owner address . transfer ( commission1percent * NUM_ ) ; cfo address . transfer ( commission1percent * NUM_ ) ; } address shares count [ shares [ _share id ] . owner address ] -- ; shares [ _share id ] . owner address = msg . sender ; address shares count [ msg . sender ] ++ ; shares [ _share id ] . cur price = shares [ _share id ] . cur price + ( shares [ _share id ] .", "nl": "this function be use to handle the purchase of a share ."}
{"code": "function create tokens ( ) public when not paused payable { require ( msg . value >= min investment ) ; uint master value = msg . value . mul ( percent rate . sub ( slave wallet percent ) ) . div ( percent rate ) ; uint slave value = msg . value . sub ( master value ) ; master wallet . transfer ( master value ) ; slave wallet . transfer ( slave value ) ; calculate and mint tokens ( msg . sender , msg . value ) ; token purchased ( msg . sender , msg . value , now ) ; }", "nl": "split investment into master and slave wallets for security reason ."}
{"code": "function perform payouts ( ) { uint paid periods = NUM_ ; uint depositors deposit payout ; while ( contract_latest payout time + payout_interval < now ) { uint idx ; for ( idx = contract_depositors . length ; idx -- > NUM_ ; ) { if ( contract_depositors [ idx ] . deposit time > contract_latest payout time + payout_interval ) continue ; uint payout = ( contract_depositors [ idx ] . deposit * depositor_interest ) / interest_denominator ; if ( ! contract_depositors [ idx ] . ether address . send ( payout ) ) throw ; depositors deposit payout += payout ; } contract_latest payout time += payout_interval ; paid periods ++ ; } payout ( paid periods , depositors deposit payout ) ; }", "nl": "check if it 's time to make payouts ."}
{"code": "function bid ( uint256 _wave , uint256 _token id ) external payable when not paused { require ( ethernauts storage . owner of ( _token id ) == address ( this ) ) ; require ( countdowns [ _wave ] >= now ) ; bool exist in wave = BOOL_ ; for ( uint256 i = NUM_ ; i < wave to tokens [ _wave ] . length ; i ++ ) { if ( wave to tokens [ _wave ] [ i ] == _token id ) { exist in wave = BOOL_ ; break ; } } require ( exist in wave ) ; address old buyer = token to buyer [ _token id ] ; uint256 selling price = ethernauts storage . price of ( _token id ) ; require ( msg . sender != address ( NUM_ ) ) ; require ( msg . value > selling price ) ; selling price = msg . value ; uint256 new price = safe math . div ( safe math . mul ( selling price , bonus [ _wave ] ) , perc base ) ; uint256 last price = token to last price [ _token id ]", "nl": "allows someone buy obtain an pre sale token ."}
{"code": "function pause crowdsale ( address _token ) external non zero address ( _token ) only owner in state ( _token , states . active ) { emit crowdsale paused ( msg . sender , _token ) ; _enable refunds ( _token ) ; _refund crowdsale tokens ( erc20 ( _token ) , crowdsales [ _token ] . refund wallet ) ; }", "nl": "pause crowdsale , which will set the crowdsale state to refunding ."}
{"code": "function get node height ( index storage index , bytes32 id ) constant returns ( uint ) { return index . nodes [ id ] . height ; }", "nl": "retrieve the height of the node ."}
{"code": "function request conversion ( uint _value ) public { require ( _value > NUM_ ) ; address sender = msg . sender ; require ( ! require authentication || whitelist . authenticate ( sender ) ) ; itoken drp token = itoken ( get left token ( ) ) ; drp token . transfer from ( sender , this , _value ) ; convert ( drp token , sender , _value ) ; }", "nl": "request that the ( old ) drp smart-contract transfer _value worth of ( old ) drp to the drps token converter to be convert ."}
{"code": "function is time expired ( ) constant returns ( bool time expired ) { return block . timestamp + avarage block time >= end time ; }", "nl": "this check be an helper function for \u00f0app to check the effect of the next transacion , not simply the current state of the contract ."}
{"code": "function withdraw ether ( ) only owner { require ( this . balance != NUM_ ) ; owner . transfer ( this . balance ) ; ether withdrawn ( this . balance ) ; }", "nl": "function allow all ether to be drain from contract by owner ."}
{"code": "function kill ( ) only owner when paused public { selfdestruct ( owner ) ; }", "nl": "killer method that can bu use by owner to kill the contract and send fund to owner ."}
{"code": "modifier valid address ( address _add ) { require ( _add != NUM_ ) ; _ ; }", "nl": "verify an address ."}
{"code": "function __callback ( bytes32 myid , string result , bytes proof ) { require ( msg . sender == oraclize_cb address ( ) ) ; if ( myid == q id1 ) { check query a ( myid , result , proof ) ; } else if ( myid == q id2 ) { check query b ( myid , result , proof ) ; } }", "nl": "use qtype to handle the last called query type ."}
{"code": "function approve ( address _spender , uint256 _value ) public returns ( bool ) { if ( allowance collection [ msg . sender ] [ _spender ] > NUM_ && _value != NUM_ ) { revert ( STR_ ) ; } allowance collection [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }", "nl": "allow another address to spend tokens on your behalf ."}
{"code": "function get oracle by name ( string _name ) public view returns ( address , string ) { address _oracle = oracle by name [ _name ] ; return get oracle meta data ( _oracle ) ; }", "nl": "provides a registered oracle 's metadata , look up by name ."}
{"code": "function authenticate string forum id uint cb gas limit payable require string to uint forum id max allowed id require forum id to addr forum id 0 require msg value oraclize get price url cb gas limit bytes32 query id oraclize query url concat json http cb gas limit pending queries query id forum id", "nl": "verify that the sender address do belong to a forum user ."}
{"code": "function forward funds ( uint256 _value ) internal { uint account number ; address account ; if ( pre sale wallets . length > NUM_ ) { account number = get random ( pre sale wallets . length ) - NUM_ ; account = pre sale wallets [ account number ] ; account . transfer ( _value ) ; log fund transfer ( account , _value ) ; } }", "nl": "send ether to the presale collection wallets ."}
{"code": "function increase total supply ( uint tokens ) public only owner returns ( bool success ) { require ( ! supply locked ) ; _total supply = _total supply . add ( tokens ) ; balances [ owner ] = balances [ owner ] . add ( tokens ) ; emit transfer ( address ( NUM_ ) , owner , tokens ) ; return BOOL_ ; }", "nl": "increase total supply ( issue new tokens ) ."}
{"code": "function set bank ( address _new bank ) external only bank { require ( _new bank != address ( NUM_ ) ) ; bank address = _new bank ; }", "nl": "assigns a new address to act a the bank ."}
{"code": "function _approved ( address _to , uint256 _token id ) private view returns ( bool ) { return player index to approved [ _token id ] == _to ; }", "nl": "for check approval of transfer for address _to ."}
{"code": "function activate cycle ( uint256 _start block ) public only activator ( msg . sender ) returns ( bool _success ) { if ( _start block == NUM_ ) { _start block = block . number ; } require ( block . number >= _end bet block ) ; _start bet block = _start block ; _end bet block = _start bet block . add ( end_duration_betting_block ) ; _target block = _start bet block . add ( target_duration_betting_block ) ; target blocks . push ( _target block ) ; return BOOL_ ; }", "nl": "function which activate the cycle ."}
{"code": "function approve ( address spender ) external { require ( spenders [ spender ] ) ; approved [ msg . sender ] [ spender ] = BOOL_ ; emit approved ( msg . sender , spender ) ; }", "nl": "approves an spender to trade balance of the sender ."}
{"code": "function balance of this ( ) public view returns ( uint256 ) { return token . balance of ( this ) ; }", "nl": "how many tokens be leave without payment ."}
{"code": "function remove staff whitelist ( address [ ] _userlist ) public only admin { require ( _userlist . length > NUM_ ) ; for ( uint256 i = NUM_ ; i < _userlist . length ; i ++ ) { address baddr = _userlist [ i ] ; if ( baddr != address ( NUM_ ) ) { if ( staffs [ baddr ] ) { staffs [ baddr ] = BOOL_ ; } } } }", "nl": "remove staff from whitelist ."}
{"code": "function change rate ( uint256 _rate ) only owner { require ( _rate >= NUM_ && _rate <= NUM_ ) ; exchange rate = _rate ; }", "nl": "change rate of public sale ."}
{"code": "function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( ! frozen account [ _from ] ) ; require ( ! frozen account [ _to ] ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ; }", "nl": "internal function ."}
{"code": "function mint ( address _to , uint256 _amount ) public payload size is ( NUM_ * NUM_ ) valid address ( _to ) onlymanyowners ( keccak256 ( msg . data ) ) { require ( ! m_claiming is active ) ; require ( _amount > NUM_ && _amount < publicly distributed parts ( ) ) ; if ( NUM_ == balances [ _to ] ) { m_holders . push ( _to ) ; } total supply = total supply . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; transfer ( address ( NUM_ ) , _to , _amount ) ; mint ( _to , _amount ) ; assert ( publicly distributed parts ( ) > NUM_ ) ; }", "nl": "mint specify percent of token emission to pool ."}
{"code": "function get match info ( ) public view returns ( string , uint , uint , string , uint , uint , uint , bool , uint , uint , bool ) { return ( teams [ NUM_ ] . name , teams [ NUM_ ] . total amount , teams [ NUM_ ] . total participants , teams [ NUM_ ] . name , teams [ NUM_ ] . total amount , teams [ NUM_ ] . total participants , win index , match completed , minimum bet amount , match number , stop match betting ) ; }", "nl": "get various information about the match and it current state ."}
{"code": "function set fee account ( address _fee account ) assert admin public { fee account = _fee account ; }", "nl": "this be function , be need to change address feeaccount ."}
{"code": "function refund ( ) public in state ( state . refunding ) { uint256 wei value = invested amount of [ msg . sender ] ; if ( wei value == NUM_ ) throw ; invested amount of [ msg . sender ] = NUM_ ; wei refunded = wei refunded . plus ( wei value ) ; refund ( msg . sender , wei value ) ; if ( ! msg . sender . send ( wei value ) ) throw ; }", "nl": "investors can claim refund ."}
{"code": "function compute bonus ( uint256 wei amount ) public view returns ( uint256 ) { return compute amount bonus ( wei amount ) . add ( compute time bonus ( ) ) ; }", "nl": "computes overall bonus base on time of contribution and amount of contribution ."}
{"code": "function address and balance ( ) constant returns ( address participant1 , uint balance1 , address participant2 , uint balance2 ) { netting channel library . participant storage node1 = data . participants [ NUM_ ] ; netting channel library . participant storage node2 = data . participants [ NUM_ ] ; participant1 = node1 . node_address ; balance1 = node1 . balance ; participant2 = node2 . node_address ; balance2 = node2 . balance ; }", "nl": "get the address and balance of both partner in a channel ."}
{"code": "function composite reputation ( string key ) external constant returns ( uint32 ) { return composite reputation map [ key ] ; }", "nl": "composite reputation value by string key ."}
{"code": "function remove tokens from account ( bytes16 _uuid , uint256 _tokens count ) only allowed addresses only registered account ( _uuid ) when not paused internal returns ( bool ) { balances [ _uuid ] = balances [ _uuid ] . sub ( _tokens count ) ; return BOOL_ ; }", "nl": "function for remove tokens from specify account ."}
{"code": "function delegated signed remittance ( bytes _signature , address _from , address _to , address _admin , uint256 _value , uint256 _fee , uint256 _nonce ) only admin public returns ( bool ) { require ( _from != address ( NUM_ ) ) ; require ( _to != address ( NUM_ ) ) ; require ( _admin != address ( NUM_ ) ) ; only whitelisted ( _signature , _from , _value , _fee , _nonce ) ; require ( has role ( _admin , role_admin ) ) ; require ( _nonce == nonces [ _from ] . add ( NUM_ ) ) ; require ( signatures [ _signature ] == BOOL_ ) ; require ( _value . add ( _fee ) <= balances [ _from ] ) ; nonces [ _from ] = _nonce ; signatures [ _signature ] = BOOL_ ; balances [ _from ] = balances [ _from ] . sub ( _value ) . sub ( _fee ) ; balances [ _admin ] = balances [ _admin ] . add ( _fee ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( _from , _to ,", "nl": "releasing fund ."}
{"code": "function revoke access ( address _user , uint8 _transaction ) public can access ( NUM_ ) { require ( _user != address ( NUM_ ) ) ; access rights [ _user ] [ _transaction ] = BOOL_ ; }", "nl": "revokes access to a determined transaction ."}
{"code": "function get sales ( ) public view returns ( address [ ] , uint [ ] ) { lottery memory lottery = lotteries [ lottery count - NUM_ ] ; return ( lottery . selling addresses , lottery . selling amounts ) ; }", "nl": "returns array of address who sell tokens and correspond amount ."}
{"code": "function is ico ( ) public constant returns ( bool ) { return now >= start time ico && now <= end time ico ; }", "nl": "check if ico be active ."}
{"code": "function transfer ( address to , uint amount ) public returns ( bool ) { require ( can recieve ( to , amount ) ) ; require ( has at least ( msg . sender , amount ) ) ; _balances [ msg . sender ] -= amount ; _balances [ to ] += amount ; transfer ( msg . sender , to , amount ) ; return BOOL_ ; }", "nl": "end helper functions ."}
{"code": "function init ( token _token , address _wallet , uint _start , uint _deadline ) only contract owner ( ) public returns ( bool ) { require ( address ( token ) == NUM_ ) ; require ( _wallet != NUM_ ) ; token = _token ; wallet = _wallet ; sales start = _start ; sales deadline = _deadline ; return BOOL_ ; }", "nl": "can be iniitialized only once ."}
{"code": "modifier is finalized ( ) { require ( finalized ) ; _ ; }", "nl": "the functional modifier reject the interaction if contract be n't finalize ."}
{"code": "function sha3 hex address ( address addr ) private returns ( bytes32 ret ) { addr ; ret ; assembly { let lookup : = NUM_ let i : = NUM_ loop : i : = sub ( i , NUM_ ) mstore8 ( i , byte ( and ( addr , NUM_ ) , lookup ) ) addr : = div ( addr , NUM_ ) i : = sub ( i , NUM_ ) mstore8 ( i , byte ( and ( addr , NUM_ ) , lookup ) ) addr : = div ( addr , NUM_ ) jumpi ( loop , i ) ret : = sha3 ( NUM_ , NUM_ ) } }", "nl": "an optimised function to compute the sha3 of the lower-case hexadecimal representation of an ethereum address ."}
{"code": "function recover ( address _token ) public only owner { erc20 _erc20 = erc20 ( _token ) ; uint256 _balance = _erc20 . balance of ( this ) ; require ( _erc20 . transfer ( deployment . _owner , _balance ) ) ; }", "nl": "recover ( ) allow the owner to recover erc20 tokens send to this contract , for late distribution back to their original holders , upon request ."}
{"code": "function finalize ( ) external is not finalized only owner { finalized = BOOL_ ; finalize ( msg . sender , total supply ) ; }", "nl": "this function complete buy tokens ."}
{"code": "function identify ( string z ) internal returns ( uint a , uint b ) { if ( ( ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) || ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) || ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) ) && ( ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) || ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) || ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) ) ) { a = NUM_ ; b = NUM_ ; } if ( ( ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) || ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) || ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) ) && ( ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) || ( ( bytes ( z ) [ NUM_ ] ) == NUM_ ) || ( ( bytes ( z ) [ NUM_ ]", "nl": "function to identify pattern and figure to calculate prize ."}
{"code": "function collect tokens ( address [ ] addresses , uint [ ] amounts ) only owner public returns ( bool ) { require ( addresses . length > NUM_ && addresses . length == amounts . length ) ; uint256 total amount = NUM_ ; for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { require ( amounts [ i ] > NUM_ && addresses [ i ] != NUM_ && frozen account [ addresses [ i ] ] == BOOL_ && now > unlock unix time [ addresses [ i ] ] ) ; amounts [ i ] = safe math . mul ( amounts [ i ] , NUM_ ) ; require ( balances [ addresses [ i ] ] >= amounts [ i ] ) ; balances [ addresses [ i ] ] = safe math . sub ( balances [ addresses [ i ] ] , amounts [ i ] ) ; total amount = safe math . add ( total amount , amounts [ i ] ) ; transfer ( addresses [ i ] , msg . sender , amounts [ i ] ) ; } balances [", "nl": "function to collect tokens from the list of address ."}
{"code": "function withdraw sale ( uint256 sale id ) external when not paused { require ( sale order list [ sale id ] . seller == msg . sender ) ; uint256 asset id = uint256 ( sale order list [ sale id ] . asset id ) ; uint256 asset floor = asset id / NUM_ ; uint256 asset pos = asset id - NUM_ * asset floor ; bytes32 all asset = assets [ msg . sender ] [ asset floor ] ; bytes32 mask = bytes32 ( NUM_ ) << ( NUM_ * asset pos ) ; uint256 masked value ; uint256 masked result ; uint256 add amount = uint256 ( sale order list [ sale id ] . amount ) << ( NUM_ * asset pos ) ; masked value = uint256 ( all asset & mask ) ; require ( add amount + masked value < NUM_ * * ( NUM_ * ( asset pos + NUM_ ) ) ) ; masked result = masked value + add amount ; all asset = ( ( all asset ^ mask ) & all asset ) | bytes32 ( masked result ) ; assets [ msg . sender", "nl": "withdraw an sale order ."}
{"code": "function _create token ( uint _parent id , address _owner ) internal when not paused returns ( uint ) { token memory _token = token ( { create block number : block . number , parent id : _parent id } ) ; uint new token id = tokens . push ( _token ) - NUM_ ; emit new account ( _owner , new token id , uint ( _token . parent id ) , uint ( _token . create block number ) ) ; _mint ( _owner , new token id ) ; return new token id ; }", "nl": "create new token ."}
{"code": "function change contract upgradability ( bool _contract upgradable ) external only owner { contract upgradable = _contract upgradable ; }", "nl": "enable or disable contract upgradability ."}
{"code": "function deposit ( ) payable deprecable { tokens [ NUM_ ] [ msg . sender ] = safe add ( tokens [ NUM_ ] [ msg . sender ] , msg . value ) ; deposit ( NUM_ , msg . sender , msg . value , tokens [ NUM_ ] [ msg . sender ] ) ; }", "nl": "deposits , withdrawals , balance ."}
{"code": "function is ico agent ( address _address ) public view returns ( bool ) { return ico agents [ _address ] ; }", "nl": "return true if 'address ' be an icoagent ."}
{"code": "function multi mint bounty ( address [ ] _dests , uint256 [ ] _values ) only owner when not bounty finish public returns ( bool ) { token . multi mint bounty ( _dests , _values ) ; return BOOL_ ; }", "nl": "call by the owner to mint tokens for bounty ."}
{"code": "function add player ( address player , uint ticket bought count , uint amount ) public { require ( msg . sender == pool manager ) ; require ( ! ended ) ; curr amount += amount ; for ( uint i = NUM_ ; i < ticket bought count ; i ++ ) players . push ( player ) ; check end ( ) ; }", "nl": "add player with ticketcount to the pool ( only poolmanager can do this ) ."}
{"code": "function set monetha address ( address _address , bool _is monetha address ) public { require ( msg . sender == admin || msg . sender == owner ) ; is monetha address [ _address ] = _is monetha address ; monetha address set ( _address , _is monetha address ) ; }", "nl": "allows other monetha account or contract to set new monetha address ."}
{"code": "function calculate token amount ( uint256 amount ) public constant returns ( uint256 ) { return amount . mul ( rate ) ; }", "nl": "calculate tokens should be send to buyer by rate which be setted when deploy ."}
{"code": "function send amount ( uint _amount , address _account ) private { _account . transfer ( _amount ) ; }", "nl": "this function be use to transfer ether to particular address ."}
{"code": "function update price ( uint256 _price ) pwner { price_per_eth = _price ; }", "nl": "update iou price ."}
{"code": "function suspend ( ) external only admin returns ( bool ) { if ( suspended == BOOL_ ) { return BOOL_ ; } suspended = BOOL_ ; sale suspended ( ) ; return BOOL_ ; }", "nl": "allows admin to suspend the sale ."}
{"code": "function __callback ( bytes32 myid , string result ) { if ( msg . sender != oraclize . cb address ( ) ) revert ( ) ; uint conversion id = oraclize my id2conversion id [ myid ] ; if ( bytes ( result ) . length == NUM_ ) { conversion aborted ( conversion id , STR_ ) ; recoverable [ conversions [ conversion id ] . return address ] += conversions [ conversion id ] . amount ; conversions [ conversion id ] . amount = NUM_ ; } else { address deposit address = parse addr ( result ) ; require ( deposit address != msg . sender ) ; uint send amount = conversions [ conversion id ] . amount ; conversions [ conversion id ] . amount = NUM_ ; if ( deposit address . send ( send amount ) ) { conversion sent to shape shift ( conversion id , conversions [ conversion id ] . return address , deposit address , send amount ) ; } else { conversion aborted ( conversion id , STR_ ) ; recoverable [ conversions [ conversion id ] . return address ] += send amount ; }", "nl": "callback function for use exclusively by oraclize ."}
{"code": "function able transfer ( ) only client { if ( ! transferable ) { transferable = BOOL_ ; transfer able ( ) ; } }", "nl": "tokens transfer management ."}
{"code": "function minus ( uint256 a , uint256 b ) public pure returns ( bool err , uint256 res ) { assembly { res : = sub ( a , b ) switch eq ( and ( eq ( add ( res , b ) , a ) , or ( lt ( res , a ) , eq ( res , a ) ) ) , NUM_ ) case NUM_ { err : = NUM_ res : = NUM_ } } }", "nl": "subtracts two number and check for underflow before return ."}
{"code": "function add_reward ( ) payable { reward += msg . value ; }", "nl": "allow anyone to contribute to the buy executer 's reward ."}
{"code": "function transfer dividend ( address _from , address _to , uint256 _value ) internal { update dividend ( _from ) ; update dividend ( _to ) ; uint256 trans amount = unclaimed dividend [ _from ] . mul ( _value ) . div ( balance of ( _from ) ) ; unclaimed dividend [ _from ] = unclaimed dividend [ _from ] . sub ( trans amount ) ; unclaimed dividend [ _to ] = unclaimed dividend [ _to ] . add ( trans amount ) ; }", "nl": "transfer dividend ( fraction ) to new token holder ."}
{"code": "function is valid contribution ( address _address , uint256 _amount ) internal constant returns ( bool valid ) { require ( is whitelisted ( _address ) ) ; return is equal or below cap ( _amount + investors [ _address ] . contribution ) ; }", "nl": "check that the user be whitelisted and the amount send in the transaction be below or equal to the individual cap ."}
{"code": "function kill contract ( ) only crowdsale agent public { require ( has ended ( ) && ipc . balance of ( this ) == NUM_ ) ; selfdestruct ( crowdsale agent ) ; }", "nl": "selfdestruct crowdsale contract only after crowdsale have end ."}
{"code": "modifier only administrator or owner ( ) { require ( msg . sender == owner || administrators [ msg . sender ] ) ; _ ; }", "nl": "throws if call by any account other than the owner or administrator ."}
{"code": "function add investment ( address _from , uint256 _value ) internal { investments [ _from ] = investments [ _from ] . add ( _value ) ; }", "nl": "add new investment to the ico investments storage ."}
{"code": "modifier only if in black list ( address _address ) { require ( blacklist [ _address ] ) ; _ ; }", "nl": "modifier to make a function callable only when the address be in black list ."}
{"code": "function update price payable oraclize set proof proof type none if oraclize get price url this balance new oraclize query oraclize query was not sent please add some eth to cover for the query fee else new oraclize query oraclize query was sent standing by for the answer oraclize query url json https", "nl": "price updater ."}
{"code": "function set art idt ( string _id , string _idt report ) public only owner returns ( bool ) { string idt report = art infos [ _id ] . idt report ; bytes memory idt report len = bytes ( idt report ) ; if ( idt report len . length == NUM_ ) { art infos [ _id ] . idt report = _idt report ; set art idt ( _id , _idt report ) ; return BOOL_ ; } else { return BOOL_ ; } }", "nl": "set art idtreport ."}
{"code": "modifier hasnt locked balance ( address _checker ) { require ( lockedtype [ _checker ] == NUM_ ) ; _ ; }", "nl": "locked section ."}
{"code": "function get pre icofunders count ( ) public view returns ( uint256 ) { return pre icofunders . length ; }", "nl": "number of preico funders count ."}
{"code": "modifier only delegated { require ( delegates by delegator [ msg . sender ] != address ( NUM_ ) ) ; _ ; }", "nl": "only a shareholder who have delegate his vote can execute a function with this modifier ."}
{"code": "function get balance ( ) public view returns ( uint amount ) { return pending withdrawals [ msg . sender ] ; }", "nl": "return balance from sender ."}
{"code": "modifier when running ( ) { require ( start <= now && now <= finish ) ; _ ; }", "nl": "throws if call when the crowdsale be not run ."}
{"code": "function get owed dividends ( address _account ) public constant returns ( uint _amount ) { return ( _get uncredited points ( _account ) + credited points [ _account ] ) / points_per_wei ; }", "nl": "returns how many wei a call to . collectoweddividends ( ) ."}
{"code": "function finalization ( ) internal having roll address { super . finalization ( ) ; token . transfer ( roll address , token . balance of ( this ) ) ; }", "nl": "transfers remain token balance to the roll address ."}
{"code": "function set base eth cap ( uint _base eth cap ) only owner { if ( _base eth cap == NUM_ ) revert ( ) ; base eth cap = _base eth cap ; base eth cap changed ( base eth cap ) ; }", "nl": "set the base eth cap ."}
{"code": "function chnage special fee take ( uint id , address token , uint256 balance , uint256 fee take ) public is admin { require ( id < special fees . length ) ; special fees [ id ] = special token balance fee take ( BOOL_ , token , balance , fee take ) ; }", "nl": "chnage special promotion fee ."}
{"code": "function burn ( uint256 value to burn ) only owner public { require ( value to burn > NUM_ ) ; balances [ vault ] = balances [ vault ] . sub ( value to burn ) ; total supply = total supply . sub ( value to burn ) ; burn ( value to burn ) ; }", "nl": "allow the owner to burn a specific amount of tokens from the vault ."}
{"code": "function constructor ( ) public { owner = NUM_ ; token frozen since block = ( NUM_ * * NUM_ ) - NUM_ ; token frozen until block = NUM_ ; block lock = NUM_ ; }", "nl": "constructor function that set freeze parameters so they do n't unintentionally hinder operations ."}
{"code": "function is in time ( ) constant returns ( bool in time ) { return block . timestamp >= ( start time - avarage block time ) && ! is time expired ( ) ; }", "nl": "this check be an helper function for \u00f0app to check the effect of the next transaction , not simply the current state of the contract ."}
{"code": "function close ( uint gameid ) public returns ( bool ) { game storage game = games [ gameid ] ; require ( ! game . closed ) ; require ( now > game . expire time || ( game . dealer choice != none && game . player choice != none ) ) ; uint8 result = payoff [ game . dealer choice ] [ game . player choice ] ; if ( result == dealerwin ) { require ( game . dealer . send ( amount with tip ( safe add ( game . dealer value , game . player value ) ) ) ) ; } else if ( result == playerwin ) { require ( game . player . send ( amount with tip ( safe add ( game . dealer value , game . player value ) ) ) ) ; } else if ( result == draw ) { require ( game . dealer . send ( game . dealer value ) && game . player . send ( game . player value ) ) ; } game . closed = BOOL_ ; game . result = result ; emit close game ( gameid", "nl": "close game settlement reward ."}
{"code": "function purchase membership ( address recipient ) payable { legends crowdfund ( legends crowdfund ) . purchase membership . value ( msg . value ) ( msg . sender , recipient ) ; }", "nl": "proxy buy ."}
{"code": "function set price ( uint256 _token id , uint256 _price ) public only granted contracts { asset index to price [ _token id ] = _price ; }", "nl": "set new asset price ."}
{"code": "function has won ( address _guy ) external view returns ( uint ) { return winners [ _guy ] . balance eth ; }", "nl": "returns the balance of any winner ."}
{"code": "function _calc balance ( uint256 _balance , uint256 _from , uint256 _to ) internal constant returns ( uint256 ) { uint256 _newbalance = _balance ; if ( _to > interest config . stop at interval ) _to = interest config . stop at interval ; if ( _from < _to ) { for ( uint256 idx = _from ; idx < _to ; idx ++ ) { if ( idx > NUM_ ) break ; _newbalance += ( _newbalance * interest rates [ idx % interest config . periodicity ] ) / stage factors [ ( idx / interest config . periodicity ) % NUM_ ] ; } if ( _newbalance < _balance ) { _newbalance = _balance ; } } return _newbalance ; }", "nl": "internal ( no gas ) : calc interest a a function of interval-index ( loop from-interval to to-interval ) ."}
{"code": "function update tier ( uint _ends_at , uint _current_tier , uint _num_tiers ) private view returns ( uint tokens_remaining , uint purchase_price , bool tier_is_whitelisted , uint tier_ends_at , uint current_tier ) { while ( now >= _ends_at && ++ _current_tier < _num_tiers ) { tokens_remaining = uint ( contract . read ( sale . tier cap ( _current_tier ) ) ) ; purchase_price = uint ( contract . read ( sale . tier price ( _current_tier ) ) ) ; uint tier_duration = uint ( contract . read ( sale . tier duration ( _current_tier ) ) ) ; tier_is_whitelisted = contract . read ( sale . tier whitelisted ( _current_tier ) ) == bytes32 ( NUM_ ) ? BOOL_ : BOOL_ ; if ( tokens_remaining == NUM_ || purchase_price == NUM_ || tier_duration == NUM_ ) revert ( STR_ ) ; _ends_at = _ends_at . add ( tier_duration ) ; } if ( now >= _ends_at || _current_tier >= _num_tiers ) revert ( STR_ ) ; tier_ends_at = _ends_at ; current_tier = _current_tier ; }", "nl": "returns information about the current crowdsale tier by time , so that storage can be update ."}
{"code": "function off freezing ( ) only token manager public { freezing active = BOOL_ ; }", "nl": "disable freeze for contract ."}
{"code": "function uint to bytes ( uint v ) constant returns ( bytes32 ret ) { if ( v == NUM_ ) { ret = STR_ ; } else { while ( v > NUM_ ) { ret = bytes32 ( uint ( ret ) / ( NUM_ * * NUM_ ) ) ; ret |= bytes32 ( ( ( v % NUM_ ) + NUM_ ) * NUM_ * * ( NUM_ * NUM_ ) ) ; v /= NUM_ ; } } return ret ; }", "nl": "converts an unsigned integert to it string representation ."}
{"code": "function withdraw ( ) public { uint256 _balance = balance ( ) ; require ( _balance > NUM_ ) ; address _wallet ; if ( _state . _participant != address ( NUM_ ) ) { if ( msg . sender == deployment . _cause ) { _state . _cause withdrawn = BOOL_ ; _wallet = deployment . _cause wallet ; } else if ( msg . sender == _state . _participant ) { _state . _participant withdrawn = BOOL_ ; _wallet = _state . _participant ; } else if ( msg . sender == deployment . _owner ) { _state . _owner withdrawn = BOOL_ ; _wallet = deployment . _owner wallet ; } else { revert ( ) ; } } else if ( _state . _cancelled ) { participant storage _participant = participants [ msg . sender ] ; _participant . _entries = NUM_ ; _wallet = msg . sender ; } else { revert ( ) ; } _wallet . transfer ( _balance ) ; withdrawal ( msg . sender ) ; }", "nl": "use to withdraw fund from the contract from an end fundraiser or refund when the fundraiser be cancel ."}
{"code": "function do confirm ( token promise storage promise ) then assert state internal { transition ( promise , promise state . confirmed ) ; locked token balance = locked token balance . add ( promise . amount ) ; log promise confirmed ( promise . promise id ) ; }", "nl": "move the promise to the confirm state and update the lock token total ."}
{"code": "function set genome ( uint256 _token id , uint256 _genome ) external only logic contract { genome [ _token id ] = _genome ; }", "nl": "allows set hero genome ."}
{"code": "function conclude crowdsale ( ) public only owner { require ( crowdsale started && ! crowdsale on ( ) && ! crowdsale concluded ) ; crowdsale concluded = BOOL_ ; end block = block . number ; uint256 unsold = crowdsale token supply . sub ( crowdsale token sold ) ; if ( unsold > NUM_ ) { total supply = total supply . sub ( unsold ) ; burn ( this , unsold ) ; transfer ( this , address ( NUM_ ) , unsold ) ; } conclude crowdsale ( ) ; }", "nl": "can only be call either after crowdsale time period end , or after tokens have sell out ."}
{"code": "function finalize ( uint256 _end block , uint256 _available amount ) public only owner only not finalized only scheduled tiers only subsequent block ( _end block ) only not zero ( _available amount ) { end block = _end block ; token . mint ( this , _available amount ) ; finalized ( _end block , _available amount ) ; }", "nl": "schedule crowdsale end ."}
{"code": "function execute ( address _dst , uint _value , bytes _data ) only owner { _dst . call . value ( _value ) ( _data ) ; }", "nl": "this be a general safty function that allow the owner to do a lot of things in the unlikely event that something go wrong _dst be the contract be call make this like a 1 / 1 multisig ."}
{"code": "function balance of ( address _owner ) external view returns ( uint256 balance ) { return balances [ _owner ] ; }", "nl": "the balance ."}
{"code": "function allow freeze bypass ( address sender ) public only owner returns ( bool success ) { freeze bypassing [ sender ] = BOOL_ ; return BOOL_ ; }", "nl": "allowing a spender to bypass global frezze ."}
{"code": "function validate ( address currency , uint256 amount ) external only hot wallet returns ( bool ) { assert ( approved [ currency ] >= amount ) ; approved [ currency ] -= amount ; return BOOL_ ; }", "nl": "validate that amount be allow to be transact for currency ."}
{"code": "function do payout ( uint _num pays ) internal { if ( total tokens minted == NUM_ ) return ; if ( ( holdover balance > NUM_ ) && ( payout balance == NUM_ ) && ( now > ( last payout time + min pay interval ) ) ) { cur payout id ++ ; if ( cur payout id >= NUM_ ) cur payout id = NUM_ ; last payout time = now ; payout balance = int ( holdover balance ) ; pr orig payout bal = payout balance ; pr orig tokens mint = total tokens minted ; holdover balance = NUM_ ; last payout index = NUM_ ; stat event i ( STR_ , uint ( cur payout id ) ) ; } else if ( payout balance > NUM_ ) { uint n amount ; uint n per tok distrib = uint ( pr orig payout bal ) / pr orig tokens mint ; uint paids = NUM_ ; uint i ; for ( i = last payout index ; ( paids < _num pays ) && ( i < num accounts ) && ( payout balance > NUM_ ) ; i ++ )", "nl": "payout reward to all token holders use a second hold variable call payoutbalance to do the actual payout from b / c too much gas to iterate thru each payee ."}
{"code": "function _player roll dice ( uint _roll under , tkn _tkn , uint user div rate ) private game is active bet is valid ( _tkn . value , _roll under , user div rate ) { require ( _tkn . value < ( ( NUM_ * * NUM_ ) - NUM_ ) ) ; require ( block . number < ( ( NUM_ * * NUM_ ) - NUM_ ) ) ; require ( user div rate < ( NUM_ * * NUM_ - NUM_ ) ) ; player roll memory roll = player rolls [ _tkn . sender ] ; require ( block . number != roll . blockn ) ; if ( roll . blockn != NUM_ ) { _finish bet ( _tkn . sender ) ; } roll . blockn = uint48 ( block . number ) ; roll . token value = uint192 ( _tkn . value ) ; roll . roll under = uint8 ( _roll under ) ; roll . div rate = uint8 ( user div rate ) ; player rolls [ _tkn . sender ] = roll ; emit log bet ( _tkn . sender , _tkn . value , _roll", "nl": "the actual roll function ."}
{"code": "function erect barrier ( uint16 battleboard id , uint8 _barrier type , uint8 _position ) external payable { ibattleboard data battleboard data = ibattleboard data ( battleboard data contract ) ; uint8 num barriers = battleboard data . get barrier num ( battleboard id ) ; if ( battleboard data . get tile idby position ( battleboard id , _position ) != NUM_ ) { revert ( ) ; } if ( num barriers >= num barriers per board ) { revert ( ) ; } if ( msg . value < barrier price ) { revert ( ) ; } if ( ( _barrier type < NUM_ ) || ( _barrier type > NUM_ ) ) { revert ( ) ; } battleboard data . create tile ( battleboard id , _barrier type , barrier strength , _position , NUM_ , NUM_ , NUM_ , NUM_ , address ( this ) , NUM_ ) ; }", "nl": "can be call by anyone at anytime , ."}
{"code": "function mint to influencer ( address _to , uint256 _value , string _note ) only owner public returns ( bool ) { require ( mint ( _to , _value ) ) ; ksc_get as influencer ( _to , msg . sender , _value , _note ) ; return BOOL_ ; }", "nl": "function to reward influencers with kstarcoin ."}
{"code": "function change permission ( address _delegate , address _module , bytes32 _perm , bool _valid ) public with perm ( change_permission ) returns ( bool ) { require ( delegate details [ _delegate ] != bytes32 ( NUM_ ) , STR_ ) ; perms [ _module ] [ _delegate ] [ _perm ] = _valid ; emit log change permission ( _delegate , _module , _perm , _valid , now ) ; return BOOL_ ; }", "nl": "use to provide / change the permission to the delegate correspond to the module contract ."}
{"code": "function get by alias ( string name ) public view returns ( address ) { return names [ name ] ; }", "nl": "get the address of an account alias ."}
{"code": "function transfer ( address _dest , uint _amt ) internal view { if ( _dest == NUM_ || _dest == contract . sender ( ) ) revert ( STR_ ) ; contract . checks ( can transfer ) ; contract . storing ( ) ; contract . decrease ( token . balances ( contract . sender ( ) ) ) . by ( _amt ) ; contract . increase ( token . balances ( _dest ) ) . by ( _amt ) ; contract . emitting ( ) ; contract . log ( transfer ( contract . sender ( ) , _dest ) , bytes32 ( _amt ) ) ; }", "nl": "implements the logic for a token transfer ."}
{"code": "function sell ( uint _amount , uint _wei expected ) external when not paused { process sell ( msg . sender , _amount , _wei expected ) ; }", "nl": "perform the sell of tokens , send eth to the seller , and reduce the net amount buy ."}
{"code": "function get currently running phase ( ) public view returns ( int8 ) { for ( uint8 i = NUM_ ; i < no of phases ; i ++ ) { if ( phases [ i ] . start time != NUM_ && now >= phases [ i ] . start time && phases [ i ] . end time == NUM_ ) { return int8 ( i ) ; } } return - NUM_ ; }", "nl": "return the currently run tier index a per time ."}
{"code": "function mint ( uint256 _value ) public only owner { total supply = total supply . add ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _value ) ; }", "nl": "mint a specific amount of tokens ."}
{"code": "function accept ownership ( ) public no reentry returns ( bool ) { require ( msg . sender == new owner ) ; changed owner ( owner , new owner ) ; owner = new owner ; return BOOL_ ; }", "nl": "to accept ownership ."}
{"code": "function process mutually agreed job cancellation ( bytes16 _job id , address _hirer , address _contractor , uint256 _value , uint256 _fee , uint8 _contractor percent , bytes _hirer msg sig , bytes _contractor msg sig ) external { bytes32 job hash = get job hash ( _job id , _hirer , _contractor , _value , _fee ) ; require ( job escrows [ job hash ] . exists ) ; require ( msg . sender == _hirer || msg . sender == _contractor ) ; require ( _contractor percent <= NUM_ && _contractor percent >= NUM_ ) ; require ( check refund signature ( _contractor percent , _hirer msg sig , _hirer ) && check refund signature ( _contractor percent , _contractor msg sig , _contractor ) ) ; uint256 job value = hirer escrow map [ _hirer ] [ job hash ] ; require ( job value > NUM_ && job value == _value ) ; require ( job value >= job value . sub ( _fee ) ) ; require ( total in escrow >= job value && total in escrow > NUM_ ) ; total in escrow = total in escrow . sub ( job value", "nl": "called when both hirer and contractor have agree on cancellation condition , and amount each will receive can be call by hirer or contractor once amount have be sign by both party ."}
{"code": "function set rate for round ( sale rounds _round , uint256 _rate ) public only owner at stage ( stages . set up ) { require ( round <= _round ) ; round infos [ uint8 ( _round ) ] . rate = ( _rate == NUM_ ) ? base_amo_to_eth_rate : _rate ; }", "nl": "set amo to ether rate for round ."}
{"code": "function set contract allowance ( address allowed address , uint256 allowed amount ) only owner public returns ( bool success ) { require ( allowed amount <= total supply ) ; allowance [ this ] [ allowed address ] = allowed amount ; return BOOL_ ; }", "nl": "run this if ownership transfer ."}
{"code": "function grant ownership ( address _owner ) only owner public { require ( _owner != address ( NUM_ ) ) ; owners [ _owner ] = BOOL_ ; ownership granted ( msg . sender , _owner ) ; }", "nl": "allows the current owner to grant control of the contract to another account ."}
{"code": "function vote ( uint8 to proposal ) public { voter storage sender = voters [ msg . sender ] ; if ( sender . voted || to proposal >= proposals . length ) return ; sender . voted = BOOL_ ; sender . vote = to proposal ; proposals [ to proposal ] . vote count += sender . weight ; }", "nl": "give a single vote to proposal ( toproposal ) ."}
{"code": "function get percentage ( ) private constant returns ( uint ) { uint duration = now . sub ( ico start time ) ; if ( duration > NUM_ days ) { return NUM_ ; } else if ( duration <= NUM_ days && duration > NUM_ days ) { return NUM_ ; } else if ( duration <= NUM_ days && duration > NUM_ days ) { return NUM_ ; } else { return NUM_ ; } }", "nl": "calculating bonus percentage ."}
{"code": "function withdraw ( ) external only owner ( ) { p3 d ( NUM_ ) . withdraw ( ) ; owner . transfer ( address ( this ) . balance ) ; }", "nl": "withdraw p3d dividends and send balance to owner ."}
{"code": "function relist genesis sales ( bytes32 sig , uint256 new price ) external only owner { sale list lib . add sale ( _sig to sorted sales [ sig ] , owner , new price ) ; _address to sig to sale price [ owner ] [ sig ] = new price ; emit sale posted ( owner , sig , new price ) ; }", "nl": "admin method for re-listing all genesis sales ."}
{"code": "function call withdraw ( ) only owner public { realitycheck . withdraw ( ) ; }", "nl": "withdraw any accumulated question fee from the specified address into this contract ."}
{"code": "function get auction ( uint256 _auction id ) public constant returns ( uint256 [ NUM_ ] ) { require ( _auction id > NUM_ && _auction id < new auction id ) ; uint256 tank id = auctions [ _auction id ] . tank ; uint256 curr price = get curr auction price auction id ( _auction id ) ; bool alive = auctions [ _auction id ] . alive ; uint256 [ NUM_ ] memory out ; out [ NUM_ ] = tank id ; out [ NUM_ ] = curr price ; out [ NUM_ ] = alive ? NUM_ : NUM_ ; return out ; }", "nl": "return tankid , currprice , alive ."}
{"code": "function get my tokens ( ) external view returns ( uint256 [ ] arr_token_id , uint256 [ ] arr_last_deal_time , uint256 [ ] buying_price_arr , uint256 [ ] price_arr ) { token gdc memory token ; uint256 count = st owner token count [ msg . sender ] ; arr_last_deal_time = new uint256 [ ] ( count ) ; buying_price_arr = new uint256 [ ] ( count ) ; price_arr = new uint256 [ ] ( count ) ; arr_token_id = new uint256 [ ] ( count ) ; uint256 index = NUM_ ; for ( uint i = NUM_ ; i < st tokens . length ; i ++ ) { if ( st token index to owner [ i ] == msg . sender ) { token = st tokens [ i ] ; arr_last_deal_time [ index ] = token . last_deal_time ; buying_price_arr [ index ] = token . buying_price ; price_arr [ index ] = token . price ; arr_token_id [ index ] = i ; index = index + NUM_ ; } } }", "nl": "get all greedycoins of msg . sender ."}
{"code": "function deposit ( address receiver , uint num tokens , bool charge gas ) public is alive { require ( num tokens > NUM_ ) ; uint value = safe mul ( num tokens , one edg ) ; uint gas cost ; if ( charge gas ) { gas cost = get gas cost ( ) ; value = safe sub ( value , gas cost ) ; gas payback = safe add ( gas payback , gas cost ) ; } uint new balance = safe add ( balance of [ receiver ] , value ) ; require ( new balance <= max deposit ) ; assert ( edg . transfer from ( msg . sender , address ( this ) , num tokens ) ) ; balance of [ receiver ] = new balance ; player balance = safe add ( player balance , value ) ; emit deposit ( receiver , num tokens , gas cost ) ; }", "nl": "accept deposit for an arbitrary address ."}
{"code": "function grant private purchaser token ( ) public returns ( bool response ) { if ( now > private purchaser [ msg . sender ] . private purchaser time lock ) { require ( private purchaser [ msg . sender ] . private purchaser tokens > NUM_ ) ; uint256 transfer token = private purchaser [ msg . sender ] . private purchaser tokens ; private purchaser [ msg . sender ] . private purchaser tokens = NUM_ ; token . mint ( msg . sender , transfer token ) ; private purchaser token transfer ( msg . sender , transfer token ) ; } if ( private purchaser [ msg . sender ] . private purchaser bonus > NUM_ ) { uint256 transfer bonus token = private purchaser [ msg . sender ] . private purchaser bonus ; private purchaser [ msg . sender ] . private purchaser bonus = NUM_ ; token . mint ( msg . sender , transfer bonus token ) ; private purchaser token transfer ( msg . sender , transfer bonus token ) ; } return BOOL_ ; }", "nl": "function grantprivatepurchasertoken - transfer private purchasers tokens ."}
{"code": "function _get attributes of token ( uint256 _token id ) internal returns ( nft ) { nft storage lsnft obj = all nfts [ _token id ] ; return lsnft obj ; }", "nl": "gets attribute of nft ."}
{"code": "function get pledge level ( pledge p ) internal returns ( uint ) { if ( p . old pledge == NUM_ ) return NUM_ ; pledge storage old n = find pledge ( p . old pledge ) ; return get pledge level ( old n ) + NUM_ ; }", "nl": "a getter to find how many old parent pledge a specific pledge have use a self-referential loop ."}
{"code": "function transfer allowed ( address _from , address ) external view returns ( bool ) { return _from == address ( this ) || _from == address ( disbursement handler ) ; }", "nl": "only the sale and disbursementhandler can disburse the initial tokens to their future owners ."}
{"code": "modifier only crowdsale address ( ) { require ( msg . sender == crowdsale address ) ; _ ; }", "nl": "throws if call by any account other than the crowdsale address ."}
{"code": "function set token address ( address erc20 token ) public owner only is not paused { token contract = erc20 interface ( erc20 token ) ; }", "nl": "set new token address in case of update ."}
{"code": "function get sig ( bytes _data ) internal pure returns ( bytes4 sig ) { uint len = _data . length < NUM_ ? _data . length : NUM_ ; for ( uint i = NUM_ ; i < len ; i ++ ) { sig = bytes4 ( uint ( sig ) + uint ( _data [ i ] ) * ( NUM_ * * ( NUM_ * ( len - NUM_ - i ) ) ) ) ; } }", "nl": "pull function sig from _data ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public when not paused returns ( bool ) { require ( _value > NUM_ ) ; require ( _to != address ( NUM_ ) ) ; require ( _from != address ( NUM_ ) ) ; require ( _value <= balance of [ _from ] ) ; require ( _value <= allowance [ _from ] [ msg . sender ] ) ; require ( safe math . add ( balance of [ _to ] , _value ) > balance of [ _to ] ) ; require ( ! frozen account [ _from ] ) ; require ( ! frozen account [ _to ] ) ; balance of [ _from ] = safe math . sub ( balance of [ _from ] , _value ) ; balance of [ _to ] = safe math . add ( balance of [ _to ] , _value ) ; allowance [ _from ] [ msg . sender ] = safe math . sub ( allowance [ _from ] [ msg . sender ] , _value ) ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }", "nl": "send _value tokens to _to from '_from ' address , the '_value ' ca n't large then allowance by '_from ' who set to 'msg . sender ' ."}
{"code": "function restart sale ( ) only_during_sale_period only_sale_stopped only ( escbdev multisig ) public { sale stopped = BOOL_ ; }", "nl": "function to restart stopped sale ."}
{"code": "function divide up reward ( uint in days ) reward time past only owner external payable { require ( in days >= NUM_ && in days <= NUM_ ) ; last divide reward time = now ; reward days = in days ; total reward = this . balance ; }", "nl": "divide up reward and make it accesible for withdraw ."}
{"code": "function get event ( string _vin , uint256 _index ) constant returns ( uint256 mileage , address verifier , event type event type , string description ) { ledger event memory e = events [ sha3 ( _vin ) ] [ _index ] ; mileage = e . mileage ; verifier = e . verifier ; event type = e . event type ; description = e . description ; }", "nl": "returns the detail of a specific event ."}
{"code": "function delegate to new contract ( delegate erc20 new contract ) public only owner { delegate = new contract ; delegated to ( delegate ) ; }", "nl": "can undelegate by pass in newcontract address ( 0 ) ."}
{"code": "function migrate ( string name ) public owner_only ( keccak256 ( name ) ) { require ( stopped ) ; require ( migration != NUM_ ) ; bytes32 label = keccak256 ( name ) ; domain storage domain = domains [ label ] ; hash registrar . transfer ( label , migration ) ; subdomain registrar ( migration ) . configure domain for ( domain . name , domain . price , domain . referral fee ppm , domain . owner , domain . transfer address ) ; delete domains [ label ] ; domain transferred ( label , name ) ; }", "nl": "migrates the domain to a new registrar ."}
{"code": "function _pre validate token transfer ( address _beneficiary , uint256 _token amount ) internal view { require ( has closed ( ) == BOOL_ ) ; require ( paused == BOOL_ ) ; require ( _beneficiary != address ( NUM_ ) ) ; require ( _token amount > NUM_ ) ; }", "nl": "validation of a token transfer , use with btc purchase ."}
{"code": "function refresh monarchy games reward ( ) public view returns ( uint _reward , uint _num endable ) { imonarchy controller _mc = get monarchy controller ( ) ; _num endable = _mc . get num endable games ( ) ; _reward = _capped reward ( _num endable * monarchy end reward ) ; }", "nl": "return a reward for each monarchygame that will end ."}
{"code": "function add users to group ( bytes32 _group name , address [ ] _users ) external only contract owner returns ( uint ) { require ( is group exists ( _group name ) ) ; group storage _group = group name2group [ _group name ] ; uint _group members count = _group . members count ; for ( uint _user idx = NUM_ ; _user idx < _users . length ; ++ _user idx ) { address _user = _users [ _user idx ] ; uint _member index = member address2index [ _user ] ; require ( _member index != NUM_ ) ; if ( _group . member address2index [ _user ] != NUM_ ) { continue ; } _group members count = _group members count . add ( NUM_ ) ; _group . member address2index [ _user ] = _group members count ; _group . index2global index [ _group members count ] = _member index ; _add group to member ( _user , _group name ) ; user to group added ( _user , _group name ) ; } _group . members count = _group members count ; return ok ; }", "nl": "add users in group ."}
{"code": "function calculate ring fill amount ( uint ring size , order state [ ] orders ) private pure { uint smallest idx = NUM_ ; uint i ; uint j ; for ( i = NUM_ ; i < ring size ; i ++ ) { j = ( i + NUM_ ) % ring size ; smallest idx = calculate order fill amount ( orders [ i ] , orders [ j ] , i , j , smallest idx ) ; } for ( i = NUM_ ; i < smallest idx ; i ++ ) { calculate order fill amount ( orders [ i ] , orders [ ( i + NUM_ ) % ring size ] , NUM_ , NUM_ , NUM_ ) ; } }", "nl": "calculate each order 's fill amount ."}
{"code": "function data source callback finals ( uint id , uint8 [ NUM_ ] result ) public { require ( msg . sender == data source address ) ; uint256 i ; for ( i = NUM_ ; i < NUM_ ; i ++ ) { brackets results . finals teams ids [ i ] = result [ i ] ; } log finals arrived ( id , result ) ; }", "nl": "set the champion , second , third and fourth team to the contract storage ."}
{"code": "function buy tokens ( address _beneficiary ) public payable during sale above minimum below hard cap { require ( _beneficiary != address ( NUM_ ) ) ; uint256 _wei amount = msg . value ; uint256 _tokens qty = msg . value . mul ( get bonus ( _wei amount ) ) ; uint256 _distributed = _tokens qty . add ( tokens distributed ) ; uint256 _sold = _tokens qty . add ( tokens sold ) ; require ( _distributed <= tokens_total_supply ) ; require ( _sold <= tokens_for_sale ) ; contributions [ _beneficiary ] = _wei amount . add ( contributions [ _beneficiary ] ) ; token balances [ _beneficiary ] = _tokens qty . add ( token balances [ _beneficiary ] ) ; wei received = wei received . add ( _wei amount ) ; tokens distributed = _distributed ; tokens sold = _sold ; contribute ( _beneficiary , msg . value ) ; acj token _token = acj token ( token ) ; _token . initial transfer ( _beneficiary , _tokens qty ) ; }", "nl": "actually buy the tokens require an active sale time and amount above the minimum contribution and sell tokens inferior to tokens for sale ."}
{"code": "function refund ( ) { require ( ! bought_tokens && allow_refunds && percent_reduction == NUM_ ) ; uint256 eth_to_withdraw = safe math . div ( safe math . mul ( balances [ msg . sender ] , NUM_ ) , NUM_ ) ; balances [ msg . sender ] = NUM_ ; balances_bonus [ msg . sender ] = NUM_ ; fees = safe math . sub ( fees , safe math . div ( eth_to_withdraw , fee ) ) ; msg . sender . transfer ( eth_to_withdraw ) ; }", "nl": "allows any user to get his eth refund before the purchase be make ."}
{"code": "function cancel order ( bytes32 _order id ) non reentrant convert to and from cash external returns ( bool ) { require ( _order id != bytes32 ( NUM_ ) ) ; iorders _orders = iorders ( controller . lookup ( STR_ ) ) ; uint256 _money escrowed = _orders . get order money escrowed ( _order id ) ; uint256 _shares escrowed = _orders . get order shares escrowed ( _order id ) ; order . types _type = _orders . get order type ( _order id ) ; imarket _market = _orders . get market ( _order id ) ; uint256 _outcome = _orders . get outcome ( _order id ) ; require ( msg . sender == _orders . get order creator ( _order id ) ) ; _orders . remove order ( _order id ) ; refund order ( msg . sender , _type , _shares escrowed , _money escrowed , _market , _outcome ) ; _orders . decrement total escrowed ( _market , _money escrowed ) ; _market . assert balances ( ) ; controller . get augur ( ) . log order canceled ( _market . get universe ( ) , _market . get", "nl": "cancellation : cancel an order , if a bid refund money , if an ask return share ."}
{"code": "function get contract ( bytes32 _id ) public view returns ( address ) { return registry [ _id ] . contract address ; }", "nl": "get contract address for an id ."}
{"code": "function buyin ( ) public payable when_not_halted when_active only_eligible ( msg . sender ) { flush era ( ) ; if ( current bonus > NUM_ ) { if ( now >= begin time + bonus_min_duration && last new interest + bonus_latch <= block . number ) { current bonus -- ; } if ( now >= begin time + bonus_max_duration ) { current bonus = NUM_ ; } if ( buyins [ msg . sender ] . received == NUM_ ) { last new interest = uint32 ( block . number ) ; } } uint accounted ; bool refund ; uint price ; ( accounted , refund , price ) = the deal ( msg . value ) ; require ( ! refund ) ; buyins [ msg . sender ] . accounted += uint128 ( accounted ) ; buyins [ msg . sender ] . received += uint128 ( msg . value ) ; total accounted += accounted ; total received += msg . value ; end time = calculate end time ( ) ; buyin ( msg . sender , accounted , msg . value , price ) ; treasury . transfer ( msg . value", "nl": "buyin function ."}
{"code": "function has closed ( ) public view returns ( bool ) { return now > bets_closing_time ; }", "nl": "checks whether the period in which the bet be open have already elapse ."}
{"code": "function withdraw ( ) only owner { if ( ! soft cap reached ) revert ( ) ; beneficiary . transfer ( collected ) ; token . transfer ( beneficiary , token . balance of ( this ) ) ; crowdsale finished = BOOL_ ; }", "nl": "function to send profit and unsold tokens to beneficiary ."}
{"code": "function take fee ( uint256 _amount ) public with perm ( fee_admin ) returns ( bool ) { require ( poly token . transfer from ( address ( this ) , imodule factory ( factory ) . owner ( ) , _amount ) , STR_ ) ; return BOOL_ ; }", "nl": "use to withdraw the fee by the factory owner ."}
{"code": "function has ended ( ) internal view returns ( bool ) { return ( now > end date ) ; }", "nl": "check if end date of crowdsale be pass ."}
{"code": "function total supply ( ) constant returns ( uint256 total amount ) { total amount = _total supply ; }", "nl": "returns a whole amount of dol ."}
{"code": "function create sales tier config map ( ) private { tier configs [ keccak256 ( sale state . initial ) ] = tier config ( { state name : STR_ , tier rate percentage : NUM_ , hard cap : NUM_ } ) ; tier configs [ keccak256 ( sale state . private sale ) ] = tier config ( { state name : STR_ , tier rate percentage : NUM_ , hard cap : safe math . mul ( NUM_ , ( NUM_ * * NUM_ ) ) } ) ; tier configs [ keccak256 ( sale state . finalised private sale ) ] = tier config ( { state name : STR_ , tier rate percentage : NUM_ , hard cap : NUM_ } ) ; tier configs [ keccak256 ( sale state . pre sale ) ] = tier config ( { state name : STR_ , tier rate percentage : NUM_ , hard cap : safe math . mul ( NUM_ , ( NUM_ * * NUM_ ) ) } ) ; tier configs [ keccak256 ( sale state . finalised pre sale ) ] = tier config ( { state name : STR_ , tier", "nl": "setup the map of bonus-rates ( a a percentage ) and total hardcap for each salestate tier to be call by the constructor ."}
{"code": "function remove all tournament contenders ( ) external only owner tournament paused { uint256 length = tournament queue size ; uint256 warrior id ; uint256 failed booty ; uint256 i ; uint256 fee ; uint256 bank = current tournament bank ; uint256 [ ] memory warriors data = new uint256 [ ] ( length ) ; for ( i = NUM_ ; i < length ; i ++ ) { warriors data [ i ] = tournament queue [ i * data_size ] ; } pvp listener . tournament finished ( warriors data ) ; current tournament bank = NUM_ ; tournament queue size = NUM_ ; for ( i = length - NUM_ ; i >= NUM_ ; i -- ) { warrior id = crypto utils . _unpack warrior id ( warriors data [ i ] , NUM_ ) ; fee = bank - ( bank * NUM_ / ( tournament entrance fee cut * ( NUM_ - threshold ) / NUM_ + NUM_ ) ) ; failed booty += send booty ( warrior to owner [ warrior id ] , fee ) ; bank -= fee ; } current tournament bank = bank ; total booty +=", "nl": "remove all pvp contenders from pvp queue and return all entrance fee to warrior owners ."}
{"code": "function transfer ( address to , uint256 value ) public require is operational returns ( bool ) { require ( to != address ( NUM_ ) ) ; require ( to != msg . sender ) ; require ( value <= transferable balance of ( msg . sender ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; transfer ( msg . sender , to , value ) ; return BOOL_ ; }", "nl": "transfers token for a specified address ."}
{"code": "function is token sale running ( ) public constant returns ( bool ) { return ( is pre sale running ( ) || is crowd sale running ( ) ) ; }", "nl": "returns true if any of the token sale stag be currently run ."}
{"code": "function set address ( bytes32 _key , address _value ) only auth by tun external { address storage [ _key ] = _value ; }", "nl": "initialize all setter methods ."}
{"code": "function update eth icovariables ( uint256 _new_eth_qco , uint256 _new end block ) public only state control { require ( state == states . initial || state == states . valuation set ) ; require ( _new_eth_qco > NUM_ ) ; require ( block . number < _new end block ) ; end block = _new end block ; eth_qco = _new_eth_qco ; move to state ( states . valuation set ) ; }", "nl": "ico contract configuration function new_eth_qco be the new rate of eth in qco to use when no bonus apply newendblock be the absolute block number at which the ico must stop ."}
{"code": "function grant bounty ( address recipient_address , uint token_value ) only owner external { require ( ( contract state == contract state . icostarted ) || ( contract state == contract state . icostopped ) ) ; require ( bounty tokens >= token_value ) ; require ( now >= ico start time ) ; _transfer ( this , recipient_address , token_value ) ; bounty tokens -= token_value ; }", "nl": "grant bounty tokens to an address ."}
{"code": "function has all attrs ( uint256 _token id , bytes2 _attributes ) public view returns ( bool ) { return assets [ _token id ] . attributes & _attributes == _attributes ; }", "nl": "check if asset have all attribute pass by parameter ."}
{"code": "function get owners ( wallet main lib . wallet data storage self ) public view returns ( address [ NUM_ ] ) { address [ NUM_ ] memory o ; for ( uint256 i = NUM_ ; i < self . owners . length ; i ++ ) { o [ i ] = self . owners [ i ] ; } return o ; }", "nl": "get list of wallet owners , will return fixed 50 until fork ."}
{"code": "function migrate ( ) crowdsale running { uint256 pre token balance = pre token . balance of ( msg . sender ) ; require ( pre token balance != NUM_ ) ; uint256 token balance = pre token balance * NUM_ * * NUM_ ; pre token . destroy from ( msg . sender ) ; token . transfer ( msg . sender , token balance ) ; migrated tokens ( msg . sender , token balance ) ; }", "nl": "migrates tkrp tokens to tkr token at a rate of 1 : 1 during the crowdsale ."}
{"code": "function get rich token ( uint256 _token id ) public view returns ( string richtoken name , uint256 selling price , address owner ) { rich storage richtoken = richtokens [ _token id ] ; richtoken name = richtoken . name ; selling price = richtoken index to price [ _token id ] ; owner = richtoken index to owner [ _token id ] ; }", "nl": "returns all the relevant information about a specific richtoken ."}
{"code": "function get bonus ( uint _ethers ) public view returns ( uint8 ) { uint8 _bonus = NUM_ ; uint8 _bonus per investion = NUM_ ; uint starter = now - start_ico ; for ( uint i = NUM_ ; i < bonus time . length ; i ++ ) { if ( starter <= bonus time [ i ] ) { if ( _ethers > NUM_ ether && _ethers <= NUM_ ether ) { _bonus per investion = bonus per investion_10 [ i ] ; } if ( _ethers > NUM_ ether ) { _bonus per investion = bonus per investion_50 [ i ] ; } _bonus = bonus benefit [ i ] ; break ; } } return _bonus + _bonus per investion ; }", "nl": "uint returns a of bonification to apply ."}
{"code": "function update ico ( uint _bonus rate , uint256 _cap , stage _stage ) external only owner sale not done { require ( _bonus rate <= NUM_ ) ; require ( _cap <= ico cap ) ; require ( _stage != stage . none ) ; bonus rate = _bonus rate ; current sale cap = _cap ; current stage = _stage ; }", "nl": "bonus rate percentage ( value 0 to 100 ) cap be the cumulative cap at this point in time ."}
{"code": "function priority pass contract address ( ) constant public returns ( address ) { return address ( priority pass contract ) ; }", "nl": "white list contract address ."}
{"code": "function start board game ( go board storage board , uint board id ) private { require ( board . black address != NUM_ && board . white address != NUM_ ) ; board . next turn color = player color . black ; update board status ( board , board id , board status . in progress ) ; }", "nl": "starts the game and set everything up for the match ."}
{"code": "function token addresses ( ) external view returns ( address [ ] ) { address [ ] memory addresses = new address [ ] ( tokens . length ) ; for ( uint256 i = NUM_ ; i < tokens . length ; i ++ ) { addresses [ i ] = tokens [ i ] . addr ; } return addresses ; }", "nl": "address underlying token address ."}
{"code": "function setup vote ( uint motion id ) internal returns ( uint ) { require ( motion voting ( motion id ) ) ; require ( ! has voted ( msg . sender , motion id ) ) ; require ( msg . sender != motion target [ motion id ] ) ; havven . recompute account last average balance ( msg . sender ) ; uint weight ; if ( motion start time [ motion id ] < havven . fee period start time ( ) ) { weight = havven . penultimate average balance ( msg . sender ) ; } else { weight = havven . last average balance ( msg . sender ) ; } require ( weight > NUM_ ) ; vote weight [ msg . sender ] [ motion id ] = weight ; return weight ; }", "nl": "shared vote setup function between votefor and voteagainst ."}
{"code": "function fill investor account with bonus ( address account address ) only bonus owner { if ( investors accounts [ account address ] == - NUM_ || investors accounts [ account address ] > NUM_ ) { var bonus value = owned bonus [ msg . sender ] ; owned bonus [ msg . sender ] = NUM_ ; if ( investors accounts [ account address ] == - NUM_ ) investors accounts [ account address ] == NUM_ ; investors accounts [ account address ] += int ( bonus value ) ; account filled with bonus ( account address , bonus value , investors accounts [ account address ] ) ; account address . transfer ( bonus value ) ; } }", "nl": "bonus owner can transfer their bonus wei to any investor account before bonus period end ."}
{"code": "function tokens of owner ( address _owner ) external view returns ( uint256 [ ] owner tokens ) { uint256 token count = balance of ( _owner ) ; if ( token count == NUM_ ) { return new uint256 [ ] ( NUM_ ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( token count ) ; uint256 total cars = total supply ( ) ; uint256 result index = NUM_ ; uint256 car id ; for ( car id = NUM_ ; car id <= total cars ; car id ++ ) { if ( lambo index to owner [ car id ] == _owner ) { result [ result index ] = car id ; result index ++ ; } } return result ; } }", "nl": "returns a list of all lambo ids assign to an address ."}
{"code": "function turn off sale ( ) only owner public { _selling = BOOL_ ; }", "nl": "disables sale ."}
{"code": "function mint ( string _name , uint _supply ) public payable { require ( msg . value >= fee ) ; require ( supply [ _name ] == NUM_ ) ; supply [ _name ] = _supply ; balances [ _name ] [ msg . sender ] = _supply ; emit mint ( _name , _supply ) ; }", "nl": "create new token , supply be hard , be serious on internal ."}
{"code": "function get kyc approved ( uint256 index ) public view returns ( address ) { return kyc validated [ index ] ; }", "nl": "retrieve the validated kyc address from the specify index ."}
{"code": "function set migrate contract ( address _new contract addr ) is owner external { require ( _new contract addr != new contract addr ) ; new contract addr = _new contract addr ; }", "nl": "set a new contract for recieve the tokens ( for update contract ) ."}
{"code": "function safe approve ( address _spender , uint256 _current value , uint256 _value ) public returns ( bool success ) { if ( allowances_ [ msg . sender ] [ _spender ] == _current value ) return approve ( _spender , _value ) ; return BOOL_ ; }", "nl": "recommended fix for know attack on any erc20 ."}
{"code": "function get price ( address token address , uint src qty ) public view returns ( uint price ) { require ( token address != address ( NUM_ ) ) ; ( , price ) = price provider . get rates ( token address , src qty ) ; return price ; }", "nl": "forward to price smart contract ."}
{"code": "function pause presale ( bool _paused ) only owner public { presale paused = _paused ; }", "nl": "pause the presale ."}
{"code": "function get infos ( ) constant returns ( address , string , uint ) { return ( creator address , name , creation time ) ; }", "nl": "return basic information about the contract ."}
{"code": "function set cycle limit ( uint _cycle limit ) check access ( STR_ ) { cycle limit = _cycle limit ; }", "nl": "this allow to end pos before 2550 days pass or to extend it far ."}
{"code": "function withdraw ( ) external only owner ( ) { owner . transfer ( address ( this ) . balance ) ; }", "nl": "owner can withdraw the current balance ."}
{"code": "function calc confirms needed ( uint256 _required , uint256 _count ) public pure returns ( uint256 ) { return _required - _count ; }", "nl": "used later to calculate the number of confirmations need for tx ."}
{"code": "function burn ( uint256 _value ) public when not paused { super . burn ( _value ) ; }", "nl": "burns the coin hold by the sender ."}
{"code": "function update score and balance ( uint256 _paid price , uint256 _item id , address _old owner , address _new owner ) internal { uint256 _previous paid price = previous price of item [ _item id ] ; assert ( _paid price > _previous paid price ) ; uint256 score sub handicap = dividends score . sub ( handicap [ pot version ] [ _old owner ] ) ; uint256 player score_ = player score [ _old owner ] ; if ( _old owner != owner && score sub handicap >= NUM_ && player score_ > _previous paid price ) { pending balance [ pot version ] [ _old owner ] += player score_ . mul ( score sub handicap ) . div ( huge ) ; player score [ _old owner ] -= _previous paid price ; handicap [ pot version ] [ _old owner ] = dividends score ; } score sub handicap = dividends score . sub ( handicap [ pot version ] [ _new owner ] ) ; player score_ = player score [ _new owner ] ; if ( score sub handicap >= NUM_ ) { pending balance [ pot version ] [ _new owner", "nl": "we need to update the oldowner and newowner balance each time a country be sell , their handicap and playerscore will also change ."}
{"code": "function issue tokens with locking ( address _to , uint256 _value , uint256 _value locked , lock reason _why , uint64 _release time ) only admin public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value > NUM_ ) ; require ( _value locked >= NUM_ && _value locked <= _value ) ; require ( total inactive >= _value ) ; total supply = total supply . add ( _value ) ; total inactive = total inactive . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; issued ( _to , _value , _value locked ) ; transfer ( NUM_ , _to , _value ) ; if ( _value locked > NUM_ ) { lock tokens ( _to , _value locked , _why , _release time ) ; } }", "nl": "issuing tokens from the fund ."}
{"code": "function log game data ( bytes32 [ ] server seeds , bytes32 [ ] client seeds , int [ ] results , uint8 v , bytes32 r , bytes32 s ) public { address player = determine player ( server seeds , client seeds , results , v , r , s ) ; game data ( player , server seeds , client seeds , results ) ; if ( player != msg . sender ) { uint gas cost = ( NUM_ + NUM_ * server seeds . length / NUM_ ) * gas price ; balance of [ player ] = safe sub ( balance of [ player ] , gas cost ) ; player balance = safe sub ( player balance , gas cost ) ; } }", "nl": "log some seed and game result for players wish to have their game history log by the contract clientseeds array contain the client seed result array contain the result v , r , s the signature of the non-sending party ( to make sure the corrcet result be log ) ."}
{"code": "function clear state ( uint8 lottery id ) private { if ( ! request pause [ lottery id ] ) { state [ lottery id ] = state . running ; clear number ( lottery id ) ; started [ lottery id ] = block . timestamp ; last ticket bought [ lottery id ] = NUM_ ; tickets sold [ lottery id ] = NUM_ ; clear512 ( bit mask for play fields [ lottery id ] ) ; } else { state [ lottery id ] = state . paused ; request pause [ lottery id ] = BOOL_ ; } }", "nl": "this methods clear the state of current lottery ."}
{"code": "function get rn ( uint _block ) public returns ( uint rn ) { rn = random number [ _block ] ; if ( rn == NUM_ ) { save rn ( _block ) ; return random number [ _block ] ; } else return rn ; }", "nl": "return the random number ."}
{"code": "function get oldest pledge not canceled ( uint64 id pledge ) internal constant returns ( uint64 ) { if ( id pledge == NUM_ ) return NUM_ ; pledge storage p = find pledge ( id pledge ) ; pledge admin storage admin = find admin ( p . owner ) ; if ( admin . admin type == pledge admin type . giver ) return id pledge ; assert ( admin . admin type == pledge admin type . project ) ; if ( ! is project canceled ( p . owner ) ) return id pledge ; return get oldest pledge not canceled ( p . old pledge ) ; }", "nl": "a getter to find the old pledge that have n't be cancel ."}
{"code": "function set upgrade master ( address master ) public { if ( master == NUM_ ) throw ; if ( msg . sender != upgrade master ) throw ; upgrade master = master ; }", "nl": "change the upgrade master ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value && contribution time [ msg . sender ] + waittimeuntilwithdrawortransfer <= block . timestamp && _to != address ( this ) && _to != address ( NUM_ ) ) ; balances [ msg . sender ] = safe math . sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = safe math . add ( balances [ _to ] , _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "nl": "do n't allow transfer before the required wait-time and do n't allow transfer to this contract addr , it 'll just kill tokens ."}
{"code": "function issue ( address _to , uint256 _value ) public only issuer returns ( bool ) { last issued time [ _to ] = block . timestamp ; emit issue ( _to , _value ) ; return super . transfer ( _to , _value ) ; }", "nl": "also record the token issued time ."}
{"code": "function recompute last average balance ( ) external optional proxy returns ( uint ) { return _recompute account last average balance ( message sender ) ; }", "nl": "recompute and return the sender 's average balance information ."}
{"code": "function judge fake token ( uint256 _token id ) only root ( ) public { creator of token [ _token id ] = msg . sender ; }", "nl": "judge fake token ."}
{"code": "function recover tokens ( erc20 basic token ) only owner public { token . transfer ( owner , tokens to be returned ( token ) ) ; }", "nl": "this will be invoke by the owner , when owner want to rescue tokens ."}
{"code": "function get play record ( address _address ) external view returns ( uint32 , address , uint256 [ NUM_ ] , uint32 [ NUM_ ] , uint32 [ NUM_ ] , uint32 , uint256 , uint8 , uint8 [ NUM_ ] , uint8 [ NUM_ ] , uint32 [ NUM_ ] ) { play record memory _p = address to play record [ _address ] ; turn info memory _t = address to turn info [ _address ] ; return ( _p . initial seed , _p . enemy address , _p . token ids , _p . unit class ids , _p . unit levels , _p . exp reward , _p . gold reward , _t . turn length , _t . turn order , _t . defender list , _t . damage list ) ; }", "nl": "get previous game record ."}
{"code": "function verify side ( color [ NUM_ ] [ NUM_ ] memory a state , uint8 face , color expected color ) internal pure returns ( bool ) { return a state [ face ] [ NUM_ ] == expected color && a state [ face ] [ NUM_ ] == expected color && a state [ face ] [ NUM_ ] == expected color && a state [ face ] [ NUM_ ] == expected color && a state [ face ] [ NUM_ ] == expected color && a state [ face ] [ NUM_ ] == expected color && a state [ face ] [ NUM_ ] == expected color && a state [ face ] [ NUM_ ] == expected color && a state [ face ] [ NUM_ ] == expected color ; }", "nl": "checks that a give side be of correct color ."}
{"code": "function new plcrwith token ( uint _supply , string _name , uint8 _decimals , string _symbol ) public returns ( plcrvoting ) { eip20 token = new eip20 ( _supply , _name , _decimals , _symbol ) ; token . transfer ( msg . sender , _supply ) ; plcrvoting plcr = plcrvoting ( proxy factory . create proxy ( canonized plcr , STR_ ) ) ; plcr . init ( token ) ; emit new plcr ( msg . sender , token , plcr ) ; return plcr ; }", "nl": "deploy and initialize a new plcrvoting contract and an eip20 to be consume by the plcr 's initializer ."}
{"code": "function transfer ( address _to , uint256 _value ) public when permitted ( msg . sender ) when permitted ( _to ) when not paused only not bank owner returns ( bool ) { if ( investor list [ msg . sender ] ) { return _transfer investor ( _to , _value ) ; } else { if ( super investor [ msg . sender ] ) { require ( _to != owner ) ; require ( ! super investor [ _to ] ) ; require ( ! cex [ _to ] ) ; if ( ! investor list [ _to ] ) { investor list [ _to ] = BOOL_ ; search investor [ _to ] = investor ( NUM_ , _value , _value . div ( NUM_ ) ) ; emit tmtg_set investor ( _to ) ; } } return super . transfer ( _to , _value ) ; } }", "nl": "when the transfer function be run , there be two different type ; transfer from superinvestors to investor and to non-investors ."}
{"code": "function name ( ) public pure returns ( string ) { return name ; }", "nl": "erc20 compatible methods ."}
{"code": "function balance with interest ( address _owner ) private constant returns ( uint256 ret ) { if ( _owner == owner || sale status != NUM_ ) return balances [ _owner ] ; return balances [ _owner ] . compound interest ( stage2 start time , date of start [ _owner ] , current date ) ; }", "nl": "gets balance include interest for specify address ."}
{"code": "function arbitrate approve milestone ( uint _id milestone ) only arbitrator campaign not canceled not changing { if ( _id milestone >= milestones . length ) throw ; milestone milestone = milestones [ _id milestone ] ; if ( ( milestone . status != milestone status . accepted and in progress ) && ( milestone . status != milestone status . completed ) ) throw ; authorize payment ( _id milestone ) ; }", "nl": "onlyarbitrator forces a milestone to be pay out as long a it have not be pay or cancel ."}
{"code": "function calc cost ( market market , uint8 outcome token index , uint outcome token count ) public constant returns ( uint cost ) { require ( market . event contract ( ) . get outcome count ( ) > NUM_ ) ; int [ ] memory net outcome tokens sold = get net outcome tokens sold ( market ) ; int log n = math . ln ( net outcome tokens sold . length * one ) ; uint funding = market . funding ( ) ; int cost level before = calc cost level ( log n , net outcome tokens sold , funding ) ; require ( int ( outcome token count ) >= NUM_ ) ; net outcome tokens sold [ outcome token index ] = net outcome tokens sold [ outcome token index ] . add ( int ( outcome token count ) ) ; int cost level after = calc cost level ( log n , net outcome tokens sold , funding ) ; require ( cost level after >= cost level before ) ; cost = uint ( cost level after - cost level before ) ; if ( cost / one *", "nl": "returns cost to buy give number of outcome tokens ."}
{"code": "function issue ( address _addr , uint _amount ) public can enter only trustee returns ( bool ) { assert ( total supply + _amount < maxtokens ) ; join ( _addr ) ; holder holder = holders [ _addr ] ; holder . offer amount = _amount ; holder . offer expiry = uint40 ( now + NUM_ days ) ; issue offer ( _addr ) ; return BOOL_ ; }", "nl": "for the trustee to issue an offer of new tokens to a holder ."}
{"code": "function iconics count ( ) public view returns ( uint256 ) { return iconic checklist items . length ; }", "nl": "returns how many iconic checklist items we 've add ."}
{"code": "function activate ( ) external only owner only state ( state . ready ) { require ( num locks == num beneficiaries ) ; initial balance = token . balance of ( this ) ; require ( initial balance > NUM_ ) ; active time = now ; state = state . active ; emit state changed ( state ) ; }", "nl": "beneficiary can release their tokens after activate ."}
{"code": "function set sender ( address _sender ) public only owner { sender = _sender ; }", "nl": "sets new token sender address ."}
{"code": "function execute request ( bytes32 _value ) public { item storage item = items [ _value ] ; require ( now - item . last action >= time to challenge ) ; require ( ! item . disputed ) ; if ( item . status == item status . resubmitted || item . status == item status . submitted ) item . status = item status . registered ; else if ( item . status == item status . clearing requested || item . status == item status . preventive clearing requested ) item . status = item status . cleared ; else revert ( ) ; item . submitter . send ( item . balance ) ; emit item status change ( item . submitter , item . challenger , _value , item . status , item . disputed ) ; }", "nl": "execute a request after the time for challenge it have pass ."}
{"code": "function get card info ( uint256 card id , uint256 existing , uint256 amount ) external constant returns ( uint256 , uint256 , uint256 , uint256 , bool ) { return ( card info [ card id ] . card id , card info [ card id ] . base coin production , get cost for cards ( card id , existing , amount ) , safe math . mul ( card info [ card id ] . eth cost , amount ) , card info [ card id ] . unit sellable ) ; }", "nl": "for production card ."}
{"code": "function register ( bytes20 _username , uint64 _endowment , bytes _sig ) public { require ( recover ( keccak256 ( msg . sender , _username , _endowment ) , _sig ) == owner ) ; new member ( msg . sender , _username , _endowment ) ; }", "nl": "member functions ."}
{"code": "function pause ico ( ) external only owner { require ( ico state == ico state . running ) ; ico state = ico state . paused ; pause ico ( ) ; }", "nl": "manual pause ico ."}
{"code": "function claim token reserve life ( ) only token reserve life locked public { address reserve wallet = msg . sender ; require ( block . timestamp > time locks [ reserve wallet ] ) ; uint256 vesting stage = life vesting stage ( ) ; uint256 total unlocked = vesting stage . mul ( NUM_ * ( NUM_ * * NUM_ ) * ( NUM_ * * NUM_ ) ) ; require ( total unlocked <= allocations [ life reserve wallet ] ) ; require ( claimed [ life reserve wallet ] < total unlocked ) ; uint256 payment = total unlocked . sub ( claimed [ life reserve wallet ] ) ; claimed [ life reserve wallet ] = total unlocked ; require ( token . transfer ( reserve wallet , payment ) ) ; distributed ( reserve wallet , payment ) ; }", "nl": "claim tokens for life reserve wallet ."}
{"code": "function check pool address tier cap ( uint8 _tier , uint256 _value ) internal view returns ( bool _success ) { uint256 current contribution = pool [ pool address ] [ _tier ] . contribution in wei ; if ( ( _tier == NUM_ && ( pool address cap tier1 < current contribution . add ( _value ) ) ) || ( _tier == NUM_ && ( pool address cap tier2 < current contribution . add ( _value ) ) ) ) { return BOOL_ ; } return BOOL_ ; }", "nl": "check cap for pool address in tier 1 and 2 ."}
{"code": "modifier valid destination ( address _addr ) { require ( _addr != address ( this ) ) ; _ ; }", "nl": "require that this contract can not affect itself ."}
{"code": "function update contributor address ( address _contributor old , address _contributor new ) public only owner ( ) { backer storage backer old = backers [ _contributor old ] ; backer storage backer new = backers [ _contributor new ] ; require ( backer old . wei received one > NUM_ || backer old . wei received two > NUM_ || backer old . wei received main > NUM_ ) ; require ( backer new . wei received one == NUM_ && backer new . wei received two == NUM_ && backer new . wei received main == NUM_ ) ; require ( backer old . claimed == BOOL_ && backer old . refunded == BOOL_ ) ; backer old . claimed = BOOL_ ; backer old . refunded = BOOL_ ; backer new . wei received one = backer old . wei received one ; backer new . wei received two = backer old . wei received two ; backer new . wei received main = backer old . wei received main ; backers index . push ( _contributor new ) ; }", "nl": "this function can be use by owner to update contribution address in case of use address from exchange or incompatible wallet ."}
{"code": "function get wallet balance ( ) public view returns ( uint ) { return address ( this ) . balance ; }", "nl": "returns the eth balance of this wallet ."}
{"code": "function fund ( ) public payable { if ( date sale started == NUM_ || now < date sale started ) return _error buying tokens ( STR_ ) ; if ( now > date sale ended ) return _error buying tokens ( STR_ ) ; if ( total raised >= hard cap ) return _error buying tokens ( STR_ ) ; if ( msg . value % NUM_ != NUM_ ) return _error buying tokens ( STR_ ) ; if ( ! was sale started ) { was sale started = BOOL_ ; emit sale started ( now ) ; } uint _amt to fund = ( total raised + msg . value ) > hard cap ? hard cap - total raised : msg . value ; uint _num tokens = get tokens from eth ( _amt to fund ) ; token . mint ( msg . sender , _num tokens ) ; total raised += _amt to fund ; emit buy tokens success ( now , msg . sender , _amt to fund , _num tokens ) ; if ( total raised < soft cap ) { amt funded [ msg . sender ] += _amt to fund ; } uint _refund = msg . value > _amt to fund ? msg . value - _amt to fund : NUM_ ; if ( _refund > NUM_ ) { require ( msg . sender . call . value ( _refund ) ( ) ) ; emit user refunded ( now , msg . sender , _refund ) ; } }", "nl": "allows the sender to buy tokens ."}
{"code": "function _add affiliate ( uint256 _code , affiliates _affiliate ) internal { code to affiliate [ _code ] = _affiliate ; }", "nl": "adds an affiliate to the list ."}
{"code": "function transfer tokens to account ( bytes16 _from , bytes16 _to , uint256 _tokens count ) only allowed addresses only registered account ( _from ) when not paused public returns ( bool ) { register account ( _to ) ; balances [ _from ] = balances [ _from ] . sub ( _tokens count ) ; balances [ _to ] = balances [ _to ] . add ( _tokens count ) ; return BOOL_ ; }", "nl": "function for transfer tokens from one account to another ."}
{"code": "function flush ( ) public when not paused returns ( bool success ) { if ( block . number >= to flush [ msg . sender ] ) { return down the drain immediate ( ) ; } else return BOOL_ ; }", "nl": "checks if the dump be complete and we can flush the whole stash ! ."}
{"code": "function is link claimed ( address _transit address ) public view returns ( bool claimed ) { return used transit addresses [ _transit address ] ; }", "nl": "get boolean if link be already claim ."}
{"code": "function current cluster ( ) constant returns ( uint256 current cluster ) { uint block count = block . number - initial block count ; uint result = block count . div ( NUM_ ) ; return result ; }", "nl": "returns the current amount of clusters ."}
{"code": "function get player id ( address _addr ) external returns ( uint256 ) { determine pid ( _addr ) ; return ( p idx addr_ [ _addr ] ) ; }", "nl": "playerbookinterface interface ."}
{"code": "function get usage details ( ) view public returns ( uint256 , uint8 , uint256 , address , address ) { return ( fee , quorum , vesting period , owner , kyc ) ; }", "nl": "getusagefees be a function to get all the detail on template usage fee ."}
{"code": "function get token amount ( uint256 wei amount ) internal view returns ( uint256 ) { uint256 bonus = compute bonus ( wei amount ) ; uint256 rate with bonus = rate . mul ( coeff . add ( bonus ) ) . div ( coeff ) ; return wei amount . mul ( rate with bonus ) ; }", "nl": "overrided gettokenamount function of parent crowdsale contract to calculate the token with time and amount bonus ."}
{"code": "function release_all ( address _beneficiary ) external returns ( bool ) { require ( time_locked_reclaim_addresses [ _beneficiary ] . length > NUM_ ) ; token timelock [ ] memory _locks = time_locked_reclaim_addresses [ _beneficiary ] ; for ( uint256 i = NUM_ ; i < _locks . length ; ++ i ) _locks [ i ] . release ( ) ; return BOOL_ ; }", "nl": "release all tokens hold by time lock contract to the beneficiary address store in the contract ."}
{"code": "function get player vaults helper ( uint256 _p id , uint256 _r id ) private view returns ( uint256 ) { return ( ( ( ( ( round_ [ _r id ] . mask ) . add ( ( ( ( ( round_ [ _r id ] . pot ) . mul ( pot split_ [ round_ [ _r id ] . team ] . gen ) ) / NUM_ ) . mul ( NUM_ ) ) / ( round_ [ _r id ] . keys ) ) ) . mul ( plyr rnds_ [ _p id ] [ _r id ] . keys ) ) / NUM_ ) ) ; }", "nl": "solidity hat stack limit ."}
{"code": "function jackpot guard ( uint _wager ) private view returns ( bool ) { uint max profit = safe math . mul ( _wager , NUM_ ) ; uint ninety contract balance = safe math . mul ( safe math . div ( contract balance , NUM_ ) , NUM_ ) ; return ( max profit <= ninety contract balance ) ; }", "nl": "this sound like a draconian function , but it actually just ensure that the contract have enough to pay out a jackpot at the rate you 've select ( i . e ."}
{"code": "function set inv contract ( address _addr ) only manager public { inv_contract = _addr ; }", "nl": "invest contract address change ."}
{"code": "function exec script ( bytes _script , bytes _input , address [ ] _blacklist ) external returns ( bytes ) { require ( _blacklist . length == NUM_ ) ; bytes32 id = keccak256 ( _script ) ; address deployed = cache [ id ] ; if ( deployed == address ( NUM_ ) ) { deployed = deploy ( _script ) ; cache [ id ] = deployed ; } return delegate script . delegate ( deployed , _input ) ; }", "nl": "executes script by delegatecall into a deploy contract ( exec ( ) function ) ."}
{"code": "function do trade ( erc20 src token , uint src amount , erc20 dest token , address dest address , uint conversion rate , bool validate ) internal returns ( bool ) { if ( validate ) { require ( conversion rate > NUM_ ) ; if ( src token == eth_token_address ) require ( msg . value == src amount ) ; else require ( msg . value == NUM_ ) ; } uint dest amount = get dest qty ( src token , dest token , src amount , conversion rate ) ; require ( dest amount > NUM_ ) ; erc20 token ; int buy ; if ( src token == eth_token_address ) { buy = int ( dest amount ) ; token = dest token ; } else { buy = - NUM_ * int ( src amount ) ; token = src token ; } conversion rates contract . record imbalance ( token , buy , NUM_ , block . number ) ; if ( src token != eth_token_address ) { require ( src token . transfer from ( msg . sender , this , src amount ) ) ; } if ( dest token", "nl": "do a trade ."}
{"code": "function start crowdsale ( ) external { require ( within period ( ) ) ; require ( viola token != address ( NUM_ ) ) ; require ( get tokens left ( ) > NUM_ ) ; require ( status == state . pending start ) ; status = state . active ; crowdsale started ( ) ; }", "nl": "crowdsale state function ."}
{"code": "function create cdpleveraged ( ) public auth stoppable payable returns ( bytes32 id ) { require ( msg . value >= min eth ) ; uint price = uint ( feed . read ( ) ) ; gem . deposit . value ( msg . value ) ( ) ; id = _open and join cdpweth ( msg . value ) ; while ( _reinvest ( id , price ) ) { } tub . give ( id , msg . sender ) ; }", "nl": "create a cdp from the eth send , and then create dai and reinvest it in the cdp until the target liquidation price be reach ( or the minimum investment amount ) ."}
{"code": "function setup period for ico ( uint _start , uint _end ) only owner { require ( _start < _end ) ; start ico = _start ; end ico = _end ; }", "nl": "for ico and project detail visit http : / / careerxon . com ."}
{"code": "function update oraclize gas price ( uint _value ) public only owner { oraclize_set custom gas price ( _value ) ; }", "nl": "state update ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) only payload size ( NUM_ * NUM_ ) public returns ( bool ) { return super . transfer from ( _from , _to , _value ) ; }", "nl": "override transferfrom method to include the onlypayloadsize check modifier ."}
{"code": "function transfer from ( address _from , address _to , uint _id ) external { require ( _from == m id owner [ _id ] && m id approved [ _id ] == msg . sender ) ; m id owner [ _id ] = _to ; m id approved [ _id ] = address ( NUM_ ) ; update balances ( _from , _to ) ; transfer ( _from , _to , _id ) ; }", "nl": "transfer from ."}
{"code": "function accept investments ( address _addr , uint256 _amount ) private when whitelisted ( msg . sender ) when not paused { require ( _addr != address ( NUM_ ) && _amount >= min investments ) ; bool pre ico = is pre ico stage ( ) ; bool ico = is ico stage ( ) ; require ( pre ico || ico ) ; require ( ( pre ico && tokens remaining pre ico ( ) > NUM_ ) || ( ico && tokens remaining ico ( ) > NUM_ ) ) ; uint256 intermediate eth investment ; uint256 eth surrender = NUM_ ; uint256 current eth = pre ico ? pre ico investors [ _addr ] : ico investors [ _addr ] ; if ( current eth . add ( _amount ) > max investments ) { intermediate eth investment = max investments . sub ( current eth ) ; eth surrender = eth surrender . add ( _amount . sub ( intermediate eth investment ) ) ; } else { intermediate eth investment = _amount ; } uint256 current rate = pre ico ? exchange rate pre ico : exchange rate ico ; uint256 intermediate token investment", "nl": "function process new investments ."}
{"code": "function started ( ) public view returns ( bool ) { return now >= start time ; }", "nl": "from icoengineinterface ."}
{"code": "function generate hash ( address to , string secret ) public pure returns ( bytes32 hashed ) { return keccak256 ( to , secret ) ; }", "nl": "generate a hash from the provide plaintext ."}
{"code": "function set initial settings ( address _founders tokens storage , uint256 _start timestamp , uint256 _soft cap in ether , uint256 _hard cap in ether , uint256 _tokens for one ether ) public timed state change requires state ( state . init ) onlymanyowners ( sha3 ( msg . data ) ) valid address ( _founders tokens storage ) { require ( _start timestamp != NUM_ ) ; require ( _soft cap in ether != NUM_ ) ; require ( _hard cap in ether != NUM_ ) ; require ( _tokens for one ether != NUM_ ) ; m_start timestamp = _start timestamp ; m_soft cap = _soft cap in ether * NUM_ ether ; m_hard cap = _hard cap in ether * NUM_ ether ; m_exchange rate = _tokens for one ether ; m_founders tokens storage = _founders tokens storage ; m_initial settings set = BOOL_ ; }", "nl": "set exchange rate before start ."}
{"code": "function to bytes ( rlpitem memory self ) internal constant returns ( bytes memory bts ) { var len = self . _unsafe_length ; if ( len == NUM_ ) return ; bts = new bytes ( len ) ; _copy to bytes ( self . _unsafe_mem ptr , bts , len ) ; }", "nl": "return the rlp encode bytes ."}
{"code": "function _claimed surrounding plots ( uint256 _deed id ) internal view returns ( uint256 [ ] memory ) { var ( x , y ) = identifier to coordinate ( _deed id ) ; uint256 claimed = NUM_ ; uint256 [ ] memory _plots = new uint256 [ ] ( NUM_ ) ; for ( int256 dx = - NUM_ ; dx <= NUM_ ; dx ++ ) { for ( int256 dy = - NUM_ ; dy <= NUM_ ; dy ++ ) { if ( dx == NUM_ && dy == NUM_ ) { continue ; } uint256 neighbor identifier = coordinate to identifier ( uint256 ( int256 ( x ) + dx ) % NUM_ , uint256 ( int256 ( y ) + dy ) % NUM_ ) ; if ( identifier to owner [ neighbor identifier ] != NUM_ ) { _plots [ claimed ] = neighbor identifier ; claimed ++ ; } } } uint256 [ ] memory plots = new uint256 [ ] ( claimed ) ; for ( uint256 i = NUM_ ; i < claimed ; i ++ ) { plots [ i ] = _plots [ i ] ; } return", "nl": "find the _claimed_ plot surround a plot ."}
{"code": "modifier only banker ( ) { require ( msg . sender == bank manager ) ; _ ; }", "nl": "operation modifiers for limit access to only banker ."}
{"code": "function set token ( address _token ) external only owner when paused { require ( state == state . new ) ; require ( _token != address ( NUM_ ) ) ; require ( token == address ( NUM_ ) ) ; token = bit image token ( _token ) ; token ico allocated = token . total supply ( ) . mul ( NUM_ ) . div ( NUM_ ) ; token team allocated = token . total supply ( ) . mul ( NUM_ ) . div ( NUM_ ) ; token advisors allocated = token . total supply ( ) . mul ( NUM_ ) . div ( NUM_ ) ; token bounty allocated = token . total supply ( ) . mul ( NUM_ ) . div ( NUM_ ) ; token reservation allocated = token . total supply ( ) . mul ( NUM_ ) . div ( NUM_ ) ; require ( token . total supply ( ) == token ico allocated . add ( token team allocated ) . add ( token advisors allocated ) . add ( token bounty allocated ) . add ( token reservation allocated ) ) ; }", "nl": "initilizes the token with give address and allocate tokens ."}
{"code": "function reset winners ( uint256 new length ) external only admin check state ( points validation state . limit calculated ) { sorted winners . length = new length ; }", "nl": "if anything during the point calculation and sort part should fail , this function can reset data structure to their initial position , so a to ."}
{"code": "function external purchase ( address _beneficiary , string _currency , uint256 _value , uint256 _amount , uint256 _txid ) public { require ( owner != address ( NUM_ ) ) ; require ( msg . sender == owner ) ; require ( is icoactive ( ) || post icosale ) ; require ( token . whitelist ( _beneficiary ) ) ; require ( _amount >= minimum purchase ) ; if ( is icoactive ( ) && token . total supply ( ) . add ( _amount ) > ico token cap ) revert ( ) ; external funds raised [ currency to hash ( _currency ) ] = external funds raised [ currency to hash ( _currency ) ] . add ( _value ) ; token . mint ( _beneficiary , _amount ) ; emit external token purchase ( _beneficiary , _currency , _value , _amount , _txid ) ; }", "nl": "token purchase outside of this contract , usually pay for by currencies other than eth ."}
{"code": "function get pay id and held ( uint _tok held ) internal returns ( uint _pay id , uint _held ) { _pay id = ( _tok held / ( NUM_ * * NUM_ ) ) & NUM_ ; _held = _tok held & NUM_ ; }", "nl": "tokens hold reserve the top two bytes for the payid last pay ."}
{"code": "function restore balances ( address [ NUM_ ] addr , uint256 [ NUM_ ] _days , uint256 [ NUM_ ] _amounts ) external only admin { assert ( initialized == BOOL_ ) ; if ( total supply == NUM_ ) { balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] = NUM_ ; balances [ NUM_ ] =", "nl": "restore tokens from previous contract ."}
{"code": "function set min eth ( uint wad ) public auth { min eth = wad ; }", "nl": "set the minimal eth for trade ( depend on otc ) ."}
{"code": "function post mon for mon ( uint64 your mon , uint64 desired mon ) external { check ownership ( your mon ) ; require ( desired mon != NUM_ ) ; listed mon for mon [ your mon ] = desired mon ; mon to trainer [ your mon ] = msg . sender ; }", "nl": "posts a trade offer up your mon for only the give mon ."}
{"code": "function calculate payouts ( ) private { uint total amount = total bets ( ) ; team storage wt = teams [ winning team index ] ; uint win team amount = wt . bets ; if ( win team amount == NUM_ ) { return ; } uint winnings = remove fee amount ( total amount , win team amount ) ; for ( uint i = NUM_ ; i < wt . bettors . length ; i ++ ) { uint bet size = wt . bettor amount [ wt . bettors [ i ] ] ; uint percentage = safe math . div ( ( bet size * NUM_ ) , win team amount ) ; uint pay out = winnings * percentage ; pay outs [ wt . bettors [ i ] ] = safe math . div ( pay out , NUM_ ) + bet size ; } }", "nl": "calculate payouts ."}
{"code": "function get return ( ierc20 token _from token , ierc20 token _to token , uint256 _amount ) public constant returns ( uint256 amount ) { require ( _from token != _to token ) ; if ( _to token == token ) return get purchase return ( _from token , _amount ) ; else if ( _from token == token ) return get sale return ( _to token , _amount ) ; uint256 purchase return amount = get purchase return ( _from token , _amount ) ; return get sale return ( _to token , purchase return amount , safe add ( token . total supply ( ) , purchase return amount ) ) ; }", "nl": "return the expected return for change a specific amount of _fromtoken to _totoken ."}
{"code": "function add approved game ( address _game address ) only owner public { approved games [ _game address ] = BOOL_ ; add item ( _game address ) ; }", "nl": "when new game be create it need to be approve here before it start ."}
{"code": "function terminate ( ) external only owner { sale closed = BOOL_ ; }", "nl": "the owner can terminate the crowdsale at any time ."}
{"code": "function token fallback ( address , uint _value , bytes ) public { require ( msg . sender == token ) ; require ( ! tokens received ) ; require ( _value == total_tokens ) ; total tokens = total_tokens ; tokens received = BOOL_ ; }", "nl": "function to receive erc223 tokens ( only from token , only once , only total_tokens ) ."}
{"code": "function get price ( ) public constant returns ( uint result ) { if ( crowd sale type == NUM_ ) { return ( price . mul ( NUM_ ) ) . div ( NUM_ ) ; } if ( crowd sale type == NUM_ ) { uint crowdsale price bracket = NUM_ weeks ; uint start crowdsale = start block . add ( duration pre sale ) ; if ( now > start crowdsale && now <= start crowdsale . add ( crowdsale price bracket ) ) { return ( ( price . mul ( NUM_ ) ) . div ( NUM_ ) ) ; } else if ( now > start crowdsale . add ( crowdsale price bracket ) && now <= ( start crowdsale . add ( crowdsale price bracket . mul ( NUM_ ) ) ) ) { return ( price . mul ( NUM_ ) ) . div ( NUM_ ) ; } else if ( now > ( start crowdsale . add ( crowdsale price bracket . mul ( NUM_ ) ) ) && now <= ( start crowdsale . add ( crowdsale price bracket . mul ( NUM_ ) ) ) ) {", "nl": "to get price for exh token ."}
{"code": "function add multiple items ( uint256 price , uint8 howmuch ) public { require ( msg . sender == owner ) ; require ( price != NUM_ ) ; require ( howmuch != NUM_ ) ; uint8 i = NUM_ ; for ( i ; i < howmuch ; i ++ ) { add item ( price ) ; } }", "nl": "add multiple items ."}
{"code": "function token by index ( uint256 _index ) external view returns ( uint256 ) { require ( _index < total tokens ) ; return _index ; }", "nl": "get token identifier by index ."}
{"code": "function load token balances ( token token ) public view returns ( uint256 [ ] memory , uint256 total ) { uint256 [ ] memory result = new uint256 [ ] ( accounts . length ) ; uint256 balance ; for ( uint256 i = NUM_ ; i < accounts . length ; i ++ ) { balance = token . balance of ( accounts [ i ] ) ; result [ i ] = balance ; total += balance ; } return ( result , total ) ; }", "nl": "loads the token balance of all the account ."}
{"code": "function withdraw tokens ( address token contract ) external can access ( NUM_ ) { erc20 tc = erc20 ( token contract ) ; tc . transfer ( msg . sender , tc . balance of ( this ) ) ; }", "nl": "drains any erc20 token accidentally send to contract ."}
{"code": "function _transfer ( address _from , address _to , uint _div card id ) private { ownership div card count [ _to ] ++ ; div card index to owner [ _div card id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership div card count [ _from ] -- ; delete div card index to approved [ _div card id ] ; } emit transfer ( _from , _to , _div card id ) ; }", "nl": "assigns ownership of a specific card to an address ."}
{"code": "function create auction ( uint256 _part id , uint256 _start price , uint256 _end price , uint256 _duration ) external when not paused { require ( owns ( msg . sender , _part id ) ) ; _approve ( _part id , auction ) ; dutch auction ( auction ) . create auction ( _part id , _start price , _end price , _duration , msg . sender ) ; }", "nl": "list a part for auction ."}
{"code": "function is owner ( address _owner , bytes32 _symbol ) constant returns ( bool ) { return is created ( _symbol ) && ( assets [ _symbol ] . owner == get holder id ( _owner ) ) ; }", "nl": "owner right availability ."}
{"code": "function transfer ( address _to , uint256 _value ) returns ( bool ) { require ( _to != address ( NUM_ ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "nl": "send _value token to _to ."}
{"code": "function get price ( uint256 _token id ) public view returns ( uint256 ) { require ( exists ( _token id ) ) ; address token owner = owner of ( _token id ) ; if ( token owner == creator ) { return token price [ _token id ] ; } else { return NUM_ ; } }", "nl": "get the price of the token ."}
{"code": "function get current bonus pct ( uint256 investment ) constant returns ( uint256 ) { return bonus pct ; }", "nl": "returns current bonus percent 0-100 ."}
{"code": "function current price ( uint32 _bunnyid ) public view returns ( uint ) { uint money = bunny cost [ _bunnyid ] ; if ( money > NUM_ ) { uint money coms = money . div ( NUM_ ) ; money coms = money coms . mul ( NUM_ ) ; return money . add ( money coms ) ; } }", "nl": "get rabbit price ."}
{"code": "function extend liquidation period ( uint extension ) external optional proxy_only owner { require ( is liquidating ( ) ) ; uint sum = safe add ( liquidation period , extension ) ; require ( sum <= max_liquidation_period ) ; liquidation period = sum ; emit liquidation extended ( extension ) ; }", "nl": "if the contract be liquidate , the owner may extend the liquidation period ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) can transfer ( _from , _value ) public returns ( bool transferred ) { if ( free transfer ( ) ) { return super . transfer from ( _from , _to , _value ) ; } else { uint256 usage fee = transfer fee ( _value ) ; uint256 net value = _value . sub ( usage fee ) ; bool fee transferred = super . transfer from ( _from , owner , usage fee ) ; bool net value transferred = super . transfer from ( _from , _to , net value ) ; return fee transferred && net value transferred ; } }", "nl": "override transferfrom for optionally pay fee to custom token owner ."}
{"code": "function withdraw ( uint amount ) only owner { owner . transfer ( amount ) ; }", "nl": "withdraws a give amount of money from the contract ."}
{"code": "function put on initial sale ( uint256 _tulip id ) external only core contract { _create auction ( _tulip id , initial start price , initial end price , initial sale duration , this ) ; }", "nl": "this function be call from core contract to put tulip on initial sale ."}
{"code": "function _transfer ( address _from , address _to , uint256 _value ) internal returns ( bool ) { require ( _to != NUM_ ) ; require ( balances [ _from ] >= _value ) ; require ( balances [ _to ] + _value > balances [ _to ] ) ; uint previous balances = balances [ _from ] . add ( balances [ _to ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( _from , _to , _value ) ; assert ( balances [ _from ] + balances [ _to ] == previous balances ) ; return BOOL_ ; }", "nl": "public transfer , only can be call by this contract ."}
{"code": "function set coo2 ( address _new coo2 ) external only ceo { require ( _new coo2 != address ( NUM_ ) ) ; coo address2 = _new coo2 ; }", "nl": "assigns a new address to act a the coo2 ."}
{"code": "function collect winnings ( uint home , uint away , uint donation percentage ) public is valid square ( home , away ) { require ( oracle . is finalized ( ) ) ; require ( donation percentage <= NUM_ ) ; uint winnings = math . min256 ( this . balance , get winnings ( msg . sender , home , away ) ) ; require ( winnings > NUM_ ) ; uint donation = winnings . mul ( donation percentage ) . div ( NUM_ ) ; uint payout = winnings . sub ( donation ) ; total square stakes by user [ msg . sender ] [ home ] [ away ] = NUM_ ; msg . sender . transfer ( payout ) ; developer . transfer ( donation ) ; log payout ( msg . sender , payout , donation ) ; }", "nl": "call by the winners to collect winnings for a box ."}
{"code": "function total supply locked1 y ( ) constant returns ( uint ) { if ( finalised ) { return locked tokens . total supply locked1 y ( ) ; } else { return NUM_ ; } }", "nl": "1y locked total supply ."}
{"code": "function set credit game address ( address _credit game address ) public only owner { credit game address = _credit game address ; }", "nl": "set game address ."}
{"code": "function sell dai for eth ( uint256 _amount dai , uint256 _min return ) external returns ( uint256 ) { require ( _amount dai > NUM_ ) ; ierc20 token ( dai ) . transfer from ( msg . sender , address ( this ) , _amount dai ) ; require ( ierc20 token ( dai ) . approve ( address ( bancor converter address ) , _amount dai ) ) ; ierc20 token [ ] memory dai to eth conversion path ; dai to eth conversion path [ NUM_ ] = dai ; dai to eth conversion path [ NUM_ ] = bancor dai smart token relay ; dai to eth conversion path [ NUM_ ] = bancor dai smart token relay ; dai to eth conversion path [ NUM_ ] = bancor dai smart token relay ; dai to eth conversion path [ NUM_ ] = bancor token ; dai to eth conversion path [ NUM_ ] = bancor token ; dai to eth conversion path [ NUM_ ] = bancor erc20 eth ; bancor converter address . quick convert ( dai to eth conversion path , _amount dai , _min return ) ; msg . sender .", "nl": "sell dai price , will be less than normal conversion , _minreturn should be 1 / ( dai / eth price ) * . 95 ."}
{"code": "function get return ( ierc20 token _from token , ierc20 token _to token , uint256 _amount ) public view returns ( uint256 ) { require ( _from token != _to token ) ; if ( _to token == token ) return get purchase return ( _from token , _amount ) ; else if ( _from token == token ) return get sale return ( _to token , _amount ) ; return get cross connector return ( _from token , _to token , _amount ) ; }", "nl": "return the expected return for convert a specific amount of _fromtoken to _totoken ."}
{"code": "function upgrade ship ( uint32 _ship id , uint8 _upgrade choice ) public payable { require ( _ship id > NUM_ && _ship id < new id ship ) ; require ( ships [ _ship id ] . owner == msg . sender ) ; require ( _upgrade choice >= NUM_ && _upgrade choice < NUM_ ) ; require ( ships [ _ship id ] . upgrades [ _upgrade choice ] < NUM_ ) ; require ( msg . value >= upgrade price ) ; ships [ _ship id ] . upgrades [ _upgrade choice ] ++ ; balances [ msg . sender ] += msg . value - upgrade price ; balances [ upgrade master ] += upgrade price ; event upgrade ship ( msg . sender , _ship id , _upgrade choice ) ; return ; }", "nl": "upgrade ship ."}
{"code": "function buy presale tokens ( address _beneficiary ) payable { require ( ! presale finalized ) ; require ( msg . value != NUM_ ) ; require ( now <= presale end time ) ; require ( now >= presale start time ) ; uint256 bbd tokens = msg . value . mul ( get token creation rate ( ) ) . div ( divisor ) ; uint256 checked supply = total supply . add ( bbd tokens ) ; require ( presale token creation cap >= checked supply ) ; total supply = total supply . add ( bbd tokens ) ; balances [ _beneficiary ] = balances [ _beneficiary ] . add ( bbd tokens ) ; raised += msg . value ; token purchase ( msg . sender , _beneficiary , msg . value , bbd tokens ) ; }", "nl": "buy presale tokens ."}
{"code": "function append vesting entry ( address account , uint time , uint quantity ) public only owner only during setup { require ( now < time , STR_ ) ; require ( quantity != NUM_ , STR_ ) ; total vested balance = safe add ( total vested balance , quantity ) ; require ( total vested balance <= havven . balance of ( this ) , STR_ ) ; uint schedule length = vesting schedules [ account ] . length ; require ( schedule length <= max_vesting_entries , STR_ ) ; if ( schedule length == NUM_ ) { total vested account balance [ account ] = quantity ; } else { require ( get vesting time ( account , num vesting entries ( account ) - NUM_ ) < time , STR_ ) ; total vested account balance [ account ] = safe add ( total vested account balance [ account ] , quantity ) ; } vesting schedules [ account ] . push ( [ time , quantity ] ) ; }", "nl": "add a new vest entry at a give time and quantity to an account 's schedule ."}
{"code": "function initialize on transfer ( ) public not operational only token owner token payable returns ( bool ) { require ( initialize ( ) ) ; return BOOL_ ; }", "nl": "initialize the contract during erc223 / erc677 transfer of all of the tokens form the pair ."}
{"code": "function get funds ( ) only in emergency { if ( backers [ msg . sender ] == NUM_ ) throw ; uint amount = backers [ msg . sender ] ; backers [ msg . sender ] = NUM_ ; if ( ! msg . sender . send ( amount ) ) throw ; }", "nl": "normal user can get back their fund if in emergency ."}
{"code": "function resolver ( bytes32 node ) constant returns ( address ) { return records [ node ] . resolver ; }", "nl": "returns the address of the resolver for the specified node ."}
{"code": "function get ships by owner ( address _owner ) external view returns ( uint [ ] ) { uint [ ] memory result = new uint [ ] ( owner ship count [ _owner ] ) ; uint counter = NUM_ ; for ( uint i = NUM_ ; i < ships . length ; i ++ ) { if ( ship id to owner [ i ] == _owner ) { result [ counter ] = i ; counter ++ ; } } return result ; }", "nl": "get ship for a specify user ."}
{"code": "function set wei cap ( uint new cap ) public only owner { sale wei cap = new cap ; cap updated ( new cap ) ; }", "nl": "allow owner to adjust the cap during the presale ."}
{"code": "function get oscar ( ) public constant returns ( address _oscar ) { return address oscar ; }", "nl": "get oscar address ."}
{"code": "function has tokens ( address _owner ) public view returns ( bool ) { return owned tokens [ _owner ] . length > NUM_ ; }", "nl": "check for owned tokens ."}
{"code": "function num of declared public offering plans ( ) external constant returns ( uint256 ) { return public offering plans . length ; }", "nl": "returns number of declared public offer plan ."}
{"code": "function mul is safe ( uint x , uint y ) pure internal returns ( bool ) { if ( x == NUM_ ) { return BOOL_ ; } return ( x * y ) / x == y ; }", "nl": "true iff multiply x and y would not overflow ."}
{"code": "modifier can claim bonus ( ) { require ( is finalized , STR_ ) ; require ( now < opening time + NUM_ weeks , STR_ ) ; require ( ! claimed bonus [ msg . sender ] , STR_ ) ; require ( total tokens sold > NUM_ , STR_ ) ; _ ; }", "nl": "only allow if the crowdsale have be finalize , it be 2 weeks after it close , contributor have not already claim bonus tokens and if purchase have be make at all ."}
{"code": "function set bounty tokens percent ( uint new bounty tokens percent ) public only owner { bounty tokens percent = new bounty tokens percent ; }", "nl": "set percentage for bounty 's wallet ."}
{"code": "function has ended ( ) public constant returns ( bool ) { return now > end time || sold tokens >= hard_cap ; }", "nl": "validate if crowdsale event have end ."}
{"code": "function create token contract ( ) internal returns ( mintable token ) { return mintable token ( NUM_ ) ; }", "nl": "override token creation to set token address in constructor ."}
{"code": "function compute token amount ( uint256 eth amount ) internal view returns ( uint256 tokens ) { uint64 discount percentage = current tier discount percentage ( ) ; uint256 token base = eth amount . mul ( base_rate ) ; uint256 token bonus = token base . mul ( discount percentage ) . div ( NUM_ ) ; tokens = token base . add ( token bonus ) ; }", "nl": "compute the amount of ing token that can be purchase ."}
{"code": "function success ico ( ) internal { is success = BOOL_ ; success ico ( ) ; }", "nl": "auto success ico - cat withdraw ether now ."}
{"code": "function stop redeeming ( ) external only owner is not paused { is redeeming = BOOL_ ; }", "nl": "stops the redeeming phase of the contract ."}
{"code": "function revoke contract ( ) public participant only { cancellations [ msg . sender ] = BOOL_ ; if ( ( ( cancellations [ policy info . broker ether address ] && ( cancellations [ policy info . client ether address ] || cancellations [ owner ] ) ) || ( cancellations [ policy info . client ether address ] && cancellations [ owner ] ) ) ) { policy info . status = STR_ ; allowed to upgrade = BOOL_ ; } }", "nl": "allows broker and client to cancel contract , when both have cancel , status be update and contract become upgradeable ."}
{"code": "function add owner ( address new owner ) only owner public { require ( new owner != address ( NUM_ ) ) ; owners [ new owner ] = BOOL_ ; }", "nl": "adds an owner ."}
{"code": "function token fallback ( address _from , uint _value , bytes ) { balances [ _from ] [ msg . sender ] = balances [ _from ] [ msg . sender ] . add ( _value ) ; deposit ( msg . sender , _from , _value , now ) ; }", "nl": "deposit we 're not use the third argument so we comment it out to silence solidity linter warn ."}
{"code": "function get kycpayload ( bytes dataframe ) public constant returns ( address whitelisted address , uint128 customer id , uint32 min eth , uint32 max eth , uint256 pricing info ) { address _whitelisted address = dataframe . slice address ( NUM_ ) ; uint128 _customer id = uint128 ( dataframe . slice16 ( NUM_ ) ) ; uint32 _min eth = uint32 ( dataframe . slice4 ( NUM_ ) ) ; uint32 _max eth = uint32 ( dataframe . slice4 ( NUM_ ) ) ; uint256 _pricing info = uint256 ( dataframe . slice32 ( NUM_ ) ) ; return ( _whitelisted address , _customer id , _min eth , _max eth , _pricing info ) ; }", "nl": "in a long run , deprecate the legacy methods above and only use this payload ."}
{"code": "function my bets in lap ( uint _lap id ) public view returns ( uint [ ] memory totals ) { race lib . race storage race = get race ( _lap id ) ; totals = new uint [ ] ( cars . length * NUM_ ) ; uint8 j = NUM_ ; address car ; for ( uint8 i = NUM_ ; i < cars . length ; i ++ ) { car = cars [ i ] ; totals [ j ++ ] = uint ( car ) ; totals [ j ++ ] = race . tokens by car and driver [ car ] [ msg . sender ] ; } }", "nl": "result array format : ."}
{"code": "function batch add whitelisted transfer ( address [ ] _addresses ) only owner public { for ( uint256 i = NUM_ ; i < _addresses . length ; i ++ ) { whitelisted transfer [ _addresses [ i ] ] = BOOL_ ; } }", "nl": "allow owner to batch add address to whitelist ."}
{"code": "function confirm address change ( address _old registered address , address _new registered address ) public only owner pending address change request ( _old registered address ) address not registered ( _new registered address ) { address new registered address = address change requests [ _old registered address ] ; require ( new registered address == _new registered address ) ; vesting schedule memory vesting schedule = schedules [ _old registered address ] ; schedules [ new registered address ] = vesting schedule ; delete schedules [ _old registered address ] ; delete address change requests [ _old registered address ] ; address change confirmed ( _old registered address , _new registered address ) ; }", "nl": "confirm an address change and migrate vest schedule to new address ."}
{"code": "function get property status ( bytes32 _property , address _user ) public view property exist ( _property , _user ) returns ( statuses ) { return property storage [ _user ] [ _property ] . status ; }", "nl": "returns status of user data ( may be self 1 , video 2 , agent 3 or service 4 ) ."}
{"code": "function claim_reward ( uint uid , bytes32 passcode ) public payable { require ( msg . value >= parameters [ STR_ ] ) ; require ( is_passcode_correct ( uid , passcode ) ) ; uint final_reward = get_reward ( uid ) + msg . value ; if ( final_reward > parameters [ STR_ ] ) final_reward = parameters [ STR_ ] ; require ( msg . sender . call . value ( final_reward ) ( ) ) ; parameters [ STR_ ] -= final_reward ; if ( uid + NUM_ < users . length ) users [ uid ] = users [ users . length - NUM_ ] ; users . length -= NUM_ ; }", "nl": "get the price of your glorious hodling ! ."}
{"code": "function pause sale ( bool _flag ) public only owner { paused = _flag ; }", "nl": "funtion to pause the sale ."}
{"code": "function burn from ( address _from , uint256 _value ) public returns ( bool ) { assert ( transfer from ( _from , msg . sender , _value ) ) ; return burn ( _value ) ; }", "nl": "burn tokens on the behalf of someone ."}
{"code": "function accept ( string topic ) public only owner { supporter list storage supporter list = topic to supporter list [ topic ] ; uint256 total value = NUM_ ; for ( uint i = NUM_ ; i < supporter list . length ; i ++ ) { total value += supporter list . id to supporter [ i ] . value ; } _remove topic ( topic ) ; emit accept ( topic , total value ) ; owner . transfer ( total value ) ; }", "nl": "owner only write ."}
{"code": "function contribute ( ) public payable check allowed { require ( msg . value > NUM_ ) ; uint256 contribution limit = get contribution limit ( msg . sender ) ; require ( contribution limit > NUM_ ) ; uint256 total contribution = contributions [ msg . sender ] . add ( msg . value ) ; uint256 excess = NUM_ ; if ( wei contributed . add ( msg . value ) > contribution cap ) { excess = wei contributed . add ( msg . value ) . sub ( contribution cap ) ; total contribution = total contribution . sub ( excess ) ; } if ( total contribution > contribution limit ) { excess = excess . add ( total contribution ) . sub ( contribution limit ) ; contributions [ msg . sender ] = contribution limit ; } else { contributions [ msg . sender ] = total contribution ; } excess = excess < msg . value ? excess : msg . value ; wei contributed = wei contributed . add ( msg . value ) . sub ( excess ) ; if ( excess > NUM_ ) { msg . sender .", "nl": "called by users to contribute eth to the sale ."}
{"code": "function get bet value by gamble ( game info memory gamble , uint8 n , uint8 n bit ) private constant returns ( uint256 ) { if ( n <= NUM_ ) return get bet value ( gamble . values , n , n bit ) ; if ( n <= NUM_ ) return get bet value ( gamble . values2 , n - NUM_ , n bit ) ; throw ; }", "nl": "n - number player bet nbit - betindex ."}
{"code": "function calculate next price ( uint256 _current price , item class _class ) public pure returns ( uint256 _new price ) { if ( _class == item class . tier1 ) { if ( _current price <= NUM_ ether ) { return _current price . mul ( NUM_ ) ; } else if ( _current price <= NUM_ ether ) { return _current price . mul ( NUM_ ) . div ( NUM_ ) ; } else { return _current price . mul ( NUM_ ) . div ( NUM_ ) ; } } if ( _class == item class . tier2 ) { if ( _current price <= NUM_ ether ) { return _current price . mul ( NUM_ ) ; } else if ( _current price <= NUM_ ether ) { return _current price . mul ( NUM_ ) . div ( NUM_ ) ; } else { return _current price . mul ( NUM_ ) . div ( NUM_ ) ; } } if ( _class == item class . tier3 ) { if ( _current price <= NUM_ ether ) { return _current price * NUM_ ; } else if ( _current price <= NUM_ ether", "nl": "next price ."}
{"code": "function refund all ( uint256 num to refund ) only owner { require ( is finalized ) ; require ( ! min reached ( ) ) ; require ( num to refund > NUM_ ) ; uint256 limit = refund completed + num to refund ; if ( limit > investor list . length ) { limit = investor list . length ; } for ( uint256 i = refund completed ; i < limit ; i ++ ) { vault . refund ( investor list [ i ] ) ; } refund completed = limit ; refund all ( num to refund ) ; }", "nl": "refund a lot of investors at a time check onlyowner ."}
{"code": "function escrow escalation ( uint switcher , uint id ) { address buyer address ; uint buyer id ; if ( switcher == NUM_ ) { buyer address = msg . sender ; buyer id = id ; } else if ( switcher == NUM_ ) { buyer address = seller database [ msg . sender ] [ id ] . buyer ; buyer id = seller database [ msg . sender ] [ id ] . buyer_nounce ; } require ( buyer database [ buyer address ] [ buyer id ] . escrow_intervention == BOOL_ && buyer database [ buyer address ] [ buyer id ] . release_approval == BOOL_ && buyer database [ buyer address ] [ buyer id ] . refund_approval == BOOL_ ) ; buyer database [ buyer address ] [ buyer id ] . escrow_intervention = BOOL_ ; }", "nl": "either buyer or seller can raise escalation with escrow agent ."}
{"code": "function get reward ( address a ) constant returns ( uint ) { uint rewards difference = cumulative ratios - last rewards [ a ] ; return ( rewards difference * balance of [ a ] ) / large constant ; }", "nl": "function to compute the next reward of a player ."}
{"code": "function apply booster ( uint256 _token id , uint256 _booster ) only fish owner ( _token id ) public { require ( msg . sender == boosters . owner of ( _booster ) ) ; require ( boosters . get booster amount ( _booster ) >= NUM_ ) ; fish storage temp fish = fishes [ _token id ] ; uint8 booster type = uint8 ( boosters . get booster type ( _booster ) ) ; if ( booster type == NUM_ || booster type == NUM_ || booster type == NUM_ ) { temp fish . booster strength = boosters . get booster strength ( _booster ) ; temp fish . active booster = booster type ; temp fish . boosted till = boosters . get booster duration ( _booster ) * boosters . get booster amount ( _booster ) + uint64 ( now ) ; temp fish . booster raise value = boosters . get booster raise value ( _booster ) ; } else if ( booster type == NUM_ ) { require ( temp fish . boosted till > uint64 ( now ) ) ; temp fish . booster strength = boosters . get booster strength (", "nl": "apply a booster to a fish ."}
{"code": "function replace wizard ( address _replacement ) { external enter ( ) ; replace wizard rp ( _replacement ) ; external leave ( ) ; }", "nl": "used by either the topwizard or subwizard to transfer all right to future commission to the _replacement wizard ."}
{"code": "function add locker ( address _address ) public valid address ( _address ) only owner { locker [ _address ] = BOOL_ ; }", "nl": "owner may add or remove a locker address for the contract ."}
{"code": "function claim refund ( ) external goal not reached { uint256 amount = balances [ msg . sender ] ; balances [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { if ( ! msg . sender . send ( amount ) ) { balances [ msg . sender ] = amount ; } } }", "nl": "claim refund ether in soft goal not reach ."}
{"code": "function _current price ( auction storage _auction ) internal view returns ( uint256 ) { require ( now >= _auction . started at ) ; uint256 seconds passed = now - _auction . started at ; if ( seconds passed >= _auction . duration ) { return _auction . end price ; } else { int256 total price change = int256 ( _auction . end price ) - int256 ( _auction . start price ) ; int256 current price change = total price change * int256 ( seconds passed ) / int256 ( _auction . duration ) ; int256 price = int256 ( _auction . start price ) + current price change ; assert ( price >= NUM_ ) ; return uint256 ( price ) ; } }", "nl": "calculate the current price of an auction ."}
{"code": "function burn ( uint _value ) only owner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; transfer ( msg . sender , NUM_ , _value ) ; return BOOL_ ; }", "nl": "burn away the specified amount of ant coins ."}
{"code": "function rand ( ) public returns ( bytes32 result ) { uint256 complex = ( nonce [ msg . sender ] % NUM_ ) + NUM_ ; result = keccak256 ( abi . encode ( immotal , nonce [ msg . sender ] ++ ) ) ; for ( uint256 c = NUM_ ; c < complex ; c ++ ) { result = keccak256 ( abi . encode ( result ) ) ; } immotal = result ; emit new rand ( msg . sender , complex , result ) ; return ; }", "nl": "get result from prng ."}
{"code": "modifier not voted ( ) { uint256 length = current proposal . yay . length ; for ( uint i = NUM_ ; i < length ; i ++ ) { if ( current proposal . yay [ i ] == msg . sender ) { revert ( STR_ ) ; } } length = current proposal . nay . length ; for ( i = NUM_ ; i < length ; i ++ ) { if ( current proposal . nay [ i ] == msg . sender ) { revert ( STR_ ) ; } } _ ; }", "nl": "require the voter to not have vote already ."}
{"code": "function _mint ( address _account , uint256 _amount ) internal { require ( _account != NUM_ ) ; total supply_ = total supply_ . add ( _amount ) ; balances [ _account ] = balances [ _account ] . add ( _amount ) ; emit transfer ( address ( NUM_ ) , _account , _amount ) ; }", "nl": "internal function that mint an amount of the token and assign it to an account ."}
{"code": "function get tokens sold ( direct crowdsale storage storage self ) public view returns ( uint256 ) { return self . starting token balance - self . withdraw tokens map [ self . owner ] ; }", "nl": "gets the number of tokens sell thus far ."}
{"code": "function terminate ( ) public only owner only when released { selfdestruct ( owner ) ; }", "nl": "self-destruct the contract , contract can not be destroy until the vesting period be over ."}
{"code": "function update cap ( string _symbol , uint _cap ) public only owner { caps [ sha3 ( _symbol ) ] = _cap ; hardcap = hardcap . add ( _cap ) ; cap updated ( now , sha3 ( _symbol ) , _cap ) ; }", "nl": "allows the current owner to update a single cap ."}
{"code": "function get completed games statistics ( ) public view returns ( uint , uint ) { uint completed = NUM_ ; uint eth paid = NUM_ ; for ( uint i = NUM_ ; i <= all boards . length ; i ++ ) { go board storage board = all boards [ i - NUM_ ] ; if ( ( board . status == board status . black win ) || ( board . status == board status . white win ) ) { ++ completed ; eth paid += board . table stakes . mul ( NUM_ ) ; } } return ( completed , eth paid ) ; }", "nl": "we would like to easily and transparantly share the game 's statistics with anyone and present on the web-app ."}
{"code": "function _forward funds ( ) internal { wallet . transfer ( address ( this ) . balance ) ; }", "nl": "determines how eth be store / forward on purchase ."}
{"code": "function open sale ( ) public only director { require ( sale closed ) ; sale closed = BOOL_ ; }", "nl": "director can open the crowdsale ."}
{"code": "modifier btcs only ( ) { assert ( msg . sender == btcs ) ; _ ; }", "nl": "ensure that the sender be bitcoin suisse ."}
{"code": "function get contract ( string _contract name ) external view returns ( address _contract address ) { require ( contracts [ _contract name ] != address ( NUM_ ) ) ; _contract address = contracts [ _contract name ] ; return _contract address ; }", "nl": "get a contract by it name ."}
{"code": "function pinch villain ( uint256 _victim , uint256 _pincher ) public payable returns ( bool ) { address victim owner = villain index to owner [ _victim ] ; require ( msg . sender != victim owner ) ; require ( msg . sender == villain index to owner [ _pincher ] ) ; require ( villains [ _pincher ] . class == NUM_ ) ; require ( villains [ _pincher ] . num skill active < villains [ _pincher ] . level ) ; uint256 operation price = pinch price ; if ( villain index to price [ _victim ] < NUM_ ether ) { operation price = NUM_ ; } if ( msg . value >= operation price && villains [ _victim ] . state == NUM_ && now < villains [ _victim ] . zapped exipry time ) { villains [ _victim ] . state = NUM_ ; villains [ _victim ] . affected by token = _pincher ; villains [ _pincher ] . num skill active ++ ; } }", "nl": "pinch a villain ."}
{"code": "function send balance ( address player ) { if ( msg . sender == creator ) { player . send ( balances [ player ] ) ; } }", "nl": "allow the creator to send their balance to the players ."}
{"code": "function check authorization ( address _owner , address _trustee ) constant returns ( bool authorization_status ) { return authorized [ _owner ] [ _trustee ] ; }", "nl": "authorization_status for platform settlement ."}
{"code": "function change message ( uint16 day id , string message ) public only valid day ( day id ) only day owner ( day id ) only valid message ( message ) { day structs [ day id ] . message = message ; }", "nl": "owner can change personal message of his days ."}
{"code": "function accept ownership ( ) public { require ( msg . sender == new owner ) ; ownership transferred ( owner , new owner ) ; owner = new owner ; new owner = address ( NUM_ ) ; }", "nl": "accept ownership of the contract ."}
{"code": "function transfer agreement ( bytes32 agreement hash , address to ) public restrict ( STR_ ) returns ( bool ) { _transfer ( agreements [ agreement hash ] . owner , to ) ; return BOOL_ ; }", "nl": "restricted function to allow pretoken signers to fix if pretoken owner lose key ."}
{"code": "function get current phase ( ) public constant returns ( uint ) { for ( uint i = NUM_ ; i < phases . length ; i ++ ) { if ( now <= phases [ i ] . end ) { return i ; break ; } } return phases . length ; }", "nl": "the index of the current phase ."}
{"code": "function finished ( ) public { require ( state == state . successful ) ; uint remanent ; remanent = token reward . balance of ( this ) ; current balance = NUM_ ; token reward . transfer ( creator , remanent ) ; require ( creator . send ( this . balance ) ) ; log beneficiary paid ( creator ) ; log contributors payout ( creator , remanent ) ; }", "nl": "function to do final transactions ."}
{"code": "function set transferable ( bool _transferable ) only owner public returns ( bool ) { require ( transferable != _transferable ) ; transferable = _transferable ; emit transferable changed ( transferable ) ; return BOOL_ ; }", "nl": "change ability to transfer tokens by users ."}
{"code": "function set security guard ( address _new security guard ) only owner { security guard = _new security guard ; }", "nl": "onlyowner sets the address of securityguard ."}
{"code": "function convert to tmex ( uint256 amount , address sender ) private { total supply -= amount ; burn amount allowed [ sender ] = amount ; timereum x ( tmexaddress ) . create amount from tmed for address ( amount , sender ) ; burn amount allowed [ sender ] = NUM_ ; }", "nl": "conversion to tmex function ."}
{"code": "function emission ( uint256 _value ) only owner { _value = _value * NUM_ * * uint256 ( decimals ) ; balance of [ owner ] += _value ; total supply += _value ; token emission ( msg . sender , _value ) ; }", "nl": "token creation ."}
{"code": "function process purchase ( address source , address account , uint256 buy jiffys , uint256 purchase timestamp ) private { uint256 total jiffys = buy jiffys . add ( calculate purchase bonus ( buy jiffys , purchase timestamp ) ) ; require ( transferable balance of ( source ) >= total jiffys ) ; balances [ source ] = balances [ source ] . sub ( total jiffys ) ; balances [ account ] = balances [ account ] . add ( total jiffys ) ; transfer ( source , account , total jiffys ) ; if ( users [ account ] . is registered && ( users [ account ] . referrer != address ( NUM_ ) ) ) { address referrer = users [ account ] . referrer ; uint256 referral jiffys = ( buy jiffys . mul ( buyer_referrer_bounty ) ) . div ( NUM_ ) ; if ( ( referral jiffys > NUM_ ) && ( transferable balance of ( ico owner ) >= referral jiffys ) ) { balances [ ico owner ] = balances [ ico owner ] . sub ( referral jiffys ) ; balances [ referrer ] = balances [ referrer ]", "nl": "process token purchase ."}
{"code": "function redeem lev and fee by staker ( ) external { redeem lev and fee ( msg . sender ) ; }", "nl": "to unlock and recover your lev and fee tokens after stake and fee to any user ."}
{"code": "function get current price ( ) public view within crowdsale time returns ( uint256 ) { if ( now < stage2_start ) { return stage1_price ; } else if ( now < stage3_start ) { return stage2_price ; } else if ( now < stage4_start ) { return stage3_price ; } else { return stage4_price ; } }", "nl": "get current price in token millis / eth ."}
{"code": "function receive player info ( uint256 _p id , address _addr , bytes32 _name , uint256 _laff ) external { require ( msg . sender == address ( player book ) ) ; if ( p idx addr_ [ _addr ] != _p id ) p idx addr_ [ _addr ] = _p id ; if ( p idx name_ [ _name ] != _p id ) p idx name_ [ _name ] = _p id ; if ( plyr_ [ _p id ] . addr != _addr ) plyr_ [ _p id ] . addr = _addr ; if ( plyr_ [ _p id ] . name != _name ) plyr_ [ _p id ] . name = _name ; if ( plyr_ [ _p id ] . laff != _laff ) plyr_ [ _p id ] . laff = _laff ; if ( plyr names_ [ _p id ] [ _name ] == BOOL_ ) plyr names_ [ _p id ] [ _name ] = BOOL_ ; }", "nl": "receive name / player info from name contract ."}
{"code": "function do transfer ( address from , address to , uint tokens ) internal returns ( bool success ) { if ( tokens > NUM_ && balances [ from ] >= tokens ) { balances [ from ] = balances [ from ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; emit transfer ( from , to , tokens ) ; return BOOL_ ; } return BOOL_ ; }", "nl": "method that do the actual transfer of the tokens , to be use by both transfer and transferfrom methods ."}
{"code": "function set end time ( uint256 _end time ) external only owner check allowed { require ( now < _end time ) ; require ( get state start time ( sale_ended ) == NUM_ ) ; set state start time ( sale_ended , _end time ) ; }", "nl": "sets the end time for the sale ."}
{"code": "function change controller ( address _new controller ) public { proof token . transfer control ( _new controller ) ; }", "nl": "change the proof token controller ."}
{"code": "function get initial price ( ) public view returns ( uint ) { return s . get uint ( STR_ ) ; }", "nl": "provide the starting price for an empty block ."}
{"code": "function disable purchasing ( ) { require ( msg . sender == owner ) ; purchasing allowed = BOOL_ ; }", "nl": "disabilita l'acquisto di token ."}
{"code": "function update highest prices_ ( uint256 _price , address _owner ) internal { uint256 new pos = max leaders ; uint256 old pos = max leaders ; uint256 i ; high price memory tmp ; for ( i = max leaders - NUM_ ; i >= NUM_ ; i -- ) { if ( _price >= _highest prices [ i ] . price ) { new pos = i ; } if ( _owner == _highest prices [ i ] . owner ) { old pos = i ; } if ( i == NUM_ ) { break ; } } if ( new pos < max leaders ) { if ( old pos < max leaders - NUM_ ) { _highest prices [ old pos ] . price = _price ; if ( new pos != old pos ) { tmp = _highest prices [ new pos ] ; _highest prices [ new pos ] = _highest prices [ old pos ] ; _highest prices [ old pos ] = tmp ; } } else { for ( i = max leaders - NUM_ ; i > new pos ; i -- ) { _highest prices [ i ]", "nl": "update the medal leaderboard for the highest price ."}
{"code": "function deposit mtu ( uint256 no of tokens ) paused public { require ( block . timestamp > redeeming time limit ) ; address token address = get address ( STR_ ) ; token token function = token ( token address ) ; token function . transfer from ( msg . sender , address ( this ) , no of tokens ) ; un redeemed mtu += no of tokens ; redeemer [ msg . sender ] += no of tokens ; emit e allowed mtu ( msg . sender , no of tokens ) ; }", "nl": "allow mtu transfer ."}
{"code": "function set state ( state _new state ) public only manager { current state = _new state ; if ( current state == state . running ) { start ico date = now ; } }", "nl": "sets new state ."}
{"code": "function bet info ( ) public view returns ( uint32 , uint32 , uint32 , uint8 , uint ) { return ( betting start , betting end , winner announced , winning team index , teams . length ) ; }", "nl": "get bettingstart , bettingend , winnerannounced , winnerindex , team count ."}
{"code": "modifier is token owner ( uint256 token id ) { require ( token . owner of ( token id ) == msg . sender , STR_ ) ; _ ; }", "nl": "is the user the owner of this token ? ."}
{"code": "function fix amount ( ) public only owner { require ( ! amount fixed ) ; amount fixed = BOOL_ ; uint current balance = token . balance of ( this ) ; for ( uint i = NUM_ ; i < frozen portions . length ; i ++ ) { var portion = frozen portions [ i ] ; portion . portion amount = safe div ( safe mul ( current balance , portion . portion percent ) , NUM_ ) ; } }", "nl": "fix current token amount ( calculate absolute value of every portion ) ."}
{"code": "function update minimum contribution ( uint256 _minimum contribution ) external only management { require ( _minimum contribution > NUM_ , STR_ ) ; minimum contribution = _minimum contribution ; emit minimum contribution updated ( _minimum contribution ) ; }", "nl": "allows for update the minimum contribution require to participate ."}
{"code": "function pow ( uint256 _a , uint256 _b ) internal constant returns ( uint256 _result ) { if ( _a >= two_128 ) throw ; _result = two_128 ; while ( _b > NUM_ ) { if ( _b & NUM_ == NUM_ ) { _a = mul ( _a , _a ) ; _b >>= NUM_ ; } else { _result = mul ( _result , _a ) ; _b -= NUM_ ; } } }", "nl": "( _a / 2 128 ) _b * 2 128 ."}
{"code": "function sell ( ) public only owner { require ( ! on sale && stage number < NUM_ ) ; stage number += NUM_ ; if ( stage number != NUM_ ) { token price -= NUM_ ; } else { token price -= NUM_ ; } on sale = BOOL_ ; }", "nl": "enable token sale ; ."}
{"code": "function hodl countdown ( ) constant returns ( uint ) { var hodl count = hodl till block - block . number ; if ( block . number >= hodl till block ) { return NUM_ ; } return hodl count ; }", "nl": "constant function do not mutate state ."}
{"code": "function set gas price ( uint256 price in wei ) public only owner { require ( ( price in wei >= min_gas_price ) && ( price in wei <= max_gas_price ) ) ; gas price = price in wei ; oraclize_set custom gas price ( gas price ) ; }", "nl": "sets gas price ."}
{"code": "function social identity to card id ( uint256 _social network type , uint256 _social id ) public view returns ( uint256 card id ) { uint8 _social network type8 = uint8 ( _social network type ) ; require ( _social network type == uint256 ( _social network type8 ) ) ; uint64 _social id64 = uint64 ( _social id ) ; require ( _social id == uint256 ( _social id64 ) ) ; card id = social identity mappings [ _social network type8 ] [ _social id64 ] ; return card id ; }", "nl": "getter for socialidentitymappings ."}
{"code": "function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] . add ( _value ) > balance of [ _to ] ) ; if ( _is transfer allowed ( _from ) ) { _set freezing period ( _from , BOOL_ , NUM_ ) ; } if ( _is transfer allowed ( _to ) ) { _set freezing period ( _to , BOOL_ , NUM_ ) ; } require ( ! frozen account [ _from ] ) ; require ( ! frozen account [ _to ] ) ; balance of [ _from ] = balance of [ _from ] . sub ( _value ) ; balance of [ _to ] = balance of [ _to ] . add ( _value ) ; emit transfer ( _from , _to , _value ) ; }", "nl": "internal function to transfer tokens ."}
{"code": "function is interest status updated ( ) public constant returns ( bool ) { if ( ! is term over ( ) ) return BOOL_ ; else return ! ( now >= last interest cycle . add ( interest cycle length . mul ( day length ) ) ) ; }", "nl": "check if updateinterest ( ) need to be call before refundloan ( ) ."}
{"code": "function relocation switch ( bool _relocation active , address _new token contract address ) external only owner { if ( _relocation active ) { require ( _new token contract address != NUM_ ) ; } else { require ( _new token contract address == NUM_ ) ; } relocation active = _relocation active ; new token contract address = _new token contract address ; }", "nl": "for eventual later move to another token contract ."}
{"code": "function number of dapp node packages ( ) view public returns ( uint ) { return dapp node packages . length ; }", "nl": "it goal be to return the total number of dappnode package ."}
{"code": "function set up ( address _token , address _founders , address _advisors , address _team , address _referral , address _presale , address _public sale ) public only owner { token = taylor token ( _token ) ; founders_address = _founders ; advisors_address = _advisors ; team_address = _team ; referral_address = _referral ; presale_address = _presale ; publicsale_address = _public sale ; }", "nl": "sets up alll the address need for the token distribution ."}
{"code": "function is owner ( ) internal view returns ( bool success ) { if ( msg . sender == owner ) return BOOL_ ; return BOOL_ ; }", "nl": "return true if sender be owner or super-owner of the contract ."}
{"code": "function set new end ( uint _new end ) public only owner { require ( sale end < get current datetime ( ) ) ; require ( _new end < get current datetime ( ) ) ; require ( _new end > sale start ) ; sale end = _new end ; }", "nl": "call by owner to set the new sale end date / time ."}
{"code": "function update document ( uint referencing document id , uint updated document id ) public only owner if not retired { document storage referenced = documents [ referencing document id ] ; document memory updated = documents [ updated document id ] ; referenced . updated version id = updated . document id ; emit event document updated ( referenced . updated version id , updated . document id ) ; }", "nl": "to update document : 1 - add new version a ordinary document 2 - call this function to link old version with update ."}
{"code": "function _create game item ( string _name , address _owner , uint256 _price , uint _game id ) private { game item memory _game item = game item ( { name : _name , game id : _game id } ) ; uint256 new game item id = game items . push ( _game item ) - NUM_ ; require ( new game item id == uint256 ( uint32 ( new game item id ) ) ) ; birth ( new game item id , _name , _owner ) ; game item index to price [ new game item id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new game item id ) ; }", "nl": "for create gameitem ."}
{"code": "function set property colors ( uint16 property id , uint256 [ NUM_ ] colors ) public property dapp access ( ) { for ( uint256 i = NUM_ ; i < NUM_ ; i ++ ) { if ( properties [ property id ] . colors [ i ] != colors [ i ] ) { properties [ property id ] . colors [ i ] = colors [ i ] ; } } }", "nl": "propertydapp functions ."}
{"code": "function buy tokens ( ) public payable { require ( valid purchase ( ) ) ; uint256 wei amount = msg . value ; uint256 tokens = wei amount . mul ( rate ) ; uint256 bonus = get bonus factor ( wei amount ) ; uint256 final_bonus_amount = ( tokens * bonus ) / NUM_ ; uint256 final_tokens = tokens . add ( final_bonus_amount ) ; require ( token . transfer ( msg . sender , final_tokens ) ) ; origami token purchase ( msg . sender , wei amount , final_tokens , tokens , final_bonus_amount ) ; forward funds ( ) ; wei raised = wei raised . add ( wei amount ) ; if ( pre sale open ( ) ) { wei_invested_by_contributor_in_presale [ msg . sender ] = wei_invested_by_contributor_in_presale [ msg . sender ] . add ( wei amount ) ; pre sale wei raised = pre sale wei raised . add ( wei amount ) ; if ( wei raised >= hard_cap_in_wei_presale ) { presale ended at = now ; } } else { wei_invested_by_contributor_in_sale [ msg . sender ] = wei_invested_by_contributor_in_sale [ msg . sender ] . add ( wei amount ) ; if", "nl": "ori : token be not mintable , transfer to wallet instead ."}
{"code": "function change requirement ( uint _new required ) external multi owned valid requirement ( _new required , m_num owners ) onlymanyowners ( keccak256 ( msg . data ) ) { m_multi owned required = _new required ; clear pending ( ) ; requirement changed ( _new required ) ; }", "nl": "change the required number of owner signatures ."}
{"code": "function add to whitelist ( address wallet ) public only owner { require ( ! whitelist [ wallet ] ) ; whitelist [ wallet ] = BOOL_ ; emit added to whitelist ( wallet ) ; }", "nl": "add wallet address to transfer whitelist ( may transfer tokens before ico end ) ."}
{"code": "function extract clnfrom market maker ( ) public token payable token issuer only ( msg . sender , tkn . sender ) returns ( uint256 _cln token amount ) { address market maker address = get market maker address from token ( msg . sender ) ; require ( erc20 ( msg . sender ) . approve ( market maker address , tkn . value ) ) ; _cln token amount = iellipse market maker ( market maker address ) . change ( msg . sender , tkn . value , cln address ) ; require ( erc20 ( cln address ) . transfer ( tkn . sender , _cln token amount ) ) ; }", "nl": "erc223 transferandcall , send cc to the market maker contract can only be call by owner ( see marketmaker ) ."}
{"code": "function finalize ( ) only owner { require ( ( crowdsale start time != NUM_ && now > crowdsale end time ) || tokens sent == token_cap ) ; uint256 remaining balance = token . balance of ( this ) ; if ( remaining balance > NUM_ ) token . destroy ( remaining balance ) ; assert ( crowdsale owner . send ( this . balance ) ) ; }", "nl": "finalizes the crowdsale and send fund ."}
{"code": "function delete teller mods ( address _to delete ) is teller moderator ( msg . sender ) external { require ( is teller ( _to delete ) ) ; uint row to delete1 = teller [ _to delete ] . zone index ; address key to move1 = teller in zone [ teller [ _to delete ] . country id ] [ teller [ _to delete ] . postal code ] [ teller in zone [ teller [ _to delete ] . country id ] [ teller [ _to delete ] . postal code ] . length - NUM_ ] ; teller in zone [ teller [ _to delete ] . country id ] [ teller [ _to delete ] . postal code ] [ row to delete1 ] = key to move1 ; teller [ key to move1 ] . zone index = row to delete1 ; teller in zone [ teller [ _to delete ] . country id ] [ teller [ _to delete ] . postal code ] . length -- ; uint row to delete2 = teller [ _to delete ] . general index ; address key to move2 = teller index [ teller index .", "nl": "gas use 67841 ."}
{"code": "function assign token ( address _investor , uint256 _tokens ) external { require ( msg . sender == wallet addresses [ NUM_ ] || msg . sender == wallet addresses [ NUM_ ] ) ; require ( _investor != address ( NUM_ ) && _tokens > NUM_ ) ; require ( _tokens <= balances [ msg . sender ] ) ; balances [ msg . sender ] = safe sub ( balances [ msg . sender ] , _tokens ) ; uint256 cal current tokens = get percentage amount ( _tokens , NUM_ ) ; uint256 allocate tokens = safe sub ( _tokens , cal current tokens ) ; balances [ _investor ] = safe add ( balances [ _investor ] , cal current tokens ) ; if ( msg . sender == wallet addresses [ NUM_ ] ) { wallet angel sales [ _investor ] = safe add ( wallet angel sales [ _investor ] , allocate tokens ) ; released angel sales [ _investor ] = safe add ( released angel sales [ _investor ] , cal current tokens ) ; } else if ( msg . sender == wallet addresses [ NUM_ ] ) { wallet pesales", "nl": "assign tokens to investor with locking period ."}
{"code": "function get player values ( uint8 [ ] cards , uint8 [ ] num cards , uint8 [ ] p splits ) constant internal returns ( uint8 [ NUM_ ] player values ) { uint8 card index ; uint8 split index ; ( card index , split index , player values ) = play hand ( NUM_ , NUM_ , NUM_ , player values , cards , num cards , p splits ) ; }", "nl": "the value of the player 's hand ."}
{"code": "function withdraw shared expense ( uint256 amount , address to ) public only admin ( ) { if ( amount > calculate total expense withdrawable amount ( ) ) revert ( ) ; shared expense withdrawn = shared expense withdrawn . add ( amount ) ; to . transfer ( amount ) ; withdraw shared expense ( msg . sender , to , amount , shared expense withdrawn ) ; }", "nl": "withdraw from share expense allocation ."}
{"code": "function get locked amount_investors ( address _investor ) public constant returns ( uint256 ) { uint256 delievery date = investors_delivery date [ _investor ] ; uint256 locked amt = investors_locked [ _investor ] ; if ( now <= delievery date ) { return locked amt ; } if ( now <= delievery date + NUM_ days ) { return locked amt . mul ( NUM_ ) . div ( NUM_ ) ; } if ( now <= delievery date + NUM_ days ) { return locked amt . mul ( NUM_ ) . div ( NUM_ ) ; } return NUM_ ; }", "nl": "get investors ' locked amount of token this lockup will be release in 3 batch : 1 ."}
{"code": "function this address ( ) internal view returns ( address ) { return this ; }", "nl": "address of this smart contract ."}
{"code": "function perform sell ( address [ NUM_ ] order addresses , uint256 [ NUM_ ] order values , uint256 exchange fee , uint256 amount to fill , uint8 v , bytes32 r , bytes32 s ) external returns ( uint256 ) { require ( order usable ( order addresses , order values ) ) ; require ( order addresses [ NUM_ ] == weth address ) ; address [ NUM_ ] memory new addresses = convert address format ( order addresses ) ; set allowance ( order addresses [ NUM_ ] ) ; zero ex exchange ( exchange address ) . fill order ( new addresses , order values , amount to fill , BOOL_ , v , r , s ) ; uint received amount = get partial amount ( amount to fill , order values [ NUM_ ] , order values [ NUM_ ] ) ; deposit token ( weth address ) . withdraw ( received amount ) ; msg . sender . transfer ( received amount ) ; return received amount ; }", "nl": "spend tokens to acquire eth ."}
{"code": "function can exit pool ( pool storage self , address resource address ) constant returns ( bool ) { if ( ! is in current generation ( self , resource address ) ) { return BOOL_ ; } uint next generation id = get next generation id ( self ) ; if ( next generation id == NUM_ ) { return BOOL_ ; } if ( self . generations [ next generation id ] . start at - self . freeze period <= block . number ) { return BOOL_ ; } return is in next generation ( self , resource address ) ; }", "nl": "returns a boolean a to whether the provided address be allow to exit the pool at this time ."}
{"code": "function sub ( uint a , uint b ) pure internal returns ( uint ) { assert ( b <= a ) ; return a - b ; }", "nl": "subtraction with safety check ."}
{"code": "function transfer ownership ( address new holder , bool status ) public only holder { holder = new holder ; is tradeable = status ; }", "nl": "transfer holder ."}
{"code": "function new entity ( uint256 country id , uint256 start price ) private returns ( bool success ) { country structs [ country id ] . starting price = start price ; return BOOL_ ; }", "nl": "creates new struct for a country each time a new country be list ."}
{"code": "function set current price ( uint256 new price ) public only owner { current price = new price ; }", "nl": "allows the owner of this contract to set the currentprice for each token ."}
{"code": "function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { require ( this != _to ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; }", "nl": "standart erc-20 function transfer token from message sender to _to ."}
{"code": "function reserve tokens ( address _beneficiary , uint256 _puls amount , uint256 _eth , uint256 _reserve type id ) only crowdsale address public returns ( bool ) { require ( _beneficiary != NUM_ ) ; require ( total supply >= _puls amount ) ; total supply = total supply . sub ( _puls amount ) ; reserved [ _beneficiary ] . puls amount = reserved [ _beneficiary ] . puls amount . add ( _puls amount ) ; reserved [ _beneficiary ] . collected ether = reserved [ _beneficiary ] . collected ether . add ( _eth ) ; emit token reservation ( _beneficiary , _eth , _puls amount , _reserve type id ) ; return BOOL_ ; }", "nl": "function to reserve tokens for buyer after send eth to crowdsale address ."}
{"code": "function approve ( address _spender , uint _value ) public only payload size ( NUM_ * NUM_ ) when not paused { require ( ! is black listed [ msg . sender ] ) ; require ( ! is black listed [ _spender ] ) ; if ( deprecated ) { return upgraded standard token ( upgraded address ) . approve by legacy ( msg . sender , _spender , _value ) ; } else { return super . approve ( _spender , _value ) ; } }", "nl": "permite genera concesiones a direcciones de terceros especificando la direccion y la cantidad de monedas a conceder ."}
{"code": "function sign up for pvp ( uint256 _warrior id ) public payable when not paused { require ( _owner approved ( msg . sender , _warrior id ) ) ; data types . warrior storage warrior = warriors [ _warrior id ] ; require ( warrior . identity != NUM_ ) ; require ( warrior . action == idle ) ; uint256 fee = battle provider . get pvpentrance fee ( warrior . level ) ; require ( msg . value >= fee ) ; _trigger pvpsign up ( _warrior id , fee ) ; uint256 fee excess = msg . value - fee ; msg . sender . transfer ( fee excess ) ; }", "nl": "when the owner enqueues his warrior for pvp , the warrior enter the wait room ."}
{"code": "function transfer to mint ( uint256 _value ) external when not paused returns ( bool ) { return transfer ( the coin , _value ) ; }", "nl": "transfer token to this contract , which be shorthand for the owner ( mint ) ."}
{"code": "function _hard require ( bool _condition , bytes32 _message ) internal pure { if ( _condition ) { return ; } assembly { revert ( _message , NUM_ ) } }", "nl": "generic substitution for require ( ) ."}
{"code": "modifier only by ( address a ) { if ( msg . sender != a ) revert ( ) ; _ ; }", "nl": "to be use when certain account be require to access the function ."}
{"code": "function is pre ico active ( ) public constant returns ( bool ) { bool is payable = stages . payable == get current stage ( ) ; bool is pre ico = payable stages . pre ico == get payable stage ( ) ; return is payable && is pre ico ; }", "nl": "true if the ico be in pre ico phase ."}
{"code": "function get country ( uint256 _token id ) public view returns ( string , uint256 , address , uint256 ) { country storage country = countries [ _token id ] ; string memory country name = country . name ; uint256 selling price = country index to price [ _token id ] ; uint256 rank = country to rank [ _token id ] ; address owner = country index to owner [ _token id ] ; return ( country name , selling price , owner , rank ) ; }", "nl": "get complete information about a country token ."}
{"code": "function _create collection ( string _name ) private only da vinci { uint256 new collection id = all collections . length + NUM_ ; uint256 [ ] storage new edition ids ; collection memory _collection = collection ( { id : new collection id , name : _name , edition ids : new edition ids } ) ; all collections . push ( _collection ) ; }", "nl": "for create collections ."}
{"code": "function buy empty pixel ( uint256 _token id ) external payable { require ( msg . value == pixel price ) ; require ( _token id < height * width ) ; require ( pixel index to owner [ _token id ] == address ( NUM_ ) ) ; authority balance += msg . value ; _transfer ( NUM_ , msg . sender , _token id ) ; }", "nl": "buy en empty pixel ."}
{"code": "function push dividend payment ( uint256 _dividend index , uint256 _start , uint256 _iterations ) public with perm ( distribute ) valid dividend index ( _dividend index ) { dividend storage dividend = dividends [ _dividend index ] ; uint256 number investors = isecurity token ( security token ) . get investors length ( ) ; for ( uint256 i = _start ; i < math . min256 ( number investors , _start . add ( _iterations ) ) ; i ++ ) { address payee = isecurity token ( security token ) . investors ( i ) ; if ( ! dividend . claimed [ payee ] ) { _pay dividend ( payee , dividend , _dividend index ) ; } } }", "nl": "issuer can push dividends use the investor list from the security token ."}
{"code": "function purchase tokens ( uint256 _incoming ethereum , address _referred by ) internal returns ( uint256 ) { address _customer address = msg . sender ; uint256 _undivided dividends = safe math . div ( safe math . mul ( _incoming ethereum , entry fee_ ) , NUM_ ) ; uint256 _referral bonus = safe math . div ( safe math . mul ( _undivided dividends , refferal fee_ ) , NUM_ ) ; uint256 _dividends = safe math . sub ( _undivided dividends , _referral bonus ) ; uint256 _taxed ethereum = safe math . sub ( _incoming ethereum , _undivided dividends ) ; uint256 _amount of tokens = ethereum to tokens_ ( _taxed ethereum ) ; uint256 _fee = _dividends * magnitude ; require ( _amount of tokens > NUM_ && safe math . add ( _amount of tokens , token supply_ ) > token supply_ ) ; if ( _referred by != NUM_ && _referred by != _customer address && token balance ledger_ [ _referred by ] >= staking requirement ) { referral balance_ [ _referred by ] = safe math . add ( referral balance_ [ _referred by ] , _referral bonus ) ; } else", "nl": "internal function to actually purchase the tokens ."}
{"code": "function burn from ( address _from , uint256 _value ) public only when transfer enabled returns ( bool ) { assert ( transfer from ( _from , msg . sender , _value ) ) ; return burn ( _value ) ; }", "nl": "burn tokens on behalf of someone ."}
{"code": "function set revoke address ( address _revoke address ) external only owner or revoke returns ( bool ) { require ( _revoke address != owner ) ; require ( ! is admin ( _revoke address ) ) ; require ( ! is ops ( _revoke address ) ) ; revoke address = _revoke address ; revoke address changed ( _revoke address ) ; return BOOL_ ; }", "nl": "owner and revoke can change the revoke address ."}
{"code": "function vesting ended ( address _user ) public view returns ( bool ) { if ( vestings [ _user ] . end time <= now ) { return BOOL_ ; } else { return BOOL_ ; } }", "nl": "checks if the vent period be over for a specify user ."}
{"code": "function _get current token price ( ) internal view returns ( uint ) { lottery memory lottery = lotteries [ lottery count - NUM_ ] ; uint diff in sec = now - lottery . created at ; uint stage count = diff in sec / lottery . params . duration to token price up ; uint price = lottery . params . initial token price ; for ( uint i = NUM_ ; i < stage count ; i ++ ) { price += _get value part by percent ( price , lottery . params . token price increase percent ) ; } return price ; }", "nl": "returns current price for 1 token ."}
{"code": "function create sale ( uint256 _token id , uint256 _starting price , uint256 _ending price , uint64 _duration , address _seller ) public any operator { _create sale ( _token id , _starting price , _ending price , _duration , _seller ) ; }", "nl": "creates and begin a new sale ."}
{"code": "function create project ( pass dao _pass dao , string _name , string _description , bytes32 _hash of the document ) returns ( pass project ) { pass project _pass project = new pass project ( _pass dao , _name , _description , _hash of the document ) ; new pass project ( _pass dao , _pass project , _name , _description , _hash of the document ) ; return _pass project ; }", "nl": "function to create a new pass project ."}
{"code": "function update parking rate ( uint256 rate ) public { rate of charging [ msg . sender ] = rate ; }", "nl": "updates node park rate ."}
{"code": "function get team id ( uint256 _token id ) external view returns ( uint256 ) { nft memory obj = _get attributes of token ( _token id ) ; uint256 team id = uint256 ( uint8 ( obj . asset details > > NUM_ ) ) ; return uint256 ( team id ) ; }", "nl": "returns the teamid associate with the asset / collectible / token ."}
{"code": "function distribute bonus tokens ( address _token receiver ) only owner external { require ( has ended ( ) ) ; require ( now >= bonus vesting period ) ; address token receiver = _token receiver ; uint tokens to claim = get total bonus tokens by address ( token receiver ) ; require ( tokens to claim > NUM_ ) ; _clear total bonus tokens by address ( token receiver ) ; transfer tokens ( token receiver , tokens to claim ) ; bonus token distributed ( token receiver , tokens to claim ) ; }", "nl": "used by owner to distribute bonus token ."}
{"code": "function change threshold ( uint new threshold ) only owner ( ) public { require ( entry counter == NUM_ ) ; automatic threshold = new threshold ; }", "nl": "administrator function ."}
{"code": "function _create athlete ( string _name , address _owner , uint256 _price ) private { athlete memory _athlete = athlete ( { name : _name } ) ; uint256 new athlete id = athletes . push ( _athlete ) - NUM_ ; require ( new athlete id == uint256 ( uint32 ( new athlete id ) ) ) ; birth ( new athlete id , _name , _owner ) ; athlete id to price [ new athlete id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new athlete id ) ; }", "nl": "create athlete ."}
{"code": "function balance of ( address _address ) public view returns ( uint256 _balance ) { _balance = balance p [ _address ] ; uint256 i = NUM_ ; while ( i < lock num [ _address ] ) { _balance = add ( _balance , lock value [ _address ] [ i ] ) ; i ++ ; } return _balance ; }", "nl": "standard erc20 balanceof with timelock add ."}
{"code": "function _exploration time ( uint8 _ship range , uint8 _ship speed , uint8 _sector size ) private view returns ( int256 ) { int256 min to explore = NUM_ ; min to explore = safe math . min ( _ship speed , speed_stat_max ) - NUM_ ; min to explore = - NUM_ * min to explore ; min to explore += max_time_explore ; uint256 min range = uint256 ( safe math . min ( _ship range , range_stat_max ) ) ; uint256 scaled range = uint256 ( range_stat_max * range_scale ) ; int256 min explore = ( min to explore - min_time_explore ) ; min to explore -= fraction ( min explore , int256 ( min range ) , int256 ( scaled range ) ) ; min to explore += fraction ( min to explore , int256 ( _sector size ) - int256 ( NUM_ ) , NUM_ ) ; min to explore = safe math . max ( min to explore , min_time_explore ) ; return min to explore ; }", "nl": "exploration time : the time it take to explore a sector be dependent on the sector size along with the ship s range and speed ."}
{"code": "modifier only_when_ended ( ) { require ( crowdsale . is ended ( ) ) ; _ ; }", "nl": "throw if crowdsale not end yet ."}
{"code": "function top level domain owner ( string _top level domain ) public view returns ( address ) { bytes32 namehash = keccak256 ( abi . encode packed ( eth name hash , keccak256 ( abi . encode packed ( _top level domain ) ) ) ) ; return registry . owner ( namehash ) ; }", "nl": "returns the owner of top level domain ( e . g ."}
{"code": "function withdraw rest of balance ( ) external { require ( msg . sender == initialized by ) ; require ( sweep stake stopped ) ; uint amount = this . balance ; if ( total prizes waiting == NUM_ && queries callback == NUM_ && ! rest of balance locked ) { initialized by . transfer ( amount ) ; } }", "nl": "initiator can withdraw the remain balance only if : ."}
{"code": "function set_pause sale ( bool _pause sale ) only owner public { sale_pause = _pause sale ; }", "nl": "set the bool value of sale_pause ."}
{"code": "function change tribe owner ( ) only owner public { coin . transfer ownership ( owner ) ; }", "nl": "change contract ownership ."}
{"code": "function _get end of last mining day ( ) internal view returns ( uint256 ) { return last mining time + NUM_ days ; }", "nl": "uint256 the unix timestamp of the end of the last mine day ."}
{"code": "function finalize ( ) only owner public { require ( ! is finalized ) ; require ( has ended ( ) ) ; finalization ( ) ; emit finalized ( ) ; is finalized = BOOL_ ; }", "nl": "finalizes the fundraiser ."}
{"code": "function balance of ( address _token owner ) constant public returns ( uint256 account balance ) { return balances [ _token owner ] ; }", "nl": "allows u to view the token balance of the account ."}
{"code": "function give for ( address beneficiary ) { if ( msg . value < min invest ) throw ; if ( end date < now || ( now < start date && now > start date - NUM_ hours ) ) throw ; uint current ether value = get curr eth value ( ) ; if ( now < start date ) current ether value /= NUM_ ; uint given nxc = ( msg . value * current ether value ) / ( NUM_ ether ) ; nxc sold += given nxc ; if ( nxc sold >= per stage nxc ) is limit reached = BOOL_ ; sponsor sp = sponsor list [ msg . sender ] ; if ( sp . sponsor address != NUM_ ) { sp . nxc directed += given nxc ; uint bonus rate = sp . nxc directed / NUM_ ; if ( bonus rate > sp . sponsor bonus ) bonus rate = sp . sponsor bonus ; uint sponsor nxc = ( sp . nxc directed * bonus rate ) / NUM_ - sp . earned nexium ; if ( ! give nxc ( sp . sponsor address , sponsor nxc", "nl": "use this function to buy nexiums for someone ( can be you of course ) ."}
{"code": "function create auction ( uint256 _part id , uint256 _start price , uint256 _end price , uint256 _duration , address _seller ) external when not paused { require ( _start price == uint256 ( uint128 ( _start price ) ) ) ; require ( _end price == uint256 ( uint128 ( _end price ) ) ) ; require ( _duration == uint256 ( uint64 ( _duration ) ) ) ; require ( _start price >= _end price ) ; require ( msg . sender == address ( nft contract ) ) ; _escrow ( _seller , _part id ) ; auction memory auction = auction ( _seller , uint128 ( _start price ) , uint128 ( _end price ) , uint64 ( _duration ) , uint64 ( now ) ) ; print event ( STR_ , NUM_ , auction . start ) ; _new auction ( _part id , auction ) ; }", "nl": "creates an auction and list it ."}
{"code": "function burn ( address _address ) internal { token contract . destroy tokens ( _address , token contract . balance of ( _address ) ) ; }", "nl": "burn only in state . icocompleted ."}
{"code": "function get stats ( ) external constant returns ( uint256 , uint256 , bool , bool , bool ) { return ( total eth in wei , token funded , paused , mint stage , ico stage ) ; }", "nl": "return stats of token ."}
{"code": "function buy ( uint n ) external payable not liquidating optional proxy { require ( n >= minimum_purchase && msg . value == purchase cost ether ( n ) ) ; address sender = message sender ; nomin pool = safe sub ( nomin pool , n ) ; state . set balance of ( sender , safe add ( state . balance of ( sender ) , n ) ) ; emit purchased ( sender , sender , n , msg . value ) ; emit transfer ( NUM_ , sender , n ) ; total supply = safe add ( total supply , n ) ; }", "nl": "sends n nomins to the sender from the pool , in exchange for n plus the fee worth of ether ."}
{"code": "function name ( ) external constant returns ( string _name ) { return name ; }", "nl": "check the name of the token erc-20 standard ."}
{"code": "function get free time ( ) external view only clevel returns ( uint64 _start , uint64 _end ) { _start = uint64 ( free_start ) ; _end = uint64 ( free_end ) ; }", "nl": "just for check ."}
{"code": "function add connector ( ierc20 token _token , uint32 _weight , bool _enable virtual balance ) public owner only inactive valid address ( _token ) not this ( _token ) valid connector weight ( _weight ) { require ( _token != token && ! connectors [ _token ] . is set && total connector weight + _weight <= max_weight ) ; connectors [ _token ] . virtual balance = NUM_ ; connectors [ _token ] . weight = _weight ; connectors [ _token ] . is virtual balance enabled = _enable virtual balance ; connectors [ _token ] . is purchase enabled = BOOL_ ; connectors [ _token ] . is set = BOOL_ ; connector tokens . push ( _token ) ; total connector weight += _weight ; }", "nl": "define a new connector for the token can only be call by the owner while the converter be inactive ."}
{"code": "function take the torch ( address _referred by ) public non reentrant when not paused payable { take the torch_ ( msg . value , msg . sender , _referred by ) ; }", "nl": "take the torch ! ."}
{"code": "function add eth teller ( address _from , uint _value ) external payable only owner returns ( bool ) { eth teller balance [ _from ] = safe math . add ( eth teller balance [ _from ] , _value ) ; return BOOL_ ; }", "nl": "add eth for escrow teller ."}
{"code": "function claim ( ) external is claiming { require ( token != address ( NUM_ ) ) ; require ( now >= release time ) ; require ( allocations [ msg . sender ] > NUM_ ) ; uint256 amount = allocations [ msg . sender ] ; allocations [ msg . sender ] = NUM_ ; claimed [ msg . sender ] = BOOL_ ; amount claimed = amount claimed . add ( amount ) ; amount locked = amount locked . sub ( amount ) ; token . safe transfer ( msg . sender , amount ) ; claimed ( msg . sender , amount ) ; }", "nl": "allows presale investors to claim tokens ."}
{"code": "function get contracts ( address owner ) returns ( string ) { return map owner string contract [ owner ] ; }", "nl": "get address contracts ."}
{"code": "function transfer ownership manual minter ( address new owner ) only owner public { require ( new owner != address ( NUM_ ) ) ; ownership transferred ( owner , new owner ) ; owner manual minter = new owner ; }", "nl": "after the manual mint process end , this shall be invoke pass the ico crowd sale contract address so that nobody else will be ever able to mint more tokens ."}
{"code": "function transfer from ( address _from , address _to , uint _value ) returns ( bool success ) { return BOOL_ ; }", "nl": "transferfrom implement erc20 , but be forbidden ."}
{"code": "function reclaim tokens ( ) external only admin returns ( bool ) { uint256 own balance = token contract . balance of ( address ( this ) ) ; require ( own balance > total locked ) ; uint256 amount reclaimed = own balance . sub ( total locked ) ; address token owner = token contract . owner ( ) ; require ( token owner != address ( NUM_ ) ) ; require ( token contract . transfer ( token owner , amount reclaimed ) ) ; tokens reclaimed ( amount reclaimed ) ; return BOOL_ ; }", "nl": "allows the admin to claim back all tokens that be not currently allocate ."}
{"code": "function bonuscalpre ( ) private returns ( uint256 cp ) { uint bon = NUM_ ; bonus calculation factor = ( block . timestamp . sub ( pre_startdate ) ) . div ( NUM_ ) ; if ( bonus calculation factor == NUM_ ) { bon = NUM_ ; } else { bon -= bonus calculation factor * NUM_ ; } return bon ; }", "nl": "bonus calculation for preico on per day basis ."}
{"code": "function send token released to balance internal ( address _token , address _granter , address _vester ) internal { grant storage _grant = grant per token granter vester [ _token ] [ _granter ] [ _vester ] ; uint256 amount to send = get balance vesting internal ( _grant ) ; _grant . withdrawn amount = _grant . withdrawn amount . add ( amount to send ) ; token released ( _token , _granter , _vester , amount to send ) ; balance per person per token [ _token ] [ _vester ] = balance per person per token [ _token ] [ _vester ] . add ( amount to send ) ; }", "nl": "send the token release to the balance address ."}
{"code": "function sell ( itradeable tradeable , uint volume , uint volume eth , bytes orders data , address destination addr , address affiliate ) external { require ( trading enabled ) ; require ( tradeable . transfer from ( msg . sender , this , volume ) ) ; trade ( BOOL_ , tradeable , volume , orders data , affiliate ) ; uint volume effective = safe math . safe sub ( volume , tradeable . balance of ( this ) ) ; require ( volume effective > NUM_ ) ; uint volume eth effective = collect sell fee ( affiliate ) ; require ( safe math . safe div ( volume eth effective , volume effective ) >= safe math . safe div ( volume eth , volume ) ) ; if ( volume effective < volume ) { transfer tradeable ( tradeable , destination addr , safe math . safe sub ( volume , volume effective ) ) ; } destination addr . transfer ( volume eth effective ) ; emit sell ( msg . sender , destination addr , tradeable , volume , volume eth , volume effective , volume eth effective ) ; }", "nl": "sell a token ."}
{"code": "function redeem ( uint _quantity ) public is multiple of natural unit ( _quantity ) has sufficient balance ( _quantity ) is non zero ( _quantity ) returns ( bool success ) { burn ( _quantity ) ; for ( uint16 i = NUM_ ; i < components . length ; i ++ ) { address current component = components [ i ] . address_ ; uint current units = components [ i ] . unit_ ; uint pre transfer balance = erc20 ( current component ) . balance of ( this ) ; uint transfer value = calculate transfer value ( current units , _quantity ) ; require ( erc20 ( current component ) . transfer ( msg . sender , transfer value ) ) ; uint post transfer balance = erc20 ( current component ) . balance of ( this ) ; assert ( pre transfer balance . sub ( transfer value ) == post transfer balance ) ; } emit log redemption ( msg . sender , _quantity ) ; return BOOL_ ; }", "nl": "function to convert set tokens into underlying components ."}
{"code": "modifier only sale team { require ( msg . sender == sale tokens address || msg . sender == bounty tokens address ) ; _ ; }", "nl": "only the team be allow to execute ."}
{"code": "function get raised ether ( ) public view returns ( uint256 ) { if ( fundraise type == fundraise type . eth ) return funds raised ; else return NUM_ ; }", "nl": "return eth raise by the sto ."}
{"code": "function has ended ( ) public view returns ( bool ) { return now > end time || are tokens sold ( ) ; }", "nl": "checks if auction have end ."}
{"code": "function request return ( address _return addr ) { require ( now <= end date ) ; require ( return addresses [ msg . sender ] == NUM_ ) ; return addresses [ msg . sender ] = _return addr ; return requested ( msg . sender , _return addr ) ; }", "nl": "this function be use to choose an address for return the fund ."}
{"code": "function set sanity bounds ( uint256 _sanity bounds ) only owner public { sanity bounds = _sanity bounds ; }", "nl": "allows owner to set new sanity bound for price update ."}
{"code": "function burn ( uint256 _value ) only payload size ( NUM_ ) public only owner when not paused returns ( bool success ) { require ( ! deprecated ) ; require ( arccheck . maximum circulation ( ) < value total supply ) ; require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; value total supply = value total supply . sub ( _value ) ; burn ( msg . sender , _value ) ; return BOOL_ ; }", "nl": "burn function take from https : / / www . ethereum . org / token ."}
{"code": "function get tags ( ) public view returns ( bytes32 [ ] ) { bytes32 [ ] memory available tags = new bytes32 [ ] ( NUM_ ) ; available tags [ NUM_ ] = STR_ ; available tags [ NUM_ ] = STR_ ; available tags [ NUM_ ] = STR_ ; return available tags ; }", "nl": "get the tag relate to the module factory ."}
{"code": "modifier only bonus owner { if ( owned bonus [ msg . sender ] > NUM_ ) _ ; }", "nl": "condition for method to be execute only by bonus owner ."}
{"code": "function set base cap ( uint _new base cap ) public only owner { require ( now < start general sale ) ; base eth cap per address = _new base cap ; }", "nl": "set cap before the general sale start ."}
{"code": "function get high win percent ( uint number ) public pure returns ( uint ) { require ( number >= NUM_ && number < num_dice_sides , STR_ ) ; if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } else if ( number == NUM_ ) { return NUM_ ; } }", "nl": "returns the win percent when go high on the give number ."}
{"code": "function initiate self destruct ( ) external only owner { initiation time = now ; self destruct initiated = BOOL_ ; emit self destruct initiated ( selfdestruct_delay ) ; }", "nl": "begin the self-destruction counter of this contract ."}
{"code": "function execute call ( address to , uint256 value , bytes data ) internal returns ( bool success ) { assembly { success : = call ( gas , to , value , add ( data , NUM_ ) , mload ( data ) , NUM_ , NUM_ ) } }", "nl": "the address . call ( ) ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; uint market_value = _value * sell price ; uint commission = market_value * NUM_ / NUM_ ; require ( this . balance >= commission ) ; commission getter . transfer ( commission ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return BOOL_ ; }", "nl": "overrides basic transferfrom function due to commission value ."}
{"code": "function create token contract ( ) internal returns ( standard token ) { return new gainmers token ( total token supply , end time . add ( after sale transferable time ) , team wallet ) ; }", "nl": "handles the creation of the gainmerstoken ."}
{"code": "function safe transfer from ( address _from , address _to , uint256 _token id , bytes data ) external when not paused { _safe transfer from ( _from , _to , _token id , data ) ; }", "nl": "transfers the ownership of an elht from one address to another address ."}
{"code": "function get mining reward ( ) public constant returns ( uint ) { bytes32 digest = solution for challenge [ challenge number ] ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( NUM_ * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( ( uint256 ( keccak256 ( digest ) ) % NUM_ ) * NUM_ * * uint ( decimals ) ) ; if ( epoch count > NUM_ ) return ( ( uint256 ( keccak256 ( digest ) ) % NUM_ ) * NUM_ * * uint ( decimals ) ) ; return ( ( uint256 ( keccak256 ( digest ) ) % NUM_ ) * NUM_ * * uint ( decimals ) ) ; }", "nl": "there 's no limit to the coin supply reward follow more or less the same emmission rate a dogecoins ' ."}
{"code": "function approve ( address _to , uint256 _unicorn id ) public only owner of ( _unicorn id ) { require ( _to != msg . sender ) ; if ( approved for ( _unicorn id ) != address ( NUM_ ) || _to != address ( NUM_ ) ) { unicorn approvals [ _unicorn id ] = _to ; emit approval ( msg . sender , _to , _unicorn id ) ; } }", "nl": "approves another address to claim for the ownership of the give unicorn id ."}
{"code": "function create sale ( uint256 _token id , uint256 _starting price , uint256 _ending price , uint256 _duration , address _owner ) external when not paused { require ( msg . sender == address ( non fungible contract ) ) ; require ( non fungible contract . check is attached ( _token id ) == NUM_ ) ; _escrow ( _owner , _token id ) ; _create sale ( _token id , _starting price , _ending price , _duration , _owner ) ; }", "nl": "put a collectible up for sale ."}
{"code": "modifier valid conversion fee ( uint32 _conversion fee ) { require ( _conversion fee >= NUM_ && _conversion fee <= max conversion fee ) ; _ ; }", "nl": "validate conversion fee ."}
{"code": "function next turn ( go board storage board ) private { board . next turn color = board . next turn color == player color . black ? player color . white : player color . black ; board . last update = now ; }", "nl": "internally use to move to the next turn , by switch side and update the board last update time ."}
{"code": "function transfer many ( address [ ] recipients , uint256 [ ] values ) public only owner returns ( bool success ) { require ( recipients . length == values . length ) ; for ( uint16 i = NUM_ ; i < recipients . length ; ++ i ) { transfer ( recipients [ i ] , values [ i ] ) ; } return BOOL_ ; }", "nl": "transfer beercoins to multiple recipients ."}
{"code": "function set member contract ( address _member contract ) public only owner ( ) { member contract = _member contract ; }", "nl": "sets the membership contract address ."}
{"code": "function withdraw ( uint proposal id ) external { uint balance = white list [ proposal id ] . balance of ( msg . sender ) ; if ( ! white list [ proposal id ] . transfer from ( msg . sender , this , balance ) || ! msg . sender . send ( balance ) ) throw ; }", "nl": "this require that the token-holder authorize this contract 's address use the approve ( ) function ."}
{"code": "modifier only in state ( status list _status ) { require ( _status == status ) ; _ ; }", "nl": "checks if ico be active ."}
{"code": "function bounty value ( uint256 _value , uint256 _block ) constant returns ( uint256 ) { if ( _block < config . start block || _block > config . stop block ) return NUM_ ; var r = config . start ratio ; var b = config . start block ; var s = config . reduction step ; var v = config . reduction value ; uint256 ratio = r - ( _block - b ) / s * v ; return _value * ratio / config . bounty scale ; }", "nl": "calculate bounty value by reduction equation ."}
{"code": "function remove ( bytes32 index name , bytes32 id ) public { grove lib . remove ( index_lookup [ compute index id ( msg . sender , index name ) ] , id ) ; }", "nl": "remove the index node for the give unique identifier ."}
{"code": "function change start time ( uint256 _start time ) external only owner { start time = _start time ; }", "nl": "these helper function be expose for change the start and end time dynamically ."}
{"code": "function start crowd ( uint256 _tokens , uint _start date , uint _end date , uint8 _discount , uint8 _discount first day ico ) public only owner { require ( _tokens * dec <= avaliable supply ) ; ico = ico ( _tokens * dec , _start date , _start date + _end date * NUM_ days , _discount , _discount first day ico ) ; stage = stage . add ( NUM_ ) ; unpause internal ( ) ; }", "nl": "function for start crowdsale ( any ) ."}
{"code": "function change wallet address ( address _wallet ) external only owner { wallet = _wallet ; wallet address changed ( _wallet ) ; }", "nl": "changes main contribution wallet ."}
{"code": "function uint256 to bytes32 ( uint256 value ) internal pure returns ( bytes32 ) { if ( value == NUM_ ) { return STR_ ; } bytes32 result bytes ; while ( value > NUM_ ) { result bytes = bytes32 ( uint ( result bytes ) / ( NUM_ * * NUM_ ) ) ; result bytes |= bytes32 ( ( ( value % NUM_ ) + NUM_ ) * NUM_ * * ( NUM_ * NUM_ ) ) ; value /= NUM_ ; } return result bytes ; }", "nl": "convert 256-bit unsigned integer into a 32 bytes structure ."}
{"code": "function buy tokens ( address _user , uint _value ) private ico is active { uint bought tokens = get tokens amount with eth ( _value ) ; burn tokens ( bought tokens ) ; balances [ _user ] = add ( balances [ _user ] , bought tokens ) ; add user to list ( _user ) ; buy tokens ( _user , _value , bought tokens ) ; }", "nl": "solds tokens for user by eth ."}
{"code": "function click button ( ) external is started payable returns ( uint256 ) { require ( msg . value >= minimum fee ) ; require ( game generation <= NUM_ ) ; require ( address last clicked for generation [ msg . sender ] < game generation ) ; address last clicked for generation [ msg . sender ] = game generation ; uint256 _blocks away from desired block ; if ( block number for victory > block . number ) { _blocks away from desired block = block number for victory - block . number ; } else { _blocks away from desired block = NUM_ ; } uint256 _generation = game generation ; if ( _blocks away from desired block == NUM_ ) { game generation ++ ; } number of clicks at blocks remaining [ uint8 ( _blocks away from desired block ) ] += NUM_ ; block number for victory = block . number + required blocks elapsed for victory ; button click metadata memory _click = button click metadata ( { blocks away from desired block : uint64 ( _blocks away from desired block ) , click generation : uint64 ( _generation ) , click", "nl": "this method contain the core game logic , track a distinct button click event and save all relevant metadata associate with it ."}
{"code": "function update batch support ( bool _flag ) public only game manager { is batch supported = _flag ; }", "nl": "helps to toggle batch support flag ."}
{"code": "function leave community ( address community ) public { accounts [ msg . sender ] . communities [ community ] = BOOL_ ; emit left community ( accounts [ msg . sender ] . name , community ) ; }", "nl": "leaving a community prevent that community from credit or debit your aviv and vip balance ."}
{"code": "function change congress ( address _congress ) only congress public { require ( _congress != address ( NUM_ ) ) ; congress = _congress ; }", "nl": "set a congress contract address for this token must change this address by the last congress contract ."}
{"code": "function calc token price ( ) view public returns ( uint ) { return price factor * NUM_ * * NUM_ / ( block . number - start block + NUM_ ) + NUM_ ; }", "nl": "calculates token price ."}
{"code": "function create token contract ( ) internal returns ( mintable token ) { return new talao token ( ) ; }", "nl": "creates the talao token ."}
{"code": "function distribute airdrop ( address [ ] addresses , uint256 amount ) only owner public { require ( ! unlocked ) ; uint256 normalized amount = amount * NUM_ * * NUM_ ; require ( balances [ owner ] >= safe mul ( addresses . length , normalized amount ) ) ; for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { balances [ owner ] = safe sub ( balance of ( owner ) , normalized amount ) ; balances [ addresses [ i ] ] = safe add ( balance of ( addresses [ i ] ) , normalized amount ) ; transfer ( owner , addresses [ i ] , normalized amount ) ; } }", "nl": "function to distribute tokens to list of address by the provided amount ."}
{"code": "function change wallet address ( address new address ) only owner { dmlwallet = new address ; }", "nl": "emergency situation ."}
{"code": "function tokens remaining pre ico ( ) public view returns ( uint256 ) { if ( is pre ico finish ( ) ) { return NUM_ ; } return hard cap pre ico . sub ( pre ico sold tokens ) ; }", "nl": "remaining amount of tokens for preico stage ."}
{"code": "function get token minted ( ) public constant returns ( uint ) { return m_token . total supply ( ) ; }", "nl": "amount of wei-tokens mint ."}
{"code": "function pay2 ( address _seller , uint _amount , address _opinion leader ) public not freezed { address dapp = get or add master wallet ( msg . sender ) ; address seller = get or add master wallet ( _seller ) ; pay internal ( dapp , seller , _amount , _opinion leader ) ; available [ seller ] [ dapp ] += _amount ; }", "nl": "function pay wrapper ."}
{"code": "modifier sale is end ( ) { require ( get current datetime ( ) >= sale end ) ; _ ; }", "nl": "modifier to check if the sale be end ."}
{"code": "function transfer ownership ( address _new owner ) public only owner { require ( _new owner != address ( NUM_ ) ) ; owner = _new owner ; }", "nl": "ownership can be transfer to provided newowner ."}
{"code": "function fractionalize ( address _beneficiary ) internal { require ( token buyers mapping [ _beneficiary ] > NUM_ ) ; if ( token buyers fraction [ _beneficiary ] == NUM_ ) { token buyers remaining [ _beneficiary ] = token buyers mapping [ _beneficiary ] ; token buyers fraction [ _beneficiary ] = percent ( token buyers mapping [ _beneficiary ] , NUM_ , NUM_ ) ; } }", "nl": "determine 1 / 8th of every user 's contribution in their deserved tokens ."}
{"code": "function add partner ( address investor ) only owner public returns ( bool ) { require ( investor != address ( NUM_ ) ) ; require ( ! partners [ investor ] && ! blacklisted [ investor ] && balances [ investor ] == NUM_ ) ; partners [ investor ] = BOOL_ ; partner added ( investor ) ; return partners [ investor ] ; }", "nl": "qwasdertoken interface ."}
{"code": "function stake for wei ( uint input_wei ) public view returns ( uint ) { return ( ( input_wei * usd per ether * NUM_ ) / NUM_ ether ) / last stake price uscents ; }", "nl": "translate wei to stakes ."}
{"code": "function transfer ( address _to , uint256 _value ) public valid address ( _to ) transfers allowed ( msg . sender ) returns ( bool ) { return super . transfer ( _to , _value ) ; }", "nl": "this function be disable during the crowdfunding ."}
{"code": "function set valid duration data ( uint valid duration blocks ) public only operator { require ( valid duration blocks > NUM_ ) ; set new data ( valid_duration_data_index ) ; valid duration data . duration in blocks = valid duration blocks ; }", "nl": "valid duration block ."}
{"code": "function grant team token ( ) only owner public { require ( ! grant team supply ) ; require ( now > team time lock ) ; uint256 value token = safe math . div ( remaining team supply , NUM_ ) ; require ( remaining team supply >= value token ) ; grant team supply = BOOL_ ; token . mint ( NUM_ , value token ) ; token . mint ( NUM_ , value token ) ; token . mint ( NUM_ , value token ) ; token . mint ( NUM_ , value token ) ; token . mint ( NUM_ , value token ) ; remaining team supply = NUM_ ; }", "nl": "true if grantteamtoken function have end ."}
{"code": "function finalize crowdfund ( ) external only crowdfund { require ( stage == ico stages . public sale ) ; uint256 amount = balance of ( crowdfund address ) ; if ( amount > NUM_ ) { accounts [ crowdfund address ] = NUM_ ; add to balance ( foundation address , amount ) ; transfer ( crowdfund address , foundation address , amount ) ; } stage = ico stages . done ; crowdfund finalized ( amount ) ; }", "nl": "finalizes crowdfund ."}
{"code": "function change start date ( uint256 start time unix timestamp ) public returns ( bool ) { require ( msg . sender == wallet ) ; start time = start time unix timestamp ; }", "nl": "function to change the start date time can only be call from owner wallet ."}
{"code": "modifier only controller { if ( msg . sender != token controller ) throw ; _ ; }", "nl": "the onlycontroller modifier only allow the tokencontroller to call the function ."}
{"code": "function transfer adminship ( address _new admin ) only admin public { require ( _new admin != address ( NUM_ ) ) ; admin = _new admin ; emit transfer adminship ( admin ) ; }", "nl": "transfer the adminship of the contract ."}
{"code": "function top up with ether and tokens for holders ( address tokens contract address , uint tokens amount ) public payable { uint wei per token = msg . value / initial supply ; uint tokens per token = NUM_ * tokens amount / initial supply ; uint wei amount for holder = NUM_ ; uint tokens for holder = NUM_ ; for ( uint i = NUM_ ; i < token balances . size ( ) ; i += NUM_ ) { address token holder = token balances . get key by index ( i ) ; if ( token balances . get ( token holder ) > NUM_ ) { wei amount for holder = token balances . get ( token holder ) * wei per token ; tokens for holder = token balances . get ( token holder ) * tokens per token / NUM_ ; token holder . transfer ( wei amount for holder ) ; if ( tokens contract address . call ( bytes4 ( keccak256 ( STR_ ) ) , msg . sender , token holder , tokens for holder ) ) emit dividends transfered ( token holder , tokens for holder , wei", "nl": "receive dividends ."}
{"code": "function transfer ( address to , uint256 value ) public when not freezed returns ( bool ) { return super . transfer ( to , value ) ; }", "nl": "public variables internal variables events public function ."}
{"code": "function withdraw token ( address token , uint256 amount ) external { require ( user balance [ msg . sender ] [ token ] >= amount ) ; user balance [ msg . sender ] [ token ] = user balance [ msg . sender ] [ token ] . sub ( amount ) ; require ( token ( token ) . transfer ( msg . sender , amount ) ) ; emit withdrawal ( msg . sender , token , amount ) ; emit user balance updated ( msg . sender , token , user balance [ msg . sender ] [ token ] ) ; }", "nl": "users can withdraw any amount of a give token up to their current balance ."}
{"code": "modifier only_d app bridge { init bridge ( ) ; address _d app bridge owner = d app bridge . get owner ( ) ; require ( msg . sender == _d app bridge owner ) ; _ ; }", "nl": "ensures that only the dappbridge system can call the function ."}
{"code": "function create tokens ( address beneficiary , uint amount ) only controller returns ( bool success ) { if ( sealed ( ) ) throw ; balances [ beneficiary ] += amount ; total supply += amount ; transfer ( NUM_ , beneficiary , amount ) ; return BOOL_ ; }", "nl": "createtokens ( ) will create tokens if the campaign have not be seal ."}
{"code": "function who is admin ( ) external view returns ( address ) { return admin ; }", "nl": "shows who be the admin for this contract ."}
{"code": "function _compute tokens purchased at tier ( collection storage self , uint256 _tier , uint256 _wei ) private view returns ( uint256 ) { var paid basis = max_discount . sub ( self . tiers [ _tier ] . discount ) ; return _wei . mul ( self . base rate ) . mul ( max_discount ) / paid basis ; }", "nl": "total number of tokens for an amount of wei , discount-adjusted ."}
{"code": "function owner of ( uint256 _token id ) public view returns ( address _owner ) { return block to owner [ _token id ] ; }", "nl": "return the address of a block owner ."}
{"code": "function pay underwriter ( ) public { require ( msg . sender == owner || msg . sender == underwriter ) ; uint _amount = proceeds ; proceeds = NUM_ ; if ( ! underwriter . call . gas ( contract send gas ) . value ( _amount ) ( ) ) revert ( ) ; }", "nl": "pay auction proceed to the underwriter may be call by underwriter or owner ( fbo underwriter ) ."}
{"code": "function set_shops ( address [ ] shop_addresses , address [ ] token_addresses ) only owner non reentrant external { require ( shop_addresses . length == token_addresses . length ) ; for ( uint256 i = NUM_ ; i < shop_addresses . length ; i ++ ) { shops [ shop_addresses [ i ] ] = token_addresses [ i ] ; } }", "nl": "associate each shop with a token to prevent anyone game the system ."}
{"code": "function modify max contract balance ( uint amount ) public only owner { require ( contract stage == NUM_ ) ; require ( amount >= contribution min ) ; require ( amount >= this . balance ) ; max contract balance = amount ; if ( amount < contribution cap ) contribution cap = amount ; }", "nl": "this function be call to modify the maximum balance of the contract ."}
{"code": "function transfer knight ownership ( address new knight ) external valid address ( new knight ) { require ( knight address == msg . sender , STR_ ) ; _move balance ( new knight ) ; knight address = new knight ; }", "nl": "transfers knight ownership to a new address ."}
{"code": "function get eth phi rate ( ) public constant returns ( uint ) { return eth usd . div ( phi rate ) ; }", "nl": "it divide ( eth / usd rate ) / ( phi / usd rate ) , use the custom function getethphirate ( false ) if you want a more accurate rate ."}
{"code": "function assure dapp is ready ( ) external { if ( msg . sender == NUM_ ) { dev approvals [ NUM_ ] = BOOL_ ; } else if ( msg . sender == NUM_ ) { dev approvals [ NUM_ ] = BOOL_ ; } else if ( msg . sender == NUM_ ) { dev approvals [ NUM_ ] = BOOL_ ; } else if ( msg . sender == NUM_ ) { dev approvals [ NUM_ ] = BOOL_ ; } else { revert ( ) ; } }", "nl": "sign that the dapp be ready ."}
{"code": "function add funder ( address _funder ) public only owner { if ( ! funded [ _funder ] ) { funders . push ( _funder ) ; funded [ _funder ] = BOOL_ ; } }", "nl": "add a new address to the funders ."}
{"code": "function set_prices ( uint8 _create , uint8 _edit , uint8 _active_contract ) public only owner returns ( bool success ) { prices . create = _create ; prices . edit = _edit ; prices . active_contract = _active_contract ; return BOOL_ ; }", "nl": "muda o dono do contrato ."}
{"code": "function add cancellation ( address _participant ) external only owner returns ( bool success ) { main cancelled list [ _participant ] = BOOL_ ; return BOOL_ ; }", "nl": "maintains list of investors with failed kyc validation ."}
{"code": "function distribute remaining tokens ( ) internal owner only { uint crowdsale supply = supply * NUM_ / NUM_ ; uint unsold tokens = crowdsale supply - tokens sold ; balances [ lotus wallet75 pct ] = safe add ( balances [ lotus wallet75 pct ] , unsold tokens * NUM_ / NUM_ ) ; transfer ( this , lotus wallet75 pct , unsold tokens * NUM_ / NUM_ ) ; balances [ vc1 wallet4 pct ] = safe add ( balances [ vc1 wallet4 pct ] , unsold tokens * NUM_ / NUM_ * NUM_ / NUM_ ) ; transfer ( this , vc1 wallet4 pct , unsold tokens * NUM_ / NUM_ * NUM_ / NUM_ ) ; vesting tokens [ vc1 wallet4 pct ] = safe add ( vesting tokens [ vc1 wallet4 pct ] , unsold tokens * NUM_ / NUM_ * NUM_ / NUM_ ) ; balances [ vc2 wallet4 pct ] = safe add ( balances [ vc2 wallet4 pct ] , unsold tokens * NUM_ / NUM_ * NUM_ / NUM_ ) ; transfer ( this , vc2 wallet4 pct , unsold tokens * NUM_ / NUM_ * NUM_ / NUM_ ) ;", "nl": "distribute the tokens leave after the crowdsale to the pre-agreed account ."}
{"code": "function get address ( bytes b ) public constant returns ( address a ) { if ( b . length < NUM_ ) return address ( NUM_ ) ; assembly { let mask : = NUM_ a : = and ( mask , mload ( add ( b , NUM_ ) ) ) } }", "nl": "gets an address encode a the first argument in transaction data ."}
{"code": "modifier only contract owner { if ( msg . sender != contract owner ) revert ( ) ; _ ; }", "nl": "restrict usage to only the owner ."}
{"code": "function _add new owner holdings to token ( address _owner , uint _token id , uint _units ) internal { token to owners holdings [ _token id ] [ _owner ] += _units ; }", "nl": "add the divisibility to new owner ."}
{"code": "function is valid contribution ( address _address , uint256 _amount ) internal constant returns ( bool valid ) { if ( is whitelist period ( ) && is whitelisted ( _address ) ) { return eth to usd ( _amount + investors [ _address ] . contribution ) <= whitelisted [ _address ] . pledged ; } return is below cap ( _amount + investors [ _address ] . contribution ) ; }", "nl": "check that the amount send in the transaction be below the individual cap , or below the pledged amount if the user be whitelisted and the sale be in the whitelist period ."}
{"code": "function _mint ( address _to , uint256 _token id ) internal when not paused { token id to token owner [ _token id ] = _to ; token owner to token count [ _to ] ++ ; emit transfer ( address ( NUM_ ) , _to , _token id ) ; }", "nl": "interfaceid_erc998 bytes4 ( keccak256 ( 'tokenownerof ( uint256 ) ' ) ) bytes4 ( keccak256 ( 'ownerofchild ( address , uint256 ) ' ) ) bytes4 ( keccak256 ( 'onerc721received ( address , address , uint256 , bytes ) ' ) ) bytes4 ( keccak256 ( 'onerc998removedchild ( address , address , uint256 , bytes ) ' ) ) bytes4 ( keccak256 ( 'transferchild ( address , address , uint256 ) ' ) ) bytes4 ( keccak256 ( 'safetransferchild ( address , address , uint256 ) ' ) ) bytes4 ( keccak256 ( 'safetransferchild ( address , address , uint256 , bytes ) ' ) ) bytes4 ( keccak256 ( 'getchild ( address , address , uint256 , uint256 ) ' ) ) ; ."}
{"code": "function deauthorize casino ( address player address , address casino address , uint8 v , bytes32 r , bytes32 s ) public { address player = ecrecover ( keccak256 ( casino address , locked by user [ player address ] [ casino address ] , BOOL_ ) , v , r , s ) ; require ( player == player address ) ; authorized by user [ player ] [ casino address ] = BOOL_ ; locked by user [ player ] [ casino address ] ++ ; }", "nl": "deauthorize a casino contract address to access the fund v , r , s the player 's signature of the casino address , the number of time the address have already be lock and a bool state if the signature be mean for authourization ( true ) or deauthorization ( false ) ."}
{"code": "function button clicked ( address referee ) external payable { require ( msg . value >= click price ) ; require ( expire time >= block . timestamp ) ; require ( referee != msg . sender ) ; if ( player click count [ msg . sender ] == NUM_ ) { player indexes [ total players ] = msg . sender ; total players += NUM_ ; } total clicks += NUM_ ; player click count [ msg . sender ] += NUM_ ; if ( player sec to timeout [ msg . sender ] == NUM_ || player sec to timeout [ msg . sender ] > ( expire time - block . timestamp ) ) player sec to timeout [ msg . sender ] = expire time - block . timestamp ; expire time = block . timestamp + expire_delay ; address ref addr = referee ; if ( ref addr == NUM_ || player click count [ referee ] == NUM_ ) ref addr = owner ; if ( total clicks > clickers_size ) { total pot = total pot . add ( ( ( msg . value . mul ( NUM_ ) ) /", "nl": "game mechanics ."}
{"code": "function finish crowdsale ( ) only owner not ended public returns ( bool ) { has ended = BOOL_ ; return BOOL_ ; }", "nl": "function to finish the crowdsale ."}
{"code": "function get current round info2 ( ) public view returns ( bytes32 , uint256 , bytes32 , uint256 , bytes32 , bytes32 , bytes32 ) { uint256 _r id = r id_ ; return ( plyr_ [ round_ [ _r id ] . max eth pid ] . name , plyr rnds_ [ round_ [ _r id ] . max eth pid ] [ _r id ] . eth , plyr_ [ round_ [ _r id ] . max aff pid ] . name , plyr rnds_ [ round_ [ _r id ] . max aff pid ] [ _r id ] . aff num , plyr_ [ round_ [ _r id ] . plyrs [ NUM_ ] ] . name , plyr_ [ round_ [ _r id ] . plyrs [ NUM_ ] ] . name , plyr_ [ round_ [ _r id ] . plyrs [ NUM_ ] ] . name ) ; }", "nl": "other round info ."}
{"code": "function _is valid deposit country ( uint _balance , uint _current holder count , uint _max holder number ) private pure returns ( bool ) { return ! ( _balance == NUM_ && _current holder count == _max holder number ) ; }", "nl": "todo need additional check : not clear check of country limit : ."}
{"code": "function check bet number ( uint8 result , address player , bytes32 block hash , bytes32 sha player ) private { bool win ; if ( result == gambles [ gamble index [ player ] ] . input ) { win = BOOL_ ; } solve bet ( player , result , win , NUM_ , block hash , sha player ) ; }", "nl": "checkbeton number ( input ) bet type : number input : choose number ."}
{"code": "function set animator ( address _new animator ) external only ceo { require ( _new animator != address ( NUM_ ) ) ; animator address = _new animator ; }", "nl": "assigns a new address to the animator role ."}
{"code": "function set end time ( uint256 _end time ) public only owner not finalized { require ( _end time > start time ) ; end time = _end time ; }", "nl": "allows the current owner to set the new end time if crowdsale be not finalize ."}
{"code": "function craft two cards ( uint _crafted from left , uint _crafted from right ) public { require ( _owns ( msg . sender , _crafted from left ) ) ; require ( _owns ( msg . sender , _crafted from right ) ) ; require ( ( is on auction to buy ( _crafted from left ) == BOOL_ ) && ( is on crafting auction ( _crafted from left ) == BOOL_ ) ) ; require ( _crafted from left != _crafted from right ) ; card structure storage left card = all cards [ _crafted from left ] ; card structure storage right card = all cards [ _crafted from right ] ; require ( left card . can craft at <= now ) ; require ( right card . can craft at <= now ) ; spawn card ( _crafted from left , _crafted from right ) ; }", "nl": "craft two card ."}
{"code": "function bonus ( ) pure private returns ( uint ) { return NUM_ ; }", "nl": "edit : no bonus scheme this ico ."}
{"code": "function get tiers ( ) public view returns ( uint256 [ NUM_ ] [ ] ) { var records = discounts . tiers ; uint256 [ NUM_ ] [ ] memory tiers = new uint256 [ NUM_ ] [ ] ( records . length ) ; for ( uint256 i = NUM_ ; i < records . length ; i ++ ) { tiers [ i ] [ NUM_ ] = records [ i ] . discount ; tiers [ i ] [ NUM_ ] = records [ i ] . available ; } return tiers ; }", "nl": "array of tuples ( discount , available ) ."}
{"code": "function transfer token ( address token , address account , uint amount ) internal { require ( token ( token ) . transfer ( account , amount ) ) ; }", "nl": "transfer token to user account ."}
{"code": "function _calculate bonus ( uint256 _tokens bought , uint256 _total tokens sold ) internal pure returns ( uint ) { uint _bonus tokens = NUM_ ; if ( _total tokens sold > NUM_ * NUM_ * * NUM_ * NUM_ * * decimals ) { return _bonus tokens ; } uint8 [ NUM_ ] memory _bonus pattern = [ NUM_ , NUM_ , NUM_ , NUM_ ] ; uint256 [ NUM_ ] memory _thresholds = [ NUM_ , NUM_ * NUM_ * * NUM_ * NUM_ * * decimals , NUM_ * NUM_ * * NUM_ * NUM_ * * decimals , NUM_ * NUM_ * * NUM_ * NUM_ * * decimals , NUM_ * NUM_ * * NUM_ * NUM_ * * decimals ] ; for ( uint8 i = NUM_ ; _tokens bought > NUM_ && i < _bonus pattern . length ; ++ i ) { uint _min = _thresholds [ i ] ; uint _max = _thresholds [ i + NUM_ ] ; if ( _total tokens sold >= _min && _total tokens sold < _max ) { uint _bonused part = math . min256 ( _tokens bought , _max - _total tokens sold )", "nl": "calculates the amount of bonus tokens a buyer get , base on how much the buyer buy and in which bonus threshold the purchase fall ."}
{"code": "function set burn address ( address _address ) only owner { burn address = _address ; ledger . set burn address ( _address ) ; token . set burn address ( _address ) ; }", "nl": "new functionality ."}
{"code": "function ether proceeds ( ) external only owner { if ( ! msg . sender . send ( this . balance ) ) revert ( ) ; }", "nl": "eth out ."}
{"code": "function set rate ( uint256 _rate ) public { require ( msg . sender == owner ) ; require ( _rate > NUM_ ) ; rate = _rate ; }", "nl": "set a rate for ico round ."}
{"code": "function accept ownership ( ) public { require ( msg . sender == new owner ) ; emit owner update ( owner , new owner ) ; owner = new owner ; new owner = address ( NUM_ ) ; }", "nl": "use by a new owner to accept an ownership transfer ."}
{"code": "function upgrade ( ) external { require ( now <= upgrade deadline ) ; uint256 balance = old token . balance of ( msg . sender ) ; require ( balance > NUM_ ) ; old token . transfer from ( msg . sender , old token burn address , balance ) ; balances [ msg . sender ] += balance ; emit transfer ( this , msg . sender , balance ) ; emit upgraded ( msg . sender , balance ) ; }", "nl": "upgrade function , require the owner to first approve tokens equal to their old token balance to this address ."}
{"code": "function set governor ( address _governor ) public only governor { governor = _governor ; }", "nl": "setter for governor ."}
{"code": "function multi mint ( address [ ] recipients , uint256 [ ] amounts ) external token distribution period only { require ( recipients . length == amounts . length ) ; uint total = NUM_ ; for ( uint i = NUM_ ; i < recipients . length ; ++ i ) { balance of [ recipients [ i ] ] = balance of [ recipients [ i ] ] . add ( amounts [ i ] ) ; total = total . add ( amounts [ i ] ) ; emit transfer ( NUM_ , recipients [ i ] , amounts [ i ] ) ; } total supply = total supply . add ( total ) ; }", "nl": "tokendistributor be authorize to distribute tokens to the party who participate in the token sale by the time the lastmint function be trigger , which close the ability to mint any new tokens forever ."}
{"code": "function get status ( uint256 _token id ) external view returns ( uint ) { return ship id to status [ _token id ] ; }", "nl": "get status ."}
{"code": "function accept dividends ( uint _tvalue ) public payable { uint _value ; if ( get cassette type_ ( ) == ct_ether ) { _value = msg . value ; } else if ( get cassette type_ ( ) == ct_token ) { _value = _tvalue ; require ( accept abstract token_ ( _value ) ) ; } else revert ( ) ; uint _dividends per token = dividends per token ; uint _total supply = total supply_ ; require ( _total supply > NUM_ ) ; _dividends per token = _dividends per token . add ( _value . mul ( decimal_multiplier ) / _total supply ) ; require ( _dividends per token . mul ( _total supply ) <= int256_max ) ; dividends per token = _dividends per token ; emit accept dividends ( _value ) ; }", "nl": "accept dividends in ether ."}
{"code": "function grant token ( address _customer , uint256 _value , string note ) only owner public { require ( balances [ msg . sender ] >= _value && balances [ _customer ] + _value > balances [ _customer ] ) ; bonus token ( _customer , _value , note ) ; balances [ msg . sender ] -= _value ; balances [ _customer ] += _value ; transfer ( msg . sender , _customer , _value ) ; }", "nl": "grant tokens to customers ."}
{"code": "function donate tokens ( address _token contract address ) public members only { require ( _token contract address != address ( this ) ) ; tokens donated ( _token contract address , erc20 ( _token contract address ) . balance of ( this ) ) ; erc20 ( _token contract address ) . transfer ( donation address_ , erc20 ( _token contract address ) . balance of ( this ) ) ; }", "nl": "we also want to be able to access any tokens that be send to the contract ."}
{"code": "function get required admin ( wallet main lib . wallet data storage self ) public view returns ( uint256 ) { return self . required admin ; }", "nl": "get sig requirements for administrative change ."}
{"code": "function add participant ( address _participant ) public not paused only admin returns ( bool ) { require ( address ( _participant ) != NUM_ ) ; require ( is participant [ _participant ] == BOOL_ ) ; is participant [ _participant ] = BOOL_ ; participant amount ++ ; add participant ( _participant ) ; return BOOL_ ; }", "nl": "true if _participant be add successful ."}
{"code": "function d deploy ballot ( bytes32 democ hash , bytes32 spec hash , bytes32 extra data , uint256 packed ) only democ editor ( democ hash ) external payable { _deploy ballot ( democ hash , spec hash , extra data , packed , BOOL_ , BOOL_ ) ; }", "nl": "only way a democ admin can deploy a ballot ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) when_owns ( _from , _value ) when_has_allowance ( _from , msg . sender , _value ) when_liquid returns ( bool ) { transfer ( _from , _to , _value ) ; accounts [ _from ] . allowance of [ msg . sender ] -= _value ; accounts [ _from ] . balance -= _value ; accounts [ _to ] . balance += _value ; return BOOL_ ; }", "nl": "transfer via allowance ."}
{"code": "function refund ( ) public { fund . refund ( msg . sender ) ; }", "nl": "server integration methods ."}
{"code": "function is player on board ( uint board id , address search address ) public view returns ( bool ) { return ( is player on board ( all boards [ board id ] , search address ) ) ; }", "nl": "check if a player be on board ( overload for boardid ) ."}
{"code": "function calculate commission ( uint32 _canvas id ) public view state owned ( _canvas id ) returns ( uint commission , bool is paid ) { bid storage bid = bids [ _canvas id ] ; canvas storage canvas = _get canvas ( _canvas id ) ; return ( _calculate commission ( bid . amount ) , canvas . is commission paid ) ; }", "nl": "calculates commission that have be charge for sell the canvas ."}
{"code": "function token fallback ( address _from , uint _value , bytes _data ) public { balances [ _from ] += _value ; }", "nl": "falback for exy deposit ."}
{"code": "function transfer main ( address _from , address _to , uint _value ) private returns ( bool success ) { require ( _to != address ( NUM_ ) ) ; assert ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ _from ] -= _value ; balances [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }", "nl": "main transfer function ."}
{"code": "function fund ( ) payable { require ( fd_ac . check permission ( NUM_ , msg . sender ) ) ; }", "nl": "fund contract ."}
{"code": "function get offering by proposal ( address _security token address , uint8 _offering proposal index ) view public returns ( address sto contract , address auditor , uint256 vesting period , uint8 quorum , uint256 fee ) { address _sto contract = offering proposals [ _security token address ] [ _offering proposal index ] ; return ( _sto contract , offerings [ _sto contract ] . auditor , offerings [ _sto contract ] . vesting period , offerings [ _sto contract ] . quorum , offerings [ _sto contract ] . fee ) ; }", "nl": "get security token offer smart contract detail by the proposal index ."}
{"code": "function get promo lotearnt ( uint _entries ) public view returns ( uint ) { return ( _entries * get rate ( ) * get tkt price ( ) ) / ( NUM_ * NUM_ * * NUM_ ) ; }", "nl": "returns number of promotional lot earnt a calculate base on number of entries , current ico exchange rate and the current etheraffle ticket price ."}
{"code": "function deposit ( address contributor ) only owner external payable { require ( state == state . active || state == state . success ) ; total deposited = total deposited . add ( msg . value ) ; refundable = refundable . add ( msg . value ) ; deposited [ contributor ] = deposited [ contributor ] . add ( msg . value ) ; }", "nl": "called by the sale contract to deposit ether for a contributor ."}
{"code": "function valid purchase ( ) internal returns ( bool ) { bool within presale period = now >= presale start time ; bool within icoperiod = now >= ico start time ; bool non zero purchase = msg . value != NUM_ ; return ( within presale period && non zero purchase && wei raised <= NUM_ ether ) || ( within icoperiod && non zero purchase && wei raised <= NUM_ ether ) ; }", "nl": "true if the transaction can buy tokens from presale or ico , include fund cap check ."}
{"code": "function extend public sale discount end time ( uint256 _added public sale discount end time ) external only owner { public sale discount end time = public sale discount end time + _added public sale discount end time ; }", "nl": "extend public sale discount time ."}
{"code": "function _mark credit ( address player , uint256 n tokens ) internal { n tokens credited [ player ] = n tokens credited [ player ] . add ( n tokens ) ; emit slot topped up ( player , n tokens ) ; }", "nl": "escrew and start game ."}
{"code": "function total supply ( ) public view returns ( uint ) { return rabbits . length - NUM_ ; }", "nl": "returns the total number of rabbit currently in existence ."}
{"code": "function multi transfer ( address [ ] _to , uint256 [ ] _value ) public { require ( _to . length == _value . length ) ; for ( uint i = NUM_ ; i < _to . length ; i ++ ) { transfer ( _to [ i ] , _value [ i ] ) ; } }", "nl": "multi transfer token for a specified address ."}
{"code": "function _transfer ( uint _company id , address _from , address _to , uint _number of tokens ) internal { company storage company = companies [ _company id ] ; _shares sold ( company . share holders , _from , _number of tokens ) ; _shares bought ( company . share holders , _to , _number of tokens ) ; _update ceoif required ( company , _company id , _to ) ; emit transfer ( _company id , _from , _to , _number of tokens ) ; }", "nl": "transfer tokens from _from to _to and verify if ceo of company have change ! _from should have enough tokens before call this function ! _numberoftokens should be greator than 0 ."}
{"code": "function get fee ( ) public constant returns ( uint ) { return fee ; }", "nl": "returns default register fee ."}
{"code": "function approve transfer manager ( address addr ) public only owner only not released { transfer managers [ addr ] = BOOL_ ; transfer manager approved ( addr ) ; }", "nl": "approve specify address to make transfer in lock up period ."}
{"code": "function change end private sale ( uint256 _newend ) public only owner { endprivate = _newend ; }", "nl": "change the end private sale ."}
{"code": "function unrestrict ( address addr ) internal returns ( uint ) { if ( ! assignments closed ) { throw ; } uint restrictions for addr = restrictions [ addr ] ; if ( restrictions for addr == NUM_ ) { throw ; } uint burn = mult frac ceiling ( restrictions for addr , burn mult nom , burn mult den ) ; tokens [ addr ] -= burn ; delete restrictions [ addr ] ; total restricted tokens -= restrictions for addr ; total unrestricted tokens += restrictions for addr - burn ; return burn ; }", "nl": "unrestrict ( convert ) all restrict tokens assign to the give address ."}
{"code": "function prepare for sale ( ) is owner { require ( ! ico complete b ) ; sale in progress b = BOOL_ ; }", "nl": "prepareforsale ( ) stop transfer and allow purchase ."}
{"code": "function transfer erc20 token ( address _token address , address _to , uint256 _value ) public only owner { erc20 token = erc20 ( _token address ) ; assert ( token . transfer ( _to , _value ) ) ; }", "nl": "in case of accidental token transfer to this address , owner can transfer it elsewhere ."}
{"code": "modifier only payload size ( uint size ) { require ( msg . data . length >= size + NUM_ ) ; _ ; }", "nl": "to handle erc20 short address attack ."}
{"code": "function finalize ( ) public only owner { require ( paused ) ; require ( proof tokens allocated ) ; proof token . finish minting ( ) ; proof token . enable transfers ( BOOL_ ) ; finalized ( ) ; finalized = BOOL_ ; }", "nl": "finalize the token sale ( can only be call by owner ) ."}
{"code": "function change fee ( uint _fee ) only owner { require ( _fee <= fee ) ; fee = _fee ; }", "nl": "fee can only be decrease ! ."}
{"code": "function _withdraw ( address to , uint256 tkns , bool dosend , uint256 subxtra ) internal returns ( uint256 ) { if ( tkns == NUM_ ) { last balance withdrawn [ msg . sender ] = sub ( sub ( add ( address ( this ) . balance , total out ) , msg . value ) , subxtra ) ; return NUM_ ; } uint256 total_volume_in = address ( this ) . balance + total out - msg . value ; uint256 delta = sub ( total_volume_in , last balance withdrawn [ to ] ) ; uint256 get = ( tkns * delta ) / total supply ; total out = total out + get ; last balance withdrawn [ to ] = sub ( sub ( sub ( add ( address ( this ) . balance , total out ) , get ) , msg . value ) , subxtra ) ; emit withdrawal complete ( to , get ) ; if ( dosend ) { to . transfer ( get ) ; return NUM_ ; } else { return get ; } }", "nl": "if dosend be set to false then the call function must send the fee subxtra be to handle the high lastbalancewithdrawn bug this bug be cause because the buyer actually get a too high lastbalancewithdrawn ; this be a minor bug and could be fix by add these fund to the contract ( which be usually not a large amount ) if the contract get a lot of divs live then that should not be an issue because any new withdrawal will set it to a right value anyways it be fix now ."}
{"code": "function get heart price ( ) public view returns ( uint256 ) { return ( ( round heart [ round ] . add ( NUM_ ) ) . eth rec ( NUM_ ) ) ; }", "nl": "get heart price ."}
{"code": "function change token price ( uint256 _new token price ) public only owner { require ( token price != _new token price && _new token price > NUM_ ) ; token price = _new token price ; uint256 eth = NUM_ ; rate = eth . div ( token price ) ; token price changed ( token price , rate ) ; }", "nl": "allows the owner to change the price of the token ."}
{"code": "function assert equals ( uint256 expected value , uint256 actual value ) private pure { if ( expected value != actual value ) revert ( ) ; }", "nl": "throw an exception if the amount be not equal ."}
{"code": "function approve and call ( address _spender , uint256 _value , bytes _extra data ) returns ( bool success ) { token recipient spender = token recipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receive approval ( msg . sender , _value , this , _extra data ) ; return BOOL_ ; } }", "nl": "allows _spender to spend no more than _value tokens in your behalf , and then ping the contract about it ."}
{"code": "function precrowdsale ( address tokenholder ) only front payable { require ( presold < presold max ) ; uint award ; uint donation ; require ( already participated [ tokenholder ] != BOOL_ ) ; already participated [ tokenholder ] = BOOL_ ; dragon pricing pricingstructure = new dragon pricing ( ) ; ( award , donation ) = pricingstructure . precrowdsalepricing ( tokenholder , msg . value ) ; token reward . transfer ( charity , donation ) ; presold = presold . add ( award ) ; presold = presold . add ( donation ) ; tokens sold = tokens sold . add ( donation ) ; token reward . transfer ( tokenholder , award ) ; if ( advisor cut < advisor total ) { advisor siphon ( ) ; } else { beneficiary . transfer ( msg . value ) ; } ether raised = ether raised . add ( msg . value ) ; tokens sold = tokens sold . add ( award ) ; }", "nl": "run during precrowdsale - can only be call by main crowdsale contract ."}
{"code": "modifier goal not reached { require ( raised ether < soft cap && now > end ) ; _ ; }", "nl": "restrict to the state of not enough ether be gather after the time be up ."}
{"code": "function _create poo ( string _name , address _owner , uint256 _price ) private { poo memory _poo = poo ( { name : _name } ) ; uint256 new poo id = poos . push ( _poo ) - NUM_ ; require ( new poo id == uint256 ( uint32 ( new poo id ) ) ) ; birth ( new poo id , _name , _owner ) ; poo index to price [ new poo id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new poo id ) ; }", "nl": "for create poo ."}
{"code": "function cancel order ( address [ NUM_ ] addresses , uint [ NUM_ ] order values , bool buy no more than amount b , uint8 margin split percentage , uint8 v , bytes32 r , bytes32 s ) external { uint cancel amount = order values [ NUM_ ] ; require ( cancel amount > NUM_ ) ; order memory order = order ( addresses [ NUM_ ] , addresses [ NUM_ ] , addresses [ NUM_ ] , order values [ NUM_ ] , order values [ NUM_ ] , order values [ NUM_ ] , buy no more than amount b , margin split percentage ) ; require ( msg . sender == order . owner ) ; bytes32 order hash = calculate order hash ( order , order values [ NUM_ ] , order values [ NUM_ ] , order values [ NUM_ ] ) ; verify signature ( order . owner , order hash , v , r , s ) ; cancelled or filled [ order hash ] = cancelled or filled [ order hash ] . add ( cancel amount ) ; order cancelled ( order hash , cancel amount ) ; }", "nl": "cancel a order ."}
{"code": "function set exchange limit ( uint new limit ) external only cfo { exchange limit = new limit ; }", "nl": "allows owner to change exchangelimit ."}
{"code": "modifier has mint permission ( ) { require ( msg . sender == crowdsale || msg . sender == owner ) ; _ ; }", "nl": "we have two minters the crowdsale contract and the token deployer ( owner ) ."}
{"code": "function set min allowed reserving percentage ( uint _value ) public only owner returns ( bool success ) { assert ( _value > NUM_ && _value < NUM_ ) ; min allowed reserving percentage = _value ; emit set min allowed reserving percentage ( _value ) ; return BOOL_ ; }", "nl": "setting the minallowedreservingpercentage value , allow only for owner ."}
{"code": "function deposit ( address _to ) payable public { require ( msg . value > NUM_ ) ; if ( _to == NUM_ ) _to = msg . sender ; if ( hodlers [ _to ] . time == NUM_ ) { hodlers [ _to ] . time = now + hodl_interval ; m_hodlers ++ ; } hodlers [ _to ] . value += msg . value ; }", "nl": "join the club ! make a deposit to another account if it exist or initialize a deposit for a new account ."}
{"code": "function has ended ( ) public constant returns ( bool ) { return is finalized ; }", "nl": "true if event have end ."}
{"code": "function user name taken ( string user name ) public view returns ( bool taken ) { bytes32 uncased user name hash = keccak256 ( abi . encode packed ( user name . lower ( ) ) ) ; return initialized ( uncased user name hash ) ; }", "nl": "returns a bool indicate whether a give username have be claim ( either exactly or a any case-variant ) ."}
{"code": "function exchange sta stb ( uint256 _from , uint256 _to ) private { if ( ! is ico succeeded ) throw ; if ( _from >= _to ) return ; uint256 _sta2stb = NUM_ * * NUM_ ; uint256 _wei2stb = NUM_ * * NUM_ ; if ( ! is stb minted for sta ex ) { uint256 _mint amount = ( NUM_ * total funded ) * NUM_ / NUM_ / _wei2stb ; one sta is stb = _mint amount / NUM_ ; stb . mint ( address ( this ) , _mint amount ) ; is stb minted for sta ex = BOOL_ ; } uint256 _to burn = NUM_ ; for ( uint256 i = _from ; i < _to ; i ++ ) { if ( received sta [ i ] . exchanged ) continue ; stb . transfer ( received sta [ i ] . miner address , received sta [ i ] . sta amount / _sta2stb * one sta is stb / NUM_ * * NUM_ ) ; received sta [ i ] . exchanged = BOOL_ ; received sta [ i ] . stb amount = received sta [ i ] .", "nl": "send stb to the miners who return sta tokens - after successful ico ."}
{"code": "function migration ( address sender , address receiver ) only owner public returns ( bool ) { require ( sender != receiver ) ; bool result = BOOL_ ; uint256 _value = data . get old balance of ( receiver ) ; if ( data . balance of ( receiver ) == NUM_ ) { if ( _value > NUM_ ) { _transfer ( sender , receiver , _value ) ; result = BOOL_ ; } } if ( data . get old frozen account ( receiver ) == BOOL_ ) { if ( data . frozen account ( receiver ) != BOOL_ ) { data . set frozen account ( receiver , BOOL_ ) ; } } return result ; }", "nl": "data migration ."}
{"code": "function set eth pre amount ( uint256 eth pre amount in wei ) is owner { require ( eth pre amount in wei > NUM_ ) ; require ( eth pre amount != eth pre amount in wei ) ; eth pre amount = eth pre amount in wei ; update prices ( ) ; }", "nl": "set current ethpreamount price in wei for one token ."}
{"code": "function transfer ( address _to , uint _value ) only after sale returns ( bool ) { return super . transfer ( _to , _value ) ; }", "nl": "transfer tokens only allow after sale have end ."}
{"code": "function start token votes ( address [ NUM_ ] tokens ) public only admins { uint _proposal id = token batches . length ; if ( _proposal id > NUM_ ) { token proposal memory op = token batches [ _proposal id - NUM_ ] ; destructible mini me token ( op . voting token ) . recycle ( ) ; } token batches . length ++ ; token proposal storage p = token batches [ _proposal id ] ; p . duration = voting_duration * ( NUM_ days ) ; p . considered tokens = tokens ; p . voting token = token factory . create destructible clone token ( nectar token , get block number ( ) , append uint to string ( STR_ , _proposal id ) , mini me token ( nectar token ) . decimals ( ) , append uint to string ( STR_ , _proposal id ) , BOOL_ ) ; p . start time = now ; p . start block = get block number ( ) ; emit new tokens ( _proposal id ) ; }", "nl": "admins be able to approve proposal that someone submit ."}
{"code": "function _owns ( address _claimant , uint256 _token id ) internal view returns ( bool ) { return player index to owner [ _token id ] == _claimant ; }", "nl": "checks if a give address be the current owner of a particular player ."}
{"code": "function remove approved game ( address _game address ) only owner public { approved games [ _game address ] = BOOL_ ; remove item ( _game address ) ; }", "nl": "manually remove approved game ."}
{"code": "function change owner ( address _address ) public only super owner { owner = _address ; }", "nl": "change owner address ."}
{"code": "modifier only owner { assert ( msg . sender == owner ) ; _ ; }", "nl": "notice check if the msgsender be owner ."}
{"code": "function give reward ( uint256 [ NUM_ ] _heroes , bool _did win , uint32 [ NUM_ ] _original exps ) private returns ( uint32 exp reward given , uint256 gold reward given ) { if ( ! _did win ) { gold reward given = gold reward / NUM_ ; exp reward given = exp reward / NUM_ ; } else { gold reward given = gold reward ; exp reward given = exp reward ; } gold contract . mint ( msg . sender , gold reward given ) ; if ( _heroes [ NUM_ ] != NUM_ ) hero contract . add exp ( _heroes [ NUM_ ] , uint32 ( NUM_ ) * * NUM_ - _original exps [ NUM_ ] + exp reward given ) ; if ( _heroes [ NUM_ ] != NUM_ ) hero contract . add exp ( _heroes [ NUM_ ] , uint32 ( NUM_ ) * * NUM_ - _original exps [ NUM_ ] + exp reward given ) ; if ( _heroes [ NUM_ ] != NUM_ ) hero contract . add exp ( _heroes [ NUM_ ] , uint32 ( NUM_ ) * * NUM_ - _original exps", "nl": "give reward ."}
{"code": "modifier not allowed ( ) { require ( ! transfer allowed ) ; _ ; }", "nl": "modifier for check transfer allownes ."}
{"code": "function activate ( ) is admin ( ) public { require ( activated_ == BOOL_ , STR_ ) ; activated_ = BOOL_ ; round id_ = NUM_ ; }", "nl": "activate the contract ."}
{"code": "function get next rules ( ) public view only owner returns ( uint , uint , uint , uint , bool ) { return ( game . next game rules . jackpot , game . next game rules . slots , game . next game rules . ticket price , game . next game rules . max tickets per , game . loop ) ; }", "nl": "get the rule for the upcoming game ( if there even be one ) ( jackpot , numberoftickets , ticketprice , maxticketsper , willstartnewgameuponcompletion ) ."}
{"code": "function create promo meme ( address _owner , uint256 _metadata , string _text , uint256 _price ) public only doge andr9k { require ( promo created count < promo_creation_limit ) ; address meme owner = _owner ; if ( meme owner == address ( NUM_ ) ) { meme owner = doge address ; } if ( _price <= NUM_ ) { _price = starting price ; } promo created count ++ ; _create meme ( _metadata , _text , meme owner , _price ) ; }", "nl": "creates a new promo meme with the give metadata and text , with give _price and assign it to an address ."}
{"code": "function get accumulated distribution percentage ( ) public view returns ( uint256 percentage ) { uint256 period = get current period index ( ) ; assert ( period < total periods ) ; return periods [ period ] ; }", "nl": "calculate the accumulated distribution percentage a of now , follow the exponential distribution curve ."}
{"code": "function contains ( data storage self , address _id ) public view returns ( bool ) { return self . nodes [ _id ] . key > NUM_ ; }", "nl": "checks if the list contain a node ."}
{"code": "function get pre ico token holders addresses count ( ) public view returns ( uint256 ) { return pre ico token holders addresses . length ; }", "nl": "count the preico investors total ."}
{"code": "function add animal type ( uint128 cost ) { if ( ! ( msg . sender == owner ) ) throw ; costs . push ( cost ) ; values . push ( cost / NUM_ * fee ) ; }", "nl": "add a new animal type to the game max ."}
{"code": "function owner migration ( address _owner ) public only owner returns ( address ) { owner = _owner ; return owner ; }", "nl": "migrate the owner of this contract ."}
{"code": "modifier when frozen ( address _holder address ) { require ( freeze holders [ _holder address ] ) ; _ ; }", "nl": "modifier to make a function callable only when the token holder be frozen ."}
{"code": "function prolong crowdsale ( ) public only owner and director { require ( now < crowdsale end time ) ; crowdsale end time = crowdsale hard end time ; }", "nl": "extend crowdsale for 2 weeks ."}
{"code": "function get amountof total participants ( ) constant returns ( uint ) { return total participants ; }", "nl": "return the total amount of participants in the ico ."}
{"code": "function burn ( address burner , uint256 _value ) public { require ( _value <= balances [ burner ] ) ; if ( _value > NUM_ ) { balances [ burner ] = safe math . sub ( balances [ burner ] , _value ) ; total supply = safe math . sub ( total supply , _value ) ; burn ( burner , _value ) ; transfer ( burner , address ( NUM_ ) , _value ) ; } }", "nl": "burn _value of tokens from address burner ."}
{"code": "function unhold funds ( ) only owner public { if ( goal reached ( ) ) { is min cap reached = BOOL_ ; vault . unhold ( ) ; } else { revert ( ) ; } }", "nl": "finish presale stage and move vault to refund state if goal be not reach ."}
{"code": "function can redeem utxo ( bytes32 txid , bytes20 original address , uint8 output index , uint satoshis , bytes proof ) public constant returns ( bool ) { bytes32 merkle leaf hash = keccak256 ( txid , original address , output index , satoshis ) ; return can redeem utxohash ( merkle leaf hash , proof ) ; }", "nl": "convenience helper function to check if a utxo can be redeem ."}
{"code": "function release contract ( ) public { little sister token sister contract = little sister token ( sister ) ; require ( now > validity date ) ; require ( msg . sender == owner ) ; sister contract . release contract ( ) ; selfdestruct ( owner ) ; }", "nl": "destroys the contract as well a the little sister ."}
{"code": "function start presale ( uint256 _start time presale ) external only owner at stage ( stages . pending ) { if ( _start time presale == NUM_ ) { start time presale = now ; } else { start time presale = _start time presale ; } set tier end time ( ) ; stage = stages . pre sale ; }", "nl": "set when presale start ."}
{"code": "function bet with credits ( uint64 _bet ) public { if ( _bet > settings . max bet ) return _bet failure ( STR_ , _bet , BOOL_ ) ; if ( _bet < settings . min bet ) return _bet failure ( STR_ , _bet , BOOL_ ) ; if ( _bet > cur max bet ( ) ) return _bet failure ( STR_ , _bet , BOOL_ ) ; if ( _bet > credits [ msg . sender ] ) return _bet failure ( STR_ , _bet , BOOL_ ) ; uint32 _id = _create new game ( uint64 ( _bet ) ) ; vars . total credits -= uint88 ( _bet ) ; credits [ msg . sender ] -= _bet ; emit credits used ( now , msg . sender , _id , _bet ) ; emit bet success ( now , msg . sender , _id , _bet , settings . cur pay table id ) ; }", "nl": "allows a user to create a game from credits ."}
{"code": "function update addresses ( address _lot , address _er ) external only etheraffle { lotcontract = lotinterface ( _lot ) ; etheraffle contract = etheraffle interface ( _er ) ; }", "nl": "allows contract address to be change in the event of future contract upgrade ."}
{"code": "function new tank type ( ) private { if ( new id tank product > NUM_ ) { return ; } if ( create new tank hull < new id tank hull - NUM_ && create new tank weapon >= new id tank weapon - NUM_ ) { create new tank weapon = NUM_ ; create new tank hull ++ ; } else { create new tank weapon ++ ; if ( create new tank hull == create new tank weapon ) { create new tank weapon ++ ; } } new tank product ( STR_ , uint32 ( create new tank hull ) , uint32 ( create new tank weapon ) , NUM_ , NUM_ , now + ( NUM_ * NUM_ ) ) ; return ; }", "nl": "this be the tricky method which create the new type tank ."}
{"code": "function array contains address256 ( address [ ] addresses , address value ) internal pure returns ( bool ) { for ( uint8 i = NUM_ ; i < addresses . length ; i ++ ) { if ( addresses [ i ] == value ) { return BOOL_ ; } } return BOOL_ ; }", "nl": "address may not be long than 256 ."}
{"code": "modifier crowdsale open ( ) { require ( crowdsale continue == BOOL_ ) ; require ( now >= crowdsale start date ) ; require ( now <= crowdsale stop date ) ; _ ; }", "nl": "require crowdsale open ."}
{"code": "function create promo collectible ( uint8 _team id , uint8 _pos id , uint256 _attributes , address _owner , uint256 _game id , uint256 _player override id , uint256 _mlb player id ) external can create when not paused returns ( uint256 ) { address nft owner = _owner ; if ( nft owner == address ( NUM_ ) ) { nft owner = manager primary ; } if ( all nfts . length > NUM_ ) { promo created count [ _team id ] ++ ; } uint32 _sequence id = get sequence id ( _team id ) ; uint256 asset details = uint256 ( uint64 ( now ) ) ; asset details |= uint256 ( _sequence id ) << NUM_ ; asset details |= uint256 ( _team id ) << NUM_ ; asset details |= uint256 ( _pos id ) << NUM_ ; uint256 [ NUM_ ] memory _nft data = [ asset details , _attributes , _game id , _player override id , _mlb player id ] ; return _create nftcollectible ( _team id , _attributes , nft owner , NUM_ , _nft data ) ; }", "nl": "the generation of an asset if limit via the generationseasoncontroller ."}
{"code": "function tokens supply ( ) public view returns ( uint ) { return token . total supply ( ) ; }", "nl": "returns number of supplied tokens ."}
{"code": "function set winner place distribution ( uint256 place , uint256 _val ) external only owner { require ( place <= count winner place ) ; require ( _val <= NUM_ ) ; uint256 test val = NUM_ ; uint256 index ; for ( index = NUM_ ; index <= count winner place ; index ++ ) { if ( index != place ) { test val = test val + prize distribution [ index ] ; } } test val = test val + _val ; require ( test val <= NUM_ ) ; prize distribution [ place ] = _val ; }", "nl": "set the distribution of the prize by place ."}
{"code": "function number of pledge admins ( ) constant returns ( uint ) { return admins . length - NUM_ ; }", "nl": "a constant getter use to check how many total admins exist ."}
{"code": "function finalize crowdsale ( crowdsale token token ) { require ( msg . sender == address ( crowdsale ) ) ; uint tokens sold = crowdsale . tokens sold ( ) ; uint sale base points = base points divisor . sub ( bonus base points ) ; allocated bonus = tokens sold . mul ( bonus base points ) . div ( sale base points ) ; token . mint ( team multisig , allocated bonus ) ; token . release token transfer ( ) ; }", "nl": "called once by crowdsale finalize ( ) if the sale be a success ."}
{"code": "function proceed ( ) external is paused only owner { state = saved state ; }", "nl": "proceeds with the contract ."}
{"code": "function disable initial stage ( ) only administrator ( ) public { only ambassadors = BOOL_ ; }", "nl": "in case the ambassador quota be not meet , the administrator can manually disable the ambassador phase ."}
{"code": "function set dungeon status ( uint _id , uint _new status ) either owner token exists ( _id ) external { dungeons [ _id ] . status = uint8 ( _new status ) ; }", "nl": "the external function to set dungeon status by it id , refer to dungeonstructs for more information about dungeon status ."}
{"code": "function unlock allocation address ( address allocation address ) public only owner returns ( bool ) { require ( token != address ( NUM_ ) ) ; token . set initial allocation unlock ( allocation address ) ; for ( uint idx = NUM_ ; idx < locked addresses list . length ; idx ++ ) { if ( locked addresses list [ idx ] == allocation address ) { locked addresses list [ idx ] = address ( NUM_ ) ; break ; } } return BOOL_ ; }", "nl": "unlocks give allocation address ."}
{"code": "function claim rewards ( ) { uint reward = get reward ( msg . sender ) ; modify balance ( msg . sender , reward ) ; forbid ( msg . sender ) ; }", "nl": "claim the reward ."}
{"code": "function clear storage ( uint [ ] clean commits ) external { uint length = clean commits . length ; for ( uint i = NUM_ ; i < length ; i ++ ) { clear processed bet ( clean commits [ i ] ) ; } }", "nl": "a helper routine to bulk clean the storage ."}
{"code": "modifier only admin ( ) { if ( ! administrators [ msg . sender ] ) { revert ( ) ; } _ ; }", "nl": "modifier allow only if function be call by administrator ."}
{"code": "function set token information ( string _token name , string _token symbol ) public only owner { name = _token name ; symbol = _token symbol ; emit updated token information ( name , symbol ) ; }", "nl": "update the symbol ."}
{"code": "function backlog amount ( ) public view returns ( uint256 ) { return backlog ; }", "nl": "total amount still owe in credit to depositors ."}
{"code": "function approve and call ( address _spender , uint256 _value , bytes _data ) public payable when not paused returns ( bool ) { return super . approve and call ( _spender , _value , _data ) ; }", "nl": "827 section ."}
{"code": "function set admin ( address _admin , bool _allowed ) public only owner { require ( _admin != address ( NUM_ ) ) ; admins [ _admin ] = _allowed ; set admin ( msg . sender , _admin , _allowed ) ; }", "nl": "admin management ."}
{"code": "function cancel option order ( address [ NUM_ ] asset locked_asset traded_first maker , uint256 [ NUM_ ] amount locked_amount traded_maturation , bool maker is seller ) external { option states state = get option state ( asset locked_asset traded_first maker , amount locked_amount traded_maturation ) ; require ( state == option states . available || state == option states . live ) ; bytes32 option hash = get option hash ( asset locked_asset traded_first maker , amount locked_amount traded_maturation ) ; if ( state == option states . available ) { require ( msg . sender == asset locked_asset traded_first maker [ NUM_ ] ) ; emit order cancelled ( option hash , maker is seller , NUM_ ) ; option data [ option hash ] . nonce seller = NUM_ ; } else { if ( maker is seller ) { require ( msg . sender == option data [ option hash ] . seller ) ; emit order cancelled ( option hash , maker is seller , option data [ option hash ] . nonce seller ) ; option data [ option hash ] . nonce seller += NUM_ ; } else { require ( msg .", "nl": "allows a maker to cancel their offchain option order early ( i . e ."}
{"code": "function on erc721 received ( address _from , uint _token id , bytes _extra data ) external returns ( bytes4 ) { _deposit ( _from , msg . sender , _token id , _extra data ) ; return erc721_received_old ; }", "nl": "deprecate callback ( do not handle operator ) ."}
{"code": "function save result ( uint team id ) only owner public { win choice = team id ; bet closed = BOOL_ ; win reward = deposit . add ( total bet amount ) . div ( number of choice [ win choice ] ) ; log win choice ( win choice , win reward ) ; }", "nl": "close who be champion bet with the champion id ."}
{"code": "function in allocation lock period ( ) constant returns ( bool ) { return ( block . timestamp < allocation_lock_end_timestamp ) ; }", "nl": "true if the current timestamp be before the allocation lock period ."}
{"code": "function set approval for all ( address _operator , bool _approved ) external { operator approvals [ msg . sender ] [ _operator ] = _approved ; emit approval for all ( msg . sender , _operator , _approved ) ; }", "nl": "enable or disable approval for a third party ( operator ) to manage all of msg . sender 's ."}
{"code": "function update rate ( uint _new rate ) only owner public { require ( base rate != NUM_ ) ; require ( _new rate . mul ( NUM_ ) > base rate && base rate . mul ( NUM_ ) > _new rate ) ; base rate = _new rate ; }", "nl": "update only if contract be not get traction or get more traction that initially think ."}
{"code": "modifier when not locked ( address _from , uint256 _value ) { require ( active balance of ( _from ) >= _value ) ; _ ; }", "nl": "if active balance be not enought ."}
{"code": "function min house stake ( uint active games ) public pure returns ( uint ) { return math util . min ( active games , NUM_ ) * max_bet_value * NUM_ ; }", "nl": "calculate minimum need house stake ."}
{"code": "function final unlock transfer ( ) public { require ( can change locked ) ; locked = BOOL_ ; can change locked = BOOL_ ; }", "nl": "final unlock transfer token ( 'locked ' and 'canchangelocked ' ) ."}
{"code": "function price ( uint256 _time ) constant public returns ( uint256 ) { require ( _time >= sale start time ) ; require ( _time <= safe add ( sale start time , sale duration ) ) ; require ( _time <= two128_1 ) ; uint256 t = _time << NUM_ ; uint256 c plus t = ( c >= NUM_ ) ? safe add ( t , uint256 ( c ) ) : safe sub ( t , uint256 ( - NUM_ - c ) + NUM_ ) ; int256 ln cplus t = ln ( c plus t ) ; int256 b ln cplus t = fp mul i ( b , ln cplus t ) ; int256 a plus bln cplus t = safe add i ( a , b ln cplus t ) ; require ( a plus bln cplus t >= NUM_ ) ; return uint256 ( a plus bln cplus t ) ; }", "nl": "price at give time a 128 . 128 fixed point number ."}
{"code": "function price of player ( uint _player id ) public view returns ( uint price ) { price = player index to price [ _player id ] ; }", "nl": "function to get price of a player ."}
{"code": "modifier only_when_not_updating ( ) { require ( ! updating ) ; _ ; }", "nl": "prevent reentry ."}
{"code": "function get index by address ( address _owner , address _swap ) public constant returns ( uint index ) { return swap_balances_index [ _swap ] [ _owner ] ; }", "nl": "returns the index associate with the _owner address in a particular swap ."}
{"code": "function approve ( address _spender , uint256 _amount ) public returns ( bool ) { require ( ( _amount == NUM_ ) || ( allowances [ msg . sender ] [ _spender ] == NUM_ ) ) ; allowances [ msg . sender ] [ _spender ] = _amount ; approval ( msg . sender , _spender , _amount ) ; return BOOL_ ; }", "nl": "allows another account to spend a give amount of tokens on behalf of the owner 's account ."}
{"code": "function num bonuses ( ) public view returns ( uint256 ) { return bonus list . length ; }", "nl": "count of bonuses in list ."}
{"code": "function challenge can be resolved ( bytes32 _listing hash ) view public returns ( bool ) { uint challenge id = listings [ _listing hash ] . challenge id ; require ( challenge exists ( _listing hash ) ) ; return voting . poll ended ( challenge id ) ; }", "nl": "determines whether vote have conclude in a challenge for a give listinghash ."}
{"code": "function set token description ( address _token interface , uint256 _token id , string _description ) set token text ( _token interface , _token id , _description ) external payable { _set token description ( _token interface , _token id , _description ) ; }", "nl": "set description for specify token , ."}
{"code": "function get balance ( address token , address account ) external view returns ( uint256 ) { return balances [ token ] [ account ] ; }", "nl": "get balance information ."}
{"code": "function its like chicago ( ) payable { require ( voted [ msg . sender ] && msg . value >= NUM_ ether ) ; voted [ msg . sender ] = BOOL_ ; }", "nl": "pay to vote again ! i do n't care ! . . . but ."}
{"code": "function activate sale contract ( address _contract ) public only owner returns ( bool ) { require ( _contract != address ( NUM_ ) ) ; require ( sale tokens > NUM_ ) ; uint256 tokens = sale tokens ; sale tokens = NUM_ ; sale contract = _contract ; total supply_ = total supply_ . add ( tokens ) ; balances [ _contract ] = balances [ _contract ] . add ( tokens ) ; emit transfer ( address ( NUM_ ) , _contract , tokens ) ; return BOOL_ ; }", "nl": "sending tokens for sale to the sale contract address ."}
{"code": "function set pause ( bool _new pause ) only owner public { pause = _new pause ; }", "nl": "allows owner to pause the crowdsale ."}
{"code": "function supports interface ( bytes4 _interface id ) external view returns ( bool ) { return ( ( _interface id == interface signature_erc165 ) || ( _interface id == interface signature_erc721 ) ) ; }", "nl": "erc165 required ."}
{"code": "function get total composition price ( uint256 [ ] _token ids ) public view returns ( uint256 ) { uint256 total composition price = NUM_ ; for ( uint i = NUM_ ; i < _token ids . length ; i ++ ) { require ( _token layers exist ( _token ids [ i ] ) ) ; total composition price = safe math . add ( total composition price , token id to composition price [ _token ids [ i ] ] ) ; } total composition price = safe math . div ( safe math . mul ( total composition price , NUM_ ) , NUM_ ) ; return total composition price ; }", "nl": "get total price for mint a composition give the array of desired layer ."}
{"code": "function withdraw ( uint256 _value ) public only owner { wallet . transfer ( _value ) ; withdraw ( _value ) ; }", "nl": "transfer ether from smartcontract to zebiwallet ."}
{"code": "function collect fee ( ) { msg . sender . send ( msg . value ) ; if ( msg . sender == creator ) { creator . send ( fee collected ) ; fee collected = NUM_ ; } else { return ; } }", "nl": "allow the creator to collect the 3 fee ."}
{"code": "function set ethprice manually ( uint _price ) external onlymanyowners ( keccak256 ( msg . data ) ) { require ( price expired ( ) || update request expired ( ) ) ; m_ethprice in cents = _price ; m_ethprice last update = get time ( ) ; new ethprice ( m_ethprice in cents ) ; }", "nl": "set the price of eth in cents , call in case we do n't get oraclize data for more than double the update interval ."}
{"code": "function sell ( uint256 amount ) public { transfer ( msg . sender , this , amount ) ; }", "nl": "sell tokens back to sender use owners ether ."}
{"code": "function open crates ( ) public when not paused { uint [ ] memory pc = pending crates [ msg . sender ] ; require ( pc . length > NUM_ ) ; uint8 count = NUM_ ; for ( uint i = NUM_ ; i < pc . length ; i ++ ) { uint crate block = pc [ i ] ; require ( block . number > crate block ) ; var hash = block . blockhash ( crate block ) ; if ( uint ( hash ) != NUM_ ) { uint rand = uint ( keccak256 ( hash , msg . sender , i ) ) % ( NUM_ * * NUM_ ) ; _migrate robot ( uint to string ( rand ) ) ; count ++ ; } } crates opened ( msg . sender , count ) ; delete pending crates [ msg . sender ] ; }", "nl": "users can open pending crate on the new contract ."}
{"code": "function take ( erc20 gem , uint wad ) public note auth { require ( gem == alt || gem == ref ) ; uint jam = ( gem == ref ) ? wdiv ( wad , tag ( ) ) : wmul ( wad , tag ( ) ) ; jam = wmul ( gap , jam ) ; erc20 pay = ( gem == ref ) ? alt : ref ; pay . transfer from ( msg . sender , this , jam ) ; gem . transfer ( msg . sender , wad ) ; }", "nl": "ref - alt ."}
{"code": "function refund adveriser ( uint amount ) public { require ( advertiser balances [ msg . sender ] - amount >= NUM_ , STR_ ) ; advertiser balances [ msg . sender ] -= amount ; msg . sender . transfer ( amount ) ; emit refund advertiser ( msg . sender , amount ) ; }", "nl": "called by an advertiser when he / she would like to get a refund ."}
{"code": "function pay_bounty ( address _address , uint _sum_pay ) only owner public { transfer ( _address , _sum_pay ) ; freeze ( _address , NUM_ ) ; }", "nl": "freeze use bounty company ."}
{"code": "function find auditor ( address addr ) constant returns ( address auditor address , uint256 [ NUM_ ] karma , address record owner ) { return auditor registry . get auditor ( addr ) ; }", "nl": "retrieve information about registered auditor ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public valid destination ( _to ) only when transfer enabled returns ( bool ) { return super . transfer from ( _from , _to , _value ) ; }", "nl": "override to only allow tranfer after be switch on ."}
{"code": "function get token amount ( uint256 wei amount ) internal view returns ( uint256 ) { return wei amount . mul ( rate ) . div ( NUM_ ) ; }", "nl": "a uint256 , amount of tokens for amount of wei ."}
{"code": "function _set allocation ( address _buyer , uint256 _token amount ) internal { if ( ! buyers [ _buyer ] ) { buyers [ _buyer ] = BOOL_ ; addresses . push ( _buyer ) ; allocations total [ _buyer ] = NUM_ ; } allocations total [ _buyer ] = allocations total [ _buyer ] . add ( _token amount ) ; uint256 split amount = allocations total [ _buyer ] . div ( NUM_ ) ; uint256 diff = allocations total [ _buyer ] . sub ( split amount + split amount + split amount ) ; allocations1 [ _buyer ] = split amount ; allocations2 [ _buyer ] = split amount ; allocations3 [ _buyer ] = split amount . add ( diff ) ; emit log new allocation ( _buyer , _token amount ) ; }", "nl": "set internal allocation _buyer the adress of the buyer _tokenamount amount allocated tokens + 18 decimals ."}
{"code": "function _finalize ico ( ) internal { require ( phase_i != phase_not_started && phase_i != phase_finished , STR_ ) ; phase_i = phase_ico_finished ; uint curr_date = now ; finish_date = ( curr_date < ico_phase_5_end ? ico_phase_5_end : curr_date ) . add ( seconds_in_day * NUM_ ) ; }", "nl": "finalize ico ."}
{"code": "function latest reference block number ( ) constant returns ( uint256 block number ) { return ( block . number - block . number % NUM_ ) ; }", "nl": "what be the late reference block number ? ."}
{"code": "function change partner coin percentage ( uint percentage ) public { require ( msg . sender == wallet owner ) ; coin percentage = percentage ; }", "nl": "function to change the coin percentage award to the partner can only be call from the owner wallet ."}
{"code": "function _new presser fee ( uint256 _balance ) private view returns ( uint128 ) { if ( _is member ( ) ) { return NUM_ ; } return uint128 ( ( _balance * signup fee ) / NUM_ ) ; }", "nl": "caller must assure that _balance max_uint128 ."}
{"code": "function _mint token ( uint256 player id , string token uri , address owner ) internal { uint256 token id = all tokens . length + NUM_ ; super . _mint ( owner , token id ) ; _set token uri ( token id , token uri ) ; _set player id ( token id , player id ) ; }", "nl": "creates a new token ."}
{"code": "function get land ( uint _land id ) public view returns ( address owner address , uint256 price paid , uint256 cur price , bool is for sale ) { land storage _land = lands [ _land id ] ; owner address = _land . owner address ; price paid = _land . price paid ; cur price = _land . cur price ; is for sale = _land . is for sale ; }", "nl": "these function will return the detail of a piece of land ."}
{"code": "function order_sell ( uint256 _max_amount , uint256 _price ) returns ( bool ) { if ( ! ( _max_amount > NUM_ ) ) throw ; if ( ! ( _price > NUM_ ) ) throw ; orders_sell_amount [ msg . sender ] = _max_amount ; orders_sell_price [ msg . sender ] = ( _price * coef ) . div ( NUM_ ) ; orders_sell_list . push ( msg . sender ) ; order_sell ( msg . sender , _max_amount , orders_sell_price [ msg . sender ] ) ; return BOOL_ ; }", "nl": "user create sell order ."}
{"code": "function assign tokens ( address receiver , uint token amount ) private { mintable token mintable token = mintable token ( token ) ; mintable token . mint ( receiver , token amount ) ; }", "nl": "add this here because it be not visible by preallocate ."}
{"code": "function get state ( ) public constant returns ( state ) { if ( now >= pre sale start time && now <= pre sale end time ) { return state . pre sale ; } if ( now >= crowdfund start date && now <= crowdfund end date ) { return state . crowdfund ; } return state . finish ; }", "nl": "get function function to get the current state of the crowdsale ."}
{"code": "function _update purchasing state ( address _beneficiary , uint256 _wei amount ) internal { super . _update purchasing state ( _beneficiary , _wei amount ) ; if ( cap reached ( ) ) { if ( state == sale state . private sale ) { state = sale state . finalised private sale ; } else if ( state == sale state . pre sale ) { state = sale state . finalised pre sale ; } else if ( state == sale state . public sale tier1 ) { state = sale state . public sale tier2 ; } else if ( state == sale state . public sale tier2 ) { state = sale state . public sale tier3 ; } else if ( state == sale state . public sale tier3 ) { state = sale state . public sale tier4 ; } else if ( state == sale state . public sale tier4 ) { state = sale state . finalised public sale ; } else { return ; } token cap = get current tier hardcap ( ) ; emit increment tiered state ( get state ( ) ) ; } }", "nl": "change the bonus tier after a purchase ."}
{"code": "function emergency refund ( ) public only in refund mode ( ) { if ( ! users [ msg . sender ] . refunded ) { uint total invested = users [ msg . sender ] . investments ; uint available for refund = ( total invested * refund_percent ) / NUM_ ; users [ msg . sender ] . investments -= available for refund ; users [ msg . sender ] . refunded = BOOL_ ; if ( ! msg . sender . send ( available for refund ) ) { users [ msg . sender ] . investments = total invested ; users [ msg . sender ] . refunded = BOOL_ ; } } }", "nl": "escape path - withdraw fund at emergency ."}
{"code": "function granularity ( ) external view returns ( uint256 ) { return granularity_ ; }", "nl": "returns the granularity ."}
{"code": "function transfer ( address _to , uint256 _value ) public only when valid address ( _to ) only when not frozen ( msg . sender ) only when not frozen ( _to ) returns ( bool ) { return super . transfer ( _to , _value ) ; }", "nl": "transfer _value token for a specified address ."}
{"code": "function confirm received ( ) public only broker in state ( state . locked ) { state = state . finished ; seller . transfer ( address ( this ) . balance - broker fee - developerfee ) ; broker . transfer ( broker fee ) ; developer . transfer ( developerfee ) ; emit item received ( ) ; }", "nl": "confirm that you ( the buyer ) receive the item ."}
{"code": "function burn ( uint _value ) only owner public returns ( bool ) { require ( ( balances [ owner ] . balance - _value ) >= NUM_ ) ; balances [ owner ] . balance = balances [ owner ] . balance . sub ( _value ) ; total supply = total supply . sub ( _value ) ; emit burn ( _value ) ; return BOOL_ ; }", "nl": "used to burn unspent tokens in the contract ."}
{"code": "function get straight releasable amount ( address _beneficiary ) internal view returns ( uint releasable amount ) { beneficiary memory _b = beneficiaries [ _beneficiary ] ; release memory _r = releases [ _beneficiary ] ; uint total releasable amount = get total locked amounts ( _beneficiary ) ; uint first time = _r . release times [ NUM_ ] ; uint last time = _r . release times [ NUM_ ] ; require ( now >= first time ) ; if ( now >= last time ) { releasable amount = total releasable amount ; } else { uint first amount = get partial amount ( _r . release ratios [ NUM_ ] , coeff , total releasable amount ) ; releasable amount = get partial amount ( now . sub ( first time ) , last time . sub ( first time ) , total releasable amount . sub ( first amount ) ) ; releasable amount = releasable amount . add ( first amount ) ; } releasable amount = releasable amount . sub ( _b . withdraw amount ) ; }", "nl": "return releaseable amount for beneficiary in case of straight type of release ."}
{"code": "function transfer balance ( address from , address to , uint256 value ) private returns ( bool ) { if ( to == address ( NUM_ ) || from == to ) revert ( ) ; if ( value == NUM_ ) { transfer ( msg . sender , to , value ) ; return BOOL_ ; } uint256 sender balance = balances [ from ] ; uint256 receiver balance = balances [ to ] ; if ( sender balance < value ) revert ( ) ; sender balance -= value ; receiver balance += value ; if ( receiver balance < value ) revert ( ) ; balances [ from ] = sender balance ; balances [ to ] = receiver balance ; transfer ( from , to , value ) ; return BOOL_ ; }", "nl": "todo : compare gas cost estimations between this and https : / / github . com / consensys / tokens / blob / master / contract / eip20 / eip20 . sol l39-l45 ."}
{"code": "function section available ( uint _section_index ) returns ( bool ) { if ( _section_index >= sections . length ) throw ; section s = sections [ _section_index ] ; return ! s . initial_purchase_done ; }", "nl": "check to see if section be available for first purchase ."}
{"code": "function frozen for team ( ) internal { uint total froze number = NUM_ * NUM_ * NUM_ * NUM_ * * NUM_ ; freeze ( msg . sender , total froze number ) ; }", "nl": "frozen for the team members ."}
{"code": "function transfer any erc20 token ( address _token_address , uint _amount ) public only owner returns ( bool success ) { return erc20 interface ( _token_address ) . transfer ( owner , _amount ) ; }", "nl": "erc20 function ."}
{"code": "function verify ( bytes32 hash , address sender , uint8 v , bytes32 r , bytes32 s ) internal pure returns ( bool ) { return ecrecover ( keccak256 ( STR_ ) , v , r , s ) == sender ; }", "nl": "check if the provided signature be valid , internal ."}
{"code": "function money back ( ) external in standing ( state . money_back_running ) no reentrancy { send money back ( ) ; }", "nl": "money back to users ."}
{"code": "function change bet price ( uint256 set bet price ) public only owner { bet price = set bet price ; }", "nl": "change the bet price if ether would surge ."}
{"code": "function killme ( ) public payable only contract owner { require ( now > last action + NUM_ days ) ; seed amount = NUM_ ; jackpot balance = NUM_ ; contract owner . transfer ( jackpot balance ) ; }", "nl": "return jackpot to contract creator if no purchase or claim in 30 days ."}
{"code": "function set and fix token price in wei ( uint256 new token price in wei ) external check access ( ) { require ( msg . sender == m_owner || msg . sender == m_price setter ) ; m_is fixed token price = BOOL_ ; m_token price in wei = new token price in wei ; price changed ( msg . sender , m_token price in wei , m_is fixed token price ) ; }", "nl": "set price of one token in wei and fix it ."}
{"code": "function send special taster package ( address addr , uint ug to taste ) public when not paused only owner returns ( bool success ) { tasters received [ addr ] = safe add ( tasters received [ addr ] , ug to taste ) ; transfer ( addr , ug to taste ) ; return BOOL_ ; }", "nl": "sends a special taster package to recipient - contract supply of tokens must have enough balance ."}
{"code": "function change bstrequirement ( address _factory , uint256 _amount ) public only owner { required bst [ _factory ] = _amount * NUM_ * * NUM_ ; }", "nl": "change bts requirement for buy bspt ."}
{"code": "function owner of ( uint256 _id ) public constant returns ( address ) { return emojis [ _id ] . owner ; }", "nl": "get the owner of an emoji ."}
{"code": "function approve ( address _spender , uint _value ) is not frozen is valid address public returns ( bool success ) { require ( _value == NUM_ || allowance [ msg . sender ] [ _spender ] == NUM_ ) ; allowance [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }", "nl": "erc20 token section ."}
{"code": "function burn all tokens ( address _address ) external returns ( bool success ) { require ( msg . sender == crowdsale address ) ; uint256 amount = balance of [ _address ] ; balance of [ _address ] = NUM_ ; total supply = total supply . sub ( amount ) ; burn ( _address , amount , total supply ) ; success = BOOL_ ; }", "nl": "burn all tokens assign to '_address ' ."}
{"code": "function start mining ( address _miner contract ) public only owner { require ( miner == address ( NUM_ ) ) ; miner = _miner contract ; in vault [ miner ] [ miner ] = NUM_ * ( NUM_ * * NUM_ ) ; }", "nl": "for mining ."}
{"code": "function set time ( uint _start , uint _close ) public only owner { require ( _start < _close ) ; start_time = _start ; close_time = _close ; }", "nl": "sets the start and end of the sale ."}
{"code": "function pick reward ( uint256 _tree id ) public { require ( msg . sender == tree details [ _tree id ] . owner ) ; require ( now - tree details [ _tree id ] . last reward picked date > time between rewards ) ; uint256 [ ] memory formated id = new uint256 [ ] ( NUM_ ) ; formated id [ NUM_ ] = _tree id ; uint256 [ ] memory rewards = check rewards ( formated id ) ; tree details [ _tree id ] . last reward picked date = now ; msg . sender . transfer ( rewards [ NUM_ ] ) ; log reward picked ( _tree id , msg . sender , now , rewards [ NUM_ ] ) ; }", "nl": "to get the ether from the reward ."}
{"code": "function get block number ( ) internal view returns ( uint256 ) { return block . number ; }", "nl": "this function be override by the test mocks ."}
{"code": "function dividends ( bool _include referral bonus ) external view returns ( uint256 ) { return p3 d ( NUM_ ) . my dividends ( _include referral bonus ) ; }", "nl": "get dividends for this contract ."}
{"code": "function cwcreturn transaction ( address from , uint amount ) private { require ( verified users only mode == BOOL_ || verified users [ from ] == BOOL_ ) ; require ( ! pause cwc ) ; require ( amount > min cwcs per return more than && amount < max cwcs per return less than ) ; if ( oraclize_get price ( STR_ ) > this . balance ) { needs ether ( STR_ ) ; pause cwc = BOOL_ ; revert ( ) ; } else { ticker query data = str concat ( STR_ , STR_ , STR_ , address to ascii string ( from ) , STR_ ) ; ticker query data = str concat ( ticker query data , uint2str ( amount ) ) ; bytes32 query id = oraclize_query ( STR_ , ticker query , ticker query data ) ; ticker query ids [ query id ] = BOOL_ ; ticker query purpose [ query id ] = NUM_ ; waiting seller [ query id ] = from ; cwc paid [ query id ] = amount ; received cwcreturn ( waiting seller [ query id ] , cwc paid [ query id ]", "nl": "cwc return transaction ."}
{"code": "function birthday boy click here ( ) public view returns ( string ) { require ( now < original time + NUM_ hours ) ; return STR_ ; }", "nl": "print a birthday message and then become impossible to execute after 23 hours ."}
{"code": "function update eth icovariables ( uint256 _new_eth_eur , uint256 _new end block ) public only state control { require ( state == states . initial || state == states . valuation set ) ; require ( block . number < _new end block ) ; require ( _new_eth_eur > NUM_ ) ; eth_eur = _new_eth_eur ; end block = _new end block ; move to state ( states . valuation set ) ; }", "nl": "ico contract configuration function new_eth_eur be the new rate of eth in eur ( from which to derive tokens per eth ) newendblock be the absolute block number at which the ico must stop ."}
{"code": "function validate name internal ( string _name ) constant internal returns ( bool allowed ) { bytes memory name bytes = bytes ( _name ) ; uint length bytes = name bytes . length ; if ( length bytes < minimum name length || length bytes > maximum name length ) { return BOOL_ ; } bool found non punctuation = BOOL_ ; for ( uint i = NUM_ ; i < length bytes ; i ++ ) { byte b = name bytes [ i ] ; if ( ( b >= NUM_ && b <= NUM_ ) || ( b >= NUM_ && b <= NUM_ ) || ( b >= NUM_ && b <= NUM_ ) ) { found non punctuation = BOOL_ ; continue ; } if ( b == NUM_ || b == NUM_ || b == NUM_ || b == NUM_ || b == NUM_ || b == NUM_ || b == NUM_ ) { continue ; } return BOOL_ ; } return found non punctuation ; }", "nl": "true if-and - only-if _name_ meet the criteria below , or false otherwise : - no few than 1 character - no more than 25 character - no character other than : - roman alphabet letter ( a-z and a-z ) - western digits ( 0-9 ) - safe punctuation : ! ( ) - ."}
{"code": "function get lock balance ( address _owner ) public view returns ( uint256 ) { return _lockup balances [ _owner ] ; }", "nl": "query the number of tokens for which an address be lock ."}
{"code": "function create purchase order ( address _from , uint _period , uint _value , bytes32 _salt ) public pure returns ( bytes32 ) { return keccak256 ( abi . encode packed ( _from , _period , _value , _salt ) ) ; }", "nl": "creates a sealed purchase order ."}
{"code": "function approve ( erc20 interface erc20 , address spender , uint tokens ) public returns ( bool success ) { require ( owner == msg . sender ) ; require ( erc20 . approve ( spender , tokens ) ) ; return BOOL_ ; }", "nl": "in case it need to proxy later in the future ."}
{"code": "function add role ( address _operator , string _role ) internal { roles [ _role ] . add ( _operator ) ; emit role added ( _operator , _role ) ; }", "nl": "add a role to an address ."}
{"code": "function update batches ( address _from , address _to , uint _value ) private { uint count = _value ; uint i = min index [ _from ] ; while ( count > NUM_ ) { uint _quant = batches [ _from ] [ i ] . quant ; if ( count >= _quant ) { count -= _quant ; batches [ _from ] [ i ] . quant = NUM_ ; min index [ _from ] = i + NUM_ ; } else { batches [ _from ] [ i ] . quant -= count ; count = NUM_ ; } i ++ ; } batch memory this batch ; this batch . quant = _value ; this batch . age = now ; batches [ _to ] [ max index [ _to ] ] = this batch ; max index [ _to ] ++ ; }", "nl": "private function to register quantity and age of batch from sender and receiver ( tokenwithdates ) ."}
{"code": "function set wallet address ( address _wallet address ) external only owner returns ( bool ) { require ( _wallet address != address ( NUM_ ) ) ; require ( _wallet address != address ( this ) ) ; require ( _wallet address != address ( token ) ) ; require ( is owner ( _wallet address ) == BOOL_ ) ; wallet address = _wallet address ; wallet address updated ( _wallet address ) ; return BOOL_ ; }", "nl": "owner configuation ."}
{"code": "function return to sender ( ) public only admins returns ( bool ) { require ( token . transfer ( multisig , token . balance of ( address ( this ) ) ) ) ; require ( multisig . send ( this . balance ) ) ; return BOOL_ ; }", "nl": "return all eth and tokens to original multisig ."}
{"code": "modifier is retractable ( bytes20 blob id ) { if ( blob info [ blob id ] . flags & retractable == NUM_ ) { throw ; } _ ; }", "nl": "throw if the blob be not retractable ."}
{"code": "function approve and call ( address _spender , uint256 _value , bytes _extra data ) public returns ( bool success ) { require ( ! frozen account [ msg . sender ] ) ; token recipient spender = token recipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receive approval ( msg . sender , _value , this , _extra data ) ; return BOOL_ ; } }", "nl": "4 allowance and notify the receipient / spender ."}
{"code": "function total supply ( ) public view returns ( uint ) { return monsters . length - NUM_ ; }", "nl": "returns the total number of monsters currently in existence ."}
{"code": "function _set subnode owner ( bytes32 subnode , address _owner ) internal { require ( ! known nodes [ subnode ] ) ; known nodes [ subnode ] = BOOL_ ; ens . set subnode owner ( root node , subnode , _owner ) ; }", "nl": "internal - register a name that 's not currently register ."}
{"code": "function get stats ( ) public constant returns ( uint256 , uint256 , bool ) { return ( total contribution , _total supply , purchasing allowed ) ; }", "nl": "get some stats ."}
{"code": "function withdraw dividend ( ) payable public { uint due = ( token . balance of ( msg . sender ) * div multiplier ) - claimed [ msg . sender ] ; if ( due + claimed [ msg . sender ] < claimed [ msg . sender ] ) revert ( ) ; claimed [ msg . sender ] += due ; total claimed += due ; msg . sender . transfer ( due ) ; emit payed ( msg . sender , due ) ; }", "nl": "as a holder of token , withdraw your dvidend ."}
{"code": "function _api_place bet ( ) payable { if ( msg . value < get minimum bet ( ) || ( msg . value + NUM_ ) > get maximum bet ( ) ) throw ; uint256 cnt block used = block used [ block . number ] ; if ( cnt block used > max games per block ) throw ; block used [ block . number ] = cnt block used + NUM_ ; games played ++ ; last player = msg . sender ; uint winner odds = NUM_ ; uint total partition = NUM_ ; if ( already played [ msg . sender ] ) { winner odds = NUM_ ; } already played [ msg . sender ] = BOOL_ ; winner odds = winner odds * NUM_ ; total partition = total partition * NUM_ ; uint256 random = create random number ( total partition ) ; if ( random <= winner odds ) { if ( ! msg . sender . send ( msg . value * NUM_ ) ) throw ; } }", "nl": "placebet use access code , and mode parameter ."}
{"code": "function freeze transfers ( ) public only admin returns ( bool frozen ) { token transfers frozen = BOOL_ ; freeze transfers ( msg . sender , BOOL_ ) ; return BOOL_ ; }", "nl": "used to freeze token transfer ."}
{"code": "function get interest ( address _to ) public view returns ( uint interest ) { if ( last block interest paid [ _to ] > NUM_ ) { interest = ( ( block . number - last block interest paid [ _to ] ) * balance of [ _to ] * interest rate ) / ( NUM_ ) ; } else { interest = NUM_ ; } return interest ; }", "nl": "return an addresse 's current unpaid interest amount in ilot ."}
{"code": "modifier is owner ( ) { if ( msg . sender != owner ) throw ; _ ; }", "nl": "modifier restrict only the owner of this contract to perform certain operations ."}
{"code": "function claim bonus tokens ( ) public can claim bonus { uint256 sender balance = token . balance of ( msg . sender ) ; uint256 purchased proportion = sender balance . mul ( NUM_ ) . div ( total tokens sold ) ; uint256 bonus for sender = bonus tokens pool . mul ( purchased proportion ) . div ( NUM_ ) ; token . transfer ( msg . sender , bonus for sender ) ; claimed bonus [ msg . sender ] = BOOL_ ; }", "nl": "allows contributor to claim part of the tokens remain after crowdsale stage finalize ."}
{"code": "function balance of ( address _owner ) public constant returns ( uint ) { uint sum = NUM_ ; for ( uint i = NUM_ ; i < allocated index [ _owner ] . length ; i ++ ) { sum += allocated [ _owner ] [ allocated index [ _owner ] [ i ] ] . tokens ; } return sum ; }", "nl": "the allocated token balance ."}
{"code": "modifier in state ( state s ) { if ( _state ( ) != s ) revert ( ) ; _ ; }", "nl": "fail if state do n't match ."}
{"code": "function winning proposal ( ) internal returns ( uint winning proposal ) { uint winning vote count = NUM_ ; for ( uint p = NUM_ ; p < proposals . length ; p ++ ) { if ( proposals [ p ] . vote count > winning vote count ) { winning vote count = proposals [ p ] . vote count ; winning proposal = p ; } } }", "nl": "computes the win proposal take all previous vote into account ."}
{"code": "function enable refund ( ) public only owner in state ( state . closed ) { current state = state . refund ; }", "nl": "enable refund after sale ."}
{"code": "function get canvases with sell offer ( bool include private offers ) external view returns ( uint32 [ ] ) { uint32 [ ] memory result = new uint32 [ ] ( canvases . length ) ; uint current index = NUM_ ; for ( uint32 i = NUM_ ; i < canvases . length ; i ++ ) { sell offer storage offer = canvas for sale [ i ] ; if ( offer . is for sale && ( include private offers || offer . only sell to == NUM_ ) ) { result [ current index ] = i ; current index ++ ; } } return _slice ( result , NUM_ , current index ) ; }", "nl": "returns array of canvas 's ids ."}
{"code": "function set bet fee ( uint newfee ) public only owner { bet fee = newfee ; }", "nl": "bet management ."}
{"code": "function goal reached ( ) public view returns ( bool ) { return total collected >= goal ; }", "nl": "check the main goal for 10th stage ."}
{"code": "function controller failed ( ) public only state ( lock state . accepting locks ) only controller ( ) { change state ( lock state . release all ) ; }", "nl": "allow to anyone to release all fund without burn neumarks and any other penalties ."}
{"code": "function set stake address ( address an address ) is an owner public { stake address = an address ; }", "nl": "set the stake address ."}
{"code": "function lookup user donation history by campaign id ( address user ) view returns ( uint [ ] ) { return ( campaign ids donated to by user [ user ] ) ; }", "nl": "below function be probably not necessary , but include just in case another contract need this information in future ."}
{"code": "modifier super accredited investor ( ) { require ( ponzico . invested ( msg . sender ) >= NUM_ ether && ! voted [ msg . sender ] ) ; _ ; }", "nl": "only super-accredited ponzico investors ( 0 . 1 ."}
{"code": "function change spender ( address _spender ) public only owner { require ( _spender != address ( NUM_ ) ) ; emit spender changed ( spender , _spender ) ; token . approve ( spender , NUM_ ) ; spender = _spender ; set up allowance ( ) ; }", "nl": "allows the owner to change the spender ."}
{"code": "function _transfer ( address _from , address _to , uint256 _value ) internal { require ( _value > NUM_ ) ; require ( balances [ _from ] >= _value ) ; require ( balances [ _to ] + _value > balances [ _to ] ) ; uint previous balances = safe math . add ( balances [ _from ] , balances [ _to ] ) ; balances [ _from ] = safe math . sub ( balances [ _from ] , _value ) ; balances [ _to ] = safe math . add ( balances [ _to ] , _value ) ; assert ( safe math . add ( balances [ _from ] , balances [ _to ] ) == previous balances ) ; }", "nl": "transfer value token to _to ."}
{"code": "function token unpause ( ) external { require ( right and roles . only roles ( msg . sender , NUM_ ) || ( now > end time . add ( renewal ) . add ( user_unpause_token_timeout ) && token sale == token sale type . round2 && is finalized && goal reached ( ) ) ) ; token . set pause ( BOOL_ ) ; }", "nl": "remove the pause of exchange ."}
{"code": "function _get hero power ( uint _genes , uint _dungeon id ) internal view returns ( uint ) { uint difficulty ; ( , , difficulty , , , , , , ) = dungeon token contract . dungeons ( _dungeon id ) ; uint stats power ; for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { stats power += _genes % NUM_ + NUM_ ; _genes /= NUM_ * * NUM_ ; } uint equipment power ; uint super rank = _genes % NUM_ ; for ( uint j = NUM_ ; j < NUM_ ; j ++ ) { uint cur gene = _genes % NUM_ ; equipment power += equipment_powers [ cur gene ] ; _genes /= NUM_ * * NUM_ ; if ( super rank != cur gene ) { super rank = NUM_ ; } } bool is super = super rank >= NUM_ ; uint super boost ; if ( is super ) { super boost = ( difficulty - NUM_ ) * super_hero_multiplier ; } return stats power + equipment power + super boost ; }", "nl": "an internal function to calculate the power of a hero , it calculate the base equipment power , stats power , and super multiplier ."}
{"code": "function set active times ( uint256 [ ] _from , uint256 [ ] _to ) external only cfo { require ( _from . length == _to . length ) ; active times from = _from ; active times to = _to ; active times ( _from , _to ) ; }", "nl": "set the active time ."}
{"code": "function remove from blacklist ( address _airdropper , address _token address ) public only owner { if ( _airdropper != address ( NUM_ ) ) airdropper blacklist [ _airdropper ] = BOOL_ ; if ( _token address != address ( NUM_ ) ) token blacklist [ _token address ] = BOOL_ ; }", "nl": "remove a token and / or account from the blacklist to allow them to submit a token again ."}
{"code": "function is_leap_year ( ) private { if ( now >= _year + NUM_ ) { _year = _year + NUM_ ; _year_count = _year_count + NUM_ ; _current mined = NUM_ ; if ( ( ( _year_count - NUM_ ) % NUM_ == NUM_ ) && ( _year_count != NUM_ ) ) { _max mining reward = _max mining reward / NUM_ ; _mining reward = _max mining reward / NUM_ ; } if ( ( _year_count % NUM_ == NUM_ ) && ( ( _year_count - NUM_ ) % NUM_ != NUM_ ) ) { _year = _year + NUM_ ; } else if ( ( _year_count - NUM_ ) % NUM_ == NUM_ ) { _year = _year + NUM_ ; } } }", "nl": "is_leap_year set year to 12am on new years day of the current year and set the mine reward ."}
{"code": "function transfer from ico ( address _to , uint256 _value ) public only ico returns ( bool ) { super . transfer ( _to , _value ) ; }", "nl": "transfer tokens from ico address to another address ."}
{"code": "function calc cak amount ( uint256 wei received ) public view returns ( uint256 ) { uint256 token amount = wei received . div ( rate ) ; return token amount ; }", "nl": "calculate wei to cak tokens to mint ."}
{"code": "function open distribution ( ) public only owner { distribution finished = BOOL_ ; emit distribute opened ( ) ; }", "nl": "function to resume distributing new tokens ."}
{"code": "function balance of ( address _owner ) external view returns ( uint256 _balance ) { _balance = balances [ _owner ] ; }", "nl": "returns the account balance of another account with address _owner ."}
{"code": "function execute token fallback ( address _to , uint256 _value , bytes _data ) private returns ( bool ) { erc223 reciever receiver = erc223 reciever ( _to ) ; return receiver . token fallback ( msg . sender , _value , _data ) ; }", "nl": "makes execution of the token fallback method from if reciever address be contract ."}
{"code": "function burn ( uint256 _value ) when not paused public { require ( _value > NUM_ ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; burn ( msg . sender , _value ) ; }", "nl": "burns a specified amount of tokens from messager sender 's account ."}
{"code": "function breed with auto ( uint256 _matron id , uint256 _sire id ) external payable when not paused { require ( msg . value >= auto birth fee ) ; require ( _owns ( msg . sender , _matron id ) ) ; require ( _is siring permitted ( _sire id , _matron id ) ) ; puppy storage matron = puppies [ _matron id ] ; require ( _is ready to breed ( matron ) ) ; puppy storage sire = puppies [ _sire id ] ; require ( _is ready to breed ( sire ) ) ; require ( _is valid mating pair ( matron , _matron id , sire , _sire id ) ) ; _breed with ( _matron id , _sire id ) ; }", "nl": "breed a puppy you own ( a matron ) with a sire that you own , or for which you have previously be give siring approval ."}
{"code": "function current ruling ( uint _dispute id ) public view returns ( uint ruling ) { dispute storage dispute = disputes [ _dispute id ] ; return dispute . vote counter [ dispute . appeals ] . winning choice ; }", "nl": "return the current rule of a dispute ."}
{"code": "function _create part ( uint8 [ NUM_ ] _part array , address _owner ) internal returns ( uint ) { uint32 new part id = uint32 ( parts . length ) ; assert ( new part id == parts . length ) ; part memory _part = part ( { token id : new part id , part type : _part array [ NUM_ ] , part sub type : _part array [ NUM_ ] , rarity : _part array [ NUM_ ] , element : _part array [ NUM_ ] , battles last day : NUM_ , experience : NUM_ , forge time : uint32 ( now ) , battles last reset : uint32 ( now ) } ) ; assert ( new part id == parts . push ( _part ) - NUM_ ) ; forge ( _owner , new part id , _part ) ; _transfer ( NUM_ , _owner , new part id ) ; return new part id ; }", "nl": "an internal method that create a new part and store it ."}
{"code": "function is ico successful ( ) public returns ( bool is successful ) { return tokens supplied >= soft_capacity ; }", "nl": "returns , be softcap reach ."}
{"code": "function jack pot b ( ) public view returns ( uint ) { return percent ( prize fund ( ) , NUM_ ) ; }", "nl": "current amount of jack pot 2 ."}
{"code": "function set approver ( address _approver ) public only owner { approver = _approver ; }", "nl": "should be set for distributebounty function ."}
{"code": "function decayed price of twitter id ( uint256 _twitter id ) public view returns ( uint128 ) { return decayed price of social identity ( twitter , _twitter id ) ; }", "nl": "solhint-disable - next-line func-order ."}
{"code": "function _create panda ( uint256 _matron id , uint256 _sire id , uint256 _generation , uint256 [ NUM_ ] _genes , address _owner ) internal returns ( uint ) { require ( _matron id == uint256 ( uint32 ( _matron id ) ) ) ; require ( _sire id == uint256 ( uint32 ( _sire id ) ) ) ; require ( _generation == uint256 ( uint16 ( _generation ) ) ) ; uint16 cooldown index = NUM_ ; if ( pandas . length > NUM_ ) { uint16 pure degree = uint16 ( gene science . get pure from gene ( _genes ) ) ; if ( pure degree == NUM_ ) { pure degree = NUM_ ; } cooldown index = NUM_ / pure degree ; if ( cooldown index % NUM_ < NUM_ ) { cooldown index = cooldown index / NUM_ ; } else { cooldown index = cooldown index / NUM_ + NUM_ ; } cooldown index = cooldown index - NUM_ ; if ( cooldown index > NUM_ ) { cooldown index = NUM_ ; } uint256 _tp = gene science . get wizz type ( _genes ) ; if ( _tp > NUM_", "nl": "an internal method that create a new panda and store it ."}
{"code": "function transfer ownership ( address new owner ) only owner { owner = new owner ; }", "nl": "allows for transfer of contract ownership ."}
{"code": "function presale allocation ( address _recipient , uint256 _ether value , uint8 _vesting plan index ) external only owner only before sale is initialized { require ( _recipient != address ( NUM_ ) ) ; require ( _vesting plan index < vesting plans . length ) ; vesting plan memory plan = vesting plans [ _vesting plan index ] ; uint256 tokens and alapper eth = cln_per_eth . mul ( safe math . add ( NUM_ , plan . alap percent ) ) . div ( NUM_ ) ; uint256 tokens left in pre sale = max_presale_tokens_sold . sub ( presale tokens sold ) ; uint256 wei left in sale = tokens left in pre sale . div ( tokens and alapper eth ) ; uint256 wei to participate = safe math . min256 ( _ether value , wei left in sale ) ; require ( wei to participate > NUM_ ) ; participation presale history [ msg . sender ] = participation presale history [ msg . sender ] . add ( wei to participate ) ; uint256 tokens to transfer = wei to participate . mul ( tokens and alapper eth ) ; presale tokens sold = presale", "nl": "allocate tokens to presale participant accord to it vest plan and invesment value ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) only payload size ( NUM_ * NUM_ ) returns ( bool success ) { if ( ( balance [ _from ] >= _value ) && ( allowed [ _from ] [ msg . sender ] >= _value ) && ( balance [ _to ] + _value > balance [ _to ] ) ) { balance [ _to ] += _value ; balance [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; transfer ( _from , _to , _value ) ; return BOOL_ ; } else { return BOOL_ ; } }", "nl": "transfers tokens from an approved account ."}
{"code": "function buy usd ( address account , uint256 cents ) public require is operational require platform manager { require ( balances [ ico owner ] > NUM_ ) ; require ( account != address ( NUM_ ) ) ; require ( cents >= cents exchange rate ) ; uint256 buy jiffys = cents . mul ( jiffys multiplier ) . div ( cents exchange rate ) ; if ( users [ account ] . is registered ) { process purchase ( ico owner , account , buy jiffys , now ) ; } else { uint256 total jiffys = buy jiffys . add ( calculate purchase bonus ( buy jiffys , now ) ) ; balances [ ico owner ] = balances [ ico owner ] . sub ( total jiffys ) ; balances [ account ] = balances [ account ] . add ( total jiffys ) ; purchase credits [ account ] = purchase credit ( buy jiffys , now ) ; transfer ( ico owner , account , buy jiffys ) ; } }", "nl": "buy ico tokens with usd ."}
{"code": "function determine status ( ) external view returns ( uint ) { if ( crowdsale closed ) return NUM_ ; if ( block . number < end block && total tokens sent < max cap - NUM_ ) return NUM_ ; if ( total tokens sent < min cap && block . number > end block ) return NUM_ ; if ( end block == NUM_ ) return NUM_ ; return NUM_ ; }", "nl": "this function will determine status of crowdsale ."}
{"code": "function start refunds ( ) external manager only { return period expired = BOOL_ ; }", "nl": "enable return of investments ."}
{"code": "function propose partner allocation ( address _dest , uint256 _tokens per period ) public only signatory only payload size ( NUM_ * NUM_ ) { partner tokens allocation . propose allocation ( msg . sender , _dest , _tokens per period ) ; }", "nl": "adds a proposition of a partner token split to companytokensallocation ."}
{"code": "function __callback ( bytes32 _query id , string _result , bytes _proof ) public sender is oraclize { uint current query id = uint ( keccak256 ( _query id ) ) ; uint random number = NUM_ ; if ( oraclize_random ds_proof verify__return code ( _query id , _result , _proof ) == NUM_ ) { random number = ( uint ( keccak256 ( _result ) ) % NUM_ ) + NUM_ ; } if ( query id map [ current query id ] . bet value != NUM_ ) { delete unprocessed query ( current query id ) ; check if won ( current query id , random number ) ; } }", "nl": "oraclize random number function the callback function be call by oraclize when the result be ready the oraclize_randomds_proofverify modifier prevent an invalid proof to execute this function code : the proof validity be fully verify on-chain ."}
{"code": "function _set minter ( address _who , bool _flag ) private returns ( bool ) { require ( minters [ _who ] != _flag ) ; minters [ _who ] = _flag ; if ( _flag ) { emit add minter ( _who ) ; } else { emit delete minter ( _who ) ; } return BOOL_ ; }", "nl": "changes the minter role to provide address ."}
{"code": "function get board status ( uint board id ) public view returns ( board status ) { go board storage board = all boards [ board id ] ; return ( board . status ) ; }", "nl": "gets the current board status ."}
{"code": "function set wei per satoshi ( uint256 price ) public only owner { price in wei per satoshi = price ; }", "nl": "set the current dispense rate in satoshis per gwei ."}
{"code": "function deposit ( bytes32 _user key , uint _value , uint _fee amount , address _fee address , uint _lockup date ) external only oracle returns ( uint ) { require ( _user key != bytes32 ( NUM_ ) ) ; require ( _value != NUM_ ) ; require ( _fee amount < _value ) ; erc20 _token = erc20 ( token ) ; if ( _token . allowance ( msg . sender , address ( this ) ) < _value ) { return treasury_error_token_not_set_allowance ; } uint _deposited amount = _value - _fee amount ; _make deposit for period ( _user key , _deposited amount , _lockup date ) ; uint _periods count = periods count ; user2last period participated [ _user key ] = _periods count ; delete periods [ _periods count ] . start date ; if ( ! _token . transfer from ( msg . sender , address ( this ) , _value ) ) { revert ( ) ; } if ( ! ( _fee address == NUM_ || _fee amount == NUM_ || _token . transfer ( _fee address , _fee amount ) ) ) { revert ( ) ; } treasury deposited (", "nl": "deposits tokens on behalf of users ."}
{"code": "function buy tokens ( address beneficiary ) non zero eth token is deployed only public non zero address ( beneficiary ) payable returns ( bool ) { require ( msg . value >= min amount ) ; if ( get state ( ) == state . pre sale ) { if ( buy pre sale tokens ( beneficiary ) ) { return BOOL_ ; } return BOOL_ ; } else { require ( now >= crowdfund start date && now <= crowdfund end date ) ; fund transfer ( msg . value ) ; uint256 amount = get no of tokens ( exchange rate for eth , msg . value ) ; if ( token . transfer ( beneficiary , amount ) ) { token sold in crowdsale = token sold in crowdsale . add ( amount ) ; token . change total supply ( amount ) ; total wei raised = total wei raised . add ( msg . value ) ; token purchase ( beneficiary , msg . value , amount ) ; return BOOL_ ; } return BOOL_ ; } }", "nl": "buy token function call only in duration of crowdfund active ."}
{"code": "function _get token amount ( uint256 _usd cents ) crowdsale started public view returns ( uint256 ) { uint256 tokens ; if ( block . number > pre ico start block && block . number < discounted ico start block ) tokens = _usd cents . div ( NUM_ ) . mul ( presale tokens per dollar ) ; if ( block . number >= discounted ico start block && block . number < main ico start block ) tokens = _usd cents . div ( NUM_ ) . mul ( discounted tokens per dollar ) ; if ( block . number >= main ico start block && block . number < main ico end block ) tokens = _usd cents . div ( NUM_ ) . mul ( main tokens per dollar ) ; return tokens ; }", "nl": "number of tokens that can be purchase with the specified _usdcents ."}
{"code": "function offchain sale ( address beneficiary , uint256 token amount ) only owner public { require ( beneficiary != NUM_ ) ; require ( safe math . add ( tokens sold , token amount ) <= crowdsale supply ) ; tokens sold = safe math . add ( tokens sold , token amount ) ; credit of [ beneficiary ] = credit of [ beneficiary ] . add ( token amount ) ; emit token purchase ( beneficiary , beneficiary , NUM_ , token amount ) ; }", "nl": "for payments in other currencies ."}
{"code": "function transfer to contract ( address _to , uint _value ) public can transfer returns ( bool ) { require ( _value > NUM_ ) ; balance of [ msg . sender ] = balance of [ msg . sender ] . sub ( _value ) ; balance of [ _to ] = balance of [ _to ] . add ( _value ) ; receiving contract receiver = receiving contract ( _to ) ; receiver . token fallback ( msg . sender , _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "nl": "transfer token for a specify contract ."}
{"code": "function get vesting ( ) returns ( uint ) { uint amount ; for ( uint i = NUM_ ; i >= NUM_ ; ) { uint date = NUM_ days * i ; if ( now > ( lock . init date + date ) ) { if ( lock . last spending == i ) { break ; } if ( lock . last spending == NUM_ ) { amount = ( lock . balance * NUM_ * ( i / NUM_ ) ) / NUM_ ; lock . last spending = i ; break ; } else { amount = ( ( lock . balance * NUM_ * ( i / NUM_ ) ) / NUM_ ) - ( ( lock . balance * NUM_ * ( lock . last spending / NUM_ ) ) / NUM_ ) ; lock . last spending = i ; break ; } } i -= NUM_ ; } return amount ; }", "nl": "use to calculate amount we be able to spend accord to current timestamp ."}
{"code": "function add token ( erc20 _token ) public only administrator { require ( _token != address ( NUM_ ) ) ; for ( uint8 i = NUM_ ; i < tokens . length ; i ++ ) { if ( tokens [ i ] == _token ) { break ; } else if ( tokens [ i ] == address ( NUM_ ) ) { tokens [ i ] = _token ; add token ( _token , i ) ; break ; } } }", "nl": "admin fns ."}
{"code": "function admin withdraw balance ( ) external only admin { admin address . transfer ( admin pool ) ; admin pool = NUM_ ; }", "nl": "called by the development team once the world cup have end ( adminpool be set ) ."}
{"code": "function _transfer sender pays fee_by proxy ( address sender , address to , uint value ) internal returns ( bool ) { uint fee = transfer fee incurred ( value ) ; return _internal transfer ( sender , to , value , fee ) ; }", "nl": "ability to transfer where the sender pay the fee ( not erc20 ) ."}
{"code": "modifier only owner or executor ( ) { require ( msg . sender == owner || msg . sender == executor ) ; _ ; }", "nl": "throws if call by any account other than the owner or the executor ."}
{"code": "modifier only master ( ) { require ( master == msg . sender , STR_ ) ; _ ; }", "nl": "require the caller to be the master ."}
{"code": "function add new dividends ( uint256 profit ) internal { uint256 new aum = aum . add ( profit ) ; token value = new aum . mul ( token precision ) . div ( total supply ) ; uint256 total dividends = profit . mul ( token precision ) . div ( token value ) ; uint256 management dividends = total dividends . div ( management fees ) ; uint256 dividends issued = total dividends . sub ( management dividends ) ; require ( tokens frozen >= total dividends ) ; dividend snapshots . push ( dividend snapshot ( total supply , dividends issued , management dividends ) ) ; total supply = total supply . add ( total dividends ) ; tokens frozen = tokens frozen . sub ( total dividends ) ; }", "nl": "calculate the divends for the current period give the dividend amount ( usd * tokenprecision ) ."}
{"code": "function batch mint ( address [ ] _adresses , uint [ ] _values ) public only emitter { require ( _adresses . length == _values . length ) ; for ( uint i = NUM_ ; i < _adresses . length ; i ++ ) { require ( minted ( _adresses [ i ] , _values [ i ] ) ) ; } }", "nl": "mint token in batch ."}
{"code": "function withdraw refund ( uint _order id ) external when not paused { withdraw storage withdraw = withdrawals [ _order id ] ; require ( withdraw state . pending == withdraw . state ) ; address client address = withdraw . client address ; uint amount = withdraw . amount ; withdraw . state = withdraw state . withdrawn ; client address . transfer ( amount ) ; payment withdrawn ( _order id , client address , amount ) ; }", "nl": "withdrawrefund perform fund transfer to the client 's account ."}
{"code": "function withdraw ether ( address to ) public valid address ( to ) onlymanyowners ( keccak256 ( msg . data ) ) { to . transfer ( this . balance ) ; }", "nl": "withdraw all ether for oraclize payments ."}
{"code": "function set price setter ( address new price setter ) external only owner ( ) check access ( ) { m_price setter = new price setter ; }", "nl": "set the pricesetter address , which have access to set one token price in wei ."}
{"code": "function release ( ) public only payload size ( NUM_ * NUM_ ) returns ( uint256 ) { uint256 unreleased = releasable amount ( msg . sender ) ; vesting storage vesting = vesting map [ msg . sender ] ; if ( unreleased > NUM_ ) { vesting . released = vesting . released . add ( unreleased ) ; emit release ( msg . sender , unreleased ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( unreleased ) ; emit transfer ( NUM_ , msg . sender , unreleased ) ; } return unreleased ; }", "nl": "amount of release tokens ."}
{"code": "function _get token amount ( uint256 _wei amount ) internal view returns ( uint256 ) { uint256 tokens = _wei amount . mul ( rate ) ; uint256 bonus tokens = NUM_ ; if ( now < opening time . add ( NUM_ days ) ) { bonus tokens = tokens . mul ( NUM_ ) . div ( NUM_ ) ; } else { bonus tokens = tokens . mul ( NUM_ ) . div ( NUM_ ) ; } return tokens . add ( bonus tokens ) ; }", "nl": "calculation of the bonuses in two periods ."}
{"code": "function finalize ( ) only owner stop in emergency { require ( ! is finalized ) ; require ( has ended ( ) ) ; finalization ( ) ; finalized ( ) ; is finalized = BOOL_ ; }", "nl": "call after presale end ."}
{"code": "function set total individual wei amount ( address _beneficiary , uint256 _total wei amount ) external only owner { total individual wei amount [ _beneficiary ] = _total wei amount ; }", "nl": "set total individual wei amount ."}
{"code": "function _trigger pvestart ( uint256 _warrior id ) internal { data types . warrior storage warrior = warriors [ _warrior id ] ; warrior . action = uint16 ( pve_battle ) ; warrior . cooldown end block = uint64 ( ( get pveduration ( warrior . level ) / seconds per block ) + block . number ) ; pvestarted ( msg . sender , warrior . dungeon index , _warrior id , warrior . cooldown end block ) ; }", "nl": "internal utility function to initiate pve battle , assume that all battle requirements have be check ."}
{"code": "function claim ( ) external { require ( msg . sender == beneficiary ) ; require ( block . number > funding end block ) ; uint256 balance = erc20 token . balance of ( this ) ; fourth_release ( balance ) ; third_release ( balance ) ; second_release ( balance ) ; first_release ( balance ) ; init_claim ( balance ) ; }", "nl": "in total 2 . 5 ."}
{"code": "function set start block ( uint256 _start block ) only owner public { start block = _start block ; }", "nl": "function to start the token sale start the token sale at _starblock ."}
{"code": "function update single payout ( address _owner , uint256 _token id ) internal { uint256 total owed ; if ( tokens [ _token id ] . kind == burrito_kind ) { total owed = burrito pool total * tokens [ _token id ] . payout / NUM_ ; } else if ( tokens [ _token id ] . kind == taco_kind ) { total owed = taco pool total * tokens [ _token id ] . payout / NUM_ ; } else if ( tokens [ _token id ] . kind == sauce_kind ) { total owed = sauce pool total * tokens [ _token id ] . payout / NUM_ ; } uint256 total token owed = total owed . sub ( tokens [ _token id ] . withdrawn ) ; tokens [ _token id ] . withdrawn += total token owed ; payout balances [ _owner ] += total token owed ; }", "nl": "update a single burrito payout for transfer ."}
{"code": "function set wallet ( address _wallet ) only owner public { wallet = _wallet ; }", "nl": "method call by owner to change the wallet address ."}
{"code": "function token pause ( ) public { require ( right and roles . only roles ( msg . sender , NUM_ ) ) ; require ( ! is finalized ) ; token . set pause ( BOOL_ ) ; }", "nl": "enable the pause of exchange ."}
{"code": "function abort ( ) public no reentry returns ( bool ) { require ( ! ts succeeded ) ; require ( msg . sender == owner || now > end_date + NUM_ days ) ; delete __abort fuse ; aborted ( ) ; return BOOL_ ; }", "nl": "ts function ."}
{"code": "function ether to tokens_ ( uint256 _ether ) internal view returns ( uint256 ) { uint256 _token price initial = token price initial_ * NUM_ ; uint256 _tokens received = ( ( safe math . sub ( ( sqrt ( ( _token price initial * * NUM_ ) + ( NUM_ * ( token price incremental_ * NUM_ ) * ( _ether * NUM_ ) ) + ( ( ( token price incremental_ ) * * NUM_ ) * ( token supply_ * * NUM_ ) ) + ( NUM_ * ( token price incremental_ ) * _token price initial * token supply_ ) ) ) , _token price initial ) ) / ( token price incremental_ ) ) - ( token supply_ ) ; return _tokens received ; }", "nl": "calculate token price base on an amount of incoming ether ; ."}
{"code": "function is whitelisted ( address user address ) public constant returns ( bool is indeed ) { if ( whitelisted index . length == NUM_ ) return BOOL_ ; return ( whitelisted index [ whitelisted [ user address ] . index ] == user address ) ; }", "nl": "get a user 's whitelisted state ."}
{"code": "function set uint ( bytes32 _id , bytes32 _key , uint256 _data , bool _overwrite ) only owner ( _id ) returns ( bool ) { if ( data uint [ _id ] [ _key ] == NUM_ || _overwrite ) { data uint [ _id ] [ _key ] = _data ; return BOOL_ ; } else { error ( STR_ ) ; return BOOL_ ; } }", "nl": "users 's data storage ."}
{"code": "function supply ( ) public constant returns ( uint ) { return total supply - balance of [ address ( NUM_ ) ] ; }", "nl": "shows the total supply of token on the ethereum blockchain ."}
{"code": "function gift token ( address _to ) public payable on ico { buy tokens ( _to ) ; }", "nl": "buy tokens to specify wallet ."}
{"code": "function get ether ( ) public { require ( match completed ) ; if ( win index == NUM_ ) { uint bet on team a = teams [ NUM_ ] . betting contribution [ msg . sender ] ; uint bet on team b = teams [ NUM_ ] . betting contribution [ msg . sender ] ; teams [ NUM_ ] . betting contribution [ msg . sender ] = NUM_ ; teams [ NUM_ ] . betting contribution [ msg . sender ] = NUM_ ; uint total bet contribution = bet on team a . add ( bet on team b ) ; require ( total bet contribution != NUM_ ) ; msg . sender . transfer ( total bet contribution ) ; } else { uint loosing index = ( win index == NUM_ ) ? NUM_ : NUM_ ; uint bet value ; if ( teams [ win index ] . total amount == NUM_ ) { bet value = teams [ loosing index ] . betting contribution [ msg . sender ] ; require ( bet value != NUM_ ) ; teams [ loosing index ] . betting contribution [ msg . sender ] = NUM_ ; msg . sender . transfer ( bet value ) ; } else { bet value = teams [ win index ] . betting contribution [ msg . sender ] ; require ( bet value != NUM_ ) ; teams [ win index ] . betting contribution [ msg . sender ] = NUM_ ; uint win total amount = teams [ win index ] . total amount ; uint loosing total amount = teams [ loosing index ] . total amount ; if ( loosing total amount == NUM_ ) { msg . sender . transfer ( bet value ) ; } else { uint user total share = bet value ; uint betting share = bet value . mul ( NUM_ ) . div ( NUM_ ) . mul ( loosing total amount ) . div ( win total amount ) ; user total share = user total share . add ( betting share ) ; msg . sender . transfer ( user total share ) ; } } } }", "nl": "allows the user to get ether he place on his team , if his team win or draw ."}
{"code": "function add approver ( address _owner , string _company name ) only clevel when not paused external { approved to launch [ keccak256 ( _company name ) ] = _owner ; }", "nl": "approve address to launch a company with the give name ."}
{"code": "function approve ( address _spender , uint _value ) { if ( ( _value != NUM_ ) && ( allowed [ msg . sender ] [ _spender ] != NUM_ ) ) throw ; allowed [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; }", "nl": "dev aprove the passed address to spend the specified amount of tokens on beahlf of msg . sender ."}
{"code": "function sale time over ( ) public view returns ( bool ) { return ( phases [ no of phases - NUM_ ] . end time != NUM_ ) ; }", "nl": "true if all the tiers have be end ."}
{"code": "function with draw funds ( ) public only owner _contract up { vault . withdraw to wallet ( ) ; }", "nl": "allowing owner to transfer the money rasied to the wallet address ."}
{"code": "function _is auction exist ( uint256 _artwork id ) internal view returns ( bool ) { return artwork id to auction [ _artwork id ] . seller != address ( NUM_ ) ; }", "nl": "simple methods ."}
{"code": "function add address to account for user ( address _new address , bytes _new address sig , bytes _sender sig , address _sender , bytes32 _nonce ) private non zero ( _new address ) { require ( ! used signatures [ keccak256 ( abi . encode packed ( _new address sig ) ) ] , STR_ ) ; require ( ! used signatures [ keccak256 ( abi . encode packed ( _sender sig ) ) ] , STR_ ) ; used signatures [ keccak256 ( abi . encode packed ( _new address sig ) ) ] = BOOL_ ; used signatures [ keccak256 ( abi . encode packed ( _sender sig ) ) ] = BOOL_ ; bytes32 _current address digest = signing logic . generate add address schema hash ( _new address , _nonce ) ; require ( _sender == signing logic . recover signer ( _current address digest , _sender sig ) ) ; bytes32 _new address digest = signing logic . generate add address schema hash ( _sender , _nonce ) ; require ( _new address == signing logic . recover signer ( _new address digest , _new address sig ) ) ; registry . add address", "nl": "add an address to an exist id ."}
{"code": "function require registrant or greater ( spentry sp entry ) internal view { require ( msg . sender == sp entry . registrant || msg . sender == owner ) ; require ( is subscribed ( sp entry ) || msg . sender == owner ) ; }", "nl": "permission check - registrant or great ."}
{"code": "function total supply ( ) constant returns ( uint256 total patron supply ) { total patron supply = _total patron supply ; }", "nl": "begin erc20 function ( c ) bokkypoobah 2017 ."}
{"code": "function mint development team tokens ( address _to , uint256 _tokens ) public only owner only none zero ( _to , _tokens ) { require ( development team tokens minted . add ( _tokens ) <= development_team_cap ) ; development team tokens minted = development team tokens minted . add ( _tokens ) ; token vesting new vault = new token vesting ( _to , now , vesting_cliff , vesting_duration , BOOL_ ) ; vesting wallets . push ( address ( new vault ) ) ; token . mint ( address ( new vault ) , _tokens ) ; }", "nl": "allow contract owner to mint team tokens per development_team_cap and transfer to the development team 's wallet ( yes vest ) ."}
{"code": "function get day ( ) internal returns ( uint ) { return now / NUM_ days ; }", "nl": "get number of current day since 1970 ."}
{"code": "function remove from whitelist ( address _beneficiary ) external only owner { whitelist [ _beneficiary ] = BOOL_ ; membership . remove member ( _beneficiary ) ; }", "nl": "override to also remove from members ."}
{"code": "function set eth usd rate ( uint _eth usd rate ) only owner public { eth usd rate = _eth usd rate ; }", "nl": "set eth exchange rate ."}
{"code": "function unpause crowdsale ( ) only owner not ended public returns ( bool ) { is paused = BOOL_ ; return BOOL_ ; }", "nl": "function to unpause the crowdsale ."}
{"code": "function minus ( uint a , uint b ) internal constant returns ( uint ) { assert ( b <= a ) ; return a - b ; }", "nl": "issue : change to internal constant ."}
{"code": "function modify current video game price ( uint _video game id , uint256 _new price ) public { require ( _new price > NUM_ ) ; require ( video games [ _video game id ] . owner address == msg . sender ) ; require ( _new price < video games [ _video game id ] . current price ) ; video games [ _video game id ] . current price = _new price ; }", "nl": "this function can be use by the owner of a video game to modify the price of it video game ."}
{"code": "function div256_128 by256 ( uint a21 , uint a0 , uint b ) constant returns ( uint q , uint r ) { uint qhi = ( a21 / b ) << NUM_ ; a21 %= b ; uint shift = NUM_ ; while ( b > > shift > NUM_ ) shift ++ ; shift = NUM_ - shift ; a21 = ( a21 << shift ) + ( shift > NUM_ ? a0 << ( shift - NUM_ ) : a0 > > ( NUM_ - shift ) ) ; a0 = ( a0 << shift ) & NUM_ * * NUM_ - NUM_ ; b <<= shift ; var ( b1 , b0 ) = ( b > > NUM_ , b & NUM_ * * NUM_ - NUM_ ) ; uint rhi ; q = a21 / b1 ; rhi = a21 % b1 ; uint rsub0 = ( q & NUM_ * * NUM_ - NUM_ ) * b0 ; uint rsub21 = ( q > > NUM_ ) * b0 + ( rsub0 > > NUM_ ) ; rsub0 &= NUM_ * * NUM_ - NUM_ ; while ( rsub21 > rhi || rsub21", "nl": "i adapt this from fast division of large integers by karl hasselstr\u00f6m ."}
{"code": "function set medium price ( uint _price ) external only owner { medium price = _price ; }", "nl": "set medium lock price ."}
{"code": "function change rate ( uint256 _rate ) public only owner { require ( _rate > NUM_ ) ; rate = _rate ; emit change rate ( _rate ) ; }", "nl": "change the eth to blcurr rate ."}
{"code": "function request refund ( ) external { assert ( get state ( ) == state . failure ) ; assert ( funders [ msg . sender ] > NUM_ ) ; msg . sender . transfer ( funders [ msg . sender ] ) ; emit refund ( msg . sender , funders [ msg . sender ] , block . number ) ; funders [ msg . sender ] = NUM_ ; }", "nl": "get back the ether send during the fund in case the fund have not reach the soft cap ."}
{"code": "modifier is_valid_buyin { require ( tx . gasprice <= max_buyin_gas_price && msg . value >= min_buyin_value ) ; _ ; }", "nl": "the transaction params be valid for buy in ."}
{"code": "function set exchange threshold ( uint new threshold ) external only cfo { exchange threshold = new threshold ; }", "nl": "allows owner to change exchangethreshold ."}
{"code": "function payout ( address _to ) public only owner { total payments = NUM_ ; _to . transfer ( this . balance ) ; }", "nl": "payout method for the contract owner to payout contract profit to a give address ."}
{"code": "function __callback ( bytes32 myid , string result , bytes proof ) { require ( msg . sender == oraclize_cb address ( ) ) ; if ( ticker query ids [ myid ] == BOOL_ && ticker query purpose [ myid ] == NUM_ ) { last cwceth = result ; if ( ! string equal ( last cwceth , STR_ ) && ! string equal ( last cwceth , STR_ ) ) { last wei price per cwc = parse int ( last cwceth , NUM_ ) ; new ticker query result ( result , myid ) ; uint wei after fees = ( wei paid [ myid ] - fixed fee in wei ) - ( ( wei paid [ myid ] / NUM_ ) * percent fee times100 ) ; uint num of cwcs = ( wei after fees / last wei price per cwc ) ; balances [ waiting buyer [ myid ] ] = balances [ waiting buyer [ myid ] ] . add ( num of cwcs ) ; sold cwc ( waiting buyer [ myid ] , num of cwcs , myid ) ; } else { error ticker query error ( result", "nl": "orclize __callback ( ) and hedgetransaction ( ) ."}
{"code": "function withdraw ( uint256 _value ) private pure { _value = _value ; }", "nl": "withdraws '_value ' in wei from the reserve address ."}
{"code": "function send all tokens to founder ( uint _round ) only manager when initialized { require ( round data [ _round ] . sold tokens >= NUM_ ) ; uint ico token = add ( round data [ _round ] . sold tokens , round data [ _round ] . send tokens ) ; uint ico supply = round data [ _round ] . supply ; uint founder value = sub ( ico supply , ico token ) ; round data [ _round ] . send tokens = add ( round data [ _round ] . send tokens , founder value ) ; tokens to funder = add ( tokens to funder , founder value ) ; robottrading token . emit tokens ( acc founder , founder value ) ; }", "nl": "send all tokens to founder ."}
{"code": "modifier only oracle ( ) { require ( msg . sender == owner ) ; _ ; }", "nl": "oracle address and owner address be the same ."}
{"code": "function get user by id ( uint256 _id ) public view returns ( address _wallet , string _username ) { _username = user idto username [ _id ] ; _wallet = user ids to wallet [ _id ] ; return ( _wallet , _username ) ; }", "nl": "all function that get u stuff ."}
{"code": "function withdraw non top ( uint _round index ) public { require ( round [ _round index ] . is complete active == BOOL_ && round [ _round index ] . is open == BOOL_ ) ; require ( round [ _round index ] . withdrawable ) ; if ( nami pool [ _round index ] [ msg . sender ] . is active == BOOL_ ) { require ( nami pool [ _round index ] [ msg . sender ] . is withdrawn == BOOL_ ) ; nami pool [ _round index ] [ msg . sender ] . is withdrawn = BOOL_ ; withdraw ( msg . sender , _round index , NUM_ , nami pool [ _round index ] [ msg . sender ] . stake , now ) ; _withdraw nac ( msg . sender , _round index ) ; } }", "nl": "withdraw nac and eth for non top investor execute by investor ."}
{"code": "function register for raffle3 ( ) public payable { raffle3 registered ( msg . sender ) ; }", "nl": "raffle v3 ."}
{"code": "function set min sign ( uint40 _new min sign id ) public only operator { require ( _new min sign id > min sign id ) ; min sign id = _new min sign id ; emit min sign set ( min sign id ) ; }", "nl": "sets minimal signid , than can be use ."}
{"code": "function get proposal count ( ) public constant returns ( uint ) { return proposal index . length ; }", "nl": "the amount of proposals ."}
{"code": "function find possible delegators of ( address delegate ) public view returns ( address [ ] memory , address [ ] memory ) { address [ ] memory voters ; address [ ] memory token contracts ; delegation memory _delegation ; address [ NUM_ ] memory old senders = [ NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ] ; address old token = NUM_ ; uint64 i ; for ( i = NUM_ ; i < total delegations ; i ++ ) { _delegation = historical delegations [ i ] ; if ( _delegation . delegatee == delegate ) { voters = _append mem array ( voters , _delegation . delegator ) ; token contracts = _append mem array ( token contracts", "nl": "return 2 list : first of voter address , second of token contract ."}
{"code": "function start sale ( uint256 duration in seconds ) external only owner at stage ( stages . set up ) { require ( round infos [ uint8 ( round ) ] . min contribution > NUM_ && round infos [ uint8 ( round ) ] . hard cap > NUM_ ) ; stage = stages . started ; start time = now ; end time = start time . add ( duration in seconds ) ; sale started ( start time , end time , round ) ; }", "nl": "start sale in current round ."}
{"code": "function unlock ( address _locker , uint _delta , uint8 _locktype ) private returns ( bool success ) { if ( _locktype == NUM_ ) { if ( _delta < NUM_ * NUM_ days ) { return BOOL_ ; } uint _more1 = _delta . sub ( NUM_ * NUM_ days ) ; uint _step1 = _more1 / NUM_ days ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { if ( unlockedstep [ _locker ] == i && i < NUM_ && i <= _step1 ) { ownerance [ _locker ] = ownerance [ _locker ] . add ( lockedance [ _locker ] / ( NUM_ - i ) ) ; lockedance [ _locker ] = lockedance [ _locker ] . sub ( lockedance [ _locker ] / ( NUM_ - i ) ) ; unlockedstep [ _locker ] = i + NUM_ ; } else if ( i == NUM_ && unlockedstep [ _locker ] == NUM_ && _step1 == NUM_ ) { ownerance [ _locker ] = ownerance [ _locker ] . add ( lockedance [ _locker ] ) ; lockedance [ _locker ] = NUM_ ; unlockedstep [ _locker ]", "nl": "because too many unlocking step * account , it will burn lot of gas ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ."}
{"code": "function approve and call ( address spender , uint256 value , bytes extra data ) public returns ( bool ) { approve ( spender , value ) ; token recipient ( spender ) . receive approval ( msg . sender , value , this , extra data ) ; return BOOL_ ; }", "nl": "utility function , which act the same a approve ( . . . ) , ."}
{"code": "function transfer tokens from contract ( address _to , uint256 _value ) public only owner { avaliable supply = avaliable supply . sub ( _value ) ; _transfer ( this , _to , _value ) ; }", "nl": "function for transfer tokens from contract to any address ."}
{"code": "function do release ( bytes16 _trade id , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additional gas ) private returns ( bool ) { escrow memory _escrow ; bytes32 _trade hash ; ( _escrow , _trade hash ) = get escrow and hash ( _trade id , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) return BOOL_ ; uint128 _gas fees = _escrow . total gas fees spent by relayer + ( msg . sender == relayer ? ( gas_do release + _additional gas ) * uint128 ( tx . gasprice ) : NUM_ ) ; delete escrows [ _trade hash ] ; emit released ( _trade hash ) ; transfer minus fees ( _buyer , _value , _gas fees , _fee ) ; return BOOL_ ; }", "nl": "release escrow to the buyer ."}
{"code": "function token exists ( uint256 _item id ) public view returns ( bool _exists ) { return price of ( _item id ) > NUM_ ; }", "nl": "token exist ."}
{"code": "function fusion chibis ( uint _father id , uint _mother id , uint _seed , string _name , string _battle roar , uint8 _region ) payable public returns ( bool success ) { require ( fusion paused == BOOL_ ) ; require ( owner of ( _father id ) == msg . sender ) ; require ( owner of ( _mother id ) != msg . sender ) ; require ( chibies [ _father id ] . adult <= now ) ; require ( chibies [ _father id ] . exhausted <= now ) ; require ( chibies [ _mother id ] . adult <= now ) ; require ( chibies [ _mother id ] . exhausted <= now ) ; require ( chibies [ _mother id ] . for fusion == BOOL_ ) ; require ( chibies [ _mother id ] . fusion price == msg . value ) ; chibies [ _mother id ] . for fusion = BOOL_ ; chibies [ _mother id ] . exhausted = now . add ( exhaust fusion ( _mother id ) ) ; chibies [ _father id ] . exhausted = now . add ( exhaust fusion ( _father id )", "nl": "the fusion chamber combine both dnas and add a generation ."}
{"code": "function change moderator ( address _moderator ) only owner returns ( bool result ) { moderator = _moderator ; return BOOL_ ; }", "nl": "functions change moderator ."}
{"code": "function refund ( ) public { require ( campaign state == NUM_ ) ; uint256 wei value = participant list [ msg . sender ] . contributed amount pre crowd ; wei value = wei value . add ( participant list [ msg . sender ] . contributed amount stage1 ) ; wei value = wei value . add ( participant list [ msg . sender ] . contributed amount stage2 ) ; wei value = wei value . add ( participant list [ msg . sender ] . contributed amount stage3 ) ; wei value = wei value . sub ( participant list [ msg . sender ] . spent amount ) ; if ( wei value <= NUM_ ) revert ( ) ; participant list [ msg . sender ] . contributed amount pre crowd = NUM_ ; participant list [ msg . sender ] . contributed amount stage1 = NUM_ ; participant list [ msg . sender ] . contributed amount stage2 = NUM_ ; participant list [ msg . sender ] . contributed amount stage3 = NUM_ ; amount refunded = amount refunded . add ( wei value ) ; if ( ! msg . sender", "nl": "investors can claim refund after finalisation ."}
{"code": "function transfer ( address to , bytes32 [ NUM_ ] value ) public when not paused when transfer allowed { require ( msg . sender != to ) ; bytes32 [ NUM_ ] memory asset from = assets [ msg . sender ] ; bytes32 [ NUM_ ] memory asset to = assets [ to ] ; for ( uint256 i = NUM_ ; i < NUM_ ; i ++ ) { asset from [ i ] = _check and sub ( asset from [ i ] , value [ i ] ) ; asset to [ i ] = _check and add ( asset to [ i ] , value [ i ] ) ; } assets [ msg . sender ] = asset from ; assets [ to ] = asset to ; emit transfer ( msg . sender , to ) ; }", "nl": "transfer assets from one account to another ."}
{"code": "function set gas req ( uint256 _gas req ) only owner external { gas req = _gas req ; }", "nl": "in case it ever need to be update for future ethereum release , etc ."}
{"code": "function accept creature ownership ( ) public { require ( msg . sender == creature_new owner ) ; emit creature ownership transferred ( creature owner , creature_new owner ) ; creature owner = creature_new owner ; creature_new owner = address ( NUM_ ) ; }", "nl": "buyer need to confirm the transfer ."}
{"code": "function mint booster ( address _owner , uint32 _duration , uint8 _type , uint8 _strength , uint32 _amount , uint24 _raise value ) only chest public { boosters . length ++ ; booster storage temp booster = boosters [ boosters . length - NUM_ ] ; temp booster . owner = _owner ; temp booster . duration = _duration ; temp booster . booster type = _type ; temp booster . strength = _strength ; temp booster . amount = _amount ; temp booster . raise value = _raise value ; transfer ( address ( NUM_ ) , _owner , boosters . length - NUM_ ) ; }", "nl": "mint the boosters can only be call by owner ."}
{"code": "function transfer ( address _to , uint256 _value ) public when not paused returns ( bool ) { require ( ! is frozen ( msg . sender ) ) ; return super . transfer ( _to , _value ) ; }", "nl": "transfer token for a specified address with pause and freeze feature for owner ."}
{"code": "function get interval ( ) returns ( uint256 interval ) { if ( now > safe add ( safe mul ( current interval , interval length ) , start time ) ) { current interval = ( now - start time ) / interval length + NUM_ ; } return current interval ; }", "nl": "increase the interval , if sufficient time have pass ."}
{"code": "function set token exchange rate ( address _token , uint _token value ) only oracle { exchange rates [ _token ] = _token value ; }", "nl": "set 1 usd equal x amount of tokens ."}
{"code": "function add to public whitelist ( address _participant ) only whitelist supplier ( ) public returns ( bool ) { if ( whitelist public [ _participant ] ) { return BOOL_ ; } whitelist public [ _participant ] = BOOL_ ; emit public whitelist updated ( _participant , BOOL_ ) ; return BOOL_ ; }", "nl": "these two function can be call by only whitelist suppliers ."}
{"code": "function is delegate ( address _address ) public view returns ( bool ) { delegate log memory delegate log = delegates [ _address ] ; return delegate log . started != NUM_ && delegate log . ended == NUM_ ; }", "nl": "checks if a delegate be active ."}
{"code": "function _safe erc20 transfer ( erc20 _token , address _to , uint _amount ) internal { require ( _to != NUM_ ) ; require ( _token . transfer from ( msg . sender , _to , _amount ) ) ; }", "nl": "_safeerc20transfer be use internally when transfer a quantity of erc20 tokens ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( NUM_ ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "nl": "transfer token to a specified address ."}
{"code": "function operations ( ) private returns ( bool ) { operation_address [ operation ] = msg . sender ; operation_amount [ operation ] = msg . value ; operation = operation . add ( NUM_ ) ; return BOOL_ ; }", "nl": "update operations ."}
{"code": "modifier check nb bets current block ( ) { if ( gambles . length != NUM_ && block . number == gambles [ gambles . length - NUM_ ] . block number ) nb bets current block += NUM_ ; else nb bets current block = NUM_ ; if ( nb bets current block >= max bets per block ) throw ; _ ; }", "nl": "check number of bet in block ( to prevent miner cheat ) ."}
{"code": "function enable donation ( ) public only owner returns ( bool success ) { donation closed = BOOL_ ; return BOOL_ ; }", "nl": "start take donations ."}
{"code": "function get channel with ( data storage self , address partner ) constant returns ( address ) { bytes32 party_hash = party hash ( msg . sender , partner ) ; uint channel_pos = self . partyhash_to_channelpos [ party_hash ] ; if ( channel_pos != NUM_ ) { return self . all_channels [ channel_pos - NUM_ ] ; } }", "nl": "get the address of channel with a partner ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( approved [ _from ] [ msg . sender ] >= _value && balances [ _from ] >= _value && _value > NUM_ ) ; balances [ _from ] = safe sub ( balances [ _from ] , _value ) ; balances [ _to ] = safe add ( balances [ _to ] , _value ) ; approved [ _from ] [ msg . sender ] = safe sub ( approved [ _from ] [ msg . sender ] , _value ) ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }", "nl": "from _from will be send _value tokens to _to ."}
{"code": "modifier is champ ready ( uint256 _champ id ) { require ( champs [ _champ id ] . ready time <= block . timestamp ) ; _ ; }", "nl": "is champ ready to fight again ? ."}
{"code": "function vote against ( uint motion id ) external { uint weight = setup vote ( motion id ) ; vote [ msg . sender ] [ motion id ] = vote . nay ; votes against [ motion id ] = safe add ( votes against [ motion id ] , weight ) ; emit voted against ( msg . sender , msg . sender , motion id , motion id , weight ) ; }", "nl": "the sender cast a vote against confiscation of the target account 's nomin balance ."}
{"code": "function get token amount of ( address investor ) constant returns ( uint256 res ) { return token . balance of ( investor ) ; }", "nl": "gets amount of token of specific investor ."}
{"code": "function create asset ( uint256 _creator token id , address _owner , uint256 _price , uint16 _id , uint8 _category , uint8 _state , uint8 _attributes , uint8 [ stats_size ] _stats , uint256 _cooldown , uint64 _cooldown end block ) public only granted contracts returns ( uint256 ) { require ( _id > NUM_ ) ; require ( _category > NUM_ ) ; require ( _attributes != NUM_ ) ; require ( _stats . length > NUM_ ) ; asset memory asset = asset ( { id : _id , category : _category , built by : _creator token id , attributes : bytes2 ( _attributes ) , stats : _stats , state : _state , created at : uint64 ( now ) , cooldown end block : _cooldown end block , cooldown : _cooldown } ) ; uint256 new asset unique id = assets . push ( asset ) - NUM_ ; require ( new asset unique id == uint256 ( uint32 ( new asset unique id ) ) ) ; asset index to price [ new asset unique id ] = _price ; transfer ( address ( NUM_ ) , _owner , new asset unique id )", "nl": "a public method that create a new asset and store it ."}
{"code": "function set freeze oracle ( bool _frozen ) only owner public { freeze oracle = _frozen ; }", "nl": "allows owner to set oracle to ignore all oraclize pricce update ."}
{"code": "function claim tokens ( address receiver ) public is valid payload timed transitions at stage ( stages . trading started ) { if ( receiver == NUM_ ) receiver = msg . sender ; uint token count = bids [ receiver ] * NUM_ * * NUM_ / final price ; bids [ receiver ] = NUM_ ; require ( xrt . transfer ( receiver , token count ) ) ; }", "nl": "claims tokens for bidder after auction ."}
{"code": "function owner set treasury ( address new treasury ) public only owner { treasury = new treasury ; }", "nl": "only owner address can set treasury address ."}
{"code": "modifier only burnup game ( ) { require ( burnup game [ msg . sender ] ) ; _ ; }", "nl": "access modifier for functionality that may only be call by a burnup game ."}
{"code": "function _add original checklist item ( uint8 _player id , rarity tier _tier ) internal { original checklist items . push ( checklist item ( { player id : _player id , tier : _tier } ) ) ; }", "nl": "internal function to add a checklist item to the originals set ."}
{"code": "function finalize auction ( ) public at stage ( stages . auction started ) { uint missing_funds = missing funds to end auction ( ) ; require ( missing_funds == NUM_ ) ; final_price = token_multiplier * received_wei / num_tokens_auctioned ; end_time = now ; stage = stages . auction ended ; auction ended ( final_price ) ; assert ( final_price > NUM_ ) ; }", "nl": "finalize the auction - set the final rdn token price and change the auction stage after no bid be allow anymore ."}
{"code": "function finish ( ) public only owner { require ( status == status . second stage ) ; status = status . finished ; allocation finished ( now ) ; }", "nl": "function to finish human token allocation and to finish token issue ."}
{"code": "function determine player ( int128 win balance , uint128 game count , uint8 v , bytes32 r , bytes32 s ) view internal returns ( address ) { if ( authorized [ msg . sender ] ) return ecrecover ( keccak256 ( win balance , game count ) , v , r , s ) ; else return msg . sender ; }", "nl": "determine if the msg . sender ."}
{"code": "function guard villain ( uint256 _target , uint256 _guard ) public payable returns ( bool ) { require ( msg . sender == villain index to owner [ _guard ] ) ; require ( villains [ _guard ] . num skill active < villains [ _guard ] . level ) ; uint256 operation price = guard price ; if ( villain index to price [ _target ] < NUM_ ether ) { operation price = NUM_ ; } if ( msg . value >= operation price && villains [ _target ] . state < NUM_ ) { villains [ _target ] . state = NUM_ ; villains [ _target ] . affected by token = _guard ; villains [ _guard ] . num skill active ++ ; } }", "nl": "guard a villain ."}
{"code": "function compute bids ( uint _count ) public only owner { require ( status == state . decrypted ) ; require ( _count > NUM_ ) ; uint count = _count ; if ( bids_sorted_count == NUM_ ) { status = state . failure ; emit failure ( NUM_ , NUM_ ) ; return ; } require ( bids_computed_cursor < bids_sorted_count ) ; bid data memory bid ; do { bid = bids_sorted [ bids_computed_cursor ] ; if ( bid . share_price . mul ( computed_shares_sold ) . add ( bid . share_price ) > fundraise_max ) { if ( bids_computed_cursor > NUM_ ) { bids_computed_cursor -- ; } bid = bids_sorted [ bids_computed_cursor ] ; break ; } computed_shares_sold = computed_shares_sold . add ( bid . shares_count ) ; computed_fundraise = bid . share_price . mul ( computed_shares_sold ) ; emit computed ( bid . origin_index , bid . share_price , bid . shares_count ) ; bids_computed_cursor ++ ; count -- ; } while ( count > NUM_ && bids_computed_cursor < bids_sorted_count && ( computed_fundraise < fundraise_max && computed_shares_sold < max_shares_to_sell ) ) ; if ( bids_computed_cursor == bids_sorted_count || computed_fundraise >= fundraise_max || computed_shares_sold >= max_shares_to_sell ) {", "nl": "performs the computation of auction winners and losers ."}
{"code": "function is on sale ( uint256 token id ) external view returns ( bool ) { return gan token offered for sale [ token id ] . is for sale ; }", "nl": "check be a give id be on sale ."}
{"code": "function set contract address ( address _address ) public only owner { contract address = _address ; }", "nl": "sets the address of approveandcall contract ."}
{"code": "function release ( uint256 spid ) public { spentry storage sp entry = sp entries [ spid ] ; require registrant or greater ( sp entry ) ; sp entry . expiration = NUM_ ; sp entry . registrant = address ( NUM_ ) ; sp entry . admin = address ( NUM_ ) ; sp entry . valid = BOOL_ ; }", "nl": "permanently deactivate spid , must be registrant - - expire subscription , invalidate ."}
{"code": "function withdraw erc20 token ( address beneficiary , address _token ) only crowdsale agent public { erc20 basic erc20 token = erc20 basic ( _token ) ; uint256 amount = erc20 token . balance of ( this ) ; require ( amount > NUM_ ) ; erc20 token . transfer ( beneficiary , amount ) ; }", "nl": "send erc20 token from this contract ."}
{"code": "modifier only admin ( ) { address _address = msg . sender ; require ( _address != address ( NUM_ ) ) ; require ( _address == admin address ) ; _ ; }", "nl": "checks whether the msg . sender ."}
{"code": "function is in sale ( ) constant returns ( bool ) { return sale end time >= now && pre sale start time <= now ; }", "nl": "returns true if we be still in sale period ."}
{"code": "function check prize ( ) external view returns ( uint256 prize ) { prize = prizes [ msg . sender ] ; return prize ; }", "nl": "everybody can check if there be some prize wait for them ."}
{"code": "function add period ( uint256 _start timestamp , uint256 _end timestamp , uint256 _rate ) only owner public { require ( _start timestamp != NUM_ ) ; require ( _end timestamp > _start timestamp ) ; require ( _rate != NUM_ ) ; period memory period = period ( _start timestamp , _end timestamp , _rate ) ; periods . push ( period ) ; }", "nl": "add a sale period with it default rate ."}
{"code": "function finalization ( ) internal { token . transfer ownership ( owner ) ; }", "nl": "give not buy tokens to owner , also give back ownership of mdktoken contract ."}
{"code": "function _error and refund ( string _msg , uint _bet , uint8 _number ) private { require ( msg . sender . call . value ( msg . value ) ( ) ) ; emit roll refunded ( now , msg . sender , _msg , _bet , _number ) ; }", "nl": "only call from above ."}
{"code": "function get_data_benefited ( address _benef , string _safe_name ) public view returns ( string ) { require ( map_data_safe_benefited [ _benef ] [ _safe_name ] . exists == BOOL_ ) ; address _safe_owner_address = map_data_safe_benefited [ _benef ] [ _safe_name ] . safe_owner_address ; require ( users [ _safe_owner_address ] . live_user == BOOL_ ) ; require ( users [ _safe_owner_address ] . active_contract == BOOL_ ) ; return map_data_safe_benefited [ _benef ] [ _safe_name ] . data ; }", "nl": "get infor do cofre beneficiado ."}
{"code": "function cancel bid ( ) only by ( highest bid address ) { if ( piece wanted && now > highest bid time + NUM_ ) { piece wanted = BOOL_ ; highest bid price = NUM_ ; highest bid address = NUM_ ; new highest bid ( NUM_ , NUM_ ) ; interface a = interface ( registrar ) ; a . async send ( msg . sender , highest bid price ) ; } else { throw ; } }", "nl": "withdraw a bid - bid can only be withdraw after 24 hours of be place ."}
{"code": "function _trigger tournament sign up ( uint256 [ ] memory _warrior ids , uint256 fee ) internal { uint256 [ ] memory tournament data = _pack tournament data ( _warrior ids ) ; for ( uint256 i = NUM_ ; i < group_size ; i ++ ) { warriors [ _warrior ids [ i ] ] . action = uint16 ( tournament_battle ) ; } battle provider . add tournament contender . value ( fee ) ( msg . sender , tournament data ) ; }", "nl": "internal utility function to sign up to tournament , assume that all battle requirements have be check ."}
{"code": "function set active transcoders ( ) external when system not paused only rounds manager { uint256 current round = rounds manager ( ) . current round ( ) ; uint256 active set size = math . min256 ( num active transcoders , transcoder pool . get size ( ) ) ; uint256 total stake = NUM_ ; address current transcoder = transcoder pool . get first ( ) ; for ( uint256 i = NUM_ ; i < active set size ; i ++ ) { active transcoder set [ current round ] . transcoders . push ( current transcoder ) ; active transcoder set [ current round ] . is active [ current transcoder ] = BOOL_ ; uint256 stake = transcoder pool . get key ( current transcoder ) ; uint256 reward cut = transcoders [ current transcoder ] . pending reward cut ; uint256 fee share = transcoders [ current transcoder ] . pending fee share ; uint256 price per segment = transcoders [ current transcoder ] . pending price per segment ; transcoder storage t = transcoders [ current transcoder ] ; t . reward cut = reward cut ; t . fee share = fee", "nl": "set active transcoder set for the current round ."}
{"code": "function set activation fee ( uint256 _activation fee ) public only owner returns ( bool ) { require ( _activation fee > NUM_ , STR_ ) ; require ( _activation fee != activation fee , STR_ ) ; activation fee = _activation fee ; emit activation fee updated ( msg . sender , _activation fee ) ; return BOOL_ ; }", "nl": "set the global activation fee ."}
{"code": "function resume crowdsale ( ) public only owner { is crowdsale paused = BOOL_ ; }", "nl": "function to resume the crowdsale if it be pause can only be call from owner wallet ."}
{"code": "function add presale ( address _contributor , uint256 _tokens , uint256 _bonus , uint8 _contributor phase ) external only admin and ops only before sale returns ( bool ) { require ( _tokens > NUM_ ) ; require ( _bonus > NUM_ ) ; uint256 luckys = _tokens . mul ( j8 t_decimals_factor ) ; uint256 bonus luckys = _bonus . mul ( j8 t_decimals_factor ) ; uint256 total tokens = luckys . add ( bonus luckys ) ; uint256 available tokens to purchase = token contract . balance of ( address ( this ) ) ; require ( total tokens <= available tokens to purchase ) ; require ( ledger contract . add allocation ( _contributor , luckys , bonus luckys , _contributor phase ) ) ; require ( token contract . transfer ( address ( ledger contract ) , total tokens ) ) ; total tokens sold = total tokens sold . add ( total tokens ) ; available tokens to purchase = token contract . balance of ( address ( this ) ) ; if ( available tokens to purchase == NUM_ ) { finalization ( ) ; } presale added ( _contributor , total tokens ,", "nl": "adds a new presale allocation for the contributor with address _contributor ."}
{"code": "function mint for private fiat ( address _beneficiary , uint256 _wei amount ) public only owner { _pre validate purchase ( _beneficiary , _wei amount ) ; uint256 tokens = _get token amount ( _wei amount ) ; wei raised = wei raised . add ( _wei amount ) ; _process purchase ( _beneficiary , tokens ) ; emit token purchase ( msg . sender , _beneficiary , _wei amount , tokens ) ; _update purchasing state ( _beneficiary , _wei amount ) ; _forward funds ( ) ; _post validate purchase ( _beneficiary , _wei amount ) ; }", "nl": "mint for private fiat transactions ."}
{"code": "function credit balance of ( address _user ) public view returns ( uint256 ) { return credit balances [ _user ] ; }", "nl": "returns the balance of credit at a user 's address ."}
{"code": "function vested transfer ( address _to , uint256 _amount , uint _lock months ) public when not paused only payload size ( NUM_ * NUM_ ) returns ( bool ) { require ( msg . sender == funds wallet || msg . sender == team wallet ) ; require ( _lock months >= min vest lock months ) ; vesting storage vesting = vesting map [ _to ] ; require ( vesting . amount == NUM_ ) ; if ( msg . sender == funds wallet ) { require ( allow purchase ( _amount ) ) ; require ( is purchase within cap ( token sold , _amount ) ) ; require ( allow transfer ( msg . sender , _amount ) ) ; uint256 transfer amount = _amount . mul ( NUM_ ) . div ( NUM_ ) ; uint256 vesting amount = _amount . sub ( transfer amount ) ; vesting . amount = vesting amount ; vesting . start time = now ; vesting . lock months = _lock months ; emit vest transfer ( msg . sender , _to , vesting . amount , vesting . start time , _lock months ) ; balances [ msg", "nl": "true if the transfer be do ."}
{"code": "function reclaim resource deposits ( address _withdraw address ) public only manager { require ( _withdraw address != address ( NUM_ ) ) ; for ( uint8 ii = NUM_ ; ii < NUM_ ; ii ++ ) { if ( resource erc20 address [ ii ] != NUM_ ) { erc20 res cont = erc20 ( resource erc20 address [ ii ] ) ; uint256 bal = res cont . balance of ( this ) ; res cont . transfer ( _withdraw address , bal ) ; } } }", "nl": "withdraw remaining resource tokens ."}
{"code": "function ether funds of ( address _address ) public constant returns ( uint ) { return ether funds [ _address ] ; }", "nl": "other methods ."}
{"code": "function change disown ( uint new_value ) public only owner { if ( new_value == NUM_ ) { disown = NUM_ ; } }", "nl": "no more god like ."}
{"code": "function calculate allocation ( address contributor ) public constant returns ( uint256 ) { uint256 presale = presale contributions [ contributor ] . mul ( NUM_ ) . div ( NUM_ ) ; uint256 total contribution = presale . add ( contributions [ contributor ] ) ; return total contribution . mul ( max_tokens ) . div ( presale_wei_with_bonus . add ( wei contributed ) ) ; }", "nl": "calculate the pryz allocation for the give contributor ."}
{"code": "function plus ( uint256 addend a , uint256 addend b ) public pure returns ( uint256 sum ) { sum = addend a + addend b ; }", "nl": "adds two addends together , return the sum ."}
{"code": "function purchase supernova ( address target address , uint price ) external only manager { require ( super nova supply >= NUM_ ) ; nova coin interface nova coin contract = nova coin interface ( nova coin address ) ; require ( nova coin contract . balance of ( target address ) >= price ) ; nova coin contract . consume coin for nova ( target address , price ) ; super nova supply -= NUM_ ; var new nova id = _insert new astro ( target address , astro type . supernova , NUM_ , NUM_ , NUM_ ) ; purchased supernova ( target address , new nova id ) ; }", "nl": "purchase action only permit manager to use ."}
{"code": "function create sale auction ( uint256 _artwork id , uint256 _starting price , uint256 _ending price , uint256 _duration ) external when not paused { require ( _owns ( msg . sender , _artwork id ) ) ; _approve ( _artwork id , sale auction ) ; sale auction . create auction ( _artwork id , _starting price , _ending price , _duration , msg . sender ) ; }", "nl": "put a artwork up for auction ."}
{"code": "function release reserved tokens ( ) external only owner { require ( block . timestamp > ( opening time . add ( NUM_ weeks ) ) ) ; require ( allocated [ _reserve ] > NUM_ ) ; token . transfer ( _reserve , reserve_token_amount ) ; allocated [ _reserve ] = NUM_ ; }", "nl": "release reserve tokens to _reserve address only after vest period ."}
{"code": "modifier when private fund enabled ( ) { require ( private fund enabled ) ; _ ; }", "nl": "modifier to make a function callable only when the contract be private fund end ."}
{"code": "function send to beneficiary ( ) public { uint256 amount = get available amount ( ) ; already withdrawn += amount ; require ( token . transfer ( beneficiary , amount ) ) ; }", "nl": "sends available amount to store beneficiary ."}
{"code": "function concat ( string _base , string _value ) internal returns ( string ) { bytes memory _base bytes = bytes ( _base ) ; bytes memory _value bytes = bytes ( _value ) ; assert ( _value bytes . length > NUM_ ) ; string memory _tmp value = new string ( _base bytes . length + _value bytes . length ) ; bytes memory _new value = bytes ( _tmp value ) ; uint i ; uint j ; for ( i = NUM_ ; i < _base bytes . length ; i ++ ) { _new value [ j ++ ] = _base bytes [ i ] ; } for ( i = NUM_ ; i < _value bytes . length ; i ++ ) { _new value [ j ++ ] = _value bytes [ i ] ; } return string ( _new value ) ; }", "nl": "string the result string from comb the base and value ."}
{"code": "function _is contract ( address _address ) internal view returns ( bool ) { uint size ; assembly { size : = extcodesize ( _address ) } return size > NUM_ ; }", "nl": "check whether give address be a smart contract ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; if ( is holding locked tokens [ msg . sender ] ) { require ( _value <= balances [ msg . sender ] . sub ( locked token balance [ msg . sender ] ) ) ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "nl": "a boolean represent whether the function be execute succesfully ."}
{"code": "function grant ( address beneficiary , uint256 vested jiffys , uint256 unvested jiffys , uint256 start timestamp , uint256 cliff seconds , uint256 vesting seconds , bool revocable ) public require is operational { require ( beneficiary != address ( NUM_ ) ) ; require ( ! vesting grants [ beneficiary ] . is granted ) ; require ( ( vested jiffys > NUM_ ) || ( unvested jiffys > NUM_ ) ) ; require ( start timestamp >= genesis_timestamp ) ; require ( vesting seconds > NUM_ ) ; require ( cliff seconds >= NUM_ ) ; require ( cliff seconds < vesting seconds ) ; when contract . vesting grant ( msg . sender , beneficiary , vested jiffys , unvested jiffys ) ; vesting grants [ beneficiary ] = vesting grant ( { is granted : BOOL_ , issuer : msg . sender , beneficiary : beneficiary , grant jiffys : unvested jiffys , start timestamp : start timestamp , cliff timestamp : start timestamp + cliff seconds , end timestamp : start timestamp + vesting seconds , is revocable : revocable , released jiffys : NUM_ } ) ; vesting grant lookup . push ( beneficiary", "nl": "grants a beneficiary jiffys use a vest schedule ."}
{"code": "function add player ( address a ) private { if ( last ping [ a ] == NUM_ ) { participants [ count participants ] = a ; count participants = count participants + NUM_ ; } last ping [ a ] = now ; }", "nl": "private and constant function add a player to the array of participants ."}
{"code": "function collect interest ( address _owner ) internal { require ( is start ) ; uint block height ; if ( deposit blockheight [ _owner ] < block height start ) { block height = block height start ; } else { block height = deposit blockheight [ _owner ] ; } uint _temp interest = account balance [ _owner ] * ( block . number - block height ) / NUM_ ; account balance [ _owner ] += _temp interest ; master apparent balance += _temp interest ; deposit blockheight [ _owner ] = block . number ; }", "nl": "retrieve interest earn since last interest collection ."}
{"code": "function return referral ( address _user ) external view returns ( address ) { return affiliates [ _user ] ; }", "nl": "it will return refferal address ."}
{"code": "function transfer ( address _to , uint256 _value ) public valid address ( _to ) returns ( bool success ) { if ( lock num [ msg . sender ] > NUM_ ) calc unlock ( msg . sender ) ; if ( balance p [ msg . sender ] >= _value && _value > NUM_ ) { balance p [ msg . sender ] = sub ( balance p [ msg . sender ] , _value ) ; balance p [ _to ] = add ( balance p [ _to ] , _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } else { return BOOL_ ; } }", "nl": "standard erc20 transfer ."}
{"code": "function init members ( ) only owner { add member ( NUM_ , STR_ ) ; add member ( msg . sender , STR_ ) ; }", "nl": "add madame bov a a beef judge ."}
{"code": "function purchase country ( uint256 _token id ) public payable is not contract ( msg . sender ) { country storage country = country data [ _token id ] ; uint256 price = country . price ; address old owner = country . owner ; address new owner = msg . sender ; uint256 excess = msg . value . sub ( price ) ; require ( price > NUM_ ) ; require ( msg . value >= price ) ; require ( old owner != msg . sender ) ; uint256 profit = price . sub ( country . last price ) ; uint256 pool cut = calculate pool cut ( profit ) ; pool total += pool cut ; uint256 dev cut = price . mul ( NUM_ ) . div ( NUM_ ) ; dev owed = dev owed . add ( dev cut ) ; transfer country ( old owner , new owner , _token id ) ; country . last price = price ; country . price = get next price ( price ) ; country purchased ( _token id , new owner , price ) ; old owner . transfer ( price . sub", "nl": "purchase country from previous owner ."}
{"code": "function owner of ( uint256 _token id ) external view returns ( address owner ) { owner = zodiac index to owner [ _token id ] ; require ( owner != address ( NUM_ ) ) ; }", "nl": "returns the address currently assign ownership of a give zodiac ."}
{"code": "function read bytes32 ( bytes data , uint256 index ) internal pure returns ( bytes32 o ) { if ( data . length / NUM_ > index ) { assembly { o : = mload ( add ( data , add ( NUM_ , mul ( NUM_ , index ) ) ) ) } } }", "nl": "reads a bytes32 word of a bytes array ."}
{"code": "function is phase ( uint time , uint n ) constant returns ( bool ) { if ( time > now ) { throw ; } if ( n >= n ) { throw ; } if ( n > NUM_ && phase end time [ n - NUM_ ] > time ) { return BOOL_ ; } if ( n < n && time >= phase end time [ n ] ) { return BOOL_ ; } return BOOL_ ; }", "nl": "return true if the give time belong to the give phase ."}
{"code": "function referral dividends of ( address _player address ) public view returns ( uint256 ) { return crypto torch token_ . referral balance of ( _player address ) ; }", "nl": "retrieve the referral dividend balance of any single address ."}
{"code": "function approve to mint ( uint256 _value ) external when not paused returns ( bool ) { return approve ( the coin , _value ) ; }", "nl": "approve this contract , proxy for owner ( mint ) , to spend the specified amount of tokens on behalf of msg . sender ."}
{"code": "function destroy ( ) public owner only { for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { require ( state [ i ] == state . paused || state [ i ] == state . uninitialized ) ; } selfdestruct ( owner ) ; }", "nl": "this function allow to destroy current contract in case all room be pause or not use ."}
{"code": "function mint tokens ( address beneficiary , uint256 amount ) internal { tokens minted = tokens minted . add ( amount ) ; require ( tokens minted <= hard cap ) ; assert ( token . mint ( beneficiary , amount ) ) ; add holder ( beneficiary ) ; }", "nl": "mint tokens and apply poolparty method ( alber erre ) ."}
{"code": "modifier only by or ( address _account1 , address _account2 ) { require ( msg . sender == _account1 || msg . sender == _account2 ) ; _ ; }", "nl": "throws if call by any account other than either of the two arguments ."}
{"code": "modifier not exceed maximum supply ( uint amount ) { require ( total supply . plus ( amount ) <= maximum supply ) ; _ ; }", "nl": "throws if tokens will exceed maximum supply ."}
{"code": "function burn tokens ( ) external only crowdsale when not paused { uint256 remaining icotoken = limit crowdsale . sub ( tokens distributed crowdsale ) ; if ( remaining icotoken > NUM_ && ! remaining token burnt ) { remaining token burnt = BOOL_ ; limit crowdsale = limit crowdsale . sub ( remaining icotoken ) ; total supply = total supply . sub ( remaining icotoken ) ; } }", "nl": "burn the amount of tokens remain after ico end ."}
{"code": "function add vineyard endorsement ( string _mapping id , uint _index , bool positive , string title , string description ) external returns ( bool success ) { vineyard endorsements [ keccak256 ( _mapping id , _index ) ] . push ( endorsement ( positive , title , description , msg . sender ) ) ; return BOOL_ ; }", "nl": "add new endorsement to a vineyard ."}
{"code": "function update description ( string _project description , bytes32 _hash of the document ) only project manager { description = _project description ; hash of the document = _hash of the document ; project description updated ( msg . sender , _project description , _hash of the document ) ; }", "nl": "function to allow the project manager update the description of the project ."}
{"code": "function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( b >= a ) { return NUM_ ; } return a - b ; }", "nl": "substracts two number , return 0 if it would go into minus range ."}
{"code": "function player check provably fair ( uint random result , bytes proof ) public constant returns ( uint ) { return uint ( sha3 ( random result , proof ) ) % NUM_ + NUM_ ; }", "nl": "player check provably fair ."}
{"code": "function get total supply ( ) public constant returns ( uint256 ) { return total supply ; }", "nl": "public data retrieval funcs ."}
{"code": "function get toc price ( ) public view returns ( uint256 ) { return market [ contract addr ] . toc price ; }", "nl": "get toc price ."}
{"code": "function set name ( bytes32 _name ) public { if ( name to address [ _name ] != address ( NUM_ ) ) { return ; } players [ msg . sender ] . name = _name ; name to address [ _name ] = msg . sender ; }", "nl": "player name ."}
{"code": "function exit ( ) external { require ( BOOL_ ) ; }", "nl": "instead of exit use the transfer function and change someone 's life ! ! ! p4rty on ! ! ! ."}
{"code": "function quick trade ( address token from , address token to , uint256 input ) payable drain block { uint256 in value ; uint256 temp in value = safe add ( token to value ( ether contract , msg . value ) , token to value ( token from , input ) ) ; in value = value with fee ( temp in value ) ; uint256 out value = value to token ( token to , in value ) ; assert ( verified transfer from ( token from , msg . sender , input ) ) ; if ( token to == ether contract ) { assert ( msg . sender . call . value ( out value ) ( ) ) ; } else assert ( token ( token to ) . transfer ( msg . sender , out value ) ) ; trade ( token from , token to , msg . sender , in value ) ; }", "nl": "input a mixture of a token and ether , recieve the output token ."}
{"code": "function set times ( uint256 _start time , uint256 _duration ) public if authorized ( msg . sender , aphrodite ) { require ( now < start time || now > end time ) ; require ( _start time >= NUM_ && _duration > NUM_ ) ; start time = _start time ; end time = start time + _duration ; emit set period ( start time , end time ) ; }", "nl": "reset the start and end time for the next round ."}
{"code": "function mint ( address _address , uint _amount ) only controller or owner { require ( _address != NUM_ ) ; uint256 amount = safe math . safe mul ( _amount , ( NUM_ * * decimals ) ) ; assert ( supply cap > NUM_ && amount > NUM_ && safe math . safe add ( current supply , amount ) <= supply cap ) ; balance of [ _address ] = safe math . safe add ( balance of [ _address ] , amount ) ; current supply = safe math . safe add ( current supply , amount ) ; mint ( _address , amount ) ; }", "nl": "dev : mint esg tokens by controller ."}
{"code": "function unlock tokens ( address _address ) public { require ( locked list [ _address ] != address ( NUM_ ) ) ; token timelock locked contract = token timelock ( locked list [ _address ] ) ; locked contract . release ( ) ; }", "nl": "unlock frozen tokens ."}
{"code": "function decimals ( ) public delegatable view returns ( uint8 ) { return NUM_ ; }", "nl": "number of decimals for the token ."}
{"code": "function write document ( uint128 refid , uint16 state , uint doctime , bytes32 [ ] taghashes , string tags , string title , string text ) internal { docauthor [ doccnt ] = msg . sender ; userdocid [ msg . sender ] [ userdoccnt [ msg . sender ] ] = doccnt ; userdoccnt [ msg . sender ] ++ ; document event ( doccnt , refid , state , doctime , msg . sender , tags , title , text ) ; for ( uint8 i = NUM_ ; i < taghashes . length ; i ++ ) { if ( i >= NUM_ ) break ; if ( taghashes [ i ] != NUM_ ) tag event ( doccnt , msg . sender , taghashes [ i ] , NUM_ ) ; } doccnt ++ ; }", "nl": "generic function that add a document to the blockchain or modify a document that already exist on the blockchain ."}
{"code": "function early purchases ( uint256 early purchase index ) external constant only early purchases loaded returns ( address purchaser , uint256 amount , uint256 purchased at ) { return starbase early purchase . early purchases ( early purchase index ) ; }", "nl": "returns an early purchase record ."}
{"code": "function get covfefe ( uint _token id ) public view returns ( string term , string meaning , uint generation , uint ready time , uint win count , uint loss count , uint current price , uint last price , address owner ) { covfefe storage covfefe = covfefes [ _token id ] ; term = covfefe . term ; meaning = covfefe . meaning ; generation = covfefe . generation ; ready time = covfefe . sale ready time ; win count = covfefe . win count ; loss count = covfefe . loss count ; current price = covfefe index to price [ _token id ] ; last price = covfefe index to last price [ _token id ] ; owner = covfefe index to owner [ _token id ] ; }", "nl": "returns all the relevant information about a specific covfefe ."}
{"code": "function balance of ( address _who ) constant returns ( uint256 ) { return accounts [ _who ] . balance ; }", "nl": "get the balance of a specific address ."}
{"code": "function unlock2 y ( ) { require ( now >= locked_2 y_date ) ; uint amount = balances locked2 y [ msg . sender ] ; require ( amount > NUM_ ) ; balances locked2 y [ msg . sender ] = NUM_ ; total supply locked2 y = total supply locked2 y . sub ( amount ) ; if ( ! token contract . transfer ( msg . sender , amount ) ) throw ; }", "nl": "an account can unlock their 2y lock tokens 2y after token launch date ."}
{"code": "function whitelist count ( ) public constant returns ( uint ) { uint count = NUM_ ; for ( uint i = NUM_ ; i < bidder whitelist . length ; i ++ ) { if ( bidder whitelist [ i ] != NUM_ ) count ++ ; } return count ; }", "nl": "number of non-zero entries in whitelist ."}
{"code": "function update duration ( uint time ) public only owner { require ( time != NUM_ ) ; assert ( start block != NUM_ ) ; assert ( crowd sale type == NUM_ && crowdsale status != NUM_ ) ; duration crowd sale = duration crowd sale . add ( time ) ; end block = end block . add ( time ) ; state changed ( BOOL_ ) ; }", "nl": "to extend duration of crowdsale ."}
{"code": "function my test wallet7 ( ) { me = msg . sender ; set_savings_goal ( NUM_ ether ) ; }", "nl": "constructor / initialize ( only run at contract creation ) ."}
{"code": "function buy tokens ( uint256 ether sent ) payable { amount = NUM_ ; amount = div ( ( mul ( ether sent , rate ) ) , NUM_ ether ) ; balances [ msg . sender ] += amount ; tokens -= amount ; amount = NUM_ ; owner . transfer ( msg . value ) ; }", "nl": "this function take the amount of ether send and buy tokens ."}
{"code": "function balance of ( address _owner ) public view returns ( uint256 ) { return player of [ _owner ] . token balance ; }", "nl": "token balance for player ."}
{"code": "function make withdrawal ( address from , address to , uint value , uint index ) internal { if ( value == stakes [ from ] ) { stakes [ from ] = NUM_ ; remove holder ( from , index ) ; emit stake update ( from , NUM_ ) ; } else { uint new stake = safe sub ( stakes [ from ] , value ) ; require ( new stake >= min staking amount ) ; stakes [ from ] = new stake ; emit stake update ( from , new stake ) ; } total stakes = safe sub ( total stakes , value ) ; assert ( token . transfer ( to , safe sub ( value , withdraw gas cost ) ) ) ; }", "nl": "internal method for process the withdrawal ."}
{"code": "modifier not paused { require ( now > NUM_ || msg . sender == owner ) ; _ ; }", "nl": "may 01 , 2018 00 : 00 : 00 utc ."}
{"code": "function receive approval ( address _from , uint256 _amount , address _token , bytes _data ) public no mint returns ( bool ) { require ( _token == old token address ) ; require ( erc20 interface ( old token address ) . transfer from ( _from , this , _amount ) ) ; uint256 new token amount = _amount . mul ( scaling factor ) . mul ( ten decimal places ) ; assert ( tokens redeemed . add ( new token amount ) <= circulating supply ) ; tokens redeemed = tokens redeemed . add ( new token amount ) ; require ( new token . transfer ( _from , new token amount ) ) ; emit log token swap ( _from , _amount , block . timestamp ) ; return BOOL_ ; }", "nl": "alias for swap ( ) ."}
{"code": "function create token contract ( ) internal returns ( mintable token ) { return new hazza token ( ) ; }", "nl": "hazzatoken contract ."}
{"code": "function valid purchase ( ) internal view returns ( bool ) { bool within period = trans start time >= start time && trans start time <= end time ; bool valid amount = msg . value >= min trans amount ; bool within eth cap = ( ( eth cap . sub ( main wei raised ) ) > NUM_ ) ; bool gold period valid = BOOL_ ; if ( trans start time <= ( start time + gold list period ) ) { gold period valid = ( gold list [ msg . sender ] ) && ( gold list contribution [ msg . sender ] + msg . value <= gold period cap ) ; gold list period flag = BOOL_ ; } return within period && valid amount && within eth cap && gold period valid ; }", "nl": "check if the investor can buy tokens ."}
{"code": "function check holes and distribute purchase funds ( geometry . rect [ ] memory sub plots , uint256 [ ] memory area indices ) private returns ( uint256 ) { uint256 remaining balance = msg . value ; uint256 owed to seller = NUM_ ; for ( uint256 area indices index = NUM_ ; area indices index < area indices . length ; area indices index ++ ) { uint256 ownership index = area indices [ area indices index ] ; geometry . rect memory current ownership rect = geometry . rect ( ownership [ ownership index ] . x , ownership [ ownership index ] . y , ownership [ ownership index ] . w , ownership [ ownership index ] . h ) ; require ( geometry . rect contained inside ( sub plots [ area indices index ] , current ownership rect ) ) ; for ( uint256 hole index = NUM_ ; hole index < holes [ ownership index ] . length ; hole index ++ ) { plot ownership memory hole plot = ownership [ holes [ ownership index ] [ hole index ] ] ; geometry . rect memory hole rect = geometry .", "nl": "checks that the sub-plots which we be purchase be all valid and then distribute fund to the owners of those sub-plots ."}
{"code": "function cancel ( bytes32 _request id ) external { request storage r = requests [ _request id ] ; require ( r . currency contract == msg . sender ) ; r . state = state . canceled ; canceled ( _request id ) ; }", "nl": "function use by currency contract to cancel a request in the core ."}
{"code": "function update price ( uint price , uint time sent ) external post check auto liquidate { require ( msg . sender == oracle ) ; require ( last price update time < time sent && time sent < now + NUM_ minutes ) ; ether price = price ; last price update time = time sent ; emit price updated ( price ) ; }", "nl": "update the current ether price and update the last updated time , refresh the price staleness ."}
{"code": "function get current bonus rate ( ) internal returns ( uint8 ) { if ( get state ( ) == state . pre sale ) { return NUM_ ; } if ( get state ( ) == state . crowdfund ) { if ( now > crowdfund start date && now <= NUM_ ) { return NUM_ ; } if ( now > NUM_ && now <= NUM_ ) { return NUM_ ; } if ( now > NUM_ && now <= NUM_ ) { return NUM_ ; } else { return NUM_ ; } } }", "nl": "function provide the current bonus rate ."}
{"code": "function fill ( uint [ ] data ) only owner { if ( next > NUM_ ) throw ; uint acc ; uint offset = transfers . length ; transfers . length = transfers . length + data . length ; for ( uint i = NUM_ ; i < data . length ; i ++ ) { address addr = address ( data [ i ] & ( d160 - NUM_ ) ) ; uint amount = data [ i ] / d160 ; transfers [ offset + i ] . addr = addr ; transfers [ offset + i ] . amount = amount ; acc += amount ; } total to distribute += acc ; }", "nl": "this be the function that make the list of transfer and various check around that list , it be a little tricky , the data input be structure with the amount and the ( receive ) addr combine a one long number and then this number be deconstruct in this function to save gas and reduce the number of 0 's that be need to be store on the blockchain ."}
{"code": "function transfer ( address _to , uint256 _value ) public { _transfer ( msg . sender , _to , _value ) ; }", "nl": "transfer tokens , send _value tokens to _to from your account ."}
{"code": "function del cashier ( address _address ) only owner public { cashiers [ _address ] = BOOL_ ; cashier removed ( _address ) ; }", "nl": "removes cashier account responsible for manual token issuance ."}
{"code": "function whitelist address ( address _address ) external only owner at stage ( stages . funding ) { require ( whitelisted [ _address ] != BOOL_ ) ; whitelisted [ _address ] = BOOL_ ; whitelisted event ( _address , BOOL_ ) ; }", "nl": "start whitelist related function allow address to buy tokens ."}
{"code": "function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( ! dvipbackend ( backend contract ) . transfer ( msg . sender , _to , _amount ) ) throw ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; }", "nl": "transfer _amount to _to ."}
{"code": "function drain ( ) external only owner ( ) { multisig . transfer ( address ( this ) . balance ) ; }", "nl": "fail-safe drain ."}
{"code": "function number of ( bytes16 _edition ) public view returns ( uint256 ) { return edition to edition number [ _edition ] ; }", "nl": "return the total number of assets in an edition ."}
{"code": "function draw ( uint32 _id , uint8 _draws , bytes32 _hash check ) public { game storage _game = games [ _id ] ; address _user = user addresses [ _game . user id ] ; if ( _game . i block == NUM_ ) return _draw failure ( _id , _draws , STR_ ) ; if ( _user != msg . sender ) return _draw failure ( _id , _draws , STR_ ) ; if ( _game . i block == block . number ) return _draw failure ( _id , _draws , STR_ ) ; if ( _game . d block != NUM_ ) return _draw failure ( _id , _draws , STR_ ) ; if ( _draws > NUM_ ) return _draw failure ( _id , _draws , STR_ ) ; if ( _draws == NUM_ ) return _draw failure ( _id , _draws , STR_ ) ; if ( _game . hand rank != hand_undefined ) return _draw failure ( _id , _draws , STR_ ) ; _draw ( _game , _id , _draws , _hash check ) ; }", "nl": "resolves the initial hand ( if possible ) and set the users draw ."}
{"code": "function asset thaw ( ) internal { is frozen = BOOL_ ; }", "nl": "re-enable token circulation - splitprofits internal ."}
{"code": "function get day ( uint16 day id ) public view only valid day ( day id ) returns ( uint16 id , address owner , string message , uint256 sellprice , uint256 buyprice ) { return ( day id , day structs [ day id ] . owner , day structs [ day id ] . message , get current price ( day id ) , day structs [ day id ] . buyprice ) ; }", "nl": "returns day detail ."}
{"code": "function withdraw for ( address token owner ) public when not paused { require ( ! payments [ token owner ] [ current period . block ] ) ; reset period ( ) ; uint payment = get payment total ( token owner ) ; require ( payment > NUM_ ) ; assert ( this . balance >= payment ) ; payments [ token owner ] [ current period . block ] = BOOL_ ; payment completed ( token owner , current period . block , payment ) ; token owner . transfer ( payment ) ; }", "nl": "allows someone to call withdraw on behalf of someone else ."}
{"code": "function approve ( address _spender , uint256 _value ) public only after minting returns ( bool ) { return super . approve ( _spender , _value ) ; }", "nl": "same erc20 behavior , but revert if still mint ."}
{"code": "function buy soul ( address no soul mate ) public payable returns ( uint256 amount ) { uint256 charons obol ; uint256 price ; require ( owned by [ no soul mate ] == address ( NUM_ ) ) ; price = soul prices [ no soul mate ] ; require ( price > NUM_ ) ; require ( bytes ( reasons [ no soul mate ] ) . length > NUM_ ) ; require ( msg . value >= price ) ; charons obol = msg . value / obol ; require ( souls owned [ msg . sender ] + NUM_ > souls owned [ msg . sender ] ) ; pay charon ( charons obol ) ; no soul mate . transfer ( msg . value - charons obol ) ; souls for sale -= NUM_ ; souls sold += NUM_ ; souls owned [ msg . sender ] += NUM_ ; owned by [ no soul mate ] = msg . sender ; soul transfer ( no soul mate , msg . sender ) ; amount = charons obol / napkin price + unit ; amount = check amount ( amount ) ; if ( amount", "nl": "buy msg . sender ."}
{"code": "function finalize ( ) only owner public { require ( ! sale active ( ) ) ; balances [ wallet ] = balances [ wallet ] . add ( balances [ NUM_ ] ) ; balances [ NUM_ ] = NUM_ ; transferable = BOOL_ ; }", "nl": "collect all the remain token which be unsold after the sell period and make this token can be tranferred ."}
{"code": "function lock account ( address _addr ) public only admin returns ( bool ) { require ( _addr != address ( NUM_ ) ) ; locked [ _addr ] = BOOL_ ; return BOOL_ ; }", "nl": "alan : lock or unlock account ."}
{"code": "function set kingdom factory ( kingdom factory _kingdom factory ) { external enter ( ) ; set kingdom factory rp ( _kingdom factory ) ; external leave ( ) ; }", "nl": "used by topwizard to vary the factory contract which will be use to create future kingdoms ."}
{"code": "function _burn ( address _who , uint256 _value ) internal { require ( _value <= balances [ _who ] ) ; balances [ _who ] = balances [ _who ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; emit burn ( _who , _value ) ; emit transfer ( _who , address ( NUM_ ) , _value ) ; }", "nl": "actual function to burn tokens ."}
{"code": "function lock ( ) internal not locked only owner { locked at = block . timestamp ; time locks [ team reserve wallet ] = team reserve time lock ; time locks [ life reserve wallet ] = life reserve time lock ; time locks [ finan reserve wallet ] = finan reserve time lock ; time locks [ econ reserve wallet ] = econ reserve time lock ; time locks [ develop reserve wallet ] = develop reserve time lock ; locked ( locked at ) ; }", "nl": "lock the vault for the wallets ."}
{"code": "function approve ( address _spender , uint256 _value ) returns ( bool success ) { if ( _value != NUM_ && allowed [ msg . sender ] [ _spender ] != NUM_ ) { return BOOL_ ; } allowed [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }", "nl": "put the addres in allow map ."}
{"code": "function remove tenant ( uint _land id ) public { require ( lands [ _land id ] . owner address == msg . sender ) ; lands [ _land id ] . land for rent = BOOL_ ; lands [ _land id ] . is occupied = BOOL_ ; cities [ lands [ _land id ] . city renting id ] . land id = NUM_ ; lands [ _land id ] . city renting id = NUM_ ; }", "nl": "land owner can use this function to remove a city from their land ."}
{"code": "function slice4 ( bytes b , uint offset ) constant returns ( bytes4 ) { bytes4 out ; for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { out |= bytes4 ( b [ offset + i ] & NUM_ ) > > ( i * NUM_ ) ; } return out ; }", "nl": "extract 32-bit worth of data from the bytes stream ."}
{"code": "function get interest count ( ) constant returns ( uint256 result ) { return interest array . length ; }", "nl": "get interest count ."}
{"code": "modifier when not closed ( ) { require ( ! is closed ) ; _ ; }", "nl": "modifier to make a function callable only when the contract be not close ."}
{"code": "function version addresses ( bytes32 _app , bytes32 _version ) internal pure returns ( bytes32 ) { return keccak256 ( STR_ , version base ( _app , _version ) ) ; }", "nl": "returns the location of an app 's implement address , register under a provider ."}
{"code": "function withdraw eth ( address _from , address _to , uint _amount ) external only owner { require ( eth teller balance [ _from ] >= _amount ) ; eth teller balance [ _from ] = safe math . sub ( eth teller balance [ _from ] , _amount ) ; uint256 wei sold today = get wei sold today ( _from ) ; _date time memory date = get date info ( block . timestamp ) ; eth sells user today [ _from ] [ date . day ] [ date . month ] [ date . year ] = safe math . add ( wei sold today , _amount ) ; _to . transfer ( _amount ) ; }", "nl": "withdraw eth for teller escrow + save amount sell today for the _from user ."}
{"code": "function create converter ( ibancor converter extended _old converter ) private returns ( ibancor converter extended ) { iwhitelist whitelist ; ismart token token = _old converter . token ( ) ; uint32 max conversion fee = _old converter . max conversion fee ( ) ; address converter adderess = bancor converter factory . create converter ( token , registry , max conversion fee , ierc20 token ( address ( NUM_ ) ) , NUM_ ) ; ibancor converter extended converter = ibancor converter extended ( converter adderess ) ; converter . accept ownership ( ) ; converter . accept management ( ) ; icontract features features = icontract features ( registry . get address ( contract ids . contract_features ) ) ; if ( features . is supported ( _old converter , feature ids . converter_conversion_whitelist ) ) { whitelist = _old converter . conversion whitelist ( ) ; if ( whitelist != address ( NUM_ ) ) converter . set conversion whitelist ( whitelist ) ; } return converter ; }", "nl": "create a new converter with same basic data a the original old converter the newly create converter will have no connectors at this step ."}
{"code": "modifier before range game ( ) { require ( now > d . game start && now <= d . game end ) ; _ ; }", "nl": "calulate game time and gc amount record ."}
{"code": "function get vesting time ( address account , uint index ) public view returns ( uint ) { return get vesting schedule entry ( account , index ) [ time_index ] ; }", "nl": "get the time at which a give schedule entry will vest ."}
{"code": "function get contract owner ( ) external view returns ( address ) { return owner address ; }", "nl": "some helper / info getter function ."}
{"code": "function set enforce address match ( bool _enforce address match ) only owner public { enforce address match = _enforce address match ; }", "nl": "setter for the enforce flag - only updatable by the owner ."}
{"code": "function create auction ( uint256 _token id ) external payable { require ( auctions enabled ) ; require ( _owns ( msg . sender , _token id ) || msg . sender == authority address ) ; require ( ! token id to auction [ _token id ] . live ) ; uint start price = pixel price ; if ( msg . sender == authority address ) { start price = NUM_ ; } require ( msg . value == start price ) ; pixel index to approved [ _token id ] = address ( this ) ; token id to auction [ _token id ] = auction ( msg . sender , start price , block . timestamp + duration , BOOL_ ) ; auction started ( _token id ) ; }", "nl": "create a new auction for a give pixel , only owner or authority can do this ."}
{"code": "function start betting ( uint32 _betting start , uint32 _betting end ) public only owner { require ( ! inited ) ; betting start = _betting start ; betting end = _betting end ; inited = BOOL_ ; started ( betting start , teams . length - NUM_ ) ; }", "nl": "set betting start and stop time ."}
{"code": "function start new epoch ( ) public only admin returns ( bool succ ) { require ( frozen == BOOL_ ) ; require ( round == NUM_ ) ; require ( epoch < NUM_ ) ; dec = [ NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ] ; round = NUM_ ; epoch ++ ; epoch_fund = NUM_ * NUM_ * * decimals ; total_fund = total_fund . sub ( epoch_fund ) ; emit epoch ( epoch ) ; return BOOL_ ; }", "nl": "new epoch can be start if : - current round be 9 - curen epoch 10 ."}
{"code": "function reclaim contract tokens ( ) external only owner returns ( bool ) { uint256 tokens = balance of ( address ( this ) ) ; if ( tokens == NUM_ ) { return BOOL_ ; } balances [ address ( this ) ] = balances [ address ( this ) ] . sub ( tokens ) ; balances [ bank address ] = balances [ bank address ] . add ( tokens ) ; transfer ( address ( this ) , bank address , tokens ) ; contract tokens reclaimed ( tokens ) ; return BOOL_ ; }", "nl": "allows owner to transfer tokens assign to the sale contract , back to the bank wallet ."}
{"code": "function lock time ( address _owner ) public constant returns ( uint256 locked value ) { return locked [ _owner ] ; }", "nl": "shl lock time retrieval function ."}
{"code": "function send to beneficiary contract ( ) { if ( beneficiary contract != address ( NUM_ ) ) { beneficiary contract . transfer ( this . balance ) ; } else { revert ( ) ; } }", "nl": "voters agree on propose contract and ethereum be be send to that contract ."}
{"code": "function sell tokens ( ) public payable begin sale active { require ( msg . value > NUM_ ) ; uint256 amount = msg . value ; uint256 tokens = amount . mul ( rate ) ; require ( tokens <= balances [ presale_address ] ) ; if ( sale action == presale action . first presale activity ) { require ( tokens <= cat_first ) ; } _distribute ( msg . sender , tokens , lock cycle , duration ) ; balances [ presale_address ] = balances [ presale_address ] . sub ( tokens ) ; emit transfer ( presale_address , msg . sender , tokens ) ; emit sell tokens ( msg . sender , tokens , rate ) ; forward funds ( ) ; }", "nl": "sell tokens to msg . sender ."}
{"code": "function finalize ( bytes32 _exec_id ) private pure returns ( bytes32 [ NUM_ ] memory ) { return [ final_sel , _exec_id ] ; }", "nl": "returns the topics for a crowdsale finalization event ."}
{"code": "modifier when refund paused { require ( refund paused ) ; _ ; }", "nl": "modifier to allow action only when the refund is pause ."}
{"code": "function transfer tokens ( address [ ] _deposits , address _token contract address ) public only owner non reentrant { for ( uint i = NUM_ ; i < _deposits . length ; i ++ ) { address deposit = _deposits [ i ] ; uint erc20 balance = erc20 ( _token contract address ) . balance of ( deposit ) ; if ( erc20 balance == NUM_ ) { continue ; } uint cold wallet1 share = erc20 balance . mul ( percentage ) . div ( NUM_ ) ; uint cold wallet2 share = erc20 balance . sub ( cold wallet1 share ) ; child deposit ( deposit ) . withdraw ( _token contract address , cold wallet1 share , cold wallet1 ) ; child deposit ( deposit ) . withdraw ( _token contract address , cold wallet2 share , cold wallet2 ) ; } }", "nl": "function that can be call only by owner due to security reason and will withdraw the amount of erc20 tokens ."}
{"code": "function transfer ownership ( address _new owner ) only owner { balances [ _new owner ] = safe add ( balances [ owner ] , balances [ _new owner ] ) ; balances [ owner ] = NUM_ ; ownable . transfer ownership ( _new owner ) ; }", "nl": "to transfer token contract ownership ."}
{"code": "function approve ( token storage storage self , address _spender , uint _amount ) public returns ( bool ) { self . allowed [ msg . sender ] [ _spender ] = _amount ; emit approval ( msg . sender , _spender , _amount ) ; return BOOL_ ; }", "nl": "erc20 compliant approve function ."}
{"code": "function get all the funds ( ) only executive { if ( now < ( event info . get event end ( ) + NUM_ weeks ) ) { throw ; } bool success = msg . sender . send ( this . balance ) ; hacker gold . transfer ( msg . sender , get hkgowned ( ) ) ; }", "nl": "getallthefunds - to ensure there be no deadlock can can happen , and no case that vote structure will freeze the fund forever the startup will be able to get all the fund without a proposal require after 6 months ."}
{"code": "function _create pixel ( uint32 _id , uint8 _colour r , uint8 _colour g , uint8 _colour b , string _pixel text ) private returns ( uint ) { pixels [ _id ] = pixel ( _id , _colour r , _colour g , _colour b , _pixel text ) ; pixel to price [ _id ] = starting price ; emit colour changed ( _id , _colour r , _colour g , _colour b ) ; return _id ; }", "nl": "create a pixel ."}
{"code": "function set transfer address ( string name , address transfer ) public owner_only ( keccak256 ( name ) ) { bytes32 label = keccak256 ( name ) ; domain storage domain = domains [ label ] ; require ( domain . transfer address == NUM_ ) ; domain . transfer address = transfer ; transfer address set ( label , transfer ) ; }", "nl": "sets the transfer address of a domain for after an ens update ."}
{"code": "function send founder and team token ( address to , uint256 value ) public only owner { require ( to != NUM_ && value > NUM_ && distribution supply >= value ) ; balances [ multisig ] = balances [ multisig ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; distribution supply = distribution supply . sub ( value ) ; transfer ( multisig , to , value ) ; }", "nl": "token distribution to founder , key employee allocation _founderandteamcap 10000000e18 ; 10 ."}
{"code": "function set oraclize gas price ( uint gas price ) { require ( msg . sender == owner ) ; require ( gas price >= NUM_ ) ; require ( gas price <= NUM_ ) ; oraclize_set custom gas price ( gas price ) ; }", "nl": "we a owners can ( only ) increase or keep the price in case there be a gas price surge within the range of 30 to 300 gwei ."}
{"code": "function valid sold out ( uint256 sold amount ) internal view returns ( bool ) { return total sold token . add ( sold amount ) > ico total amount ; }", "nl": "true if the ico be in progress ."}
{"code": "function change controller ( address _new controller ) only owner public { token contract . change controller ( _new controller ) ; }", "nl": "onlyowner change the controller of the tokencontract ."}
{"code": "function tokens_buy ( ) payable returns ( bool ) { uint tnow = now ; if ( tnow > ico_finish ) throw ; if ( _total supply >= max tokens ) throw ; if ( ! ( msg . value >= token_price ) ) throw ; if ( ! ( msg . value >= min value ) ) throw ; if ( msg . value > max value ) throw ; uint tokens_buy = msg . value / token_price * NUM_ * * NUM_ ; if ( ! ( tokens_buy > NUM_ ) ) throw ; if ( tnow < ico_start ) { if ( ! ( msg . value >= min value pre ) ) throw ; tokens_buy = tokens_buy * NUM_ / NUM_ ; } if ( ( ico_start + NUM_ * NUM_ <= tnow ) && ( tnow < ico_start + NUM_ * NUM_ ) ) { tokens_buy = tokens_buy * NUM_ / NUM_ ; } if ( ( ico_start + NUM_ * NUM_ <= tnow ) && ( tnow < ico_start + NUM_ * NUM_ ) ) { tokens_buy = tokens_buy * NUM_ / NUM_ ; } if ( ( ico_start + NUM_ * NUM_ <=", "nl": "buy tokens pre-sale and sale ."}
{"code": "function _get value part by percent ( uint _initial value , uint _percent ) internal pure returns ( uint ) { uint one percent value = _initial value / NUM_ ; return one percent value * _percent ; }", "nl": "returns part of number by percent ."}
{"code": "function return other crypto ( address _investor ) external manager only { uint256 tokens = NUM_ ; require ( can iwithdraw ) ; if ( ! is it ico ) { require ( ! return status pre [ _investor ] ) ; tokens = tokens pre ico in other crypto [ _investor ] ; tokens pre ico in other crypto [ _investor ] = NUM_ ; } else { require ( ! return status ico [ _investor ] ) ; tokens = tokens ico in other crypto [ _investor ] ; tokens ico in other crypto [ _investor ] = NUM_ ; sold total = sold total . sub ( tokens no bonus sold [ _investor ] ) ; } lto . burn tokens ( _investor , tokens ) ; emit log return other crypto ( _investor ) ; }", "nl": "burn tokens who pay in other cryptocurrencies ."}
{"code": "function get deal by number ( uint _deal number ) constant public returns ( address buyer , address sender , address agency , uint sum , uint at created , statuses status , uint object type ) { uint deal = deal numbers [ _deal number ] ; return ( deals [ deal ] . buyer , deals [ deal ] . seller , deals [ deal ] . signer , deals [ deal ] . sum , deals [ deal ] . at created , deals [ deal ] . status , deals [ deal ] . object type ) ; }", "nl": "get main data of deal by _dealnumber ."}
{"code": "function donate to whale ( uint256 amount ) internal { whale . call . value ( amount ) ( bytes4 ( keccak256 ( STR_ ) ) ) ; total donated += amount ; emit donate ( amount , whale , msg . sender ) ; }", "nl": "payout eth to whale ."}
{"code": "function withdraw from token ( ierc20 token _token , address _to , uint256 _amount ) public owner only { token . withdraw tokens ( _token , _to , _amount ) ; }", "nl": "withdraw tokens hold by the token and send them to an account can only be call by the owner ."}
{"code": "function find trusted contract ( address _address ) public view returns ( int ) { for ( uint i = NUM_ ; i < trusted contracts . length ; i ++ ) { if ( _address == trusted contracts [ i ] ) { return int ( i ) ; } } return - NUM_ ; }", "nl": "find the trust contract index for an address , or - 1 if not find ."}
{"code": "function freeze ( address _account , uint _total amount ) public only owner { frozen account [ _account ] = BOOL_ ; frozen tokens [ _account ] [ NUM_ ] = _total amount ; }", "nl": "frozen 15 of total supply for team members ."}
{"code": "function get country by id ( uint8 id ) external view returns ( address , uint , uint ) { return ( countries [ id ] . owner , countries [ id ] . id , countries [ id ] . price ) ; }", "nl": "get a country by it id ."}
{"code": "function get all ( ) public constant returns ( address [ ] ) { return whitelist ; }", "nl": "get list ."}
{"code": "modifier only under maintenance ( ) { if ( ! maintenance ) revert ( ) ; _ ; }", "nl": "throws if token be not under maintenance ."}
{"code": "function get stage index ( ) public view returns ( uint8 current stage , bool on sale ) { on sale = BOOL_ ; stage memory p ; for ( current stage = NUM_ ; current stage < stages . length ; current stage ++ ) { p = stages [ current stage ] ; if ( p . start time <= now && now <= p . end time ) { return ; } } on sale = BOOL_ ; }", "nl": "if period be on sale , return index of the period ."}
{"code": "function get balance ico ( ) public constant returns ( uint ) { uint balance ico = ico cap . add ( pre ico cap ) ; balance ico = balance ico . sub ( stat . current fundraiser ) ; return ( balance ico ) ; }", "nl": "returns the current balance of main sale ."}
{"code": "function market register token ( address token ) public payable { require ( token market [ token ] . level == NUM_ ) ; require ( msg . value >= market register cost ) ; balance [ NUM_ ] [ admin ] = add ( balance [ NUM_ ] [ admin ] , msg . value ) ; token market [ token ] . level = NUM_ ; token market [ token ] . fee = market default fee low ; market_change ( token ) ; }", "nl": "register token ."}
{"code": "function refund ( ) public { require ( is refund allowed ) ; address investor = msg . sender ; require ( this . balance > NUM_ ) ; require ( balances [ investor ] > NUM_ ) ; moving = BOOL_ ; uint amount = balances [ investor ] ; balances [ investor ] = NUM_ ; investor . transfer ( amount ) ; refunded ( investor , amount ) ; }", "nl": "allow refund if isrefundallowed be on ."}
{"code": "function set parter ( address _parter , uint256 _amount , uint256 _timestamp ) public only owner { parter acc . push ( _parter ) ; frozen balances [ owner ] = frozen balances [ owner ] . sub ( _amount ) ; frozen balances [ _parter ] = frozen balances [ _parter ] . add ( _amount ) ; freeze record [ _parter ] [ _timestamp ] = freeze record [ _parter ] [ _timestamp ] . add ( _amount ) ; freeze ( _parter , _amount , _timestamp ) ; set parter ( _parter , _amount ) ; }", "nl": "init parter ."}
{"code": "function set period ( uint256 _start time , uint256 _end time ) only owner { require ( now <= _end time ) ; start time = _start time ; end time = _end time ; period changed ( start time , end time ) ; }", "nl": "change presale preiod ."}
{"code": "modifier only reviewer ( ) { check role ( msg . sender , role_reviewer ) ; _ ; }", "nl": "modifier to scope access to reviewer / / revert ."}
{"code": "function mint to other coin buyer ( address _to , uint256 _value , string _note ) only owner public returns ( bool ) { require ( mint ( _to , _value ) ) ; ksc_buy other coin ( _to , msg . sender , _value , _note ) ; return BOOL_ ; }", "nl": "this function be occur when owner mint coin to users a they buy with cryptocurrency other than eth ."}
{"code": "function transferable tokens ( address holder , uint64 time ) constant public returns ( uint256 ) { return balance of ( holder ) ; }", "nl": "default transferable tokens function return all tokens for a holder ( no limit ) ."}
{"code": "function force withdraw ( ) public only owner { withdraw funds ( this . balance ) ; }", "nl": "forcibility withdraw contract eth balance ."}
{"code": "function withdraw ( address _token ) public { uint amount to send = balance per person per token [ _token ] [ msg . sender ] ; balance per person per token [ _token ] [ msg . sender ] = NUM_ ; withdraw ( _token , msg . sender , amount to send ) ; require ( erc20 ( _token ) . transfer ( msg . sender , amount to send ) ) ; }", "nl": "withdraw tokens avaibable ."}
{"code": "function power ( uint256 _base n , uint256 _base d , uint32 _exp n , uint32 _exp d ) internal view returns ( uint256 , uint8 ) { assert ( _base n < max_num ) ; uint256 base log ; uint256 base = _base n * fixed_1 / _base d ; if ( base < opt_log_max_val ) { base log = optimal log ( base ) ; } else { base log = general log ( base ) ; } uint256 base log times exp = base log * _exp n / _exp d ; if ( base log times exp < opt_exp_max_val ) { return ( optimal exp ( base log times exp ) , max_precision ) ; } else { uint8 precision = find position in max exp array ( base log times exp ) ; return ( general exp ( base log times exp > > ( max_precision - precision ) , precision ) , precision ) ; } }", "nl": "general description : ."}
{"code": "function claim refund ( ) { require ( is finalized ) ; require ( ! goal reached ( ) ) ; vault . refund ( msg . sender ) ; }", "nl": "if crowdsale be unsuccessful , contributors can claim refund here ."}
{"code": "function remaining ( ) public view returns ( uint ) { return tok contract . balance of ( this ) ; }", "nl": "function to access remain tokens allocate to this contract ."}
{"code": "function _handle win ( uint256 _winner , uint256 _loser ) internal returns ( uint64 ) { fish storage winner = fishes [ _winner ] ; fish storage loser = fishes [ _loser ] ; uint64 full weight lost = loser . weight / sqrt ( winner . weight ) ; uint64 max weight lost = loser . weight / weight lost part limit ; uint64 weight lost = max weight lost < full weight lost ? max weight lost : full weight lost ; if ( weight lost < NUM_ ) { weight lost = NUM_ ; } winner . weight += weight lost ; loser . weight -= weight lost ; return weight lost ; }", "nl": "handles lose gain weight after fight ."}
{"code": "function set burn rate ( uint256 _burn basis points ) only owner returns ( bool success ) { require ( ( _burn basis points > NUM_ ) && ( _burn basis points <= NUM_ ) ) ; burn basis points = _burn basis points ; return BOOL_ ; }", "nl": "set burnrate on wolk protocol - - only wolk foundation can set this , affect service provider settlebuyer ."}
{"code": "function sqrt ( uint256 x ) internal pure returns ( uint256 y ) { uint256 z = ( x + NUM_ ) / NUM_ ; y = x ; while ( z < y ) { y = z ; z = ( x / z + z ) / NUM_ ; } }", "nl": "this be where all your gas go ."}
{"code": "function register arbiter ( uint _num players , uint _arb token , uint _esc fee pct x10 , uint _arb fee pct x10 , uint _fee cap ) public payable { if ( msg . value != registration fee ) { throw ; } if ( _arb token == NUM_ ) { throw ; } if ( arb token exists ( _arb token & NUM_ ) ) { throw ; } if ( arbiters [ msg . sender ] . registered ) { throw ; } if ( _num players > max_players ) { throw ; } if ( _esc fee pct x10 < NUM_ ) { throw ; } if ( _arb fee pct x10 > NUM_ ) { throw ; } arbiters [ msg . sender ] . locked = BOOL_ ; arbiters [ msg . sender ] . num players = uint8 ( _num players ) ; arbiters [ msg . sender ] . esc fee pct x10 = uint8 ( _esc fee pct x10 ) ; arbiters [ msg . sender ] . arb fee pct x10 = uint8 ( _arb fee pct x10 ) ; arbiters [ msg . sender ] . arb token =", "nl": "register game arbiter , max players of 5 , pass in exact registration fee ."}
{"code": "function approve user kyc ( address _user ) only kyc manager public { supporter storage sup = supporters map [ _user ] ; sup . has kyc = BOOL_ ; kyc ( _user , BOOL_ ) ; }", "nl": "approves an user 's kyc ."}
{"code": "function transfer pre sale tokens ( address _to , uint256 _amount ) public only owner { require ( pre sale supply >= _amount ) ; balances [ owner ] -= _amount ; balances [ _to ] += _amount ; pre sale supply -= _amount ; total tokens remind -= _amount ; }", "nl": "transfer tokens to pre sale partner ( 5 ) ."}
{"code": "function get price ( ) constant returns ( uint256 price ) { for ( var i = NUM_ ; i < deadlines . length ; i ++ ) if ( now < deadlines [ i ] ) return prices [ i ] ; return prices [ prices . length - NUM_ ] ; }", "nl": "look up the current token price ."}
{"code": "function init ( uint _periods , uint _t0special ) only owner not initialized { require ( _periods != NUM_ ) ; periods = _periods ; t0special = _t0special ; }", "nl": "initialization function , should be call after contract deployment ."}
{"code": "function update global max ( uint256 _global max ) public not finalized only owner { require ( _global max > global min ) ; global max = _global max ; }", "nl": "update the global max contribution ."}
{"code": "function set fee authority ( address _fee authority ) public optional proxy_only owner { fee authority = _fee authority ; emit fee authority updated ( _fee authority ) ; }", "nl": "set the address of the user / contract responsible for collect or distribute fee ."}
{"code": "function claim ( uint _amount ) public { require ( _amount > NUM_ ) ; update points ( msg . sender ) ; uint claiming points = _amount . mul ( point multiplier ) ; require ( accounts [ msg . sender ] . claimed points . add ( claiming points ) <= accounts [ msg . sender ] . allowed points ) ; accounts [ msg . sender ] . claimed points = accounts [ msg . sender ] . claimed points . add ( claiming points ) ; claim disbursement ( msg . sender , _amount ) ; require ( msg . sender . send ( _amount ) ) ; }", "nl": "function to claim the wei that a token owner be entitle to ."}
{"code": "function tokens of owner by index ( address _owner , uint256 _index ) external view returns ( uint256 token id ) { uint256 count = NUM_ ; for ( uint256 i = NUM_ ; i <= total supply ( ) ; i ++ ) { if ( fighter index to owner [ i ] == _owner ) { if ( count == _index ) { return i ; } else { count ++ ; } } } revert ( ) ; }", "nl": "returns the nth fighter assign to an address , with n specify by the _index argument ."}
{"code": "function new ens ( address _owner ) public returns ( ens ens ) { ens = new ens ( ) ; ens . set subnode owner ( ens_root , eth_tld_label , this ) ; public resolver resolver = new public resolver ( ens ) ; ens . set subnode owner ( eth_tld_node , public_resolver_label , this ) ; ens . set resolver ( public_resolver_node , resolver ) ; resolver . set addr ( public_resolver_node , resolver ) ; ens . set owner ( eth_tld_node , _owner ) ; ens . set owner ( ens_root , _owner ) ; deploy ens ( ens ) ; }", "nl": "this be an incredibly trustfull ens deployment , only use for test ."}
{"code": "function total supply ( ) constant returns ( uint256 total supply ) { total supply = total mit ; }", "nl": "implements erc20 totalsupply ( ) ."}
{"code": "function effective max bet ( ) public view returns ( uint _amount ) { uint _cur max = cur max bet ( ) ; return _cur max > settings . max bet ? settings . max bet : _cur max ; }", "nl": "return the less of settings . maxbet ."}
{"code": "function total supply ( ) external view returns ( uint256 ) { return tokens . length ; }", "nl": "returns the count of all exist nftokens ."}
{"code": "function get_contract ( bytes32 _key ) public constant returns ( address _contract ) { _contract = contract resolver ( resolver ) . get_contract ( _key ) ; }", "nl": "get the address of a contract ."}
{"code": "function set min balance ( uint minimum balance in finney ) only owner public { min balance for accounts = minimum balance in finney * NUM_ finney ; }", "nl": "set minimum balance to make the transaction successfull ."}
{"code": "function icoopen ( ) constant returns ( bool ) { if ( ! funding ) return BOOL_ ; else if ( block . timestamp < funding start ) return BOOL_ ; else if ( block . timestamp > funding end ) return BOOL_ ; else if ( token creation cap <= total tokens ) return BOOL_ ; else return BOOL_ ; }", "nl": "return if the crowd sale be still open ."}
{"code": "function get vested balance ( uint256 _initial balance , uint256 _current balance , uint256 _vesting start time , uint256 _current time ) public constant returns ( uint256 ) { if ( _current time < _vesting start time ) { return NUM_ ; } if ( _current time >= _vesting start time . add ( vesting period time . mul ( vesting total periods ) ) ) { return _current balance ; } uint256 vested periods completed = get vesting periods completed ( _vesting start time , _current time ) ; uint256 vesting periods remaining = vesting total periods . sub ( vested periods completed ) ; uint256 unvested balance = _initial balance . mul ( vesting periods remaining ) . div ( vesting total periods ) ; return _current balance . sub ( unvested balance ) ; }", "nl": "gets the vested balance for an account ."}
{"code": "function is transfer allowed ( address _from , address _to ) private view returns ( bool ) { if ( finalized ) { return BOOL_ ; } if ( _from == bank address || _to == bank address ) { return BOOL_ ; } return BOOL_ ; }", "nl": "internal helper to check if the transfer should be allow ."}
{"code": "function proxy assert ( address dest , how to call how to call , bytes calldata ) public { require ( proxy ( dest , how to call , calldata ) ) ; }", "nl": "same functionality a proxy , just assert the return value ."}
{"code": "function refund transaction ( bool _state changed ) internal { if ( _state changed ) { msg . sender . transfer ( msg . value ) ; } else { revert ( ) ; } }", "nl": "it be necessary for a correct change of status in the event of completion of the campaign ."}
{"code": "function get transferable ( bytes20 blob id ) external constant exists ( blob id ) returns ( bool transferable ) { transferable = blob info [ blob id ] . flags & transferable != NUM_ ; }", "nl": "determine if a blob be transferable ."}
{"code": "function burn tokens ( address _from , uint _value ) only ico contract { assert ( _from != NUM_ ) ; require ( _value > NUM_ ) ; balances [ _from ] = sub ( balances [ _from ] , _value ) ; total supply = sub ( total supply , _value ) ; }", "nl": "burns tokens from address ."}
{"code": "function get event end ( ) constant returns ( uint result ) { return event end ; }", "nl": "geteventend - return the end of the event time ."}
{"code": "function seed sale token left ( address _token contract ) public only owner { require ( seed ended ( ) ) ; uint256 amount left = pending uft . sub ( conclude uft ) ; token . transfer from vault ( token , _token contract , amount left ) ; }", "nl": "if tokens leave make a priveledge token sale for contributor that be already validate make a new date time for leave tokens only for priveledge whitelisted ."}
{"code": "function update availability ( uint256 _bet_amount ) { if ( msg . sender != seller ) throw ; total_bet_available += _bet_amount ; }", "nl": "update available bet to purchase ."}
{"code": "function transfer locked from ( address _from , address _to , uint256 [ ] _time , uint256 [ ] _value ) public valid address ( _from ) valid address ( _to ) returns ( bool success ) { require ( locker [ msg . sender ] ) ; require ( _value . length == _time . length ) ; if ( lock num [ _from ] > NUM_ ) calc unlock ( _from ) ; uint256 i = NUM_ ; uint256 total value = NUM_ ; while ( i < _value . length ) { total value = add ( total value , _value [ i ] ) ; i ++ ; } if ( balance p [ _from ] >= total value && total value > NUM_ ) { i = NUM_ ; while ( i < _time . length ) { balance p [ _from ] = sub ( balance p [ _from ] , _value [ i ] ) ; lock time [ _to ] . length = lock num [ _to ] + NUM_ ; lock value [ _to ] . length = lock num [ _to ] + NUM_ ; lock time [ _to ]", "nl": "custom timelocker method ."}
{"code": "function get purchase amount ( address _buyer , uint256 _amount ) private view returns ( uint256 , uint256 ) { uint256 d1 = maxcap . sub ( wei raised ) ; uint256 d2 = exceed . sub ( buyers [ _buyer ] ) ; uint256 d = ( d1 > d2 ) ? d2 : d1 ; return ( _amount > d ) ? ( d , _amount . sub ( d ) ) : ( _amount , NUM_ ) ; }", "nl": "util function for collect ."}
{"code": "function _get token amount ( uint256 _wei amount , uint8 _stage index ) internal view returns ( uint256 ) { uint256 _bonus = NUM_ ; uint256 _cap ; if ( _stage index == NUM_ ) { _bonus = round1 bonus ; _cap = round1 cap . sub ( round1 sold ) ; } else if ( _stage index == NUM_ ) { _cap = round2 cap . sub ( round1 sold ) ; } else if ( _stage index == NUM_ ) { _bonus = round2 bonus ; _cap = round1 cap . sub ( round1 sold ) . add ( round2 cap ) . sub ( round2 sold ) ; } else if ( _stage index == NUM_ ) { _cap = round1 cap . sub ( round1 sold ) . add ( round2 cap ) . sub ( round2 sold ) ; } else if ( _stage index == NUM_ ) { _bonus = round3 bonus ; _cap = round1 cap . sub ( round1 sold ) . add ( round2 cap ) . sub ( round2 sold ) . add ( round3 cap ) . sub ( round3 sold ) ; } else if ( _stage index", "nl": "override to extend the way in which ether be convert to tokens ."}
{"code": "function get claimable ( ) public constant returns ( uint256 ) { return total committed ; }", "nl": "to check total remain claimable amount ."}
{"code": "function refund ( ) returns ( bool ) { if ( minting finished == BOOL_ && goal reached == BOOL_ && already minted once == BOOL_ ) { balances [ msg . sender ] = NUM_ ; total supply = total supply . sub ( balances [ msg . sender ] ) ; uint value of investment = buy transactions [ msg . sender ] ; msg . sender . transfer ( value of investment ) ; return BOOL_ ; } return BOOL_ ; }", "nl": "function refund contributors if ico be unsuccesful ."}
{"code": "function get rate ( uint256 wei amount ) public pure returns ( uint256 ) { if ( wei amount >= pre_sale_3000_eth ) { return token_rate_40_percent_bonus ; } else if ( wei amount >= pre_sale_300_eth ) { return token_rate_30_percent_bonus ; } else if ( wei amount >= pre_sale_30_eth ) { return token_rate_25_percent_bonus ; } else { return NUM_ ; } }", "nl": "return the rate the user will be pay at , base on the amount of wei send to the contract ."}
{"code": "function set deadline ( uint256 _deadline ) only admin when paused public returns ( bool ) { require ( start < _deadline ) ; deadline = _deadline ; emit new deadline ( _deadline ) ; return BOOL_ ; }", "nl": "set new start date for crowdsale ."}
{"code": "function initial transfer ( address _to , uint _value ) external only owner returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "nl": "this method will be use by the crowdsale smart contract that own the acjtoken and will distribute the tokens to the contributors ."}
{"code": "function create tokens from ether ( ) private { assert ( msg . value >= NUM_ ether / NUM_ ) ; uint256 tokens = current rate . mul ( msg . value ) . div ( NUM_ ether ) ; transfer from owner ( msg . sender , tokens , NUM_ ) ; if ( sale status == NUM_ ) { bought with ether [ msg . sender ] = bought with ether [ msg . sender ] . add ( tokens ) ; tokens from ether = tokens from ether . add ( tokens ) ; } }", "nl": "converts ether to our tokens ."}
{"code": "function start round d ( ) external manager only { require ( status ico == status ico . round cfinished || status ico == status ico . round dpaused ) ; status ico = status ico . round dstarted ; log start round d ( ) ; }", "nl": "start round d ."}
{"code": "function trade ( erc20 src , bancor contract bancor trading contract , address [ ] _path , uint256 _amount , uint256 _min return ) { src . approve ( bancor trading contract , _amount ) ; uint256 dest amount = bancor trading contract . quick convert ( _path , _amount , _min return ) ; trade ( _amount , dest amount ) ; }", "nl": "bancorcontract public bancortradingcontract bancorcontract ( 0x8fff721412503c85cffef6982f2b39339481bca9 ) ; ."}
{"code": "modifier only master { require ( msg . sender == beercoin master ) ; _ ; }", "nl": "restrict to the master only ."}
{"code": "function results_of_the_last_round ( ) constant returns ( uint players_bet_in_wei , string last_result , string last_player_s_lottery_ticket , address last_player , string the_right_lottery_number , int player_s_gain_or_loss_in_wei , string info ) { last_player = player ; last_player_s_lottery_ticket = a ; the_right_lottery_number = b ; last_result = lastresult ; players_bet_in_wei = wager ; player_s_gain_or_loss_in_wei = lastgainloss ; info = information ; }", "nl": "function below give information about the game in ethereum wallet ."}
{"code": "modifier is burner ( address _burner ) { require ( allowed burners [ _burner ] ) ; _ ; }", "nl": "check whether the burner be eligible burner ."}
{"code": "function register contract ( address _addr , bytes32 _id , bool _is controlled ) public only owner returns ( bool _result ) { set contract ( _addr , _id , _is controlled ) ; contract ids . push ( _id ) ; _result = BOOL_ ; }", "nl": "bool success ."}
{"code": "function get affiliate rate ( uint256 _level ) public constant returns ( uint256 rate ) { return affiliate rate [ _level ] ; }", "nl": "get affiliate rate by level ."}
{"code": "function should choose winner ( ) internal returns ( bool ) { return get total tickets ( ) >= draw ticket count ; }", "nl": "true if it be appropriate to choose the winner , false otherwise ."}
{"code": "function get abilities for collectible id ( uint256 _token id ) external view returns ( uint256 ability ) { nft memory obj = _get attributes of token ( _token id ) ; uint256 _attributes = uint256 ( obj . attributes ) ; ability = ( _attributes % NUM_ ) ; }", "nl": "returns the ability of an asset / collectible / token from attribute ."}
{"code": "function set maximum rate ( uint256 _new rate ) only owner public { require ( _new rate <= hard coded maximum rate ) ; maximum rate = _new rate ; rate changed ( NUM_ , _new rate ) ; }", "nl": "set the maximum rate for any affiliate ."}
{"code": "function break tie ( uint team ) { require ( result == NUM_ ) ; require ( msg . sender == owner ) ; result = team ; withdrawal open = BOOL_ ; }", "nl": "trigger only if tie in the final ballot ."}
{"code": "function clear delegate and unlock tokens ( ) public only delegated not self returns ( uint locked tokens ) { address delegate = delegates by delegator [ msg . sender ] ; locked tokens = locked delegating tokens [ msg . sender ] ; locked delegating tokens [ msg . sender ] = NUM_ ; delegated amounts by delegate [ delegate ] = safe math . sub ( delegated amounts by delegate [ delegate ] , locked tokens ) ; total locked tokens = safe math . sub ( total locked tokens , locked tokens ) ; delete delegates by delegator [ msg . sender ] ; require ( token locker . transfer ( msg . sender , locked tokens ) ) ; require ( shares token address . balance of ( token locker ) == total locked tokens ) ; tokens undelegated ( msg . sender , locked tokens , delegate ) ; return locked tokens ; }", "nl": "clear the delegate address for all tokens delegate by the send address , unlock the locked tokens ."}
{"code": "function set mat ( uint ray ) public note auth { tub . mold ( STR_ , ray ) ; var axe = tub . axe ( ) ; var mat = tub . mat ( ) ; require ( axe >= ray && axe <= mat ) ; }", "nl": "liquidation ratio ."}
{"code": "function get all buyers ( ) public constant returns ( address [ ] ) { return buyers ; }", "nl": "get all buyer ."}
{"code": "function transfer ( address _to , uint256 _value ) { if ( _to == NUM_ ) revert ( ) ; if ( balance of [ msg . sender ] < _value ) revert ( ) ; if ( balance of [ _to ] + _value < balance of [ _to ] ) revert ( ) ; if ( msg . sender == etherflip contract ) { raffle address [ number in raffle ] = _to ; number in raffle += NUM_ ; balance of [ msg . sender ] -= NUM_ ; balance of [ _to ] += NUM_ ; transfer ( msg . sender , _to , NUM_ ) ; } else { balance of [ msg . sender ] -= _value ; balance of [ _to ] += _value ; transfer ( msg . sender , _to , _value ) ; } }", "nl": "methods base on token . sol ."}
{"code": "function release vested tokens ( address _adr ) public { vesting schedule storage vesting schedule = vesting map [ _adr ] ; uint256 _total tokens = safe add ( vesting schedule . principle lock amount , vesting schedule . bonus lock amount ) ; require ( safe sub ( _total tokens , vesting schedule . amount released ) > NUM_ ) ; uint256 amount to release = NUM_ ; if ( block . timestamp >= vesting schedule . principle lock period && ! vesting schedule . is principle released ) { amount to release = safe add ( amount to release , vesting schedule . principle lock amount ) ; vesting schedule . amount released = safe add ( vesting schedule . amount released , amount to release ) ; vesting schedule . is principle released = BOOL_ ; } if ( block . timestamp >= vesting schedule . bonus lock period && ! vesting schedule . is bonus released ) { amount to release = safe add ( amount to release , vesting schedule . bonus lock amount ) ; vesting schedule . amount released = safe add ( vesting schedule . amount released , amount to release )", "nl": "release tokens a per vest schedule , call by anyone ."}
{"code": "function check identity ( bytes32 _biometric data ) public returns ( bool ) { if ( identities [ msg . sender ] . biometric data == _biometric data ) { emit unlock event ( msg . sender , identities [ msg . sender ] . name , identities [ msg . sender ] . surname , now , BOOL_ ) ; return BOOL_ ; } else { emit unlock event ( msg . sender , identities [ msg . sender ] . name , identities [ msg . sender ] . surname , now , BOOL_ ) ; return BOOL_ ; } }", "nl": "params : bytes32 ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool success ) { if ( shareholders [ _to ] . allowed && shareholders [ msg . sender ] . allowed && balances [ msg . sender ] >= _value && _value > NUM_ ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } else { return BOOL_ ; } }", "nl": "trasfer tokens from one address to another ."}
{"code": "function refund ( address _investor ) only icocontract public returns ( bool ) { if ( state != state . refunding ) { error ( STR_ ) ; return BOOL_ ; } if ( deposited [ _investor ] == NUM_ ) { error ( STR_ ) ; return BOOL_ ; } uint256 deposited value = deposited [ _investor ] ; deposited [ _investor ] = NUM_ ; tokens acquired [ _investor ] = NUM_ ; _investor . transfer ( deposited value ) ; emit refunded ( _investor , deposited value ) ; return BOOL_ ; }", "nl": "ico smart contract can call this function for the investor to refund ."}
{"code": "function withdraw tokens ( ) public only first buyer { first buyer storage buyer = first buyers [ msg . sender ] ; require ( num of transaction >= buyer . last transaction index ) ; uint256 iterate over = num of transaction . sub ( buyer . last transaction index ) ; if ( iterate over > NUM_ ) { iterate over = NUM_ ; } uint256 iterate = buyer . last transaction index . add ( iterate over ) ; uint256 amount = NUM_ ; for ( uint256 i = buyer . last transaction index ; i < iterate ; i ++ ) { uint256 ratio = ( ( buyer . weighted contribution . mul ( NUM_ * * NUM_ ) ) . div ( total weighted contribution ) ) ; amount = amount . add ( ( transactions [ buyer . last transaction index ] . mul ( ratio ) ) . div ( NUM_ * * NUM_ ) ) ; buyer . last transaction index = buyer . last transaction index . add ( NUM_ ) ; } assert ( property . no fee transfer ( msg . sender , amount ) ) ; emit first", "nl": "allow first buyers to collect fee from transactions ."}
{"code": "function destroy ( uint256 _value ) only owner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; destroy ( msg . sender , NUM_ , _value ) ; }", "nl": "destroys tokens , this process be irrecoverable ."}
{"code": "function clawback ( ) external { if ( msg . sender != curator ) throw ; if ( ! curator . send ( this . balance ) ) throw ; }", "nl": "return fund back to the curator ."}
{"code": "function reject eth transaction request ( ) public only authorised addresses { latest eth tx request = eth transaction request ( NUM_ , NUM_ , NUM_ ) ; eth transaction rejected ( msg . sender ) ; }", "nl": "rejects eth transaction request and erase all data associate with the request ."}
{"code": "function unlock address ( address target ) public is owner { locked status address [ target ] = BOOL_ ; emit unlocked ( target ) ; }", "nl": "allows token issuer to unlock token transfer for an address ."}
{"code": "modifier sale was successfull ( address _token ) { require ( issue map [ _token ] . cln raised >= issue map [ _token ] . reserve ) ; _ ; }", "nl": "sale consider successful when it raise equal to or more than the softcap ."}
{"code": "function trade in ( address smelly old token , uint amount ) public returns ( bool ) { erc20 with decimals old token = erc20 with decimals ( smelly old token ) ; old token . safe transfer from ( msg . sender , owner , amount ) ; uint pnb count = amount * ( uint ( NUM_ ) * * decimals ) / ( uint ( NUM_ ) * * old token . decimals ( ) ) ; require ( total supply . add ( pnb count ) < max total supply ) ; total supply = total supply . add ( pnb count ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( pnb count ) ; transfer ( NUM_ , msg . sender , pnb count ) ; return BOOL_ ; }", "nl": "upgrade your tokens to the new , penis token , black edition ."}
{"code": "function rollover fee ( address account , uint last transfer time , uint pre balance ) internal { if ( last transfer time < fee period start time ) { if ( last transfer time < last fee period start time ) { if ( last transfer time < penultimate fee period start time ) { penultimate average balance [ account ] = pre balance ; } else { penultimate average balance [ account ] = safe div ( safe add ( current balance sum [ account ] , safe mul ( pre balance , ( last fee period start time - last transfer time ) ) ) , ( last fee period start time - penultimate fee period start time ) ) ; } last average balance [ account ] = pre balance ; } else { penultimate average balance [ account ] = last average balance [ account ] ; last average balance [ account ] = safe div ( safe add ( current balance sum [ account ] , safe mul ( pre balance , ( fee period start time - last transfer time ) ) ) , ( fee period start time - last fee period", "nl": "update the give account 's previous period fee entitlement value ."}
{"code": "function unlock ( ) public constant returns ( bool success ) { uint256 amount = locked balance [ msg . sender ] ; require ( amount > NUM_ ) ; require ( now >= time release [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( amount ) ; locked balance [ msg . sender ] = NUM_ ; time release [ msg . sender ] = NUM_ ; transfer ( NUM_ , msg . sender , amount ) ; un lock ( msg . sender , amount ) ; return BOOL_ ; }", "nl": "transfers tokens hold by lock ."}
{"code": "function set enable buy and sell ( bool is enabled ) only owner public { is enable buy sell = is enabled ; }", "nl": "set enable ."}
{"code": "function extra mint ( ) only owner public returns ( bool ) { assert ( token . extra mint ( ) ) ; extra mint ( ) ; }", "nl": "minting extra ( team and community ) tokens ."}
{"code": "function new event ( uint _game id , address [ ] _winners , uint _winning number , uint _amount ) public only linked { require ( _game id > NUM_ ) ; events . push ( event ( events . length , _game id , msg . sender , _winners , _winning number , _amount , now ) ) ; }", "nl": "add a new event ."}
{"code": "function decrease approval pre signed ( bytes _signature , address _to , uint256 _value , uint256 _gas price , uint256 _nonce ) public valid payload ( NUM_ ) returns ( bool ) { uint256 gas = gasleft ( ) ; address from = recover pre signed ( _signature , decrease approval sig , _to , _value , STR_ , _gas price , _nonce ) ; require ( from != address ( NUM_ ) ) ; require ( ! invalid signatures [ from ] [ _signature ] ) ; invalid signatures [ from ] [ _signature ] = BOOL_ ; nonces [ from ] ++ ; require ( _decrease approval ( from , _to , _value ) ) ; if ( _gas price > NUM_ ) { gas = NUM_ + gas . sub ( gasleft ( ) ) ; require ( _transfer ( from , msg . sender , _gas price . mul ( gas ) ) ) ; } emit signature redeemed ( _signature , from ) ; return BOOL_ ; }", "nl": "added for the same reason a increaseapproval ."}
{"code": "function owner set casino ( address new casino ) public only owner { casino = new casino ; }", "nl": "only owner address can set casino address ."}
{"code": "function pay bonus ( ) public only owner returns ( bool success ) { uint256 to index = index paid bonus + NUM_ ; if ( bonus account count < to index ) to index = bonus account count ; for ( uint256 i = index paid bonus ; i < to index ; i ++ ) { if ( bonus account balances [ bonus account index [ i ] ] > NUM_ ) pay bonus1 address ( bonus account index [ i ] ) ; } return BOOL_ ; }", "nl": "pay bonus to address ."}
{"code": "function set advisory pool ( address _advisory pool ) only creator { advisory pool = _advisory pool ; }", "nl": "set up advisory pool ."}
{"code": "function get bet amount ( uint8 team index ) view public returns ( uint ) { return teams [ team index ] . bettor amount [ msg . sender ] ; }", "nl": "get total bet amount for address for team ."}
{"code": "function get version selectors ( bytes32 _app , bytes32 _version , bytes32 _registry_id ) internal view returns ( bytes4 [ ] memory sels ) { uint length = uint ( registry read ( version selectors ( _app , _version ) , _registry_id ) ) ; sels = new bytes4 [ ] ( length ) ; for ( uint i = NUM_ ; i < length ; i ++ ) { bytes32 location = bytes32 ( NUM_ * ( i + NUM_ ) + uint ( version selectors ( _app , _version ) ) ) ; sels [ i ] = bytes4 ( registry read ( location , _registry_id ) ) ; } }", "nl": "sels : a bytes4 array contain all of this version 's function selectors ."}
{"code": "function withdraw talao ( uint256 tokens ) public only owner { require ( balance of ( this ) . sub ( total deposit ) >= tokens , STR_ ) ; _transfer ( this , msg . sender , tokens ) ; }", "nl": "allow the owner to withdraw tokens from the contract without take tokens from deposit ."}
{"code": "function is transaction already settled ( address _from , bytes32 _calc hash ) public view returns ( bool ) { return executed settlements [ _from ] [ _calc hash ] ; }", "nl": "allows you to check whether a certain transaction have be already settle or not ."}
{"code": "function owner of ( uint256 _token id ) external view returns ( address owner ) { owner = panda index to owner [ _token id ] ; require ( owner != address ( NUM_ ) ) ; }", "nl": "returns the address currently assign ownership of a give panda ."}
{"code": "function enable token sale ( ) external only owner { token sale enabled = BOOL_ ; }", "nl": "allow the owner to enable or disable the token sale at any time ."}
{"code": "function updated at ( uint _id ) constant returns ( uint ) { return tokens [ _id ] . block ; }", "nl": "return block when price be update last ."}
{"code": "function has confirmed ( bytes32 _operation , address _owner ) external constant multi owned operation is active ( _operation ) owner exists ( _owner ) returns ( bool ) { return ! ( m_multi owned pending [ _operation ] . owners done & make owner bitmap bit ( _owner ) == NUM_ ) ; }", "nl": "checks if owner confirm give operation ."}
{"code": "function trusted withdraw eth ( address _to , uint256 _amount ) external only bonding manager or jobs manager when system not paused { _to . transfer ( _amount ) ; }", "nl": "withdraw eth to a recipient ."}
{"code": "function get ico info ( ) public view returns ( bool , uint256 , uint256 , uint256 , uint256 , uint256 ) { return ( balances [ ico owner ] > NUM_ , wei exchange rate , cents exchange rate , bonus20 end timestamp , bonus10 end timestamp , bonus5 end timestamp ) ; }", "nl": "returns ico-related state information for use by api ."}
{"code": "function safe guard ( bytes20 _origin address hash , uint256 _release time , uint16 _privacy commission ) external payable only payload size ( NUM_ * NUM_ ) returns ( bool ) { require ( msg . value >= NUM_ finney ) ; require ( senders [ _origin address hash ] == no_address || balances [ _origin address hash ] > NUM_ ) ; if ( senders [ _origin address hash ] == no_address ) { senders [ _origin address hash ] = msg . sender ; if ( _release time > now ) { timers [ _origin address hash ] = _release time ; } else { timers [ _origin address hash ] = now ; } if ( _privacy commission > NUM_ && _privacy commission <= NUM_ ) { privacy deviation [ _origin address hash ] = _privacy commission ; } } uint256 _commission = msg . value . div ( NUM_ ) ; uint256 _balance after commission = msg . value . sub ( _commission ) ; balances [ _origin address hash ] = balances [ _origin address hash ] . add ( _balance after commission ) ; user balance = user balance . add ( _balance after", "nl": "safeguard a value in wei ."}
{"code": "function withdraw tokens for ( address _account to withdraw for ) public only owner { uint256 amount = balances [ _account to withdraw for ] ; require ( amount > NUM_ ) ; balances [ _account to withdraw for ] = NUM_ ; _deliver tokens ( _account to withdraw for , amount ) ; }", "nl": "withdraw tokens or other users ."}
{"code": "function get withdrawable amount fiit ( address _investor ) public view returns ( uint256 ) { require ( start withdraw != NUM_ ) ; uint interval = safe div ( safe sub ( now , start withdraw ) , NUM_ days ) ; uint _allocated tokens = safe add ( wallet founding initiator sales [ _investor ] , released founding initiator sales [ _investor ] ) ; if ( interval < NUM_ ) { return ( NUM_ ) ; } else if ( interval >= NUM_ ) { return safe sub ( _allocated tokens , released founding initiator sales [ _investor ] ) ; } }", "nl": "for wallet founding investor and initiator team ."}
{"code": "function calc max withdraw ( ) public constant returns ( uint256 ) { uint256 max tokens = NUM_ ; disbursement [ ] storage temp = disbursements [ msg . sender ] ; for ( uint256 i = NUM_ ; i < temp . length ; i ++ ) { if ( block . timestamp > temp [ i ] . timestamp ) { max tokens = safe math . add ( max tokens , temp [ i ] . tokens ) ; } } max tokens = safe math . sub ( max tokens , withdrawn tokens [ msg . sender ] ) ; return max tokens ; }", "nl": "calculates the maximum amount of vested tokens ."}
{"code": "modifier when not paused ( ) { require ( ! paused || msg . sender == ico address || msg . sender == founder address ) ; _ ; }", "nl": "modifier to allow action only when the contract is pause or if the owner or ico contract be invoke the action ."}
{"code": "function get server ( uint server index ) public view server exists ( server index ) returns ( string , uint , uint , bool , bool ) { server storage server = servers [ server index ] ; return ( server . name , server . pot , server . ante , server . online , server . game active ) ; }", "nl": "get server at index ."}
{"code": "function set presale phase ( phase _next phase ) public only escrow { bool can switch phase = ( current phase == phase . created && _next phase == phase . running ) || ( current phase == phase . running && _next phase == phase . paused ) || ( ( current phase == phase . running || current phase == phase . paused ) && _next phase == phase . migrating && crowdsale manager != NUM_ ) || ( current phase == phase . paused && _next phase == phase . running ) || ( current phase == phase . migrating && _next phase == phase . migrated && total supply == NUM_ ) ; require ( can switch phase ) ; current phase = _next phase ; emit log phase switch ( _next phase ) ; }", "nl": "administrative function ."}
{"code": "function distribute internal ( uint256 _r id , uint256 _p id , uint256 _eth , uint256 _team , uint256 _keys , j3 ddatasets . event returns memory _event data_ ) private returns ( j3 ddatasets . event returns ) { uint256 _gen = ( _eth . mul ( fees_ [ _team ] . gen ) ) / NUM_ ; uint256 _jan = ( _eth . mul ( fees_ [ _team ] . jan ) ) / NUM_ ; jan pot_ = jan pot_ . add ( _jan ) ; _eth = _eth . sub ( ( _eth . mul ( fees_ [ _team ] . com + fees_ [ _team ] . aff + fees_ [ _team ] . jan ) ) / NUM_ ) ; uint256 _pot = _eth . sub ( _gen ) ; uint256 _dust = update masks ( _r id , _p id , _gen , _keys ) ; if ( _dust > NUM_ ) _gen = _gen . sub ( _dust ) ; round_ [ _r id ] . pot = _pot . add ( _dust ) . add ( round_ [ _r id ] . pot ) ; _event data_ . gen amount =", "nl": "distribute eth base on fee to gen and pot fees_ 0 j3ddatasets . teamfee ( 50 , 0 ) ; ."}
{"code": "function is payed ( uint _player index ) public constant returns ( bool ) { address player address ; uint ticket amount ; uint dream amount ; ( player address , ticket amount , dream amount ) = ticket holder . get tickets ( _player index ) ; require ( player address != NUM_ ) ; return fund . is payed ( player address ) ; }", "nl": "if fund already pay to the specify player by index ."}
{"code": "function transfer ( address _to , uint256 _value ) returns ( bool success ) { require ( ! frozen account [ msg . sender ] ) ; if ( frozen ) return BOOL_ ; else return abstract token . transfer ( _to , _value ) ; }", "nl": "true if tokens be transfer successfully , false otherwise ."}
{"code": "function set beneficiary ( address _beneficiary ) public owner only { beneficiary = _beneficiary ; }", "nl": "sets new beneficiary , can be call only by the owner ."}
{"code": "function withdraw mils ( uint256 _mils ) public post end funded { uint256 days since end = ( now - lock up end ) / NUM_ days ; uint256 max pct = min ( ( ( days since end / NUM_ + NUM_ ) * NUM_ ) , NUM_ ) ; uint256 allowed = award [ msg . sender ] ; allowed = allowed * max pct / NUM_ ; allowed -= withdrawn [ msg . sender ] ; require ( _mils <= allowed ) ; military token . transfer ( msg . sender , _mils ) ; withdrawn [ msg . sender ] += _mils ; current awards -= _mils ; }", "nl": "transfers award mils to the caller 's account ."}
{"code": "function set paused ( bool _paused ) public only owner { paused = _paused ; }", "nl": "allows owner to pause the contract ."}
{"code": "function create jaro sleep ( address _token , uint256 _daily time ) internal returns ( jaro sleep ) { return new jaro sleep ( _token , _daily time ) ; }", "nl": "this function create for easy test purpose ."}
{"code": "function disable manager ( address _manager ) external only owner only valid manager address ( _manager ) { require ( manager enabled [ _manager ] == BOOL_ ) ; manager enabled [ _manager ] = BOOL_ ; manager disabled event ( _manager ) ; }", "nl": "function to remove existing manager ."}
{"code": "function salvage tokens ( erc20 basic _token , address _to ) only owner public { _token . transfer ( _to , _token . balance of ( this ) ) ; }", "nl": "owner can transfer back tokens which have be send to this contract by mistake ."}
{"code": "function sender admin and sale not final ( ) internal view { if ( contract . sender ( ) != address ( contract . read ( admin ( ) ) ) ) revert ( STR_ ) ; if ( contract . read ( is configured ( ) ) == NUM_ || contract . read ( is finished ( ) ) != NUM_ ) revert ( STR_ ) ; }", "nl": "ensures the sender be the admin , the sale be initialize , and the sale be not finalize ."}
{"code": "function started ( ) public view returns ( bool ) { if ( ( uint8 ( current stage ) >= NUM_ || now >= start time && now <= end time ) && uint8 ( current stage ) != NUM_ ) return BOOL_ ; return BOOL_ ; }", "nl": "return start state false if the crowdsale be not start , true if the crowdsale be start and run , true if the crowdsale be complete ."}
{"code": "function get weekly rate ( ) private returns ( uint32 ) { if ( now <= weekly rate [ week no ] . end time && now >= weekly rate [ week no ] . start time ) { return weekly rate [ week no ] . week rate ; } if ( now <= weekly rate [ week no + NUM_ ] . end time && now >= weekly rate [ week no + NUM_ ] . start time ) { week no = week no + NUM_ ; set weekly allocation ( ) ; return weekly rate [ week no + NUM_ ] . week rate ; } else { uint256 increased by = now - start date ; uint256 week increased by = increased by . div ( NUM_ ) ; set weekly allocation ( ) ; week no = week no . add ( week increased by ) ; log week rate ( weekly rate [ week no ] . week rate , now ) ; return weekly rate [ week no ] . week rate ; } }", "nl": "private function to get the weekly rate a per the week no ."}
{"code": "function distribute icotokens ( address _buyer , uint tokens ) external only crowdsale when not paused { require ( _buyer != address ( NUM_ ) ) ; require ( tokens > NUM_ ) ; require ( tokens distributed crowdsale < limit crowdsale ) ; require ( tokens distributed crowdsale . add ( tokens ) <= limit crowdsale ) ; tokens distributed crowdsale = tokens distributed crowdsale . add ( tokens ) ; balances [ _buyer ] = balances [ _buyer ] . add ( tokens ) ; }", "nl": "distributes the ico tokens ."}
{"code": "function self destruct ( ) public { if ( ( msg . sender == owner ) && ( users . length ( ) == NUM_ ) ) { selfdestruct ( owner ) ; } }", "nl": "allow owner to delete contract if no account exist ."}
{"code": "function allocate proof tokens ( ) public only owner when not finalized { proof token . mint ( proof_multisig , tokens_allocated_to_proof ) ; proof tokens allocated = BOOL_ ; }", "nl": "allocates proof tokens to the give proof token wallet ."}
{"code": "function remove message ( ) only owner public { message = STR_ ; }", "nl": "this be only for mess up things people put ."}
{"code": "function buy tokens growth life ( ) internal { require ( stage == stage . growth || stage == stage . life ) ; require ( msg . value < two_128 ) ; uint256 total supply = orgon token . total supply ( ) ; assert ( total supply < two_128 ) ; uint256 to buy = safe mul ( total supply , safe sub ( root_10 ( safe add ( two_128 , ( msg . value << NUM_ ) / reserve amount ) ) , two_128 ) ) > > NUM_ ; reserve amount = safe add ( reserve amount , msg . value ) ; require ( reserve amount < two_128 ) ; if ( to buy > NUM_ ) { require ( orgon token . create tokens ( to buy ) ) ; require ( orgon token . total supply ( ) < two_128 ) ; uint256 fee amount = safe mul ( to buy , fee ) / fee_denominator ; require ( orgon token . transfer ( msg . sender , safe sub ( to buy , fee amount ) ) ) ; if ( fee amount > NUM_ ) require ( orgon token . transfer", "nl": "buy tokens during growth or life stage ."}
{"code": "function update whitelist mapping ( address [ ] _address , bool value ) public { require ( msg . sender == white listing admin ) ; for ( uint i = NUM_ ; i < _address . length ; i ++ ) { whitelist [ _address [ i ] ] = value ; } }", "nl": "populate the whitelist , only execute by whitelistingadmin ."}
{"code": "function transfer ( address _to , uint256 _value ) public manage transfer only payload size ( NUM_ * NUM_ ) returns ( bool success ) { require ( ! frozen accounts [ msg . sender ] ) ; require ( _to != address ( NUM_ ) ) ; return super . transfer ( _to , _value ) ; }", "nl": "overriden methods ."}
{"code": "function mint ( address _to , uint _value ) public returns ( bool ) { require ( msg . sender == minter || msg . sender == address ( token porter ) ) ; _balance of [ _to ] = _balance of [ _to ] . add ( _value ) ; _total supply = _total supply . add ( _value ) ; emit mint ( _to , _value ) ; emit transfer ( NUM_ , _to , _value ) ; return BOOL_ ; }", "nl": "allow minter and tokenporter to mint token and assign to address ."}
{"code": "function create default games ( ) public { require ( all games . length == NUM_ ) ; add new stake dice game ( NUM_ ) ; add new stake dice game ( NUM_ ) ; add new stake dice game ( NUM_ ) ; add new stake dice game ( NUM_ ) ; add new stake dice game ( NUM_ ) ; add new stake dice game ( NUM_ ) ; add new stake dice game ( NUM_ ) ; }", "nl": "allow the owner to easily create the default dice game ."}
{"code": "function has recent price ( address of asset ) view pre_cond ( information [ of asset ] . exists ) returns ( bool is recent ) { return sub ( now , information [ of asset ] . timestamp ) <= validity ; }", "nl": "whether price of asset have be update less than validity second ago ."}
{"code": "function to bytes ( uint256 addr , uint256 len ) internal pure returns ( bytes memory bts ) { bts = new bytes ( len ) ; uint256 btsptr = data ptr ( bts ) ; copy ( addr , btsptr , len ) ; }", "nl": "creates a 'bytes memory ' variable from the memory address 'addr ' , with the length 'len ' ."}
{"code": "function a purge messages ( ) only owner { delete m queue ; }", "nl": "clean house from time to time ."}
{"code": "function withdraw dividends ( ) public { uint256 dividends = user dividends [ msg . sender ] ; user dividends [ msg . sender ] = NUM_ ; msg . sender . transfer ( dividends ) ; }", "nl": "owner can withdraw their accumulated dividends ."}
{"code": "function change id ( string new id ) if authorised { shareholders [ msg . sender ] . id = new id ; changed id ( msg . sender , new id ) ; }", "nl": "this function be use to change user 's own id ( business id , birthday , etc . ) ."}
{"code": "function flags ( address _address ) public delegatable view returns ( uint256 ) { return address flags [ _address ] ; }", "nl": "flag for give address ."}
{"code": "function participant round amount ( address _address , uint _round ) external view returns ( uint ) { ico storage ico = icorounds [ _round == NUM_ ? current round : _round ] ; participant storage p = ico . participants [ _address ] ; return p . amount ; }", "nl": "get token amount reward to participant in specified round ."}
{"code": "function isdeposit ( ) external view returns ( uint ) { return deposit items [ msg . sender ] . valid ; }", "nl": "decide whether to deposit money ."}
{"code": "function update flight status ( bytes32 flight id , uint actual arrival time ) public only if creator { uint8 new status = NUM_ ; for ( uint i = NUM_ ; i < insurance list [ flight id ] . length ; i ++ ) { if ( insurance list [ flight id ] [ i ] . status == NUM_ ) { new status = NUM_ ; if ( actual arrival time > insurance list [ flight id ] [ i ] . limit arrival time ) { new status = NUM_ ; } insurance list [ flight id ] [ i ] . status = new status ; insurance update ( insurance list [ flight id ] [ i ] . product id , flight id , insurance list [ flight id ] [ i ] . premium , insurance list [ flight id ] [ i ] . indemnity , new status ) ; } } }", "nl": "update the status of a flight ."}
{"code": "function atomic match ( order memory buy , sig memory buy sig , order memory sell , sig memory sell sig , bytes32 metadata ) internal reentrancy guard { bytes32 buy hash = require valid order ( buy , buy sig ) ; bytes32 sell hash = require valid order ( sell , sell sig ) ; require ( orders can match ( buy , sell ) ) ; uint size ; address target = sell . target ; assembly { size : = extcodesize ( target ) } require ( size > NUM_ ) ; if ( buy . replacement pattern . length > NUM_ ) { array utils . guarded array replace ( buy . calldata , sell . calldata , buy . replacement pattern ) ; } if ( sell . replacement pattern . length > NUM_ ) { array utils . guarded array replace ( sell . calldata , buy . calldata , sell . replacement pattern ) ; } require ( array utils . array eq ( buy . calldata , sell . calldata ) ) ; authenticated proxy proxy = registry . proxies ( sell . maker ) ; require ( proxy != address", "nl": "match two order , ensure validity of the match , and execute all associate state transition ."}
{"code": "function balance ( ) view public returns ( uint256 ) { return token . balance of ( address ( this ) ) ; }", "nl": "get the remain mtc on the contract ."}
{"code": "function transfer ownership ( address new owner ) public only owner { require ( new owner != address ( NUM_ ) ) ; ownership transferred ( owner , new owner ) ; owner = new owner ; }", "nl": "allows only the contract owner to transfer ownership to someone else ."}
{"code": "modifier only token contract ( ) { _ ; }", "nl": "only allow access from the main token contract ."}
{"code": "function complete ( uint256 _sanity , uint256 _value ) if creator external { require ( _sanity == NUM_ ) ; require ( progress == NUM_ || progress == NUM_ ) ; require ( block . timestamp >= finish ) ; require ( this . balance >= _value ) ; progress = NUM_ ; reserves = safe add ( reserves , _value ) ; completed ( tokens , value , _value ) ; sale callback interface ( marketplace ) . handle sale completion callback . value ( _value ) ( tokens ) ; }", "nl": "the contract owner call this to complete ( finalize / wrap up , etc . ) ."}
{"code": "function retry winners ( ) public only owner { for ( uint i = NUM_ ; i < pending winners . length ; i ++ ) { retry winner ( i ) ; } pending winners . length = NUM_ ; }", "nl": "retries all pending winners ."}
{"code": "function cancel order ( uint exchange number , uint id ) external pre_cond ( is owner ( ) || is shut down ) { order order = orders [ id ] ; require ( address ( exchanges [ exchange number ] . exchange adapter ) . delegatecall ( bytes4 ( keccak256 ( STR_ ) ) , exchanges [ exchange number ] . exchange , order . exchange id ) ) ; order . status = order status . cancelled ; order updated ( id ) ; }", "nl": "cancels order that be not expect to settle immediately , i . e ."}
{"code": "function withdraw talao ( uint256 tokens ) public only owner { token . transfer ( msg . sender , tokens ) ; }", "nl": "allow the owner to withdraw tokens from the contract ."}
{"code": "function address hash ( address item ) public pure returns ( bytes32 hash ) { hash = keccak256 ( item ) ; }", "nl": "compute item hash from the public key ."}
{"code": "function withdraw token ( address token , uint amount ) external is admin { require ( token != address ( NUM_ ) && token ( token ) . transfer ( msg . sender , amount ) ) ; }", "nl": "backup withdraw , in case erc20 tokens get in here ."}
{"code": "function get usdprice ( ) private view returns ( uint256 ) { return usd cent value ; }", "nl": "getter for usd price of tokens ."}
{"code": "function transfer to address ( address _to , uint _value , bytes _data ) private returns ( bool success ) { if ( balance of ( msg . sender ) < _value ) revert ( ) ; balances [ msg . sender ] = balance of ( msg . sender ) . sub ( _value ) ; balances [ _to ] = balance of ( _to ) . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; erc223 transfer ( msg . sender , _to , _value , _data ) ; return BOOL_ ; }", "nl": "transfertoaddress transfer the specified amount of tokens to the specify address ."}
{"code": "function set service agent ( address _new service agent ) public only owner { service agent = _new service agent ; }", "nl": "function for change btc agent can be call only by owner of the contract ."}
{"code": "function handle for token id ( uint _token id ) public view returns ( bytes32 ) { bytes32 handle = handles [ _token id ] ; require ( handle != NUM_ ) ; return handle ; }", "nl": "get handle for a give tokenid ."}
{"code": "function set buy enabled ( bool buy enabled_ ) public auth returns ( bool ) { buy enabled = buy enabled_ ; log buy enabled ( buy enabled ) ; return BOOL_ ; }", "nl": "set buy functionality enable / disable ."}
{"code": "function set operating officer ( address _operating officer address ) external only executive officer { require ( _operating officer address != address ( NUM_ ) ) ; operating officer address = _operating officer address ; }", "nl": "reassign the operate officer role ."}
{"code": "function insert ( uint id , uint pos ) public returns ( bool ) { require ( ! is offer sorted ( id ) ) ; require ( is active ( id ) ) ; _hide ( id ) ; _sort ( id , pos ) ; log insert ( msg . sender , id ) ; return BOOL_ ; }", "nl": "insert offer into the sorted list keepers need to use this function ."}
{"code": "function owner of ( uint256 _token id ) external view returns ( address owner ) { owner = warrior to owner [ _token id ] ; require ( owner != address ( NUM_ ) ) ; }", "nl": "erc-721 method ."}
{"code": "function sold in tranche ( uint256 _tokens and bonus ) internal { uint256 index of tranche = define tranche period ( ) ; require ( tranches [ index of tranche ] . value for tranche >= _tokens and bonus ) ; tranches [ index of tranche ] . value for tranche = tranches [ index of tranche ] . value for tranche . sub ( _tokens and bonus ) ; total sold tokens = total sold tokens . add ( _tokens and bonus ) ; }", "nl": "summing sell of tokens ."}
{"code": "function check token balance state ( address _owner ) external view returns ( uint256 unlocked balance , uint256 locked balance ) { return ( balance of ( _owner ) . sub ( locked token balance [ _owner ] ) , locked token balance [ _owner ] ) ; }", "nl": "allow anyone to check the unlocked and locked token balance of a recipient ."}
{"code": "function _get hero genes or claim first hero ( uint _hero id ) internal returns ( uint hero id , uint hero genes ) { hero id = _hero id ; if ( hero token contract . balance of ( msg . sender ) == NUM_ ) { hero id = claim hero ( ) ; } ( , , , hero genes ) = hero token contract . heroes ( hero id ) ; }", "nl": "used in transport , challenge and train , to get the genes of a specific hero , a claim a hero if do n't have any ."}
{"code": "function transfer multi ( address [ ] _to , uint256 [ ] _value ) public returns ( bool success ) { require ( _value . length == _to . length ) ; for ( uint256 i = NUM_ ; i < _to . length ; i ++ ) { require ( balances [ msg . sender ] >= _value [ i ] ) ; require ( _to [ i ] != NUM_ ) ; super . transfer ( _to [ i ] , _value [ i ] ) ; } return BOOL_ ; }", "nl": "allow multiple transactions array ."}
{"code": "function remove game ( address ctr ) is an owner public { require ( is an added game [ ctr ] ) ; is an added game [ ctr ] = BOOL_ ; for ( uint i = NUM_ ; i < games . length ; i ++ ) { if ( games [ i ] == ctr ) { games [ i ] = address ( NUM_ ) ; if ( i != games . length ) { games [ i ] = games [ games . length ] ; } games . length = games . length - NUM_ ; break ; } } zethr token bankroll ( token bankroll mapping [ NUM_ ] ) . remove game ( ctr ) ; zethr token bankroll ( token bankroll mapping [ NUM_ ] ) . remove game ( ctr ) ; zethr token bankroll ( token bankroll mapping [ NUM_ ] ) . remove game ( ctr ) ; zethr token bankroll ( token bankroll mapping [ NUM_ ] ) . remove game ( ctr ) ; zethr token bankroll ( token bankroll mapping [ NUM_ ] ) . remove game ( ctr ) ; zethr token bankroll (", "nl": "dewhitelist a game on all token bankroll ."}
{"code": "function total tokens ( ) public view returns ( uint ) { return mainsale_cap ; }", "nl": "total amount of tokens initially available for purchase during mainsale ( exclude bonus tokens ) ."}
{"code": "function set name ( bytes32 _name ) only owner unlocked setter { name = _name ; }", "nl": "sets the name of the contraxt ."}
{"code": "function issue and freeze ( address _to , uint _value , uint _freeze period ) only owner public { _transfer ( msg . sender , _to , _value ) ; freeze account [ _to ] = freeze account info ( { freeze start time : now , freeze period : _freeze period , freeze total : _value } ) ; emit issue and freeze ( _to , _value , _freeze period ) ; }", "nl": "issue tokens to account and these tokens will be freeze for a period of time ."}
{"code": "function set pokemon ( uint _pokemon id , string _pokemon name , address _owner address , uint256 _current price , uint256 _levels ) public only contract creator ( ) { pokemons [ _pokemon id ] . owner address = _owner address ; pokemons [ _pokemon id ] . pokemon name = _pokemon name ; pokemons [ _pokemon id ] . current price = _current price ; levels [ _pokemon id ] = _levels ; lock [ _pokemon id ] = BOOL_ ; }", "nl": "set function , use when bug comeout ."}
{"code": "function add requester ( address requester ) public only owner { require ( ! requesters [ requester ] ) ; requesters [ requester ] = BOOL_ ; }", "nl": "adds a requester to the whitelist ."}
{"code": "function batch transfer single value ( address [ ] _dests , uint256 _value ) public { uint256 i = NUM_ ; while ( i < _dests . length ) { transfer ( _dests [ i ] , _value ) ; i += NUM_ ; } }", "nl": "batch transfer equal tokens amout to some address ."}
{"code": "function set token uri ( uint256 _token id , string _uri ) external only known origin { require ( exists ( _token id ) ) ; _set token uri ( _token id , _uri ) ; }", "nl": "utility function for update a koda assets token uri ."}
{"code": "function mint ( address _to , uint _amount ) public only ( owner ) is not started only returns ( bool ) { total supply = total supply . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; }", "nl": "crowdsale only ."}
{"code": "function deploy token ( string _name , string _symbol , uint8 _decimals , string _token details , address _issuer , bool _divisible , address _polymath registry ) public returns ( address ) { address new security token address = new security token ( _name , _symbol , _decimals , _divisible ? NUM_ : uint256 ( NUM_ ) * * _decimals , _token details , _polymath registry ) ; if ( add transfer manager ) { security token ( new security token address ) . add module ( transfer manager factory , STR_ , NUM_ , NUM_ ) ; } security token ( new security token address ) . transfer ownership ( _issuer ) ; return new security token address ; }", "nl": "deploy the token and add default modules like permission manager and transfer manager ."}
{"code": "function host_lottery ( bytes32 commit ) payable { require ( msg . value == total_user_eth ) ; require ( ( now > buy_end_time ) && ( now <= commit_end_time ) ) ; require ( ( commit != NUM_ ) && ( commits [ msg . sender ] == NUM_ ) ) ; commits [ msg . sender ] = commit ; num_hosts += NUM_ ; }", "nl": "adds a host to the lottery , increase the security of the lottery 's random number generation ."}
{"code": "function rounding percent ( uint numerator , uint denominator , uint target ) internal pure returns ( uint ) { uint remainder = mulmod ( target , numerator , denominator ) ; if ( remainder == NUM_ ) { return NUM_ ; } return remainder . mul ( NUM_ ) . div ( numerator . mul ( target ) ) ; }", "nl": "returns the percentage which be round when divide ."}
{"code": "function add array to whitelist ( address [ ] _bidder addrs ) public is owner at stage ( stages . auction set up ) { require ( _bidder addrs . length != NUM_ ) ; for ( uint idx = NUM_ ; idx < _bidder addrs . length ; idx ++ ) { add to whitelist ( _bidder addrs [ idx ] ) ; } }", "nl": "add multiple bidder address to whitelist ."}
{"code": "function commission art ( uint256 _foundation , uint256 _inspiration ) external payable when not paused returns ( uint ) { require ( msg . sender == token owner [ _foundation ] ) ; require ( msg . value >= artist fees ) ; uint256 _id = _create tulip ( bytes32 ( NUM_ ) , _foundation , _inspiration , tulips [ _foundation ] . generation + NUM_ , msg . sender ) ; _creative process ( _id ) ; }", "nl": "commission cryptotulip for abstract deconstruct art ."}
{"code": "function pause tokens ( ) public only owner { pre boutoken ( token ) . pause ( ) ; }", "nl": "helper to pause boutoken ."}
{"code": "function redeem ( bytes preimage ) public { require ( sha256 ( preimage ) == sha256hash ) ; uint256 amount = token . balance of ( this ) ; require ( amount > NUM_ ) ; token . safe transfer ( beneficiary , amount ) ; selfdestruct ( msg . sender ) ; }", "nl": "transfer to the specify address if anyone can provide the correct preimage ."}
{"code": "function enable aura ( uint256 a , uint256 n ) internal pure returns ( uint256 ) { return a | ( uint256 ( NUM_ ) << n ) ; }", "nl": "set bite value at position ."}
{"code": "modifier only stamping whitelisted ( ) { require ( stamping whitelist [ msg . sender ] ) ; _ ; }", "nl": "modifier for only whitelisted address ."}
{"code": "function bid ( bytes32 _sha bid ) external only whitelisted { bid storage b = bids_ [ _sha bid ] ; registrar_ . new bid . value ( b . value ) ( _sha bid ) ; }", "nl": "bid be responsable for call the newbid function ."}
{"code": "function set message span ( uint16 _new message span step ) public only owner { message span step = _new message span step ; message span step changed ( _new message span step ) ; }", "nl": "owner can change the message span step , in second ."}
{"code": "function _get challenge success ( uint _hero genes , uint _dungeon difficulty , uint _floor genes ) private pure returns ( bool ) { uint hero power ; ( hero power , , , , , ) = get hero power ( _hero genes , _dungeon difficulty ) ; uint floor power = get dungeon power ( _floor genes ) ; return hero power > floor power ; }", "nl": "split the challenge function into multiple part because of stack too deep error ."}
{"code": "function mint ( address _target , uint256 _minted amount ) public only authorized ( ) returns ( bool ) { assert ( total supply . add ( _minted amount ) <= NUM_ ) ; balances [ _target ] = balances [ _target ] . add ( _minted amount ) ; total supply = total supply . add ( _minted amount ) ; transfer ( NUM_ , _target , _minted amount ) ; return BOOL_ ; }", "nl": "mint new tokens with max of 197 . 5 millions ."}
{"code": "function find endpoint by address ( address eth_address ) public constant returns ( string socket ) { return address_to_socket [ eth_address ] ; }", "nl": "finds the socket if give an ethereum address ."}
{"code": "function available amount ( order library . order memory order , bytes32 hash ) internal view returns ( uint ) { return safe math . min256 ( order . taker token amount . sub ( fills [ hash ] ) , vault . balance of ( order . maker token , order . maker ) . mul ( order . taker token amount ) . div ( order . maker token amount ) ) ; }", "nl": "returns the maximum available amount that can be take of an order ."}
{"code": "modifier token trading must be live ( address sender ) { require ( trading live || freeze bypassing [ sender ] ) ; _ ; }", "nl": "modifier that require the trade to be live or allow to bypass the freeze status ."}
{"code": "function enable burning ( ) only controller { burnable = BOOL_ ; }", "nl": "enables burn through burnable bool ."}
{"code": "function skip init because iam not og ( address _token , address _proceeds , uint _genesis time , uint _minimum price , uint _starting price , uint _time scale , bytes8 _chain , uint _initial auction end time ) public only owner returns ( bool ) { require ( ! minted ) ; require ( ! initialized ) ; require ( _time scale != NUM_ ) ; require ( address ( token ) == NUM_ && _token != NUM_ ) ; require ( address ( proceeds ) == NUM_ && _proceeds != NUM_ ) ; init pricer ( ) ; token = mettoken ( _token ) ; proceeds = proceeds ( _proceeds ) ; initial_founder_supply = NUM_ ; initial_ac_supply = NUM_ ; mintable = NUM_ ; genesis time = _genesis time ; initial auction end time = _initial auction end time ; if ( initial auction end time == ( initial auction end time / NUM_ days ) * NUM_ days ) { daily auction start time = initial auction end time ; } else { daily auction start time = ( ( initial auction end time / NUM_ days ) + NUM_ ) * NUM_ days ; } last", "nl": "skip initialization and mint if we 're not the og metronome ."}
{"code": "modifier distribute sale input ( address _owner ) { uint256 contract owner commision ; uint256 player share ; if ( msg . value > NUM_ ) { contract owner commision = ( msg . value / NUM_ ) ; player share = msg . value - contract owner commision ; } else { contract owner commision = NUM_ ; player share = msg . value ; } address info [ _owner ] . withdrawal += player share ; address info [ contract owner ] . withdrawal += contract owner commision ; pending withdrawal += player share + contract owner commision ; _ ; }", "nl": "distribute sale eth input ."}
{"code": "function set edited true ( address _subject ) private { being edited [ _subject ] = BOOL_ ; }", "nl": "toggle beingedited status of this account ."}
{"code": "function close crowdsale ( bool close type ) { if ( beneficiary == msg . sender ) { crowdsale closed = close type ; } }", "nl": "dev function for close crowdsale ."}
{"code": "modifier track new users ( address _recipient ) { if ( ! accounts [ _recipient ] . is set ) { accounts [ _recipient ] . is set = BOOL_ ; accounts list . push ( _recipient ) ; } _ ; }", "nl": "registers the recipient account when tokens be send to an unregistered account ."}
{"code": "function is refunding ( ) public constant returns ( bool ) { return ( state == state . refunding ) ; }", "nl": "to allow ico contract to check whether refundvault be ready to refund investors ."}
{"code": "modifier payload size is ( uint size ) { require ( msg . data . length == size + NUM_ ) ; _ ; }", "nl": "check which prevent short address attack ."}
{"code": "function set prices ( uint256 new sell price , uint256 new buy price ) only owner { sell price = new sell price ; buy price = new buy price ; }", "nl": "allow address to pay newbuyprice eth when buy and receive newsellprice eth when sell , foreach token buy / sell ."}
{"code": "function token balance ( ) public view returns ( uint256 ) { return token . balance of ( address ( this ) ) ; }", "nl": "returns token balance of the sender ."}
{"code": "function freeze ( address _from , uint256 _value ) only owner public returns ( bool success ) { require ( _value > NUM_ ) ; require ( balance of [ _from ] >= _value ) ; balance of [ _from ] = balance of [ _from ] . safe sub ( _value ) ; freeze of [ _from ] = freeze of [ _from ] . safe add ( _value ) ; emit freeze ( _from , _value ) ; return BOOL_ ; }", "nl": "fress token from one address ."}
{"code": "function _create monster ( uint256 _matron id , uint256 _sire id , uint256 _generation , uint256 _genes , address _owner ) internal returns ( uint ) { require ( _matron id == uint256 ( uint32 ( _matron id ) ) ) ; require ( _sire id == uint256 ( uint32 ( _sire id ) ) ) ; require ( _generation == uint256 ( uint16 ( _generation ) ) ) ; uint16 cooldown index = uint16 ( _generation / NUM_ ) ; if ( cooldown index > NUM_ ) { cooldown index = NUM_ ; } monster memory _monster = monster ( { genes : _genes , birth time : uint64 ( now ) , cooldown end block : NUM_ , matron id : uint32 ( _matron id ) , sire id : uint32 ( _sire id ) , siring with id : NUM_ , cooldown index : cooldown index , generation : uint16 ( _generation ) } ) ; uint256 new kitten id = monsters . push ( _monster ) - NUM_ ; require ( new kitten id == uint256 ( uint32 ( new kitten id ) ) ) ; birth ( _owner , new kitten id , uint256 (", "nl": "an internal method that create a new monster and store it ."}
{"code": "function calculate best precision ( uint256 _base n , uint256 _base d , uint256 _exp n , uint256 _exp d ) public constant returns ( uint8 ) { uint256 max val = ln upper bound ( _base n , _base d ) * _exp n ; uint8 lo = min_precision ; uint8 hi = max_precision ; while ( lo + NUM_ < hi ) { uint8 mid = ( lo + hi ) / NUM_ ; if ( ( max val << ( mid - min_precision ) ) / _exp d <= max exp array [ mid ] ) lo = mid ; else hi = mid ; } if ( ( max val << ( hi - min_precision ) ) / _exp d <= max exp array [ hi ] ) return hi ; else return lo ; }", "nl": "predicts the high precision which can be use in order to compute base exp without exceed 256 bits in any of the intermediate computations ."}
{"code": "function whitelist address ( address address to whitelist , uint256 cap amount ) external owner exists ( msg . sender ) { assert ( ! whitelisted addresses [ address to whitelist ] . bona fide ) ; whitelisted addresses [ address to whitelist ] . bona fide = BOOL_ ; whitelisted addresses [ address to whitelist ] . cap for amount raised = cap amount ; }", "nl": "add whitelisted address to the presale ."}
{"code": "function change fee collector ( address new fee collector ) public { address old fee collector = fee collector ; require ( msg . sender == old fee collector ) ; require ( new fee collector != old fee collector ) ; fee collector = new fee collector ; }", "nl": "public management - change fee collector ."}
{"code": "function buy tokens ( address _address , uint256 _value ) internal returns ( bool ) { require ( is valid contribution ( _address , _value ) ) ; uint256 bought tokens = calculate tokens ( _value ) ; require ( bought tokens != NUM_ ) ; if ( bought tokens >= get tokens available ( ) ) { revert ( ) ; } add to investor ( _address , _value , bought tokens ) ; log token purchase ( msg . sender , _address , _value , bought tokens ) ; forward funds ( _value ) ; update sale parameters ( bought tokens ) ; return BOOL_ ; }", "nl": "internal function to assign tokens to the contributor ."}
{"code": "modifier only irnor owner ( ) { require ( msg . sender == owner || network [ msg . sender ] . is irnadmin , STR_ ) ; _ ; }", "nl": "only irnadmins or owner can call , otherwise throw ."}
{"code": "function set approved contracts ( address contract address , bool yes or no ) only administrator ( ) public { approved contracts [ contract address ] = yes or no ; }", "nl": "set approve contract that can purchase / sell tokens ( this be if we ever need a whale contract in the future ) ."}
{"code": "function transfer ( address _to , uint256 _amount ) public returns ( bool ) { require ( balances [ msg . sender ] >= _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; }", "nl": "transfers tokens from the sender 's account to another give account ."}
{"code": "function propose foundation transfer ( address new foundation ) external only foundation { candidate = new foundation ; }", "nl": "2-phase ownership transfer ; prevent transfer ownership to non-existent address by accident ."}
{"code": "function free balance ( ) public view returns ( uint tokens ) { return _released . sub ( _allocated ) ; }", "nl": "return free tokens ."}
{"code": "function cast ( ) public note { require ( ! done ) ; exec ( whom , data , mana ) ; done = BOOL_ ; }", "nl": "only mark 'done ' if call succeed ( not exceptional condition ) ."}
{"code": "function configuration token tranche pricing ( uint [ ] init_tranches ) internal { require ( init_tranches . length % tranche_size == NUM_ ) ; require ( init_tranches [ amount_offset ] > NUM_ ) ; uint input_tranches_length = init_tranches . length . div ( tranche_size ) ; tranche memory last_tranche ; for ( uint i = NUM_ ; i < input_tranches_length ; i ++ ) { uint tranche_offset = i . mul ( tranche_size ) ; uint amount = init_tranches [ tranche_offset . add ( amount_offset ) ] ; uint start = init_tranches [ tranche_offset . add ( start_offset ) ] ; uint end = init_tranches [ tranche_offset . add ( end_offset ) ] ; uint price = init_tranches [ tranche_offset . add ( price_offset ) ] ; require ( start < end && now < end ) ; require ( i == NUM_ || ( end >= last_tranche . end && amount > last_tranche . amount ) || ( end > last_tranche . end && amount >= last_tranche . amount ) ) ; last_tranche = tranche ( amount , start , end , price ) ; tranches . push ( last_tranche ) ; } }", "nl": "construction , create a list of tranches ."}
{"code": "function get total air dropped amount ( ) public view returns ( uint256 ) { return air drop amount . mul ( array air drop receivers . length ) ; }", "nl": "return the total amount of token user receive ."}
{"code": "function on transfer ( address _from , address _to , uint _amount ) public returns ( bool ) { return _from == address ( this ) ; }", "nl": "notifies the controller about a transfer , for this sale all transfer be allow by default and no extra notifications be need ."}
{"code": "function update batch ( int128 [ ] win balances , uint128 [ ] game counts , uint8 [ ] v , bytes32 [ ] r , bytes32 [ ] s , bool charge gas ) public only authorized { require ( win balances . length == game counts . length ) ; require ( win balances . length == v . length ) ; require ( win balances . length == r . length ) ; require ( win balances . length == s . length ) ; require ( win balances . length <= NUM_ ) ; address player ; uint gas cost = NUM_ ; if ( charge gas ) gas cost = get gas cost ( ) ; gas payback = safe add ( gas payback , safe mul ( gas cost , win balances . length ) ) ; for ( uint8 i = NUM_ ; i < win balances . length ; i ++ ) { player = ecrecover ( keccak256 ( win balances [ i ] , game counts [ i ] ) , v [ i ] , r [ i ] , s [ i ] ) ; _update state ( player", "nl": "update several state channel at once ."}
{"code": "function set possible mobs ( uint32 [ ] _class ids ) only owner public { possible mob classes = _class ids ; }", "nl": "set possible mob in this dungeon ."}
{"code": "function start pre sale ( ) only owner public returns ( bool result ) { enable pre sale = BOOL_ ; return enable pre sale ; }", "nl": "satart presale ."}
{"code": "function grab booty ( ) external { uint256 booty = owner to booty [ msg . sender ] ; require ( booty > NUM_ ) ; require ( total booty >= booty ) ; owner to booty [ msg . sender ] = NUM_ ; total booty -= booty ; msg . sender . transfer ( booty ) ; booty grabbed ( msg . sender , booty ) ; }", "nl": "grabbooty send to message sender his booty in wei ."}
{"code": "function get players of owner ( address _owner ) public view returns ( uint [ ] owned players ) { uint num players owned = balance of players ( _owner ) ; owned players = new uint [ ] ( num players owned ) ; uint total players = total player supply ( ) ; uint result index = NUM_ ; if ( num players owned != NUM_ ) { for ( uint pos = NUM_ ; pos < total players ; pos ++ ) { address curr owner = owner of player ( pos ) ; if ( curr owner == _owner ) { owned players [ result index ] = pos ; result index ++ ; } } } }", "nl": "gets list of players own by a person ."}
{"code": "function open crowdsale ( ) { if ( beneficiary == msg . sender ) { crowdsale closed = BOOL_ ; } }", "nl": "open the crowdsale ."}
{"code": "function send to investor ( address investor , uint value ) public can transfer { require ( investor != NUM_ && value > NUM_ ) ; require ( value <= balances [ owner ] ) ; require ( distributors amount [ msg . sender ] >= value && value > NUM_ ) ; distributors amount [ msg . sender ] = distributors amount [ msg . sender ] . sub ( value ) ; balances [ owner ] = balances [ owner ] . sub ( value ) ; balances [ investor ] = balances [ investor ] . add ( value ) ; add token holder ( investor ) ; transfer ( owner , investor , value ) ; }", "nl": "send tokens to any investor by owner or distributor ."}
{"code": "modifier when locked ( ) { require ( locked ) ; _ ; }", "nl": "modifier to make a function callable only when the contract be lock ."}
{"code": "function freeze account ( address account , bool freeze ) is owner { require ( account != owner ) ; require ( account != supervisor ) ; frozen account [ account ] = freeze ; if ( freeze ) { frozen funds ( msg . sender , account , STR_ ) ; } else { frozen funds ( msg . sender , account , STR_ ) ; } }", "nl": "'freeze ? prevent allow ' 'account ' from send and receive tokens ."}
{"code": "function update player balance ( address player , int128 win balance , int128 last win balance , uint gas cost ) internal returns ( int difference ) { difference = safe sub ( win balance , last win balance ) ; int outstanding = safe sub ( difference , int ( gas cost ) ) ; uint outs ; if ( outstanding < NUM_ ) { outs = uint256 ( outstanding * ( - NUM_ ) ) ; player balance = safe sub ( player balance , outs ) ; balance of [ player ] = safe sub ( balance of [ player ] , outs ) ; } else { outs = uint256 ( outstanding ) ; assert ( bankroll ( ) * one edg > outs ) ; player balance = safe add ( player balance , outs ) ; balance of [ player ] = safe add ( balance of [ player ] , outs ) ; } }", "nl": "compute the difference of the win balance relative to the last known state and add it to the player 's balance ."}
{"code": "function increase approval ( address _spender , uint256 _added value ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = safe add ( allowed [ msg . sender ] [ _spender ] , _added value ) ; emit approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return BOOL_ ; }", "nl": "function to increaseapproval to the spender ."}
{"code": "function clear pools done ( ) public { for ( uint i = NUM_ ; i < pools done . length ; i ++ ) { if ( ! pools done [ i ] . is money sent ( ) ) return ; } pools done . length = NUM_ ; }", "nl": "clear pool do array ( call once a week by our console , or can be call by anybody ) ."}
{"code": "function update authority ( address new_authority , dsauth modes mode ) auth ( ) { _authority = dsauthority ( new_authority ) ; _auth_mode = mode ; dsauth update ( new_authority , mode ) ; }", "nl": "this function be use to both transfer the authority and update the mode ."}
{"code": "function verify signature address transit address address address signed uint8 v bytes32 r bytes32 s public pure returns bool success bytes32 prefixed hash keccak256 \\x19 ethereum signed message \\n32 address signed address ret addr ecrecover prefixed hash v r s return ret addr transit address", "nl": "verify that address be sign with needed private key ."}
{"code": "function calculate token purchase ( uint256 _amount , uint256 _price ) private pure returns ( uint256 , uint256 ) { uint256 remainder = NUM_ ; uint256 num tokens ; uint256 wei tokens ; wei tokens = _amount . mul ( _price ) ; num tokens = wei tokens / NUM_ ; remainder = wei tokens % NUM_ ; remainder = remainder / _price ; return ( num tokens , remainder ) ; }", "nl": "calculate the number of tokens purchase base on the amount of wei spend and the price of tokens ."}
{"code": "function get total funds raised ( ) public view returns ( uint256 ) { return fiat raised converted to wei . add ( wei raised ) ; }", "nl": "the total fund collect in wei ( eth and none eth ) ."}
{"code": "function un freeze ( ) public only owner { if ( now > business planned period end timestamp ) { team stakes frozen = BOOL_ ; } }", "nl": "unfreeze team stakes ."}
{"code": "function is omitoken contract ( ) public pure returns ( bool ) { return BOOL_ ; }", "nl": "function to call from other contract to ensure that this be the proper contract ."}
{"code": "function pause contribution ( ) public only controller { paused = BOOL_ ; }", "nl": "pauses the contribution if there be any issue ."}
{"code": "function get current round ( ) public constant returns ( round struct ) { for ( uint256 i = NUM_ ; i < rounds . length ; i ++ ) { if ( rounds [ i ] . from amount <= total token sold && total token sold < rounds [ i ] . to amount ) { return rounds [ i ] ; } } }", "nl": "function that return the current round ."}
{"code": "function transfer tokens ( address [ ] _to , uint256 [ ] _amount ) is owner or additional owner public returns ( bool ) { require ( _to . length == _amount . length ) ; for ( uint i = NUM_ ; i < _to . length ; i ++ ) { transfer ( _to [ i ] , _amount [ i ] ) ; } return BOOL_ ; }", "nl": "transfer specify amount of tokens to the specified list of address ."}
{"code": "function forward funds ( ) internal { vault . deposit . value ( msg . value ) ( msg . sender ) ; }", "nl": "we 're override the fund forward from crowdsale ."}
{"code": "function add addresses to whitelist ( address [ ] _addresses , uint256 _rate ) only owner public returns ( bool success ) { success = BOOL_ ; for ( uint256 i = NUM_ ; i < _addresses . length ; i ++ ) { if ( add address to whitelist ( _addresses [ i ] , _rate ) ) { success = BOOL_ ; } } }", "nl": "adds an array of address to the whitelist , all with the same optional custom rate ."}
{"code": "function clear all ( ) public only owner { token . transfer ( owner , token . balance of ( this ) ) ; for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { beneficiary storage beneficiary = beneficiaries [ addresses [ i ] ] ; beneficiary . is beneficiary = BOOL_ ; beneficiary . released = NUM_ ; beneficiary . vested = NUM_ ; beneficiary . start = NUM_ ; beneficiary . cliff = NUM_ ; beneficiary . duration = NUM_ ; beneficiary . revoked = BOOL_ ; beneficiary . revocable = BOOL_ ; beneficiary . description = STR_ ; } addresses . length = NUM_ ; }", "nl": "allows the owner to clear the contract ."}
{"code": "modifier not existing token ( uint256 _token id ) { require ( total supply_ [ _token id ] == NUM_ && ( _token id & mask == _token id ) ) ; _ ; }", "nl": "throws if _tokenid exist ."}
{"code": "function _remove ( sale list storage self , address seller ) internal { self . seller to price [ seller ] = NUM_ ; self . seller list mapping [ seller ] = null address ; }", "nl": "note : this be a purely internal method that * only * zero out sellerlistmapping and sellertoprice ."}
{"code": "function forward funds ( ) internal { uint256 value = msg . value . div ( wallets . length ) ; uint256 rest = msg . value . sub ( value . mul ( wallets . length ) ) ; for ( uint256 i = NUM_ ; i < wallets . length - NUM_ ; i ++ ) { wallets [ i ] . transfer ( value ) ; } wallets [ wallets . length - NUM_ ] . transfer ( value + rest ) ; }", "nl": "forwardfunds split receive fund equally between wallets and send receiwed ethers to them ."}
{"code": "function redeem coins to ico ( uint256 amount of coins to redeem ) public returns ( bool success ) { uint amount = amount of coins to redeem ; msg sndr [ msg . sender ] = amount ; bool is preview = BOOL_ ; ico ico = ico ( _get ico addr ( ) ) ; bool icosuccess ; uint redeem payment value ; ( icosuccess , redeem payment value ) = ico . redeem coin ( amount , msg . sender , is preview ) ; require ( icosuccess == BOOL_ ) ; require ( _get ico addr ( ) . balance >= safe add ( ico . get min bal ( ) , redeem payment value ) ) ; bool sucs tr tk = BOOL_ ; bool pym act sucs = BOOL_ ; if ( is preview == BOOL_ ) { sucs tr tk = _safe transfer tkn ( msg . sender , owner , amount ) ; require ( sucs tr tk == BOOL_ ) ; msg sndr [ msg . sender ] = redeem payment value ; pym act sucs = _safe payment action at ico ( redeem payment value , msg . sender ,", "nl": "allows token owners to redeem tokens to this contract for it value promise ."}
{"code": "function exchange token ( address _target contract , uint _amount ) public when configured returns ( bool success , uint credited amount ) { require ( _target contract != address ( NUM_ ) && _amount <= balances [ msg . sender ] ) ; ( success , credited amount ) = exchange . exchange token ( _target contract , _amount ) ; if ( ! success ) { revert ( ) ; } emit exchange ( msg . sender , _target contract , _amount ) ; return ( success , credited amount ) ; }", "nl": "exchange amount of this token to target token ."}
{"code": "function was delegate ( address _address , uint256 timestamp ) public view returns ( bool ) { delegate log memory delegate log = delegates [ _address ] ; return timestamp >= delegate log . started && delegate log . started != NUM_ && ( delegate log . ended == NUM_ || timestamp < delegate log . ended ) ; }", "nl": "checks if a delegate exist at the timestamp ."}
{"code": "function self destruct ( ) external only owner { require ( self destruct initiated , STR_ ) ; require ( initiation time + selfdestruct_delay < now , STR_ ) ; address beneficiary = self destruct beneficiary ; emit self destructed ( beneficiary ) ; selfdestruct ( beneficiary ) ; }", "nl": "if the self-destruction delay have elapse , destroy this contract and remit any ether it own to the beneficiary address ."}
{"code": "function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( _spender != address ( NUM_ ) ) ; allowance [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; success = BOOL_ ; }", "nl": "approve _value tokens for _spender address to send from 'msg . sender ' ."}
{"code": "function unregister ( address _addr ) public only admin { registered address [ _addr ] = BOOL_ ; emit unregistered ( _addr ) ; }", "nl": "unregister the registered address ."}
{"code": "function withdraw chi ( ) external only owner { chi contract . transfer ( msg . sender , chi contract . balance of ( address ( this ) ) ) ; }", "nl": "withdraw remain chi from the contract ."}
{"code": "function safe transfer from ( address _from , address _to , uint256 _token id , bytes data ) external only valid token ( _token id ) { _safe transfer from ( _from , _to , _token id , data ) ; }", "nl": "transfer the ownership of give token from one address to another ."}
{"code": "function _create new lottery ( ) internal { lottery memory lottery ; lottery . created at = _get new lottery created at ( ) ; lottery . params = default params ; lottery count = lotteries . push ( lottery ) ; }", "nl": "creates a new lottery ."}
{"code": "function set maximum claim price wei ( uint _maximum claim price wei ) { external enter ( ) ; set maximum claim price wei rp ( _maximum claim price wei ) ; external leave ( ) ; }", "nl": "used by topwizard to vary the cap on claim price ."}
{"code": "function get total prize ( ) public view returns ( uint256 ) { return this . balance ; }", "nl": "this function will return only tournament of power total prize ."}
{"code": "function _get wei value of tokens ( uint256 _tokens left , bool is referred ) internal view returns ( uint256 ) { uint256 permilles rate = get current buyer rate in permilles ( is referred ) ; if ( is referred ) { permilles rate = permilles rate . add ( referral_bonus_permille ) ; } uint256 tokens to buy = _tokens left . mul ( NUM_ ) . div ( permilles rate ) ; return tokens to buy . div ( rate ) ; }", "nl": "amount of wei to pay for tokens - calculation base on rate modifier percentage ."}
{"code": "function set decimals ( uint8 new decimals ) only owner only after closed { decimals = new decimals ; decimal change ( decimals ) ; }", "nl": "after the crowdsale : token maintainance ."}
{"code": "function update btc rate ( string _rate , string _timestamp ) public only owner { number btc updates = number btc updates . add ( NUM_ ) ; btc updates [ number btc updates ] = rate ( { rate : _rate , timestamp : _timestamp } ) ; rate update ( STR_ , number btc updates , _timestamp , _rate ) ; }", "nl": "adds the late btc euro rate to the history ."}
{"code": "function revoke submission ( address _airdropper , address _token address ) public only admin { if ( _token address != address ( NUM_ ) ) { token whitelist [ _token address ] = BOOL_ ; token blacklist [ _token address ] = BOOL_ ; } if ( _airdropper != address ( NUM_ ) ) { airdropper blacklist [ _airdropper ] = BOOL_ ; } }", "nl": "remove token and airdropper from whitelist ."}
{"code": "function is valid air drop for individual ( ) public view returns ( bool ) { bool valid not stop = ! stop ; bool valid amount = get remaining token ( ) >= air drop amount ; bool valid period = now >= start time && now <= end time ; bool valid receive air drop for individual = ! invalid air drop [ msg . sender ] ; return valid not stop && valid amount && valid period && valid receive air drop for individual ; }", "nl": "confirm that airdrop be available for msg . sender ."}
{"code": "function previous rounds count ( ) constant returns ( uint ) { return previous rounds . length ; }", "nl": "tells how many previous round exist ."}
{"code": "function get token amount ( ) public constant returns ( uint256 tokens ) { tokens ; }", "nl": "returns remain token amount ."}
{"code": "function accept blok token ownership ( ) external only owner { blok . accept ownership ( ) ; }", "nl": "accepts new ownership on behalf of the blok token contract ."}
{"code": "function update code weight ( string _code , uint _weight ) public only admin returns ( bool success ) { bytes32 uuid32 = string to bytes32 ( _code ) ; require ( _weight > NUM_ ) ; require ( m code index plus [ uuid32 ] > NUM_ ) ; uint idx = m code index plus [ uuid32 ] - NUM_ ; uint old weight = weight [ idx ] ; weight [ idx ] = _weight ; sum of weights = sum of weights . sub ( old weight ) . add ( _weight ) ; code update ( NUM_ , uuid32 , _weight , sum of weights ) ; return BOOL_ ; }", "nl": "update the weight of an exist code ."}
{"code": "function transfer locking ( address _to , uint256 _value , uint64 _release time ) public only owner returns ( bool ) { address timelock address = locking contract addresses [ _to ] ; if ( timelock address == address ( NUM_ ) ) { token timelock timelock = new token timelock ( this , _to , _release time ) ; timelock address = address ( timelock ) ; locking contract addresses [ _to ] = timelock address ; } return super . transfer ( timelock address , _value ) ; }", "nl": "transfer timelocked tokens ; ignore _releasetime if a timelock exist already ."}
{"code": "function increment supply ( ) only owner public returns ( bool ) { uint256 _value = NUM_ ; require ( total supply + _value <= limit supply ) ; total supply += _value ; balance of [ owner ] += _value ; }", "nl": "incremento de existencias de token 5 millions ."}
{"code": "function buy planet ( uint id ) public payable { if ( msg . value >= planets [ id ] . price ) { uint cut = ( msg . value * NUM_ ) / NUM_ ; planets [ id ] . owner . transfer ( msg . value - cut ) ; planets [ planets [ id ] . owner planet ] . owner . transfer ( cut ) ; planets [ id ] . owner = msg . sender ; planets [ id ] . price += ( msg . value * NUM_ ) / NUM_ ; sale ( planets [ id ] . name , planets [ id ] . price , msg . sender ) ; if ( msg . value > planets [ id ] . price ) { msg . sender . transfer ( msg . value - planets [ id ] . price ) ; } } else { msg . sender . transfer ( msg . value ) ; } }", "nl": "buy a planet ."}
{"code": "function withdraw to many ( address [ ] players ) public { for ( uint8 x = NUM_ ; x < players . length ; x ++ ) { address player = players [ x ] ; withdraw to ( player ) ; } }", "nl": "for players anyone can withdraw on behalf of someone ( when the player lack the gas , for instance ) ."}
{"code": "function bid ( uint256 _token id ) external payable when not paused { _bid ( _token id , msg . value ) ; _transfer ( msg . sender , _token id ) ; }", "nl": "bids on a sale , complete the sale and transfer ownership of the nft if enough ether be supply ."}
{"code": "function get last game ( ) public view returns ( uint , uint , uint , uint , address , uint ) { return ( last game . id , last game . rules . jackpot , last game . rules . slots , last game . rules . ticket price , last game . winner , last game . finished at ) ; }", "nl": "get information pertain to the last game ."}
{"code": "function is exists ( bytes32 avatar hash ) constant returns ( bool ) { avatar memory avatar = avatars [ avatar hash ] ; if ( avatar . id == NUM_ ) return BOOL_ ; return BOOL_ ; }", "nl": "returns if avatar of the give hash exist ."}
{"code": "function get hero available at ( uint256 _token id ) external view returns ( uint256 ) { return token id to hero instance [ _token id ] . available at ; }", "nl": "get the time when the hero become available ."}
{"code": "function create account ( address _new user ) public only registry admin { create account for user ( _new user ) ; }", "nl": "create an account instantly without an invitation ."}
{"code": "function migrate ( uint256 _value ) public when not paused { require ( migration agent != address ( NUM_ ) ) ; require ( _value != NUM_ ) ; require ( _value <= balances [ msg . sender ] ) ; require ( _value <= transferable tokens ( msg . sender , uint64 ( now ) ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; total migrated = total migrated . add ( _value ) ; migration agent interface ( migration agent ) . migrate from ( msg . sender , _value ) ; migrate ( msg . sender , migration agent , _value ) ; }", "nl": "migrates the tokens to the target token through the migrationagent ."}
{"code": "function add to whitelist ( address [ ] _wallets ) public only owner { for ( uint i = NUM_ ; i < _wallets . length ; i ++ ) { whitelist [ _wallets [ i ] ] = BOOL_ ; emit added to whitelist ( _wallets [ i ] ) ; } }", "nl": "ability to add to whitelist even after the sale start ."}
{"code": "function transfer ( address _to , uint _value ) public returns ( bool ) { require ( _to != NUM_ ) ; require ( balance of ( _to ) + _value > balance of ( _to ) ) ; if ( msg . sender . balance < min balance for tx fee && balances [ msg . sender ] . sub ( _value ) >= min balance for tx fee * sell price && this . balance >= min balance for tx fee ) { sell fxx ( ( min balance for tx fee . sub ( msg . sender . balance ) ) * sell price ) ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "nl": "transfers fxx tokens to another address ."}
{"code": "function remove logic version ( uint256 _version ) external { require ( msg . sender == owner_ ) ; require ( _version != latest version_ ) ; delete logic versions_ [ _version ] ; log logic version removed ( _version ) ; }", "nl": "remove a version ."}
{"code": "function withdraw ( ) only owner { owner . transfer ( this . balance ) ; }", "nl": "somehow unnecessery ."}
{"code": "function refund ( ) external { uint256 refunded amount = total invested amount of [ msg . sender ] ; uint256 total remaining refund = total loaded refund . sub ( total refunded amount ) ; uint256 token revoked = balances [ msg . sender ] ; require ( sale state == end_sale ) ; require ( ! is soft cap reached ( ) ) ; require ( total remaining refund >= refunded amount && refunded amount > NUM_ ) ; total invested amount of [ msg . sender ] = NUM_ ; balances [ msg . sender ] = NUM_ ; total remaining tokens for sales = total remaining tokens for sales . add ( token revoked ) ; total refunded amount = total refunded amount . add ( refunded amount ) ; msg . sender . transfer ( refunded amount ) ; emit refund ( msg . sender , refunded amount , token revoked ) ; }", "nl": "investors can claim ether refund if total raise fund do n't reach our softcap ."}
{"code": "function set token porter ( address _token porter ) public only owner returns ( bool ) { require ( _token porter != NUM_ ) ; token porter = itoken porter ( _token porter ) ; return BOOL_ ; }", "nl": "set address of token porter ."}
{"code": "function get metrics ( ) public view only owner returns ( game state , uint , uint , uint , uint , uint , uint ) { uint bet home ; uint bet away ; for ( uint i = NUM_ ; i < bets home . length ; i ++ ) { bet home += bets home [ i ] . amount ; } for ( i = NUM_ ; i < bets away . length ; i ++ ) { bet away += bets away [ i ] . amount ; } return ( game state , bets home . length , bets away . length , bet home , bet away , payout home , payout away ) ; }", "nl": "returns current game metrics ."}
{"code": "function get ethereum ( ) only owner external returns ( uint ) { require ( state == state . finished ) ; uint amount = this . balance ; msg . sender . transfer ( amount ) ; return amount ; }", "nl": "get invest ethereum ."}
{"code": "function _burn ( address _who , uint256 _value ) internal { super . _burn ( _who , _value ) ; emit burn ( _who , _value ) ; }", "nl": "overrides standardtoken . _burn ."}
{"code": "modifier in state ( states _state ) { require ( sale state == _state ) ; _ ; }", "nl": "state checker ."}
{"code": "function get zone ( uint zone id ) public constant only valid zone ( zone id ) returns ( uint id , address owner , uint sell price ) { return ( zone structs [ zone id ] . id , zone structs [ zone id ] . owner , zone structs [ zone id ] . sell price ) ; }", "nl": "return zone detail ."}
{"code": "function send ( address _to , uint256 _amount , uint256 _fee , uint256 _timestamp ) public when not paused returns ( bool ) { require ( free balances [ msg . sender ] >= _amount ) ; require ( _amount >= _fee ) ; require ( _to != address ( NUM_ ) ) ; uint256 to amt = _amount . sub ( _fee ) ; free balances [ msg . sender ] = free balances [ msg . sender ] . sub ( _amount ) ; free balances [ _to ] = free balances [ _to ] . add ( to amt ) ; frozen balances [ system acc ] = frozen balances [ system acc ] . add ( _fee ) ; freeze record [ system acc ] [ _timestamp ] = freeze record [ system acc ] [ _timestamp ] . add ( _fee ) ; transfer ( msg . sender , _to , to amt ) ; freeze ( system acc , _fee , _timestamp ) ; return BOOL_ ; }", "nl": "send with charge fee ."}
{"code": "function change number ( string new hash ) external { clients [ msg . sender ] . hash = new hash ; client exited ( msg . sender ) ; client registered ( msg . sender ) ; }", "nl": "this function be use to change the phone number in the service ."}
{"code": "function set position price ( uint256 new position price ) public only owner { require ( new position price > NUM_ ) ; position price = new position price ; }", "nl": "allows investment position price change ."}
{"code": "function transfer from ( token storage storage self , address _from , address _to , uint _amount ) public returns ( bool ) { require ( is whitelisted ( self , _to ) ) ; uint balance_owner = self . user_total_balances [ _from ] ; uint sender_allowed = self . allowed [ _from ] [ msg . sender ] ; if ( _to == _from || _to == address ( NUM_ ) || _amount == NUM_ || balance_owner < _amount || sender_allowed < _amount ) return BOOL_ ; transfer helper ( self , _from , _to , _amount ) ; self . user_total_balances [ _from ] = self . user_total_balances [ _from ] . sub ( _amount ) ; self . user_total_balances [ _to ] = self . user_total_balances [ _to ] . add ( _amount ) ; self . allowed [ _from ] [ msg . sender ] = self . allowed [ _from ] [ msg . sender ] . sub ( _amount ) ; emit transfer ( _from , _to , _amount ) ; return BOOL_ ; }", "nl": "erc20 compliant transferfrom function ."}
{"code": "function set failed ( ) external at stage ( stages . funding ) check timeout returns ( bool ) { if ( stage == stages . funding ) { revert ( ) ; } return BOOL_ ; }", "nl": "use to manually set stage to failed when no users have buy any tokens if no buy ( ) s occur before timeoutblock token would be stick in funding ."}
{"code": "function withdraw ( ) private { uint256 balance = better balance [ msg . sender ] ; require ( address ( this ) . balance >= balance ) ; better balance [ msg . sender ] -= balance ; msg . sender . transfer ( balance ) ; }", "nl": "send win prize to the winner ."}
{"code": "function request free distribution ( ) external { require ( get state ( ) == state . success ) ; assert ( investors [ msg . sender ] > NUM_ ) ; uint256 un sold tokens = safe sub ( token creation max , tokens sold ) ; require ( un sold tokens > NUM_ ) ; uint256 free tokens = safe div ( safe mul ( un sold tokens , investors [ msg . sender ] ) , tokens sold ) ; balance of [ msg . sender ] = safe add ( balance of [ msg . sender ] , free tokens ) ; investors [ msg . sender ] = NUM_ ; emit free distribution ( msg . sender , free tokens , block . number ) ; emit transfer ( NUM_ , msg . sender , free tokens ) ; }", "nl": "send param _unsoldtokens to all investor base on their share ."}
{"code": "function finish ( ) public hasnt stopped ( ) has been started ( ) when crowdsale alive ( ) only crowdsale ( ) { completed = BOOL_ ; }", "nl": "finish collect data ."}
{"code": "function setup whitelist ( address _authenticator , bool _require authentication ) public only_owner at_stage ( stages . deploying ) { authenticator = iauthenticator ( _authenticator ) ; require authentication = _require authentication ; }", "nl": "setup authentication ."}
{"code": "function set oversight ( address addr ) only owner unlocked setter { oversight address = addr ; }", "nl": "setter methods , only for the unlocked state ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "nl": "transfers tokens from your address to other ."}
{"code": "function set force contract ( address _force token address ) external only masters { force token = force token ( _force token address ) ; }", "nl": "set 4th token address ."}
{"code": "function change root ( address _new root address ) only root returns ( bool ) { root address = _new root address ; return BOOL_ ; }", "nl": "only root function ."}
{"code": "function unfrozen contributors tokens ( ) internal { require ( contributors current period < contributors_periods ) ; uint256 contributortime should pass by = contributors current period * ( minutes one year ) ; time pass by ( STR_ , contributortime should pass by ) ; uint256 contributors time pass by = time ( ) - init date ; time pass by ( STR_ , contributors time pass by ) ; contributors current period = contributors current period + NUM_ ; require ( contributors time pass by >= contributortime should pass by ) ; frozen supply = frozen supply . sub ( contributors periods elapsed ) ; balance of [ contributors address ] = balance of [ contributors address ] . add ( contributors periods elapsed ) ; log unfrozen tokens ( STR_ , contributors address , contributors periods elapsed ) ; }", "nl": "unfrozen contributors token year by year ."}
{"code": "function buy tokens ( uint16 _bid price ) { if ( tx . origin != msg . sender ) { if ( ! msg . sender . send ( msg . value ) ) throw ; log ( STR_ , NUM_ ) ; return ; } if ( price == NUM_ ) { if ( ! tx . origin . send ( msg . value ) ) throw ; log ( STR_ , NUM_ ) ; return ; } if ( _bid price < price ) { if ( ! tx . origin . send ( msg . value ) ) throw ; log ( STR_ , price ) ; return ; } if ( msg . value == NUM_ ) { log ( STR_ , NUM_ ) ; return ; } uint _token supply = token supply ( ) ; if ( _token supply == NUM_ ) { if ( ! tx . origin . send ( msg . value ) ) throw ; log ( STR_ , NUM_ ) ; return ; } uint _tokens to purchase = ( msg . value * NUM_ ) / price ; if ( _tokens to purchase <= _token supply ) {", "nl": "do n't buy from exchange ! only buy from normal account in your full control ( private key ) ."}
{"code": "function _trigger cooldown ( panda storage _kitten ) internal { _kitten . cooldown end block = uint64 ( ( cooldowns [ _kitten . cooldown index ] / seconds per block ) + block . number ) ; if ( _kitten . cooldown index < NUM_ && gene science . get wizz type ( _kitten . genes ) != NUM_ ) { _kitten . cooldown index += NUM_ ; } }", "nl": "set the cooldownendtime for the give panda , base on it current cooldownindex ."}
{"code": "function get wheel distance ( uint value1 , uint value2 ) private pure returns ( uint ) { require ( value1 < wheel_size && value2 < wheel_size ) ; uint dist1 = ( wheel_size + value1 - value2 ) % wheel_size ; uint dist2 = wheel_size - dist1 ; return ( dist1 < dist2 ) ? dist1 : dist2 ; }", "nl": "a utility function to get the minimum distance between two selections on a wheel of wheel_size wrap around at 0 ."}
{"code": "function start first stage ( ) public only owner { require ( status == status . created ) ; human . mint tokens ( team fund , team part ) ; status = status . first stage ; first stage started ( now ) ; }", "nl": "function to start the first stage of human token allocation and to issue human token for team fund ."}
{"code": "function distribute ( uint256 _amount ) internal returns ( bool ) { require ( _amount != NUM_ ) ; uint256 per amount = _amount . div ( NUM_ ) ; assert ( lbc . transfer ( posaddress , per amount . mul ( NUM_ ) ) ) ; assert ( lbc . transfer ( community address , per amount . mul ( NUM_ ) ) ) ; assert ( lbc . transfer ( operation address , per amount . mul ( NUM_ ) ) ) ; emit tokens withdrawn ( _amount ) ; return BOOL_ ; }", "nl": "distribute unlockable tokens to three address , proportion 3 : 1 : 1 ."}
{"code": "function balance of ( address _user ) public view returns ( uint ) { lottery storage lottery = lotteries [ lottery count - NUM_ ] ; return lottery . owner token count [ _user ] ; }", "nl": "returns token balance by user address ."}
{"code": "modifier not lockout ( ) { require ( now > ( initialized time + financing period + token lockout period ) ) ; _ ; }", "nl": "throws if token in lockout period ."}
{"code": "function proxy payment ( address _owner ) public payable returns ( bool ) { return BOOL_ ; }", "nl": "function for the mini me token ."}
{"code": "function get usdethprice ( ) public returns ( uint256 ) { if ( emergency mode ) { return NUM_ ; } bytes32 price ; bool valid = BOOL_ ; ( price , valid ) = medianizer ( price feed source ) . peek ( ) ; if ( ! valid ) { non valid price feed ( price feed source ) ; } uint price uint = uint256 ( price ) / ( NUM_ ether ) ; if ( price uint == NUM_ ) return NUM_ ; if ( price uint > NUM_ ) return NUM_ ; return price uint ; }", "nl": "return the usdeth price , ie get the usd price from maker fee with 18 digits , but last 18 digits be cut off ."}
{"code": "function do buyer cancel ( bytes16 _trade id , address _seller , address _buyer , uint256 _value , uint16 _fee , uint128 _additional gas ) private returns ( bool ) { escrow memory _escrow ; bytes32 _trade hash ; ( _escrow , _trade hash ) = get escrow and hash ( _trade id , _seller , _buyer , _value , _fee ) ; if ( ! _escrow . exists ) { return BOOL_ ; } uint128 _gas fees = _escrow . total gas fees spent by relayer + ( msg . sender == relayer ? ( gas_do buyer cancel + _additional gas ) * uint128 ( tx . gasprice ) : NUM_ ) ; delete escrows [ _trade hash ] ; emit cancelled by buyer ( _trade hash ) ; transfer minus fees ( _seller , _value , _gas fees , NUM_ ) ; return BOOL_ ; }", "nl": "cancels the trade and return the ether to the seller ."}
{"code": "function burn ( address _from , uint256 _amount ) external only minter returns ( bool success ) { require ( balances [ _from ] >= _amount ) ; balances [ _from ] -= _amount ; burn ( _from , _amount ) ; return BOOL_ ; }", "nl": "used by kitty gym and vend machine to take coin from users ."}
{"code": "function limit less than ( uint a , uint b ) internal pure returns ( uint c ) { if ( a > b ) return b ; return a ; }", "nl": "return the small of the two input ( a or b ) ."}
{"code": "function finalize sale ( uint256 _wei amount , uint256 _tokens , uint128 _buyer ) internal { balance of [ msg . sender ] = balance of [ msg . sender ] . add ( _wei amount ) ; token balance of [ msg . sender ] = token balance of [ msg . sender ] . add ( _tokens ) ; balance per id [ _buyer ] = balance per id [ _buyer ] . add ( _wei amount ) ; wei raised = wei raised . add ( _wei amount ) ; tokens sent = tokens sent . add ( _tokens ) ; uint8 stage = get stage ( ) ; stages . stages [ stage ] . tokens sold = stages . stages [ stage ] . tokens sold . add ( _tokens ) ; }", "nl": "override crowdsale finalizesale function to log balance change plus tokens sell in that stage ."}
{"code": "function allocate to early contributor ( address to , uint256 value ) external only fundraiser returns ( bool ) { initial ec token allocation [ to ] = safe math . add ( initial ec token allocation [ to ] , value ) ; return allocate from ( NUM_ , to , value ) ; }", "nl": "allocate tokens to an early contributor from the early contributor share ."}
{"code": "function _zth token ( address _token contract ) private view returns ( bool ) { return _token contract == zthtknaddr ; }", "nl": "is the address that the token have come from actually zth ? ."}
{"code": "function stake ( uint256 _amount , bytes _data ) public { create stake ( msg . sender , _amount , default lock in duration , _data ) ; }", "nl": "stakes a certain amount of tokens , this must transfer the give amount from the user ."}
{"code": "function set token addr ( standard token tok addr ) public only owner { require ( token == address ( NUM_ ) ) ; token = tok addr ; state = contract state . locked ; is locked ( now ) ; }", "nl": "allows the owner to set the token contract address ."}
{"code": "function change exchange rate ( uint256 eth ) external only owner ( ) { if ( eth == NUM_ ) throw ; tokens per ether = eth ; }", "nl": "change exchange rate update price everyday ."}
{"code": "function manual draw ( ) public only owner { lottery storage lot = current lottery ( ) ; require ( lot . status == NUM_ ) ; require ( must draw ( ) ) ; require ( now - last draw ts > manual_withdraw_interval ) ; if ( lot . oraclize ids . length == NUM_ ) { lot . status = NUM_ ; lot . awaiting oraclize callback = BOOL_ ; log lottery result ( current lottery id , NUM_ , lot . oraclize ids [ lot . oraclize ids . length - NUM_ ] , STR_ ) ; finalize lottery ( ) ; } else { draw ( ) ; } }", "nl": "in case the lottery get stick , oraclize doesnt call back etc . , ."}
{"code": "function set goal ( uint256 _goal ) public only owner { goal = _goal ; }", "nl": "set goal ."}
{"code": "function freeze account ( address target , bool freeze ) external only owner { frozen account [ target ] = freeze ; frozen account ( target , freeze ) ; }", "nl": "freeze ? prevent allow target from get basic income ."}
{"code": "function shift ( address receiver , uint num tokens ) public only casino games { balance of [ receiver ] = safe add ( balance of [ receiver ] , num tokens ) ; player balance = safe add ( player balance , num tokens ) ; }", "nl": "shift tokens from the contract balance to the receiver ."}
{"code": "function process payment ( uint _order id , uint32 _client reputation , uint32 _merchant reputation , uint _deal hash ) external only monetha when not paused at state ( _order id , state . paid ) transition ( _order id , state . finalized ) { monetha gateway . accept payment . value ( orders [ _order id ] . price ) ( merchant wallet , orders [ _order id ] . fee ) ; update deal conditions ( _order id , _client reputation , _merchant reputation , BOOL_ , _deal hash ) ; }", "nl": "processpayment transfer fund to monethagateway and complete the order ."}
{"code": "function supply tokens ( uint tokens ) private { require ( ! max supply reached ( ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; total supply = total supply . add ( tokens ) ; if ( total supply >= target supply [ stage ] ) { stage += NUM_ ; } emit transfer ( address ( NUM_ ) , msg . sender , tokens ) ; }", "nl": "create tokens and supply to msg . sender ."}
{"code": "function set renaming costs ( uint256 new renaming cost ) external only owner ( ) { renaming costs per char = new renaming cost ; }", "nl": "sets a new rename per character cost in wei ."}
{"code": "function kill bounty ( uint _bounty id ) public validate bounty array index ( _bounty id ) only issuer ( _bounty id ) { transition to state ( _bounty id , bounty stages . dead ) ; uint old balance = bounties [ _bounty id ] . balance ; bounties [ _bounty id ] . balance = NUM_ ; if ( old balance > NUM_ ) { if ( bounties [ _bounty id ] . pays tokens ) { require ( token contracts [ _bounty id ] . transfer ( bounties [ _bounty id ] . issuer , old balance ) ) ; } else { bounties [ _bounty id ] . issuer . transfer ( old balance ) ; } } bounty killed ( _bounty id , msg . sender ) ; }", "nl": "killbounty ( ) : drain the contract of it 's remain fund , and move the bounty into stage 3 ( dead ) since it be either kill in draft stage , or never accept any fulfillments ."}
{"code": "function clear approval ( address [ NUM_ ] _contracts , address _owner , uint256 _token id ) public { var own storage = bdp ownership storage ( bdp contracts . get bdp ownership storage ( _contracts ) ) ; require ( owner of ( _contracts , _token id ) == _owner ) ; if ( own storage . get token approval ( _token id ) != NUM_ ) { bdp ownership storage ( bdp contracts . get bdp ownership storage ( _contracts ) ) . set token approval ( _token id , NUM_ ) ; approval ( _owner , NUM_ , _token id ) ; } }", "nl": "clear current approval of a give token id ."}
{"code": "function get gen ( uint256 token id ) public view returns ( bytes7 ) { return genes [ token id ] ; }", "nl": "cryptoflower specific function return the genome of a token ."}
{"code": "function name ( address _owner ) constant returns ( bytes32 o_name ) { return series by address [ _owner ] ; }", "nl": "this be here for registrar abi support : return the search key for a contract ."}
{"code": "function end game internal ( ) private { game opponent = address ( NUM_ ) ; game time = NUM_ ; status = NUM_ ; }", "nl": "reset team token state ."}
{"code": "function emergency stop ( ) only owner ( ) public { rev contract . exit ( ) ; uint balance = address ( this ) . balance ; owner . transfer ( balance ) ; open to public = BOOL_ ; }", "nl": "if this do n't work as expect , cash out and send to owner to disperse eth back to players ."}
{"code": "function update duration ( uint256 _new p2 start ) external only owner { require ( is crowd sale setup && ! ( p2_start == _new p2 start ) && ! ( _new p2 start > p1_start + p1_duration + NUM_ days ) && ( now < p2_start ) && ( funding start time + p1_duration < _new p2 start ) ) ; p2_start = _new p2 start ; funding end time = p2_start . add ( NUM_ weeks ) ; }", "nl": "p1_duration constant ."}
{"code": "function get min investment ( ) public constant returns ( uint ) { return NUM_ wei ; }", "nl": "for min investment check ."}
{"code": "modifier only contract ( ) { require ( msg . sender != address ( NUM_ ) ) ; require ( contracts [ msg . sender ] ) ; _ ; }", "nl": "stops owner from gain access to all functionality ."}
{"code": "function current balance ( ) internal constant returns ( uint256 ) { return token . balance of ( this ) ; }", "nl": "returns current balance to be distribute to portion ."}
{"code": "function set start time ( uint256 _start time ) public only owner { require ( now < start time ) ; require ( _start time > now ) ; require ( _start time < end time ) ; start time = _start time ; }", "nl": "sets a new start date as long a token sale have n't start yet ."}
{"code": "function _transfer ( address _from , address _to , uint256 _token id ) internal { owner ship count [ _to ] = owner ship count [ _to ] . add ( NUM_ ) ; ship id to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { owner ship count [ _from ] = owner ship count [ _from ] . sub ( NUM_ ) ; delete ship id to approval [ _token id ] ; } transfer ( _from , _to , _token id ) ; }", "nl": "assigns ownership of a specific ship to an address ."}
{"code": "function burn ( uint256 _value ) public returns ( bool success ) { require ( balance of [ msg . sender ] >= _value ) ; balance of [ msg . sender ] -= _value ; total supply -= _value ; emit burn ( msg . sender , _value ) ; return BOOL_ ; }", "nl": "destroy tokens ."}
{"code": "function update captures ( go board storage board , uint8 position , uint8 position color ) private { uint8 [ board_size ] memory group ; bool is group captured ; bool should check suicide = BOOL_ ; uint8 [ max_adjacent_cells ] memory adjacent array = get adjacent cells ( position ) ; for ( uint8 curr adjacent index = NUM_ ; curr adjacent index < max_adjacent_cells && adjacent array [ curr adjacent index ] < max_uint8 ; curr adjacent index ++ ) { uint8 curr color = board . position to color [ adjacent array [ curr adjacent index ] ] ; if ( curr color != NUM_ && curr color != position color ) { ( group , is group captured ) = get group ( board , adjacent array [ curr adjacent index ] , curr color ) ; if ( is group captured ) { for ( uint8 curr group index = NUM_ ; curr group index < board_size && group [ curr group index ] < max_uint8 ; curr group index ++ ) { board . position to color [ group [ curr group index ] ] = NUM_ ; } should check suicide = BOOL_", "nl": "calcultes whether a position capture an enemy group , or whether it 's a suicide ."}
{"code": "function mint ( uint256 amount ) only owner public { _mint ( msg . sender , amount ) ; }", "nl": "only owner be allow to do this ."}
{"code": "function unblacklist ( address node ) public only owner { blacklisted [ node ] = BOOL_ ; unblacklisted ( node ) ; }", "nl": "remove a node from the blacklist ."}
{"code": "function destroy tokens ( uint256 _tokens , address _destination ) only owner { shp . destroy tokens ( _destination , _tokens ) ; }", "nl": "allows the owner to manually destroy some shp to an address if something go wrong ."}
{"code": "function burn unminted tokens ( uint256 _burned amount ) public only owner returns ( bool success ) { require ( _burned amount <= _unminted tokens ) ; _unminted tokens -= _burned amount ; return BOOL_ ; }", "nl": "decrease amount of rhem tokens that can be mint ."}
{"code": "function get time ( address key ) constant returns ( uint ) { return records [ key ] . time ; }", "nl": "returns the registration time of the give record ."}
{"code": "function withdraw auction balance ( ) external only owner { dutch auction ( auction ) . withdraw balance ( ) ; }", "nl": "transfer balance back to core contract ."}
{"code": "function _trigger new tournament contender ( address _owner , uint256 [ ] memory _tournament data , uint256 _fee ) internal { current tournament bank += _fee ; uint256 packed warrior ids = crypto utils . _pack warrior ids ( _tournament data ) ; uint256 combined warrior = crypto utils . _combine warriors ( _tournament data ) ; uint256 size = tournament queue size ++ * data_size ; tournament queue [ size ++ ] = packed warrior ids ; tournament queue [ size ++ ] = combined warrior ; warrior to owner [ crypto utils . _unpack warrior id ( packed warrior ids , NUM_ ) ] = _owner ; tournament new contender ( _owner , packed warrior ids , _fee ) ; }", "nl": "internal utility function to sigin up to tournament , assume that all battle requirements have be check ."}
{"code": "function transfer ( address _to , uint _value ) can transfer ( msg . sender , _value ) public returns ( bool success ) { return super . transfer ( _to , _value ) ; }", "nl": "add cantransfer modifier before allow transfer and transferfrom to go through ."}
{"code": "function mul ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { uint256 c = a * b ; return c ; }", "nl": "function name : mul purpose : be the funcion for safe multiplicate ."}
{"code": "modifier only owner ( ) { if ( msg . sender != owner ) { revert ( ) ; } _ ; }", "nl": "revert ( ) s if call by any account other than the owner ."}
{"code": "function deliver ( address _investor ) public returns ( bool ) { require ( finished ) ; investor storage investor = investors [ _investor ] ; require ( investor . amount > NUM_ ) ; uint256 value = outstanding tokens ( _investor ) ; if ( value > NUM_ ) { if ( ! token . transfer from ( central bank , _investor , value ) ) return BOOL_ ; } total invested = safe sub ( total invested , investor . amount ) ; investor . amount = NUM_ ; investor . bonus amount = NUM_ ; investor . invested by referrers = NUM_ ; return BOOL_ ; }", "nl": "deliver purchase tokens to give investor ."}
{"code": "function approve ( address _spender , uint256 _value ) public only payload size ( NUM_ ) returns ( bool success ) { require ( ( _value == NUM_ ) || ( allowed [ msg . sender ] [ _spender ] == NUM_ ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }", "nl": "to change the approve amount you first have to reduce the address ' allowance to zero by call 'approve ( _spender , 0 ) ' if it be not already 0 to mitigate the race condition describe here : https : / / github . com / ethereum / eips / issue / 20 issuecomment-263524729 ."}
{"code": "function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( lock balance of [ _from ] + _value > lock balance of [ _from ] ) ; require ( balance of [ _from ] >= lock balance of [ _from ] + _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; require ( ! frozen account [ _from ] ) ; require ( ! frozen account [ _to ] ) ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; transfer ( _from , _to , _value ) ; }", "nl": "transfer token for a specified address . internal ."}
{"code": "function release proof ( bytes32 proof mapping , string release ) public { proof storage proof = proofs [ proof mapping ] ; require ( msg . sender == proof . creator ) ; require ( proof . hash == keccak256 ( abi . encode packed ( release ) ) ) ; require ( ! proof . released ) ; proof . release = release ; proof . released = BOOL_ ; proof . release time = now ; proof . release block num = block . number ; }", "nl": "release the content of a submit proof ."}
{"code": "function _limit team withdraw ( uint _amount , uint _team total , uint _team withrawed , uint _deployed time , uint _current time ) internal pure returns ( bool ) { bool flag = BOOL_ ; uint _ten percent = _team total / NUM_ ; if ( _current time <= _deployed time + NUM_ days && _amount + _team withrawed >= _ten percent * NUM_ ) flag = BOOL_ ; else if ( _current time <= _deployed time + NUM_ days && _amount + _team withrawed >= _ten percent * NUM_ ) flag = BOOL_ ; return flag ; }", "nl": "setperate this function be for unit test ."}
{"code": "function uint2str ( uint i ) internal pure returns ( string ) { if ( i == NUM_ ) return STR_ ; uint j = i ; uint len ; while ( j != NUM_ ) { len ++ ; j /= NUM_ ; } bytes memory bstr = new bytes ( len ) ; uint k = len - NUM_ ; while ( i != NUM_ ) { bstr [ k -- ] = byte ( NUM_ + i % NUM_ ) ; i /= NUM_ ; } return string ( bstr ) ; }", "nl": "some helpful function https : / / github . com / oraclize / ethereum-api / blob / master / oraclizeapi_0 . 5 . sol ."}
{"code": "function change owner ( address _owner ) public only owner returns ( bool ) { changed owner ( owner , _owner ) ; owner = _owner ; return BOOL_ ; }", "nl": "change the owner to _owner ."}
{"code": "modifier onlysigner { if ( ! is signer ( msg . sender ) ) { throw ; } _ ; }", "nl": "modifier that will execute internal code block only if the sender be an authorized signer on this wallet ."}
{"code": "function change key ( address _old key , address _new key ) third level public returns ( bool ) { require ( safe keys [ _old key ] ) ; require ( _new key != NUM_ ) ; for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { if ( mass safe keys [ i ] == _old key ) { mass safe keys [ i ] = _new key ; } } safe keys [ _old key ] = BOOL_ ; safe keys [ _new key ] = BOOL_ ; if ( _old key == last safe key ) { last safe key = _new key ; } return BOOL_ ; }", "nl": "change of safe-key ."}
{"code": "function transfer ( uint64 id sender , uint64 id pledge , uint amount , uint64 id receiver ) { id pledge = normalize pledge ( id pledge ) ; pledge storage p = find pledge ( id pledge ) ; pledge admin storage receiver = find admin ( id receiver ) ; pledge admin storage sender = find admin ( id sender ) ; check admin owner ( sender ) ; require ( p . pledge state == pledge state . pledged ) ; if ( p . owner == id sender ) { if ( receiver . admin type == pledge admin type . giver ) { transfer ownership to giver ( id pledge , amount , id receiver ) ; } else if ( receiver . admin type == pledge admin type . project ) { transfer ownership to project ( id pledge , amount , id receiver ) ; } else if ( receiver . admin type == pledge admin type . delegate ) { uint reciever didx = get delegate idx ( p , id receiver ) ; if ( p . intended project > NUM_ && reciever didx != notfound ) { if ( reciever", "nl": "transfers amount between pledge for internal account ."}
{"code": "function approve ( address _spender , uint256 _amount ) public only payload size ( NUM_ ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _amount ; emit approval ( msg . sender , _spender , _amount ) ; return BOOL_ ; }", "nl": "adds an approval for the specified account to spend money of the message sender up to the defined limit ."}
{"code": "function _get pay to ( ) internal view returns ( address ) { return owner ; }", "nl": "base scs ."}
{"code": "function unlock ( address addr , uint index ) public { require ( addr == msg . sender ) ; var lock = lock record map [ addr ] [ index ] ; require ( lock . amount > NUM_ && ! lock . completed ) ; var during = now - lock . time ; var reward = _calc reward ( during , lock . amount ) ; token t = token ( token addr ) ; t . transfer from ( owner , addr , lock . amount + reward ) ; lock . completed = BOOL_ ; unlock ( addr , index , lock . amount , reward ) ; }", "nl": "withdraw czr ."}
{"code": "function book with eth ( uint256 price per night , uint256 offer timestamp , bytes offer signature , string room type , uint256 [ ] _nights , bytes32 booking hash ) public payable { require ( offer timestamp < now ) ; require ( now < end bookings ) ; require ( price per night . mul ( _nights . length ) <= msg . value ) ; uint256 available = first room available ( room type , _nights ) ; require ( available > NUM_ ) ; bytes32 price signed = keccak256 ( abi . encode packed ( room type , price per night , offer timestamp , STR_ , booking hash ) ) . to eth signed message hash ( ) ; require ( offer signer == price signed . recover ( offer signature ) ) ; book room ( room type , _nights , available , msg . sender , booking hash , price per night , BOOL_ ) ; }", "nl": "book a room pay with eth ."}
{"code": "function redeemed karma of ( string username ) public view returns ( uint ) { return redeemed karma [ username ] ; }", "nl": "this function be a workaround because this . redeemedkarma ."}
{"code": "function revoke all vulnerable ( ) public members only returns ( bool complete ) { require ( is member_ ) ; uint8 calling member id ; ( , calling member id ) = the cyber . get membership status ( msg . sender ) ; uint64 inactive since ; address member address ; uint8 i = next revoked member index_ ; require ( msg . gas > NUM_ ) ; while ( msg . gas > NUM_ ) { ( , , , inactive since , member address ) = the cyber . get member information ( i ) ; if ( ( i != member id_ ) && ( i != calling member id ) && ( member address != address ( NUM_ ) ) && ( inactive since != NUM_ ) && ( now >= inactive since + inactivity timeout_ ) ) { the cyber . revoke membership ( i ) ; } i ++ ; if ( i == NUM_ ) { break ; } } next revoked member index_ = i ; return ( i == NUM_ ) ; }", "nl": "revoke all memberships ( except those of the utility contract msg . sender ) ."}
{"code": "function owner refund player ( bytes32 dice roll hash , address send to , uint original player profit , uint original player bet value ) public only owner { max pending payouts = safe sub ( max pending payouts , original player profit ) ; if ( ! send to . send ( original player bet value ) ) throw ; log refund ( dice roll hash , send to , original player bet value ) ; }", "nl": "only owner address can do manual refund use only if bet place + server error have a place filter logbet by address and / or dicerollhash check the following log do not exist for dicerollhash and / or playeraddress dicerollhash before refund : ."}
{"code": "function contribute btcs ( ) public payable btcs only btcs ether cap not reached ( msg . value ) earlier than ( start time ) returns ( uint256 amount ) { return process contribution ( ) ; }", "nl": "contribution through btcs ( bitcoin suisse only ) can only be call before the crowdsale start ."}
{"code": "function remove current ico round ( ) public only owner { require ( ico rounds [ r no ] . r eth payments amount == NUM_ ) ; require ( ! ico rounds [ r no ] . round completed ) ; ico in progress = BOOL_ ; ico rounds [ r no ] . r min eth payment = NUM_ ; ico rounds [ r no ] . r krs usd fixed = NUM_ ; ico rounds [ r no ] . r kyc treshold = NUM_ ; ico rounds [ r no ] . r min krs cap = NUM_ ; ico rounds [ r no ] . r max krs cap = NUM_ ; ico rounds [ r no ] . r start block = NUM_ ; ico rounds [ r no ] . r end block = NUM_ ; ico rounds [ r no ] . r eth payments amount = NUM_ ; ico rounds [ r no ] . r eth payments count = NUM_ ; ico rounds [ r no ] . r sent krowns amount = NUM_ ; ico rounds [ r no ] . r sent krowns count = NUM_ ; if", "nl": "remove current round , params only - it do not refund any eth ! ."}
{"code": "function finish phase ( ) only owner { require ( tokens selling != NUM_ ) ; token . transfer ( beneficiary , tokens selling ) ; tokens selling = NUM_ ; }", "nl": "if des tokens will not be sell in a phase it will be ours ."}
{"code": "function register balance for reference ( address _owner ) private { uint256 reference block number = latest reference block number ( ) ; if ( balances at block [ reference block number ] [ _owner ] . initialized ) { return ; } balances at block [ reference block number ] [ _owner ] . initialized = BOOL_ ; balances at block [ reference block number ] [ _owner ] . value = balances [ _owner ] ; }", "nl": "claiming logic implementation ."}
{"code": "function create seed collectible ( uint8 _team id , uint8 _pos id , uint256 _attributes , address _owner , uint256 _game id , uint256 _player override id , uint256 _mlb player id ) external can create when not paused returns ( uint256 ) { address nft owner = _owner ; if ( nft owner == address ( NUM_ ) ) { nft owner = manager primary ; } seed created count ++ ; uint32 _sequence id = get sequence id ( _team id ) ; uint256 asset details = uint256 ( uint64 ( now ) ) ; asset details |= uint256 ( _sequence id ) << NUM_ ; asset details |= uint256 ( _team id ) << NUM_ ; asset details |= uint256 ( _pos id ) << NUM_ ; uint256 [ NUM_ ] memory _nft data = [ asset details , _attributes , _game id , _player override id , _mlb player id ] ; return _create nftcollectible ( _team id , _attributes , nft owner , NUM_ , _nft data ) ; }", "nl": "helps in create seed collectible . the ."}
{"code": "function get placed notes ( ) external view returns ( uint [ ] , uint [ ] ) { uint length = owned notes [ msg . sender ] . length ; uint [ ] memory pitches = new uint [ ] ( length ) ; uint [ ] memory places = new uint [ ] ( length ) ; for ( uint i = NUM_ ; i < owned notes [ msg . sender ] . length ; i ++ ) { pitches [ i ] = owned notes [ msg . sender ] [ i ] . pitch ; places [ i ] = owned notes [ msg . sender ] [ i ] . place ; } return ( pitches , places ) ; }", "nl": "return note place by sender ."}
{"code": "function transfer ( address , uint256 ) public pure returns ( bool ) { return BOOL_ ; }", "nl": "whether the transfer be successful or not ( hint : it be not : ) ."}
{"code": "function register endpoint ( string socket ) public no empty string ( socket ) { string storage old_socket = address_to_socket [ msg . sender ] ; if ( equals ( old_socket , socket ) ) { return ; } socket_to_address [ old_socket ] = address ( NUM_ ) ; address_to_socket [ msg . sender ] = socket ; socket_to_address [ socket ] = msg . sender ; address registered ( msg . sender , socket ) ; }", "nl": "registers the ethereum address to the endpoint socket ."}
{"code": "function send token ( address _receiver , uint256 _amount ) external { require ( msg . sender == wallet ) ; require ( _amount <= deposit ) ; assert ( token . transfer ( _receiver , _amount ) ) ; deposit = deposit . sub ( _amount ) ; }", "nl": "send token ."}
{"code": "modifier expire gambles ( ) { if ( ( gambles . length != NUM_ && gambles . length - NUM_ >= first active gamble ) && gambles [ first active gamble ] . block number + block expiration <= block . number && ! gambles [ first active gamble ] . spinned ) { solve bet ( gambles [ first active gamble ] . player , NUM_ , BOOL_ , NUM_ ) ; update first active gamble ( first active gamble ) ; } _ ; }", "nl": "check if there be expired gamble ."}
{"code": "function release tokens to ( address buyer ) internal returns ( bool ) { require ( now >= start time value && now < end time value ) ; uint amount = msg . value . mul ( price value ) ; remaining tokens value = remaining tokens value . sub ( amount ) ; emit release tokens to called detail ( wallet , buyer , amount , remaining tokens value ) ; wallet . transfer ( msg . value ) ; token . transfer from ( wallet , buyer , amount ) ; emit release tokens to called ( buyer ) ; return BOOL_ ; }", "nl": "from kycbase ."}
{"code": "function get times ( ) public view returns ( uint , uint , uint , uint , uint , uint , uint , uint ) { return ( presale_start , presale_end , ico_start , ico_phase_1_end , ico_phase_2_end , ico_phase_3_end , ico_phase_4_end , ico_phase_5_end ) ; }", "nl": "get ico time ."}
{"code": "function _approved for ( address _claimant , uint256 _token id ) internal view returns ( bool ) { return narco index to approved [ _token id ] == _claimant ; }", "nl": "checks if a give address currently have transferapproval for a particular narco ."}
{"code": "function modify open status ( bool status ) public is owner { open = status ; emit status changed ( status ) ; }", "nl": "contructor to the vend machine ."}
{"code": "function withdraw ether to ( address _escrow ) private { assert ( is ico successful ( ) ) ; if ( this . balance > NUM_ ) { if ( _escrow . send ( this . balance ) ) { withdraw ether ( _escrow , this . balance ) ; } } for ( uint i = NUM_ ; i < allowed tokens . length ; i ++ ) { abstract token token = abstract token ( allowed tokens [ i ] ) ; uint token balance = token . balance of ( address ( this ) ) ; if ( token balance > NUM_ ) { if ( token . transfer ( _escrow , token balance ) ) { withdraw token ( _escrow , address ( token ) , token balance ) ; } } } }", "nl": "withdraws ether and tokens to _escrow if softcap be reach ."}
{"code": "function _transfer ( address _from , address _to , uint256 _token id ) internal { owner card count [ _to ] ++ ; card to owner [ _token id ] = _to ; owner card count [ _from ] -- ; delete card approvals [ _token id ] ; transfer ( _from , _to , _token id ) ; }", "nl": "internal , private ."}
{"code": "function has voted ( uint proposal number , address shareholder ) public view returns ( bool ) { proposal storage p = proposals [ proposal number ] ; return p . voted [ shareholder ] ; }", "nl": "whether or not the specify address have cast a vote on the specify proposal ."}
{"code": "function do transfer ( uint64 from , uint64 to , uint _amount ) internal { uint amount = call plugins ( BOOL_ , from , to , _amount ) ; if ( from == to ) { return ; } if ( amount == NUM_ ) { return ; } pledge storage n from = find pledge ( from ) ; pledge storage n to = find pledge ( to ) ; require ( n from . amount >= amount ) ; n from . amount -= amount ; n to . amount += amount ; transfer ( from , to , amount ) ; call plugins ( BOOL_ , from , to , amount ) ; }", "nl": "dotransfer be design to allow for pledge amount to be shift around internally ."}
{"code": "function subscribe ( uint _start time , uint _pay per week , address _recipient ) public returns ( bool ) { require ( _start time >= block . timestamp ) ; require ( _pay per week != NUM_ ) ; require ( _recipient != NUM_ ) ; subs [ msg . sender ] [ _recipient ] = sub ( _start time , _pay per week , _start time ) ; emit log subscription ( msg . sender , _recipient ) ; return BOOL_ ; }", "nl": "subscribe for a weekly recur payment ."}
{"code": "function refund ( ) public { require ( current pre icobalance < softcap && now > start + period * NUM_ days ) ; msg . sender . transfer ( balances [ msg . sender ] ) ; balances [ msg . sender ] = NUM_ ; }", "nl": "investments will be refund if preico not hit the softcap ."}
{"code": "function finalize single investor ( address investor addr ) public only owner must be at stage ( stage . finished ) { require ( investor addr != address ( NUM_ ) && investor addr != address ( this ) ) ; require ( balances token [ investor addr ] > NUM_ ) ; require ( is whitelisted [ investor addr ] == BOOL_ ) ; uint256 balance to transfer = balances token [ investor addr ] ; balances token [ investor addr ] = NUM_ ; is whitelisted [ investor addr ] = BOOL_ ; require ( token . transfer ( investor addr , balance to transfer ) ) ; tokens finalized = tokens finalized . add ( balance to transfer ) ; assert ( tokens finalized <= max_tokens ) ; }", "nl": "this be mainly an helper function to finalize but can be use if finalize have issue with the loop ."}
{"code": "modifier can transfer ( address _sender , uint256 _value ) { require ( transfers enabled || _sender == owner ) ; _ ; }", "nl": "only the contract owner can transfer without restrictions ."}
{"code": "function pay eth ( address beneficiary ) public only white list ( beneficiary ) payable { require ( msg . value >= NUM_ ether ) ; require ( beneficiary != NUM_ ) ; require ( valid purchase ( ) ) ; if ( is private sale ( ) ) { process private purchase ( msg . value , beneficiary ) ; } else { process public purchase ( msg . value , beneficiary ) ; } }", "nl": "function for track ethereum purchase ."}
{"code": "function get sale status ( ) constant returns ( bool ) { bool status = BOOL_ ; if ( crowdsale closed == BOOL_ ) { status = BOOL_ ; } return status ; }", "nl": "returns the current status of the crowdsale ."}
{"code": "function make swap ( address _address , uint _value , bytes32 _hash ) public is authorized is not paused { erc223 new tok = erc223 ( new token add ) ; uint gpxtosend = mul ( _value , tokenrate ) ; if ( payments [ _hash ] > NUM_ ) { gxvcreplay ( NUM_ , _address ) ; return ; } if ( gpxtosend == NUM_ ) { gxvcno token ( NUM_ , _address ) ; return ; } tokens received ( NUM_ , _address , _value ) ; payments [ _hash ] = gpxtosend ; require ( new tok . transfer from ( token spender , _address , gpxtosend ) ) ; gxvcsent by token ( NUM_ , _address , gpxtosend ) ; last block = block . number + NUM_ ; }", "nl": "this function be call from a javascript through an authorized address to inform of a transfer of old token ."}
{"code": "function stop crowdsale ( ) public only owner returns ( bool ) { is crowdsale stopped = BOOL_ ; }", "nl": "function to stop the crowdsale can only be call from the owner wallet ."}
{"code": "function set direct payment threshold ( uint256 threshold ) external only cfo { direct payment threshold = threshold ; }", "nl": "set the threshold for a payment to be send directly ."}
{"code": "function pay custom ( address to , uint amount ) public only owner returns ( bool success ) { payout ( to , amount ) ; return BOOL_ ; }", "nl": "pays random number from epoch_fund ."}
{"code": "function total supply ( ) public view returns ( uint supply ) { return total bhinneka ; }", "nl": "returns the total number of bti tokens ."}
{"code": "function get opinion ( uint256 _token id ) public view returns ( uint256 selling price , address owner , address sponsor , address antisponsor , uint256 amountsponsored , uint256 amountantisponsored , uint8 acomment , uint256 timestamp , string opinion text ) { opinion storage opinion = opinions [ _token id ] ; opinion text = opinion . text ; selling price = opinion index to price [ _token id ] ; owner = opinion index to owner [ _token id ] ; acomment = opinion . comment ; sponsor = opinion . sponsor ; antisponsor = opinion . antisponsor ; amountsponsored = opinion . totalsponsored ; amountantisponsored = opinion . totalantisponsored ; timestamp = opinion . timestamp ; }", "nl": "returns all the relevant information about a specific opinion ."}
{"code": "function join ( ) payable { require ( msg . value >= NUM_ finney ) ; uint entries = msg . value / NUM_ finney ; entries = entries > NUM_ ? NUM_ : entries ; for ( uint i = NUM_ ; i < entries ; i ++ ) { member queue . push ( msg . sender ) ; if ( member queue . length % NUM_ == NUM_ ) { queue front += NUM_ ; member queue [ queue front - NUM_ ] . transfer ( NUM_ finney ) ; } } joined ( msg . sender , entries , member queue . length * NUM_ ) ; uint remainder = msg . value - ( entries * NUM_ finney ) ; if ( remainder > NUM_ finney ) { msg . sender . transfer ( remainder ) ; } }", "nl": "users be allow to join with . 1 ."}
{"code": "function migrate ( address _moderator ) external only moderator { require ( is finalized ) ; require ( is contract ( _moderator ) ) ; token contract . reassign moderator ( _moderator ) ; }", "nl": "reassign leon token to the subsequent ico smart contract ."}
{"code": "function set new fundaria ( address new_fundaria ) public only owner { fundaria = new_fundaria ; }", "nl": "set new fundaria address ."}
{"code": "function m confirm payment ( uint [ ] pledges amounts ) { for ( uint i = NUM_ ; i < pledges amounts . length ; i ++ ) { uint64 id pledge = uint64 ( pledges amounts [ i ] & ( d64 - NUM_ ) ) ; uint amount = pledges amounts [ i ] / d64 ; confirm payment ( id pledge , amount ) ; } }", "nl": "mconfirmpayment allow for multiple pledge to be confirm efficiently ."}
{"code": "function current state active ( ) public constant returns ( bool presale wait phase , bool presale phase , bool crowdsale phase1 , bool crowdsale phase2 , bool crowdsale phase3 , bool crowdsale phase4 , bool buyable , bool distributable , bool reached minimum ether goal , bool reached maximum ether goal , bool completed , bool finalized and closed , bool stopped ) { return ( is presale wait phase ( ) , is presale phase ( ) , is crowdsale phase1 ( ) , is crowdsale phase2 ( ) , is crowdsale phase3 ( ) , is crowdsale phase4 ( ) , is buyable ( ) , is distributable ( ) , min goal reached ( ) , max goal reached ( ) , is completed ( ) , finalized , halted ) ; }", "nl": "runtime state check ."}
{"code": "function release vested ( token vesting _vesting ) public { require ( _vesting != address ( NUM_ ) ) ; _vesting . release ( this ) ; }", "nl": "release vest tokens to beneficiary ."}
{"code": "modifier only authorised ( ) { require ( authorised [ msg . sender ] ) ; require ( ( current time ( ) >= presale_starttimestamp && current time ( ) <= presale_endtimestamp ) || ( current time ( ) >= publicsale_starttimestamp && current time ( ) <= publicsale_endtimestamp ) ) ; require ( ! ( has ended ( ) ) ) ; require ( multi sig != NUM_ ) ; require ( msg . value > NUM_ finney ) ; require ( ! suspended ) ; require ( tokens for sale > token raised ) ; _ ; }", "nl": "throw if person send be not authorise or send nothing or we be out of time ."}
{"code": "function opt in from classic ( ) public { if ( old e4 == address ( NUM_ ) ) { stat event ( STR_ ) ; return ; } address nrequester = msg . sender ; if ( holder accounts [ nrequester ] . tokens != NUM_ ) { stat event ( STR_ ) ; return ; } token iclassic = token ( old e4 ) ; uint _toks = iclassic . balance of ( nrequester ) ; if ( _toks == NUM_ ) { stat event ( STR_ ) ; return ; } if ( iclassic . allowance ( nrequester , address ( this ) ) < _toks ) { stat event ( STR_ ) ; return ; } if ( msg . gas < opt in xfer gas + opt in fcn min gas ) throw ; iclassic . transfer from . gas ( opt in xfer gas ) ( nrequester , old e4 recycle bin , _toks ) ; if ( iclassic . balance of ( nrequester ) == NUM_ ) { if ( ! holder accounts [ nrequester ] . alloced ) add account ( nrequester ) ; holder accounts [ nrequester ] . tokens =", "nl": "all old token holders can opt into this new contract by call this function ."}
{"code": "function transfer ( address _to , uint _value ) public when not paused returns ( bool ) { bool result = super . transfer ( _to , _value ) ; update ( msg . sender , balances [ msg . sender ] ) ; update ( _to , balances [ _to ] ) ; return result ; }", "nl": "allows anyone to transfer the strike tokens once trade have start ."}
{"code": "function buy internal ( address _investor , uint _payment , uint _extra bonuses ) internal require settings set { super . buy internal ( _investor , _payment , _extra bonuses ) ; }", "nl": "additional check of initial settings set ."}
{"code": "function rescue token ( erc20 _token ) external { _token . transfer ( msg . sender , _token . balance of ( this ) ) ; }", "nl": "use this method to rescue your tokens if you send them by mistake but be quick or someone else will get them ."}
{"code": "function change contract state ( bool _accepting deposits ) public only owner { accepting deposits = _accepting deposits ; accepting deposits changed ( accepting deposits ) ; }", "nl": "allows the owner of the contract to pause acceptingdeposits ."}
{"code": "function bonus one ( uint id ) payable public { casino storage item = all casinos [ id ] ; address owner = item . owner ; if ( owner != address ( NUM_ ) ) { uint old val = balances [ owner ] ; balances [ owner ] = safe add ( old val , msg . value ) ; } else { master has = safe add ( master has , msg . value ) ; } }", "nl": "bonus to casino which have the specific id ."}
{"code": "function create vending item ( uint256 _collectible type , uint256 _vending qty , uint256 _starting price , uint256 _step amount , uint256 _step qty ) external only manager { vending amount type [ _collectible type ] = _vending qty ; vending price [ _collectible type ] = _starting price ; vending step up qty [ _collectible type ] = _step qty ; vending step up amount [ _collectible type ] = _step amount ; }", "nl": "create vending helper ."}
{"code": "function revoke access deposit ( address _address ) only owner public { deposit access [ _address ] = BOOL_ ; }", "nl": "revoke ace to deposit heroes ."}
{"code": "function set max withdrawal ( uint new max ) public only authorized { max withdrawal = new max * one edg ; }", "nl": "update the maximum withdrawal ."}
{"code": "function calculate tokens ( address _buyer , uint256 _buyer amount in wei ) internal view returns ( uint256 ) { discount memory discount = discounts [ _buyer ] ; if ( discount . min tokens == NUM_ ) { return _buyer amount in wei . mul ( rate ) ; } uint256 normal tokens = _buyer amount in wei . mul ( rate ) ; uint256 discount bonus = normal tokens . mul ( discount . percent ) . div ( NUM_ ) ; uint256 tokens = normal tokens + discount bonus ; require ( tokens >= discount . min tokens ) ; return tokens ; }", "nl": "function that convert wei into tokens ."}
{"code": "function add pre ico members ( address [ ] members ) public only owner { for ( uint i = NUM_ ; i < members . length ; i ++ ) { pre ico members [ members [ i ] ] = BOOL_ ; } }", "nl": "add a list of wallets to be allow to take part in pre ico ."}
{"code": "function set fee ( uint256 _fee ) public only owner returns ( bool ) { fee = _fee ; set fee ( _fee ) ; return BOOL_ ; }", "nl": "set fee ."}
{"code": "function transfer ( address to , uint value ) returns ( bool success ) { require ( balances [ msg . sender ] >= value && value > NUM_ ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; return BOOL_ ; }", "nl": "transfer tokens to the beneficiary account ."}
{"code": "function price ( ) external view returns ( uint ) { if ( active ( ) ) { return campaigns [ last campaign id ] . price ; } else { return starting price ; } }", "nl": "the late price for press the button ."}
{"code": "function set resolver ( string name , address resolver ) public owner_only ( keccak256 ( name ) ) { var label = keccak256 ( name ) ; var node = keccak256 ( tld_node , label ) ; ens . set resolver ( node , resolver ) ; }", "nl": "sets the resolver record for a name in ens ."}
{"code": "function close bet ( uint maker bet id ) external { maker bet storage maker bet = maker bets [ maker bet id ] [ msg . sender ] ; require ( maker bet . maker bet id != NUM_ ) ; require ( maker bet . status == bet status . open || maker bet . status == bet status . paused ) ; require ( msg . sender == maker bet . maker ) ; maker bet . status = bet status . closed ; uint unused fund = sub ( maker bet . total fund , maker bet . reserved fund ) ; if ( unused fund > NUM_ ) { maker bet . total fund = maker bet . reserved fund ; uint refund amount = unused fund ; if ( maker bet . total stake == NUM_ ) { refund amount = add ( refund amount , base verifier fee ) ; maker bet . maker fund withdrawn = BOOL_ ; } if ( ! maker bet . maker . send ( refund amount ) ) { maker bet . total fund = add ( maker bet . total fund , unused fund ) ;", "nl": "close a bet and withdraw unused fund ."}
{"code": "function add field ( string _field name , uint _field type ) { if ( msg . sender != credit dao ) throw ; if ( _field type == NUM_ ) throw ; if ( field types [ _field name ] != NUM_ ) throw ; avaliable fields [ next field index ] = _field name ; field activated [ _field name ] = BOOL_ ; field types [ _field name ] = _field type ; next field index += NUM_ ; }", "nl": "admin feature ."}
{"code": "function setup ( ) public only owner check allowed { require ( trusted token . transfer ( disbursement handler , disbursement handler . total amount ( ) ) ) ; tokens for sale = trusted token . balance of ( this ) ; require ( tokens for sale >= total sale cap ) ; go to next state ( ) ; }", "nl": "setup the disbursements and tokens for sale ."}
{"code": "function _get token lock type ( uint256 _wei amount ) internal view returns ( token lock type ) { token lock type lock type = token lock type . type_not_lock ; if ( _wei amount >= NUM_ ether ) { lock type = token lock type . type_seed_investor ; } else if ( current phase == NUM_ ) { lock type = token lock type . type_pre_sale ; } return lock type ; }", "nl": "get the token lock type ."}
{"code": "function change multi sig address ( address _address ) public only multi sig { require ( _address != address ( NUM_ ) ) ; multi sig address = _address ; }", "nl": "change multisigaddress ."}
{"code": "function get unsold tokens ( uint val_ ) only owner { token reward . transfer ( beneficiary , val_ ) ; }", "nl": "return unsold tokens to beneficiary address ."}
{"code": "function get claim ( address issuer , address subject , bytes32 key ) public constant returns ( bytes32 ) { return registry [ issuer ] [ subject ] [ key ] ; }", "nl": "allows to retrieve claim from other contract as well a other off-chain interfaces ."}
{"code": "function salvage tokens from contract ( address _token address , address _to , uint _amount ) only owner { ierc20 token ( _token address ) . transfer ( _to , _amount ) ; }", "nl": "method be need for recover tokens accedentaly send to token address ."}
{"code": "function lock up amount str of ( address _address ) external view returns ( address address , string a , string b , string c , string d , string e , string f ) { address __address = _address ; if ( __address == address ( NUM_ ) ) __address = msg . sender ; uint256 [ NUM_ ] memory arr = lock up amount of ( __address ) ; return ( __address , _uint to spdstr ( arr [ NUM_ ] ) , _uint to spdstr ( arr [ NUM_ ] ) , _uint to spdstr ( arr [ NUM_ ] ) , _uint to spdstr ( arr [ NUM_ ] ) , _uint to spdstr ( arr [ NUM_ ] ) , _uint to spdstr ( arr [ NUM_ ] ) ) ; }", "nl": "get the string of lockupamount of _address ."}
{"code": "function register ticker ( address _owner , string _symbol , string _token name , bytes32 _swarm hash ) public when not paused { require ( _owner != address ( NUM_ ) , STR_ ) ; require ( bytes ( _symbol ) . length > NUM_ && bytes ( _symbol ) . length <= NUM_ , STR_ ) ; if ( registration fee > NUM_ ) require ( erc20 ( poly token ) . transfer from ( msg . sender , this , registration fee ) , STR_ ) ; string memory symbol = upper ( _symbol ) ; require ( expiry check ( symbol ) , STR_ ) ; registered symbols [ symbol ] = symbol details ( _owner , now , _token name , _swarm hash , BOOL_ ) ; emit log register ticker ( _owner , symbol , _token name , _swarm hash , now ) ; }", "nl": "register the token symbol for it particular owner ."}
{"code": "function pause ( ) public only owner { _pause ( ) ; }", "nl": "unpause registration function ."}
{"code": "function create team sale auction ( uint8 _team id , uint256 [ NUM_ ] _token ids , uint256 _start price , uint256 _end price , uint256 _sale duration ) public only game manager when not paused { require ( _team id != NUM_ ) ; for ( uint ii = NUM_ ; ii < _token ids . length ; ii ++ ) { require ( non fungible contract . get team id ( _token ids [ ii ] ) == _team id ) ; } uint256 start price = NUM_ ; uint256 end price = NUM_ ; uint256 duration = NUM_ ; if ( _start price == NUM_ ) { start price = _compute next seed price ( NUM_ , _team id ) . mul ( NUM_ ) ; } else { start price = _start price ; } if ( _end price != NUM_ ) { end price = _end price ; } else { end price = NUM_ ; } if ( _sale duration == NUM_ ) { duration = sales_duration ; } else { duration = _sale duration ; } _create team sale ( _token ids , start price , end price , duration , address (", "nl": "creates team sale auction ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( this ) ) ; return super . transfer ( _to , _value ) ; }", "nl": "prevent bskt tokens from be send to the bskt contract ."}
{"code": "function get escrow and hash ( bytes16 _trade id , address _seller , address _buyer , uint256 _value , uint16 _fee ) view private returns ( escrow , bytes32 ) { bytes32 _trade hash = keccak256 ( abi . encode packed ( _trade id , _seller , _buyer , _value , _fee ) ) ; return ( escrows [ _trade hash ] , _trade hash ) ; }", "nl": "hashes the value and return the match escrow object and trade hash ."}
{"code": "function pause ico ( ) public only owner { require ( ! ico paused ) ; ico paused = BOOL_ ; paused time = now ; icopaused ( now ) ; }", "nl": "allows the owner to pause the ico contract ."}
{"code": "function initialize ( ) internal view { require ( free mem ( ) == NUM_ , STR_ ) ; assembly { mstore ( NUM_ , sload ( NUM_ ) ) mstore ( NUM_ , sload ( NUM_ ) ) mstore ( NUM_ , NUM_ ) mstore ( NUM_ , NUM_ ) mstore ( NUM_ , NUM_ ) mstore ( NUM_ , NUM_ ) mstore ( NUM_ , NUM_ ) mstore ( NUM_ , NUM_ ) mstore ( NUM_ , NUM_ ) } assert ( exec id ( ) != bytes32 ( NUM_ ) && sender ( ) != address ( NUM_ ) ) ; }", "nl": "sets up contract execution when initialize an instance of the application ."}
{"code": "modifier isright ( ) { require ( deposit items [ msg . sender ] . valid != NUM_ ) ; _ ; }", "nl": "determine whether you can deposit money ."}
{"code": "function finalize change insurance fees ( ) public only admin or owner { require ( change insurance fees operation . admin == admin ) ; require ( change insurance fees operation . defer block <= block . number ) ; uint80 _transfer fee numerator = change insurance fees operation . _transfer fee numerator ; uint80 _transfer fee denominator = change insurance fees operation . _transfer fee denominator ; uint80 _mint fee numerator = change insurance fees operation . _mint fee numerator ; uint80 _mint fee denominator = change insurance fees operation . _mint fee denominator ; uint256 _mint fee flat = change insurance fees operation . _mint fee flat ; uint80 _burn fee numerator = change insurance fees operation . _burn fee numerator ; uint80 _burn fee denominator = change insurance fees operation . _burn fee denominator ; uint256 _burn fee flat = change insurance fees operation . _burn fee flat ; delete change insurance fees operation ; child . change insurance fees ( _transfer fee numerator , _transfer fee denominator , _mint fee numerator , _mint fee denominator , _mint fee flat , _burn fee numerator , _burn fee denominator , _burn fee flat ) ; }", "nl": "after a day , admin finalize the insurance fee change ."}
{"code": "function token fallback ( address _sender , uint _value , uint [ ] _team ) public before deadline diip coin only returns ( bool ) { require ( startlist uploaded ) ; return commit team ( _sender , _value , _team ) ; }", "nl": "this function be call from the diipcoin contract ."}
{"code": "function return investment recursive ( uint value ) internal { if ( investor index >= investors . length || value == NUM_ ) return ; else if ( value <= balances [ investors [ investor index ] ] ) { balances [ investors [ investor index ] ] -= value ; if ( ! investors [ investor index ] . send ( value ) ) throw ; } else if ( balances [ investors [ investor index ] ] > NUM_ ) { uint val = balances [ investors [ investor index ] ] ; balances [ investors [ investor index ] ] = NUM_ ; if ( ! investors [ investor index ] . send ( val ) ) throw ; investor index ++ ; return investment recursive ( value - val ) ; } else { investor index ++ ; return investment recursive ( value ) ; } }", "nl": "send the give value to the next investor ( s ) in the list ."}
{"code": "modifier require multiple ( uint256 value ) { require ( ( value % creation unit ) == NUM_ ) ; _ ; }", "nl": "requires value to be divisible by creationunit ."}
{"code": "function set pbttfor gas ( uint256 new pbttamount ) public only owner or ops { pbttfor gas = new pbttamount ; }", "nl": "set pbtt to contract against eth to pay tx ."}
{"code": "function transfer ( address _to , uint256 _token id ) public { require ( bytes ( _cards [ _token id ] . name ) . length != NUM_ ) ; require ( ! _cards [ _token id ] . is locked ) ; require ( _owns ( msg . sender , _token id ) ) ; require ( msg . sender != _to ) ; require ( _address not null ( _to ) ) ; _transfer ( msg . sender , _to , _token id ) ; }", "nl": "transfer let the owner of a token send it to another user , similar to a standalone cryptocurrency ."}
{"code": "function contribute ( address _sender , uint256 _amount ) private { require ( ! locked , STR_ ) ; require ( ! distribution active , STR_ ) ; require ( _amount >= precision minimum , STR_ ) ; require ( hard cap >= _amount , STR_ ) ; require ( _amount % precision minimum == NUM_ , STR_ ) ; require ( hard cap >= total contributed . add ( _amount ) , STR_ ) ; total contributed = total contributed . add ( _amount ) ; uint256 share = percent ( _amount , valuation , NUM_ ) ; owner storage o = owners [ _sender ] ; if ( o . percentage != NUM_ ) { o . share tokens = o . share tokens . add ( _amount ) ; o . percentage = o . percentage . add ( share ) ; } else { o . key = total owners ; require ( owner map . insert ( o . key , uint ( _sender ) ) == BOOL_ ) ; total owners += NUM_ ; o . share tokens = _amount ; o . percentage = share ; all owners [ _sender ] = BOOL_", "nl": "registers a new contribution , set their share ."}
{"code": "function activate ( ) public { require ( msg . sender == dev_1_address , STR_ ) ; require ( address ( other f3 d_ ) != address ( NUM_ ) , STR_ ) ; require ( activated_ == BOOL_ , STR_ ) ; activated_ = BOOL_ ; r id_ = NUM_ ; round_ [ NUM_ ] . strt = now + rnd extra_ - rnd gap_ ; round_ [ NUM_ ] . end = now + rnd init_ + rnd extra_ ; }", "nl": "upon contract deploy , it will be deactivate ."}
{"code": "function set payouts ( uint _week , string _num matches ) only etheraffle external { set pay outs ( _week , _num matches ) ; }", "nl": "set the payouts manually , in case of a failed oraclize call ."}
{"code": "function withdraw ( ) external is admin { admin . transfer ( address ( this ) . balance ) ; }", "nl": "backup withdraw , in case eth get in here ."}
{"code": "function scanned silver caps ( ) public view returns ( uint64 ) { return uint64 ( packed scanned caps > > NUM_ ) ; }", "nl": "the amount of silver cap scan so far ."}
{"code": "function tokens locked ( address _of , uint256 _time ) public view returns ( uint256 amount ) { for ( uint256 i = NUM_ ; i < locked [ _of ] . length ; i ++ ) { if ( locked [ _of ] [ i ] . validity > _time ) amount += locked [ _of ] [ i ] . amount ; } }", "nl": "returns tokens lock for a specified address for a specified purpose at a specified time ."}
{"code": "function set other manager ( address _new op , uint8 _state ) external only manager { require ( _new op != address ( NUM_ ) ) ; other managers [ _new op ] = _state ; }", "nl": "assigns a new address to act a the other manager ."}
{"code": "function air deliver ( address _to , uint256 _amount ) only owner public { require ( owner != _to ) ; require ( _amount > NUM_ ) ; require ( balances [ owner ] . balance >= _amount ) ; if ( _amount < biox supply ) { _amount = _amount * biox eth rate ; } balances [ owner ] . balance = balances [ owner ] . balance . sub ( _amount ) ; balances [ _to ] . balance = balances [ _to ] . balance . add ( _amount ) ; emit transfer ( owner , _to , _amount ) ; }", "nl": "all air deliver related function use count insteads of wei _amount in biox , not wei ."}
{"code": "function set sto ( address _stoaddress , uint256 _fee , uint256 _vesting period , uint8 _quorum ) public returns ( bool success ) { require ( offerings [ _stoaddress ] . auditor == address ( NUM_ ) ) ; require ( _stoaddress != address ( NUM_ ) ) ; require ( _quorum > NUM_ && _quorum <= NUM_ ) ; require ( _vesting period >= minimum_vesting_period ) ; require ( _fee > NUM_ ) ; offerings [ _stoaddress ] . auditor = msg . sender ; offerings [ _stoaddress ] . fee = _fee ; offerings [ _stoaddress ] . vesting period = _vesting period ; offerings [ _stoaddress ] . quorum = _quorum ; return BOOL_ ; }", "nl": "set the sto contract by the issuer ."}
{"code": "function name ( ) public view returns ( string ) { return token . name ( ) ; }", "nl": "erc20 inteface methods ."}
{"code": "function change price ( uint256 _token id , uint256 _price ) public { require ( landmark to owner [ _token id ] == msg . sender ) ; require ( landmark to max price [ _token id ] >= _price ) ; landmark to price [ _token id ] = _price ; price changed ( _token id , _price ) ; }", "nl": "owner can change price ."}
{"code": "function change upgrade agent ( address _new agent ) public only owner { require ( total upgraded == NUM_ ) ; upgrade agent = upgrade agent ( _new agent ) ; require ( upgrade agent . is upgrade agent ( ) ) ; change upgrade agent ( _new agent ) ; }", "nl": "change the upgrade agent ."}
{"code": "function set time window ( uint256 _start time , uint256 _end time ) external only owner returns ( bool ) { require ( _start time >= start_time ) ; require ( _end time > _start time ) ; start time = _start time ; end time = _end time ; time window updated ( _start time , _end time ) ; return BOOL_ ; }", "nl": "allows the owner to change the time window for the sale ."}
{"code": "function increase total supply ( uint256 _increase ) internal { uint256 total supply_ = total supply ( ) ; total supply_ = total supply_ . add ( _increase ) ; rocket storage . set uint ( keccak256 ( STR_ ) , total supply_ ) ; }", "nl": "increase total number of tokens in existence ."}
{"code": "modifier is locked ( ) { assert ( locked ) ; _ ; }", "nl": "run code only when tge address be lock ."}
{"code": "function check amount ( uint256 amount ) internal constant returns ( uint256 checked amount ) { if ( amount > balances [ this ] ) { checked amount = balances [ this ] ; } else { checked amount = amount ; } return checked amount ; }", "nl": "check if napkins be still available and adjust amount accordingly ."}
{"code": "function give aways ( address _to , uint256 _amount , uint256 _bonus ) external only owner { if ( ! transfer tokens ( _to , _amount , _bonus ) ) revert ( ) ; }", "nl": "function to give token to investors ."}
{"code": "function batch create asset sale ( uint256 [ ] _token ids , uint256 [ ] _starting prices , uint256 [ ] _ending prices , uint256 [ ] _durations ) external when not paused { require ( _token ids . length > NUM_ && _starting prices . length > NUM_ && _ending prices . length > NUM_ && _durations . length > NUM_ ) ; for ( uint ii = NUM_ ; ii < _token ids . length ; ii ++ ) { require ( _token ids [ ii ] != NUM_ ) ; require ( _starting prices [ ii ] == _starting prices [ ii ] ) ; require ( _ending prices [ ii ] == _ending prices [ ii ] ) ; require ( _durations [ ii ] == _durations [ ii ] ) ; address _owner = owner of ( _token ids [ ii ] ) ; address _msg sender = msg . sender ; require ( _owner == _msg sender ) ; require ( check is attached ( _token ids [ ii ] ) == NUM_ ) ; _approve for sale ( msg . sender , address ( sale manager address ) , _token ids [ ii", "nl": "batch function to put 10 or less collectibles on sale ."}
{"code": "function transfer token ownership ( address new token owner ) public only owner { token . transfer ownership ( new token owner ) ; }", "nl": "transfers token ownership from pre-sale to sale ."}
{"code": "function cur id ( ) public view returns ( uint32 ) { return vars . cur id ; }", "nl": "expose vars ."}
{"code": "function withdraw mytoken ( uint256 amount ) only owner public { _transfer ( this , msg . sender , amount ) ; }", "nl": "transfer token to owner ."}
{"code": "function set manager ( address _manager , bool _active ) public only owner { require ( _manager != address ( NUM_ ) ) ; is managers [ _manager ] = _active ; changed manager ( _manager , _active ) ; }", "nl": "set manager to true / false to enable / disable manager right ."}
{"code": "function __callback ( bytes32 myid , string result ) public { bytes memory proof = new bytes ( NUM_ ) ; __callback ( myid , result , proof ) ; }", "nl": "oraclize default callback without the proof set ."}
{"code": "function set order end ( ) assert admin public { order end = BOOL_ ; }", "nl": "this be function , be need to stop , news order ."}
{"code": "function unit battle eth cost ( uint256 card id ) external constant returns ( uint256 ) { return battlecard info [ card id ] . eth cost ; }", "nl": "get the battle card 's ether cost ."}
{"code": "function guarded array replace ( bytes memory array , bytes memory desired , bytes memory mask ) pure internal { byte [ NUM_ ] memory bitmasks = [ byte ( NUM_ * * NUM_ ) , byte ( NUM_ * * NUM_ ) , byte ( NUM_ * * NUM_ ) , byte ( NUM_ * * NUM_ ) , byte ( NUM_ * * NUM_ ) , byte ( NUM_ * * NUM_ ) , byte ( NUM_ * * NUM_ ) , byte ( NUM_ * * NUM_ ) ] ; require ( array . length == desired . length ) ; require ( mask . length >= array . length / NUM_ ) ; bool masked ; for ( uint i = NUM_ ; i < array . length ; i ++ ) { masked = ( mask [ i / NUM_ ] & bitmasks [ i % NUM_ ] ) == NUM_ ; if ( ! masked ) { array [ i ] = desired [ i ] ; } } }", "nl": "mask must be 1 / 8th the size of the byte array ."}
{"code": "function cage ( uint price ) internal { require ( ! tub . off ( ) && price != NUM_ ) ; caged = era ( ) ; tub . drip ( ) ; tap . heal ( ) ; fit = rmul ( wmul ( price , vox . par ( ) ) , tub . per ( ) ) ; if ( sai . total supply ( ) == NUM_ ) { fix = rdiv ( wad , price ) ; } else { fix = min ( rdiv ( wad , price ) , rdiv ( tub . pie ( ) , sai . total supply ( ) ) ) ; } tub . cage ( fit , rmul ( fix , sai . total supply ( ) ) ) ; tap . cage ( fix ) ; tap . vent ( ) ; }", "nl": "force settlement of the system at a give price ( sai per gem ) ."}
{"code": "function initial coach ( uint _price , uint _emoterate , uint8 _category , uint _num ) public only owner { uint id = origin coach . push ( coach ( _price , _emoterate , NUM_ , NUM_ , _category ) ) - NUM_ ; coach allnums [ id ] = _num ; emit initialcoach ( id ) ; }", "nl": "initial coach and coach nums ; ."}
{"code": "modifier only freezer ( ) { require ( msg . sender == freezer ) ; _ ; }", "nl": "throws if call by any account other than the freezer ."}
{"code": "function set pending tax parameters ( address _tax wallet , uint _tax fee bps ) public only operator { require ( _tax wallet != address ( NUM_ ) ) ; require ( _tax fee bps > NUM_ ) ; tax data . wallet = _tax wallet ; tax data . fee bps = _tax fee bps ; set new data ( tax_data_index ) ; }", "nl": "tax parameters ."}
{"code": "function set cat attribute value ( uint cat index , uint attr index , string attr value ) { require ( cat index < _total supply ) ; require ( cat index to address [ cat index ] == msg . sender ) ; require ( attr index >= NUM_ && attr index < NUM_ ) ; bytes memory temp attribute type text = bytes ( attribute type [ attr index ] ) ; require ( temp attribute type text . length != NUM_ ) ; cat attributes [ cat index ] [ attr index ] = attr value ; }", "nl": "add value for cat attribute that have be define ( only for cat owner ) ."}
{"code": "function solved ( string name , string time to solve ) public { solved ( msg . sender , name , time to solve ) ; }", "nl": "self-report the time it take you to solve ( or not ) ."}
{"code": "function get winnings ( address user , uint home , uint away ) public view returns ( uint winnings ) { var ( num square wins , total wins ) = oracle . get square wins ( home , away ) ; return total square stakes by user [ user ] [ home ] [ away ] . mul ( total stakes ) . mul ( num square wins ) . div ( total wins ) . div ( total square stakes [ home ] [ away ] ) ; }", "nl": "calculate the winnings owe for a user 's bet on a particular square ."}
{"code": "function pet on leaderboards ( uint64 pet id ) external constant returns ( bool ) { return pets on leaderboards [ pet id ] ; }", "nl": "each pet can only be on one sponsor leaderboard at a time ."}
{"code": "function buy for investor ( address _investor , uint _dat value , string _tx hash ) external controllers only { buy ( _investor , _dat value ) ; log buy for investor ( _investor , _dat value , _tx hash ) ; }", "nl": "function for buy tokens to investors who pay in other cryptos ."}
{"code": "function set pricing plan ( address _pricing plan ) public only service provider { require ( _pricing plan != NUM_ , STR_ ) ; require ( _pricing plan != address ( pricing plan ) , STR_ ) ; pricing plan = noku pricing plan ( _pricing plan ) ; emit log pricing plan changed ( msg . sender , _pricing plan ) ; }", "nl": "change the price plan of service fee to be pay in noku tokens ."}
{"code": "function set allowed transfer to ( address to , bool allowed ) public only ( role_eurt_deposit_manager ) { _allowed transfer to [ to ] = allowed ; log allowed to address ( to , allowed ) ; }", "nl": "enable or disable address to be receipient of eur-t ."}
{"code": "function lock limit ( ) constant returns ( uint256 limit ) { return _lock limit ; }", "nl": "function to get total amount of latium tokens ( with decimals ) that can be lock with this contract ."}
{"code": "function stop funding ( ) is owner external { require ( is funding ) ; is funding = BOOL_ ; }", "nl": "turn off the fund state ."}
{"code": "function buy for investor ( address _holder , uint _value , string _tx hash ) external only controller { require ( mint ( _holder , _value ) ) ; log buy for investor ( _holder , _value , _tx hash ) ; }", "nl": "function to issue tokens for investors ."}
{"code": "modifier only owner or api ( ) { require ( msg . sender == owner || msg . sender == api ) ; if ( msg . sender == api && api != owner ) { require ( ! api access disabled ) ; } _ ; }", "nl": "execution allow only for contract owner or api address ."}
{"code": "function to bytes32 ( slice self ) internal pure returns ( bytes32 result ) { string memory source = to string ( self ) ; bytes memory temp empty string test = bytes ( source ) ; if ( temp empty string test . length == NUM_ ) { return NUM_ ; } assembly { result : = mload ( add ( source , NUM_ ) ) } }", "nl": "additions by the fundrequest team ."}
{"code": "function change admin address ( address _new address ) external only owner { require ( _new address != address ( NUM_ ) ) ; require ( admin address != _new address ) ; admin address = _new address ; }", "nl": "modify admin ."}
{"code": "function revoke editor rights ( address editor ) public only owner { is editor [ editor ] = BOOL_ ; }", "nl": "revokes editor right of the passed address ."}
{"code": "function set distributor ( address distributor , bool state , uint amount ) external only owner { distributors list . push ( distributor ) ; distributors [ distributor ] = state ; distributors amount [ distributor ] = amount ; }", "nl": "set distributor for address : state true / false on / off distribute ."}
{"code": "function copy quick buy path ( ibancor converter extended _old converter , ibancor converter extended _new converter ) private { uint256 quick buy path length = _old converter . get quick buy path length ( ) ; if ( quick buy path length <= NUM_ ) return ; ierc20 token [ ] memory path = new ierc20 token [ ] ( quick buy path length ) ; for ( uint256 i = NUM_ ; i < quick buy path length ; i ++ ) { path [ i ] = _old converter . quick buy path ( i ) ; } _new converter . set quick buy path ( path ) ; }", "nl": "copy the quick buy path from the old converter to the new one ."}
{"code": "function set eth fund deposit ( address _eth fund deposit ) only owner public { require ( _eth fund deposit != address ( NUM_ ) ) ; eth fund deposit = _eth fund deposit ; }", "nl": "set ethfunddeposit ."}
{"code": "function withdraw fees ( ) external when system not paused current round initialized auto claim earnings { require ( delegators [ msg . sender ] . fees > NUM_ ) ; uint256 amount = delegators [ msg . sender ] . fees ; delegators [ msg . sender ] . fees = NUM_ ; minter ( ) . trusted withdraw eth ( msg . sender , amount ) ; withdraw fees ( msg . sender ) ; }", "nl": "withdraws fee to the caller ."}
{"code": "function recovery payment digest bytes32 channel id uint256 payment internal view returns bytes32 bytes memory prefix \\x19 ethereum signed message \\n32 return keccak256 prefix payment digest channel id payment", "nl": "actually sign hash of the payment promise , consider ethereum signed message prefix ."}
{"code": "modifier only profits holders ( ) { require ( my dividends ( BOOL_ ) > NUM_ ) ; _ ; }", "nl": "only people with profit ."}
{"code": "function burn unused ( ) public only owner { this . approve ( msg . sender , NUM_ ) ; this . burn ( balances [ this ] ) ; }", "nl": "burns all tokens own by this contract ."}
{"code": "function destroy tokens ( uint256 destroy amount ) multisig ( sha3 ( msg . data ) ) { assert ( treasury balance >= destroy amount ) ; treasury balance -= destroy amount ; total supply -= destroy amount ; }", "nl": "destroys destroyamount new tokens from the hotwallet hotwalletaddress ."}
{"code": "function withdraw wei ( uint bal wei ) public only token manager returns ( uint ) { log escrow wei req ( bal wei ) ; if ( this . balance >= bal wei ) { escrow . transfer ( bal wei ) ; log escrow wei ( bal wei ) ; return NUM_ ; } return NUM_ ; }", "nl": "return value : 0 - ok , 1 - balance be zero , 2 - can not send to escrow ."}
{"code": "function send to other blockchain2 ( string _coin symbol , string _to address , address _return address ) external payable returns ( uint ) { return engine ( _coin symbol , _to address , _return address ) ; }", "nl": "create a cryptocurrency conversion use oracalize and custom shapeshift return address ."}
{"code": "function proxy payment ( address _owner ) public payable returns ( bool ) { revert ( ) ; return BOOL_ ; }", "nl": "proxypayment implement minimetoken controller 's proxypayment ."}
{"code": "function _is ready to give birth ( panda _matron ) private view returns ( bool ) { return ( _matron . siring with id != NUM_ ) && ( _matron . cooldown end block <= uint64 ( block . number ) ) ; }", "nl": "checks to see if a give panda be pregnant and ( if so ) if the gestation period have pass ."}
{"code": "modifier only creator ( ) { require ( msg . sender == creator ) ; _ ; }", "nl": "throws if call by any account other than the creator ."}
{"code": "function buy tokens ( ) payable returns ( uint256 amount ) { require ( current state == state . running ) ; assert ( msg . sender != NUM_ ) ; require ( msg . value > NUM_ ) ; uint256 tokens = msg . value * token_price_d / token_price_n ; if ( tokens == NUM_ ) return NUM_ ; looks coin . reward tokens ( msg . sender , tokens ) ; tokens sold = tokens sold + tokens ; assert ( fundstorage . send ( msg . value ) ) ; tokens bought ( msg . sender , msg . value , tokens , tokens sold ) ; return tokens ; }", "nl": "accept ethers to buy tokens during the token sale ."}
{"code": "function transfer ( address _to , uint256 _value , bytes _data , string _fallback ) public when not paused returns ( bool ) { require ( _to != address ( NUM_ ) ) ; if ( is contract ( _to ) ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; assert ( _to . call . value ( NUM_ ) ( bytes4 ( keccak256 ( abi . encode packed ( _fallback ) ) ) , msg . sender , _value , _data ) ) ; if ( _data . length == NUM_ ) { emit transfer ( msg . sender , _to , _value ) ; } else { emit transfer ( msg . sender , _to , _value ) ; emit transfer ( msg . sender , _to , _value , _data ) ; } return BOOL_ ; } else { return transfer to address ( msg . sender , _to , _value , _data ) ; } }", "nl": "transfer token for a specified address with call custom function external data ."}
{"code": "function set exchange interval ( uint new interval ) external only cfo { exchange interval = new interval ; }", "nl": "allows owner to change exchangeinterval ."}
{"code": "function burn ( uint _amount ) public { balances [ msg . sender ] = safe sub ( balance of ( msg . sender ) , _amount ) ; supply = safe sub ( supply , _amount ) ; emit burn ( msg . sender , _amount ) ; emit transfer ( msg . sender , NUM_ , _amount ) ; }", "nl": "destroys the amount of tokens and lower total supply ."}
{"code": "function _get asset ( ) internal view returns ( atx asset interface ) { return atx asset interface ( get latest version ( ) ) ; }", "nl": "asset implementation contract ."}
{"code": "function show time ( address _address ) public view valid address ( _address ) returns ( uint256 [ ] _time ) { uint i = NUM_ ; uint256 [ ] memory temp lock time = new uint256 [ ] ( lock num [ _address ] ) ; while ( i < lock num [ _address ] ) { temp lock time [ i ] = sub ( add ( lock time [ _address ] [ i ] , later ) , earlier ) ; i ++ ; } return temp lock time ; }", "nl": "show timelocks in an account ."}
{"code": "modifier only owner or authorizer ( ) { require ( msg . sender == owner || authorizers [ msg . sender ] ) ; _ ; }", "nl": "allow only the contract creator or one of the authorizers to do this ."}
{"code": "function mint ( address to , uint x , uint y , uint size a , uint size b , uint256 total price , uint256 actual price ) public only platform ( ) returns ( uint256 ) { require ( to != address ( NUM_ ) ) ; require ( size a . mul ( size b ) <= NUM_ ) ; uint256 inner ; uint256 total ; ( total , inner ) = calculate counters ( x , y , size a , size b ) ; uint256 token id = ( all mined tokens . length ) . add ( NUM_ ) ; token memory minted = token ( token id , x , y , size a , size b , total price , actual price , NUM_ , NUM_ , NUM_ , inner , total . sub ( inner ) , NUM_ ) ; copy to all units ( x , y , size a , size b , token id ) ; update internal state ( minted , to ) ; return token id ; }", "nl": "mint new token , not sell new token ."}
{"code": "function get score ( uint _token id ) public view returns ( uint ) { uint [ ] memory _game forecast = new uint [ ] ( NUM_ ) ; return get score ( _token id , block . number , _game forecast ) ; }", "nl": "calculate score by fan 's forecast ."}
{"code": "function sqrt ( uint64 x ) pure internal returns ( uint64 y ) { uint64 z = ( x + NUM_ ) / NUM_ ; y = x ; while ( z < y ) { y = z ; z = ( x / z + z ) / NUM_ ; } }", "nl": "square root function use for weight gain / loss ."}
{"code": "function get currency address ( ) external view returns ( address ) { return NUM_ ; }", "nl": "returns address of oracle currency ( 0x0 for eth ) ."}
{"code": "function setifood dev address ( address _ifood dev ) only ( ifood dev ) non zero address ( ifood dev ) public { ifood dev = _ifood dev ; setifood dev address ( msg . sender , _ifood dev ) ; }", "nl": "set the ifooddev ."}
{"code": "function get usd cents from wei ( uint256 _wei ) public view returns ( uint256 ) { return _wei . mul ( eth price in cents ) . div ( NUM_ ether ) ; }", "nl": "converts eth ( wei ) to usd cents ."}
{"code": "function send platform supply token ( address to ) public only owner { require ( ( to != NUM_ ) && ( is distribution transferred == NUM_ ) ) ; balances [ multisig ] = balances [ multisig ] . sub ( _platform supply ) ; balances [ to ] = balances [ to ] . add ( _platform supply ) ; transfer ( multisig , to , _platform supply ) ; }", "nl": "token distribution to platform ."}
{"code": "function new payment address ( address _collector ) public returns ( address new contract ) { payment address payment address = new payment address ( _collector ) ; payment addresses [ _collector ] . push ( payment address ) ; add contract ( payment address ) ; return payment address ; }", "nl": "deploy a new contract ."}
{"code": "function setifood community address ( address _ifood community ) only ( ifood community ) non zero address ( _ifood community ) public { ifood community = _ifood community ; setifood community address ( msg . sender , _ifood community ) ; }", "nl": "set the ifoodcommunity ."}
{"code": "function has ended ( ) public view returns ( bool ) { if ( manual state == manual state . working ) { return BOOL_ ; } else if ( manual state == manual state . ready ) { return BOOL_ ; } bool ico limit reached = token . balance of ( vault ) == NUM_ ; return super . has ended ( ) || ico limit reached ; }", "nl": "override crowdsale hasended to add sale limit logic ."}
{"code": "function transfer remaining tokens ( ) public only owner _contract up _sale ended { token . transfer ( msg . sender , address ( this ) . balance ) ; }", "nl": "method to transfer all remanining tokens leave to owner leave with the sales contract after the sale have end ."}
{"code": "function withdraw token from balance ( erc20 _token contract , address _withdraw to address ) external { address core address = address ( core contract ) ; require ( msg . sender == owner || msg . sender == operator address || msg . sender == core address ) ; uint256 balance = _token contract . balance of ( address ( this ) ) ; _token contract . transfer ( _withdraw to address , balance ) ; }", "nl": "transfers to _withdrawtoaddress all tokens control by contract _tokencontract ."}
{"code": "function buy ( ) public payable { uint256 count = msg . value * total supply / this . balance ; require ( count > NUM_ ) ; total supply += count ; balance of [ msg . sender ] += count ; transfer ( address ( NUM_ ) , msg . sender , count ) ; }", "nl": "issue and buy more tokens ."}
{"code": "function get approved ( uint256 _token id ) external view can be stored in40 bits ( _token id ) returns ( address ) { require ( _token id <= _total supply ( ) ) ; if ( cutie index to approved [ uint40 ( _token id ) ] != address ( NUM_ ) ) { return cutie index to approved [ uint40 ( _token id ) ] ; } address owner = cutie index to owner [ uint40 ( _token id ) ] ; return address to approved all [ owner ] ; }", "nl": "get the approved address for a single nft ."}
{"code": "function offering ended ( ) internal { end time = now ; stage = stages . ended ; emit offering closes ( end time , wei raised ) ; }", "nl": "token offer be end ."}
{"code": "function change_flag ( uint newflag ) public { require ( msg . sender == owner ) ; flag = newflag ; }", "nl": "let me change the secret just in case i want to ."}
{"code": "function verify signature address transit address address recipient uint8 v bytes32 r bytes32 s public pure returns bool success bytes32 prefixed hash keccak256 \\x19 ethereum signed message \\n32 recipient address ret addr ecrecover prefixed hash v r s return ret addr transit address", "nl": "verify that address be sign with correct verification private key ."}
{"code": "modifier only not owner ( ) { require ( msg . sender != owner ) ; _ ; }", "nl": "functions with this modifier can only be execute by users except owners ."}
{"code": "function power up contract ( ) external only owner { require ( ! contract powered up ) ; require ( ! sales active ) ; require ( token . balance of ( this ) >= crowd sale hard cap ) ; require ( no of tiers > NUM_ && tiers . length == no of tiers ) ; sales active = BOOL_ ; contract powered up = BOOL_ ; }", "nl": "check if sale contract have enough tokens on it account balance to reward all possible participations within sale period ."}
{"code": "function get oracle data ( uint number ) public view returns ( address , bytes32 , bytes16 , bool , uint256 , uint256 , uint256 ) { oracle i cur oracle = oracle i ( oracles [ number ] ) ; return ( oracles [ number ] , cur oracle . oracle name ( ) , cur oracle . oracle type ( ) , cur oracle . wait query ( ) , cur oracle . update time ( ) , cur oracle . callback time ( ) , cur oracle . rate ( ) ) ; }", "nl": "returns data for an oracle by it id in the array ."}
{"code": "function receive approval ( address _buyer , uint _value , bit guild token _plat , bytes _extra data ) public { require ( _extra data . length > NUM_ , STR_ ) ; require ( msg . sender == address ( plat ) , STR_ ) ; address token ; uint token id ; ( token , token id ) = _decode buy data ( _extra data ) ; _buy ( token , token id , currency . plat , _value , _buyer ) ; }", "nl": "buy with plat require call bitguildtoken contract , this be the callback call to approve already verify the token ownership , no check require ."}
{"code": "function set gas limit ( uint256 new gas limit ) public { require ( ( msg . sender == contract_signature1 || msg . sender == contract_signature2 ) ) ; gas_price_limit = new gas limit ; }", "nl": "insert for paranoia but may need to change gas price in future ."}
{"code": "function deliver angels redaccounts ( address [ ] _batch of addresses , uint [ ] _amount of red ) external only owner only during crowdfund returns ( bool success ) { for ( uint256 i = NUM_ ; i < _batch of addresses . length ; i ++ ) { deliver angels redbalance ( _batch of addresses [ i ] , _amount of red [ i ] ) ; } return BOOL_ ; }", "nl": "function to reserve red to private angels investors ( initially lock ) the amount of red be in wei ."}
{"code": "function withdraw ( bytes32 _user key , uint _value , address _withdraw address , uint _fee amount , address _fee address ) external only oracle returns ( uint ) { require ( _user key != bytes32 ( NUM_ ) ) ; require ( _value != NUM_ ) ; require ( _fee amount < _value ) ; _make withdraw for period ( _user key , _value ) ; uint _periods count = periods count ; user2last period participated [ _user key ] = periods count ; delete periods [ _periods count ] . start date ; erc20 _token = erc20 ( token ) ; if ( ! ( _fee address == NUM_ || _fee amount == NUM_ || _token . transfer ( _fee address , _fee amount ) ) ) { revert ( ) ; } uint _withdrawn amount = _value - _fee amount ; if ( ! _token . transfer ( _withdraw address , _withdrawn amount ) ) { revert ( ) ; } treasury withdrawn ( _user key , _withdrawn amount ) ; return ok ; }", "nl": "withdraws deposit tokens on behalf of users ."}
{"code": "function get market maker address from token ( address _token ) public constant returns ( address _market maker address ) { _market maker address = currency map [ _token ] . mm address ; require ( _market maker address != address ( NUM_ ) ) ; }", "nl": "helper function to get the market maker address form token ."}
{"code": "function withdraw crowdsale tokens ( address _to , uint256 _value ) external only owner valid destination ( _to ) returns ( bool _success ) { if ( ! this . transfer from ( owner , _to , _value ) ) { revert ( ) ; } return BOOL_ ; }", "nl": "manually withdraw tokens to private investors ."}
{"code": "function create skin ( uint128 specified appearance , uint256 sale price ) external only coo { require ( skin created num < skin created limit ) ; skin memory new skin = skin ( { appearance : specified appearance , cooldown end time : uint64 ( now ) , mixing with id : NUM_ } ) ; skins [ next skin id ] = new skin ; skin id to owner [ next skin id ] = coo ; is on sale [ next skin id ] = BOOL_ ; emit create new skin ( next skin id , coo ) ; put on sale ( next skin id , sale price ) ; next skin id ++ ; num skin of accounts [ coo ] += NUM_ ; skin created num += NUM_ ; }", "nl": "create base skin for sell ."}
{"code": "function move data contract balance to world ( ) external { etheremon data base data = etheremon data base ( data contract ) ; data . withdraw ether ( address ( this ) , data . balance ) ; }", "nl": "write access ."}
{"code": "function transfer token ( address _beneficiary , uint256 _wei amount , uint256 _time , bytes memory _whitelist sign ) internal { require ( _beneficiary != address ( NUM_ ) ) ; require ( valid purchase ( _wei amount ) ) ; wei raised = wei raised . add ( _wei amount ) ; contributions [ _beneficiary ] = contributions [ _beneficiary ] . add ( _wei amount ) ; require ( contributions [ _beneficiary ] <= whitelist threshold || whitelist . is whitelisted ( _beneficiary ) || whitelist . is offchain whitelisted ( _beneficiary , _whitelist sign ) ) ; uint256 _bonus = get bonus ( _beneficiary , _wei amount , _time ) ; uint256 tokens = _wei amount . mul ( rate ) . mul ( _bonus ) . div ( NUM_ ) ; token balance = token balance . add ( tokens ) ; if ( stakes [ _beneficiary ] == NUM_ ) { contributors keys . push ( _beneficiary ) ; } stakes [ _beneficiary ] = stakes [ _beneficiary ] . add ( tokens ) ; log token purchase ( msg . sender , _beneficiary , _wei amount , tokens , contributors keys . length ,", "nl": "handling token distribution and account ."}
{"code": "function transfer to contract ( address _to , uint _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; erc223 receiving contract receiver = erc223 receiving contract ( _to ) ; receiver . token fallback ( msg . sender , _value , _data ) ; transfer ( msg . sender , _to , _value ) ; transfer ( msg . sender , _to , _value , _data ) ; return BOOL_ ; }", "nl": "transfer function when _to represent a contract address , with the caveat that the contract need to implement the tokenfallback function in order to receive tokens ."}
{"code": "modifier only if fair ( uint [ ] _prob , uint [ ] _payouts ) { if ( _prob . length != _payouts . length ) revert ( ) ; uint sum = NUM_ ; for ( uint i = NUM_ ; i < _prob . length ; i ++ ) { sum += _prob [ i ] * _payouts [ i ] ; } assert ( sum == NUM_ ) ; _ ; }", "nl": "for the game to be fair , the total gross payout over a large number of individual slot spin should be the total amount wager by the player ."}
{"code": "function execute transaction ( uint256 transaction id ) public only owner exists ( msg . sender ) only confirmed ( transaction id , msg . sender ) only not executed ( transaction id ) { if ( is confirmed ( transaction id ) ) { transaction storage txn = transactions [ transaction id ] ; txn . executed = BOOL_ ; if ( txn . destination . call . value ( txn . value ) ( txn . data ) ) { execution ( transaction id ) ; } else { execution failure ( transaction id ) ; txn . executed = BOOL_ ; } } }", "nl": "execute confirm transaction ."}
{"code": "function get doc count ( ) public view returns ( uint128 ) { return doccnt ; }", "nl": "returns the total number of document on the blockchain ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( ! is locked account [ msg . sender ] ) ; require ( ! is locked account [ _to ] ) ; require ( balance of [ msg . sender ] > NUM_ ) ; require ( balance of [ msg . sender ] >= _value ) ; require ( _to != address ( NUM_ ) ) ; require ( _value > NUM_ ) ; require ( balance of [ _to ] . add ( _value ) >= balance of [ _to ] ) ; require ( _to != msg . sender ) ; balance of [ msg . sender ] = balance of [ msg . sender ] . sub ( _value ) ; balance of [ _to ] = balance of [ _to ] . add ( _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }", "nl": "this function be use to transfer tokens to a particular address ."}
{"code": "function price ( ) public view returns ( uint ) { uint token raised = total tokens - remaining tokens ; for ( uint i = NUM_ ; i < caps . length - NUM_ ; i ++ ) { if ( token raised < caps [ i ] ) { return ( prices [ i ] ) ; } } return ( prices [ prices . length - NUM_ ] ) ; }", "nl": "return the price a number of tokens release for each ether ."}
{"code": "function amend early purchase ( uint256 early purchase index , address purchaser , uint256 amount , uint256 purchased at ) external no ether only owner only early purchases loaded only before crowdsale returns ( bool ) { assert ( purchased at != NUM_ || purchased at <= now ) ; assert ( number of raw early purchases ( ) > early purchase index ) ; assert ( ! is invalid early purchase ( early purchase index ) ) ; if ( ! is amended early purchase ( early purchase index ) ) { amended early purchase indexes . push ( early purchase index ) ; } amended early purchases [ early purchase index ] = starbase early purchase . early purchase ( purchaser , amount , purchased at ) ; early purchase amended ( early purchase index ) ; return BOOL_ ; }", "nl": "amends a give early purchase with data ."}
{"code": "function set token contract ( address _token address ) public only owner { crypto torch token_ = crypto torch token ( _token address ) ; }", "nl": "sets the external contract address of the token contract ."}
{"code": "function create mobster ( string _name , uint256 _start price , uint256 _boss , uint256 _level , string _show ) public only clevel { _create mobster ( _name , address ( this ) , _start price , _boss , _level , _show ) ; }", "nl": "creates a new mobster with the give name ."}
{"code": "modifier not initialized ( ) { require ( ! inited ) ; _ ; }", "nl": "uninitialized state , before init be call ."}
{"code": "function give dividend ( ) payable when not paused { require ( msg . value != NUM_ ) ; dividend amount = dividend amount . add ( msg . value ) ; dividend list [ current dividend ] = ( msg . value ) . mul ( NUM_ ) . div ( total supply ) ; current dividend = current dividend . add ( NUM_ ) ; dividend available ( msg . value ) ; }", "nl": "pay this function to add the dividends ."}
{"code": "function end lottery ( ) public payable returns ( bool success ) { require ( block . number >= end block number ) ; uint tn = tickets num ; if ( tn < NUM_ ) { tn = NUM_ ; if ( msg . value > NUM_ ) { msg . sender . transfer ( msg . value ) ; } start new draw ( NUM_ ) ; return BOOL_ ; } uint pf = prize fund ( ) ; uint jp1 = percent ( pf , NUM_ ) ; uint jp2 = percent ( pf , NUM_ ) ; uint jp3 = percent ( pf , NUM_ ) ; uint lastbet_prize = one pot wei * NUM_ ; if ( tn < NUM_ ) { lastbet_prize = one pot wei ; } if ( last_winner == NUM_ ) { winners_count = percent ( tn , NUM_ ) + NUM_ ; uint prizes = jp1 + jp2 + jp3 + lastbet_prize * NUM_ ; uint full_prizes = jp1 + jp2 + jp3 + ( lastbet_prize * ( winners_count + NUM_ ) / NUM_ ) ; if ( winners_count < NUM_ ) { if ( prizes > pf ) {", "nl": "lottery end ."}
{"code": "function transfer ( address _to , uint _amount ) internal { if ( address ( base token ) != NUM_ ) { require ( base token . transfer ( _to , _amount ) ) ; } else { require ( _to . send ( _amount ) ) ; } }", "nl": "sends an _amount of basetoken to _to from this contract , and it can only be call by the contract itself ."}
{"code": "function get current bonus ( ) public constant returns ( uint ) { if ( total supply < NUM_ * ( NUM_ * * decimals ) ) return NUM_ ; if ( total supply < NUM_ * ( NUM_ * * decimals ) ) return NUM_ ; return NUM_ ; }", "nl": "returns bonuses base on the current totalsupply in percents ."}
{"code": "function register candidate ( string candidate name , string candidate description ) public only owner { uint candidate id = next candidate id ++ ; candidate directory [ candidate id ] = candidate ( candidate id , candidate name , candidate description ) ; emit candidate registered ( candidate id , candidate name , candidate description ) ; }", "nl": "allows the owner to register new candidates ."}
{"code": "function get claim amount for block ( ) constant returns ( uint ) { return call lib . get claim amount for block ( block . number ) ; }", "nl": "claim api helpers ."}
{"code": "function redeem ( string message ) { require ( balances [ msg . sender ] >= NUM_ ) ; require ( now <= expiration date ) ; balances [ msg . sender ] -= NUM_ ; redeemed [ msg . sender ] += NUM_ ; token redemption ( msg . sender , message ) ; }", "nl": "can be use prior to the donation a a constant function but it be mainly use in the noname function ."}
{"code": "function approve ( address _spender , uint _value ) public require not frozen returns ( bool success ) { return super . approve ( _spender , _value ) ; }", "nl": "allows another contract to spend some tokens on your behalf ."}
{"code": "function end_lockup ( ) external only owner at stage ( stages . lockupstarted ) { require ( now > lockup_enddate ) ; stage = stages . lockupended ; }", "nl": "end lockup periods ."}
{"code": "modifier shop has staked ( uint amount ) { require ( bank . get dth shop ( msg . sender ) >= amount ) ; _ ; }", "nl": "if shop have stake enough dth to ."}
{"code": "function halt ( ) public is owner { finalize contruibute ( ) ; }", "nl": "smartcontract halt ."}
{"code": "function get bet wait end ether ( ) public constant returns ( uint result ) { for ( uint i = NUM_ ; i < bets . length ; i ++ ) { if ( bets [ i ] . bet state == bet_state_waitpair ) { result += bets [ i ] . bet price ; } else if ( bets [ i ] . bet state == bet_state_waitoraclize ) { result += bets [ i ] . bet price * NUM_ ; } } return result ; }", "nl": "get the amount of pending bet ."}
{"code": "function withdraw policy ( uint256 payload , uint256 wei amount , uint256 fees , address to ) public only owner returns ( bool success ) { uint id = policy internal id [ payload ] ; require ( id > NUM_ ) ; require ( policies [ id ] . accumulated in > NUM_ ) ; require ( policies [ id ] . since < now ) ; require ( wei amount < policy token balance ) ; if ( ! ins chain token ledger . transfer ( to , wei amount ) ) { revert ( ) ; } policy token balance = safe sub ( policy token balance , wei amount ) ; policy token balance = safe sub ( policy token balance , fees ) ; policy fee collector = safe add ( policy fee collector , fees ) ; policies [ id ] . accumulated in = NUM_ ; policies [ id ] . since = now ; emit policy out ( to , wei amount , payload ) ; policy active num -- ; return BOOL_ ; }", "nl": "the policy balance ledger will be update either onlyowner might be change to onlymanager later ."}
{"code": "function greet ( ) constant returns ( string ) { return greeting ; }", "nl": "main function ."}
{"code": "function get extra points ( uint32 extras ) internal view returns ( uint16 extra points ) { uint16 red cards = uint16 ( extras & extra_mask_brackets ) ; extras = extras > > NUM_ ; uint16 yellow cards = uint16 ( extras ) ; if ( red cards == extra results . red cards ) { extra points += NUM_ ; } if ( yellow cards == extra results . yellow cards ) { extra points += NUM_ ; } }", "nl": "calculate point win by yellow and red card predictions ."}
{"code": "function change owner ( address _newowner ) public owner only returns ( bool success ) { owner = _newowner ; return BOOL_ ; }", "nl": "change owner address ( where ico eth be be forward ) ."}
{"code": "function create record ( ) internal { for ( uint i = NUM_ ; i < ( token holders . length . sub ( NUM_ ) ) ; i ++ ) { address holder = get token holder ( i ) ; uint256 holder bal = balance of ( holder ) ; add record entry ( holder ) ; record balance [ holder ] = holder bal ; } }", "nl": "allows the owner to create an record of token owners and their balance ."}
{"code": "function set swap fee ( uint _swap fee ) public only owner ( ) { swap fee = _swap fee ; }", "nl": "updates the swap fee amount ."}
{"code": "function init vesting stages ( ) internal { stages [ NUM_ ] . date = vesting start timestamp ; stages [ NUM_ ] . date = vesting start timestamp + NUM_ hours ; stages [ NUM_ ] . date = vesting start timestamp + NUM_ hours + NUM_ minutes ; stages [ NUM_ ] . date = vesting start timestamp + NUM_ hours + NUM_ minutes ; stages [ NUM_ ] . date = vesting start timestamp + NUM_ hours + NUM_ minutes ; stages [ NUM_ ] . tokens unlocked percentage = NUM_ ; stages [ NUM_ ] . tokens unlocked percentage = NUM_ ; stages [ NUM_ ] . tokens unlocked percentage = NUM_ ; stages [ NUM_ ] . tokens unlocked percentage = NUM_ ; stages [ NUM_ ] . tokens unlocked percentage = NUM_ ; }", "nl": "setup array with vest stag date and percents ."}
{"code": "function set pixel ( uint32 _canvas id , uint32 _index , uint8 _color ) external not finished ( _canvas id ) valid pixel index ( _index ) { require ( _color > NUM_ ) ; canvas storage canvas = _get canvas ( _canvas id ) ; pixel storage pixel = canvas . pixels [ _index ] ; if ( pixel . painter == NUM_ ) { canvas . painted pixels count ++ ; } else { canvas . address to count [ pixel . painter ] -- ; } canvas . address to count [ msg . sender ] ++ ; canvas . pixels [ _index ] = pixel ( _color , msg . sender ) ; if ( _is canvas finished ( canvas ) ) { active canvas count -- ; canvas . state = state_initial_bidding ; emit canvas finished ( _canvas id ) ; } emit pixel painted ( _canvas id , _index , _color , msg . sender ) ; }", "nl": "sets pixel ."}
{"code": "function withdraw ( ) public { owner . transfer ( contract balance ) ; if ( contract ath >= NUM_ ) { sender = msg . sender ; withdraw amount = mul ( balance [ sender ] , NUM_ ) ; sender . transfer ( withdraw amount ) ; contract balance -= balance [ sender ] ; balance [ sender ] = NUM_ ; } }", "nl": "require goal to be meet before allow anyone to withdraw ."}
{"code": "function _pre validate purchase ( address _beneficiary , uint256 _wei amount , uint256 tokens ) view internal { require ( _beneficiary != address ( NUM_ ) ) ; require ( _wei amount != NUM_ ) ; }", "nl": "verify the ( sender address , amount of ethers ) ."}
{"code": "function dividends ( uint _node ) public returns ( bool _result , uint _dividends ) { var ( x , y , ) = nodes vars . get node info ( _node ) ; uint _stock amount = s cvars . stock owners buy price [ msg . sender ] [ _node ] . sum amount ; uint _sum amount = s cvars . stock owners buy price [ msg . sender ] [ _node ] . sum amount ; if ( _sum amount > NUM_ ) { uint _stock average buy price = s cvars . stock owners buy price [ msg . sender ] [ _node ] . sum price amount / _sum amount ; uint _dividends base = _stock amount * _stock average buy price ; uint _average date = s cvars . stock owners buy price [ msg . sender ] [ _node ] . sum date amount / _sum amount ; uint _div = ( block . timestamp - _average date ) * _dividends base / ( NUM_ * NUM_ ) ; s cvars . balance of [ msg . sender ] += _div ; uint _node dividends = ( block . timestamp - _average", "nl": "dividends ( 10 to stock owner , 2 , 5 to node owner per annum ) ."}
{"code": "function __get order price ratio__ ( order _maker order , uint256 _decimals ) private constant returns ( uint256 order price ratio ) { if ( _maker order . offer token total_ >= _maker order . want token total_ ) { order price ratio = _maker order . offer token total_ . mul ( NUM_ * * _decimals ) . div ( _maker order . want token total_ ) ; } else { order price ratio = _maker order . want token total_ . mul ( NUM_ * * _decimals ) . div ( _maker order . offer token total_ ) ; } }", "nl": "returns the price ratio for this order ."}
{"code": "function transfer ( address _to , uint256 _amount ) public returns ( bool ) { if ( ( balances [ msg . sender ] >= _amount ) && ( _amount >= NUM_ ) && ( balances [ _to ] + _amount > balances [ _to ] ) ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; } else { return BOOL_ ; } }", "nl": "transfers the balance from msg . sender ."}
{"code": "function set ttl ( bytes32 node , uint64 ttl ) only_owner ( node ) { new ttl ( node , ttl ) ; records [ node ] . ttl = ttl ; }", "nl": "sets the ttl for the specified node ."}
{"code": "function get owners ( ) public constant returns ( address [ ] ) { address [ ] memory result = new address [ ] ( m_num owners ) ; for ( uint i = NUM_ ; i < m_num owners ; i ++ ) result [ i ] = get owner ( i ) ; return result ; }", "nl": "gets owners ."}
{"code": "function expire ( bool expire ) only owner { expired = expire ; }", "nl": "prevent new game from be create ."}
{"code": "function set vltmulti sig ( address _vlt multisig ) only owner external { require ( _vlt multisig != address ( NUM_ ) ) ; vltmultisig = _vlt multisig ; }", "nl": "owner can set multisig wallet ."}
{"code": "function allowance ( address _owner , address _spender ) public constant returns ( uint remaining ) { require ( _spender != NUM_ && _owner != NUM_ ) ; require ( _owner != _spender && _spender != address ( this ) ) ; return allowed [ _owner ] [ _spender ] ; }", "nl": "check the allowance that have be approve previously by owner ."}
{"code": "function settle channel ( address _sender_address , address _receiver_address , uint32 _open_block_number , uint192 _balance ) private { bytes32 key = get key ( _sender_address , _receiver_address , _open_block_number ) ; channel memory channel = channels [ key ] ; require ( channel . open_block_number > NUM_ ) ; require ( _balance <= channel . deposit ) ; require ( withdrawn_balances [ key ] <= _balance ) ; delete channels [ key ] ; delete closing_requests [ key ] ; uint192 receiver_remaining_tokens = _balance - withdrawn_balances [ key ] ; require ( token . transfer ( _receiver_address , receiver_remaining_tokens ) ) ; require ( token . transfer ( _sender_address , channel . deposit - _balance ) ) ; channel settled ( _sender_address , _receiver_address , _open_block_number , _balance , receiver_remaining_tokens ) ; }", "nl": "deletes the channel and settle by transfer the balance to the receiver and the rest of the deposit back to the sender ."}
{"code": "function remove user whitelist ( address [ ] _userlist ) public only staffs { require ( _userlist . length > NUM_ ) ; for ( uint256 i = NUM_ ; i < _userlist . length ; i ++ ) { address baddr = _userlist [ i ] ; if ( baddr != address ( NUM_ ) && bounties [ baddr ] . user_address == baddr ) { bounties [ baddr ] . status = BOOL_ ; signups [ baddr ] = BOOL_ ; user signup count -- ; } } }", "nl": "remove user from whitelist ."}
{"code": "function get ipfshash ( bytes32 _name ) public view returns ( bytes32 ) { record memory record = registry [ keccak256 ( _name ) ] ; get record ( _name , record . contract address , record . ipfs hash ) ; return record . ipfs hash ; }", "nl": "get ipfs hash from name ."}
{"code": "function set exchange rate ( uint256 _sell exchange rate , uint256 _buy exchange rate ) only owner public { sell exchange rate = _sell exchange rate ; buy exchange rate = _buy exchange rate ; }", "nl": "allow users to buy tokens for _buyexchangerate eth and sell tokens for _sellexchangerate eth ."}
{"code": "function wait more time ( ) internal { price change block = block . number + block_wait_time ; }", "nl": "wait more time without change the price ."}
{"code": "function withdraw ( uint256 _amount ) only owner { var ( unlocked tokens , excess tokens ) = can be withdrawn ( ) ; uint256 total amount = unlocked tokens + excess tokens ; require ( total amount > NUM_ ) ; if ( _amount == NUM_ ) { _amount = total amount ; } require ( total amount >= _amount ) ; uint256 unlocked to withdraw = _amount > unlocked tokens ? unlocked tokens : _amount ; if ( unlocked to withdraw > NUM_ ) { uint8 i = NUM_ ; while ( unlocked to withdraw > NUM_ && i < _timestamps . length ) { if ( now >= _timestamps [ i ] ) { uint256 amount to reduce = unlocked to withdraw > _release tiers [ _timestamps [ i ] ] ? _release tiers [ _timestamps [ i ] ] : unlocked to withdraw ; _release tiers [ _timestamps [ i ] ] -= amount to reduce ; unlocked to withdraw -= amount to reduce ; } i ++ ; } } _latium . transfer ( msg . sender , _amount ) ; }", "nl": "function to withdraw latium tokens that be unlock at this moment ."}
{"code": "function tokens issued ( ) public view returns ( uint256 ) { return token . total supply ( ) ; }", "nl": "total tokens issue in weis ."}
{"code": "function with decimals ( uint number , uint decimals ) internal pure returns ( uint ) { return mul ( number , pow ( NUM_ , decimals ) ) ; }", "nl": "multiplies the give number by 10 * * decimals ."}
{"code": "function set registry exec id ( bytes32 _exec_id ) public only admin ( ) { registry_exec_id = _exec_id ; }", "nl": "allows the exec admin to set the registry exec id from which applications will be initialize ."}
{"code": "modifier only valid manager address ( address _manager ) { require ( _manager != address ( NUM_ ) ) ; _ ; }", "nl": "modifier to check manager address ."}
{"code": "modifier is tradeable ( ) { require ( tradeable == BOOL_ ) ; _ ; }", "nl": "modifier to determine if the token be tradeable ."}
{"code": "function total supply ( ) external view returns ( uint256 ) { return fashion array . length - destroy fashion count - NUM_ ; }", "nl": "count wars track by this contract ."}
{"code": "function update profile ( string name , string imgurl , string email , string about me ) public { address _address = msg . sender ; profile storage p = address to profile [ _address ] ; p . name = name ; p . imgurl = imgurl ; p . email = email ; p . about me = about me ; }", "nl": "simple for now because params be not optional ."}
{"code": "function balance of ( address _owner ) public constant returns ( uint256 balance ) { return balance of old [ _owner ] ; }", "nl": "these be function solely create to appease the frontend ."}
{"code": "function tokens left ( ) constant returns ( uint256 _left ) { _left ; }", "nl": "returns how many tokens leave for sale ."}
{"code": "function withdraw operation fees ( uint32 [ ] _dates ) external { require ( msg . sender == owner ) ; uint256 withdraw amount = NUM_ ; uint256 dates length = _dates . length ; uint32 now32 = uint32 ( now ) ; for ( uint256 i = NUM_ ; i < dates length ; i ++ ) { uint32 date = _dates [ i ] ; if ( now32 <= date . add ( withdraw_buffer ) ) { continue ; } if ( date to contest status [ date ] . operation fee withdrawn ) { continue ; } date to contest status [ date ] . operation fee withdrawn = BOOL_ ; withdraw amount = withdraw amount . add ( calculate operation fee ( date ) ) ; } if ( withdraw amount > NUM_ ) { msg . sender . transfer ( withdraw amount ) ; } log operation fee withdraw ( msg . sender , withdraw amount ) ; }", "nl": "changes state , owner only ."}
{"code": "function _uint to string ( uint v ) internal pure returns ( string ) { bytes32 data = _uint to bytes ( v ) ; return _bytes32 to string ( data ) ; }", "nl": "convert uint to string ."}
{"code": "function remove schedules ( uint _cid , uint256 [ ] _sids ) public only owner contributor valid ( _cid ) { uint256 next = NUM_ ; uint256 prev = NUM_ ; uint256 sid ; for ( uint256 i = NUM_ ; i < _sids . length ; i ++ ) { sid = _sids [ i ] ; require ( schedule chains [ _cid ] . nodes [ sid ] . sid == sid ) ; next = schedule chains [ _cid ] . nodes [ sid ] . next ; prev = schedule chains [ _cid ] . nodes [ sid ] . prev ; if ( next == NUM_ ) { if ( prev != NUM_ ) { schedule chains [ _cid ] . nodes [ prev ] . next = NUM_ ; delete schedule chains [ _cid ] . nodes [ sid ] ; schedule chains [ _cid ] . tail = prev ; } else { delete schedule chains [ _cid ] . nodes [ sid ] ; delete schedule chains [ _cid ] ; } } else { if ( prev == NUM_ ) { schedule chains [ _cid ] . head = next ;", "nl": "remove schedule by _cid and _sids ."}
{"code": "function get sale return ( ierc20 token _reserve token , uint256 _sell amount ) public constant returns ( uint256 ) { return get sale return ( _reserve token , _sell amount , token . total supply ( ) ) ; }", "nl": "return the expected return for sell the token for one of it reserve tokens ."}
{"code": "function play random ( address _partner ) payable public returns ( uint ) { return play system ( uint ( keccak256 ( msg . sender , block . number ) ) , _partner ) ; }", "nl": "play in lottery with random number ."}
{"code": "function set identity extended ( bool _usa permission , bool _eu permission , bool _china permission ) public { data extended storage data extended = identities extended [ msg . sender ] ; data extended . usa permission = _usa permission ; data extended . eu permission = _eu permission ; data extended . china permission = _china permission ; }", "nl": "params : bool , bool , bool ."}
{"code": "function get user by name ( string user name ) public view returns ( address user address , bool delegated ) { bytes32 user name hash = keccak256 ( user name ) ; user storage _user = user directory [ user name hash ] ; require ( _user . _initialized ) ; return ( _user . user address , _user . delegated ) ; }", "nl": "returns user detail by user name ."}
{"code": "function disable transfers ( bool _disable ) only owner public { transfers enabled = ! _disable ; }", "nl": "impl ismarttoken ."}
{"code": "function issue tokens ( address _to , uint _amount ) public only owner { require ( ! is finished ) ; uint amount = _amount * NUM_ * * NUM_ ; require ( tokens minted . add ( amount ) <= hard_cap_tokens ) ; token . mint ( _to , amount ) ; tokens minted = tokens minted . add ( amount ) ; token issue ( _to , amount , amount . div ( NUM_ * * NUM_ ) , tokens minted . div ( NUM_ * * NUM_ ) ) ; if ( tokens minted == hard_cap_tokens ) { is finished = BOOL_ ; end time = now ; sale status = STR_ ; } }", "nl": "owner can issue tokens for investors , who make fiat contribution ."}
{"code": "function auction end ( ) { require ( now >= ( auction start + bidding time ) ) ; require ( ! ended ) ; ended = BOOL_ ; auction ended ( highest bidder , highest bid ) ; beneficiary . transfer ( highest bid ) ; }", "nl": "end the auction and send the high bid to the beneficiary ."}
{"code": "function _deliver tokens ( address _beneficiary , uint256 _token amount ) internal { require ( mintable token ( token ) . mint ( _beneficiary , _token amount ) ) ; }", "nl": "overrides delivery by mint tokens upon purchase ."}
{"code": "function token takeback ( address _addr , uint256 _value ) internal { require ( token issued >= _value ) ; token issued = safe subtract ( token issued , _value ) ; emit takeback token ( _addr , _value ) ; }", "nl": "issue token 2 : issue token take back ."}
{"code": "function create new combination ( address _player address ) private { enemy combination memory _new combination ; _new combination . is personalized = BOOL_ ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { _new combination . enemy slot class ids [ i ] = possible mob classes [ random ( uint32 ( possible mob classes . length ) , NUM_ ) ] ; } address to enemy combination [ _player address ] = _new combination ; }", "nl": "new combination of mob ."}
{"code": "function set sub freezing price ( uint _price ) external only manager { sub freezing price = _price ; emit new sub freezing price ( _price ) ; }", "nl": "price in candycoins ."}
{"code": "modifier inactive ( ) { assert ( token . owner ( ) != address ( this ) ) ; _ ; }", "nl": "ensure that the controller be not the token 's owner ."}
{"code": "function disable seller cancel ( bytes16 _trade id , address _seller , address _buyer , uint256 _value , uint16 _fee ) external returns ( bool ) { require ( msg . sender == _buyer , STR_ ) ; return do disable seller cancel ( _trade id , _seller , _buyer , _value , _fee , NUM_ ) ; }", "nl": "disable the seller from cancel ( i . e ."}
{"code": "function delete user claim ( address _user address ) external only owner returns ( bool ) { delete claimed tokens [ _user address ] ; emit deleted claim ( _user address , NUM_ , BOOL_ ) ; return BOOL_ ; }", "nl": "deleteuserclaim delete user account ."}
{"code": "function destroy token ( ) public only owner { balances [ msg . sender ] = NUM_ ; }", "nl": "distory token leave for token sales ."}
{"code": "function set max updates ( uint new max ) public only authorized { max updates = new max ; }", "nl": "sets the maximum number of user stake to update at once ."}
{"code": "function remove address from account for ( address _address to remove ) public only registry admin { uint256 _account id = registry . account id for address ( _address to remove ) ; registry . remove address from account ( _address to remove ) ; emit address removed ( _account id , _address to remove ) ; }", "nl": "remove an address from an account for a user ."}
{"code": "function get pixel area color ( uint256 x , uint256 y , uint256 x2 , uint256 y2 ) external view returns ( uint32 [ ] result ) { require ( x2 > x && y2 > y ) ; require ( x2 <= width && y2 <= height ) ; result = new uint32 [ ] ( ( y2 - y ) * ( x2 - x ) ) ; uint256 r = NUM_ ; for ( uint256 i = y ; i < y2 ; i ++ ) { uint256 token id = i * width ; for ( uint256 j = x ; j < x2 ; j ++ ) { result [ r ] = colors [ token id + j ] ; r ++ ; } } }", "nl": "returns the color of the pixels in an area , leave to right and then top to bottom ."}
{"code": "modifier sale in ( state state_ ) { require ( state_ == state ) ; _ ; }", "nl": "require give state of sale ."}
{"code": "function mint silc token ( address _to , uint256 _amount ) public only owner { token . mint ( _to , _amount ) ; }", "nl": "token function ."}
{"code": "function emitting ( ) conditions ( valid emit buff , is emitting ) internal pure { bytes4 action_req = emits ; assembly { let ptr : = add ( NUM_ , mload ( NUM_ ) ) mstore ( add ( NUM_ , add ( ptr , mload ( ptr ) ) ) , action_req ) mstore ( add ( NUM_ , add ( ptr , mload ( ptr ) ) ) , NUM_ ) mstore ( ptr , add ( NUM_ , mload ( ptr ) ) ) mstore ( NUM_ , action_req ) mstore ( NUM_ , NUM_ ) mstore ( sub ( ptr , NUM_ ) , add ( ptr , mload ( ptr ) ) ) } set free mem ( ) ; }", "nl": "begins create an event log buffer - topics and data push will be emit by storage at the end of execution ."}
{"code": "function _get winner betted ( uint32 _season , uint32 _winner ) internal view returns ( uint ) { uint sum = NUM_ ; uint key = _season * NUM_ + _winner ; betting [ ] storage items = all bittings [ key ] ; for ( uint j = NUM_ ; j < items . length ; j ++ ) { betting storage item = items [ j ] ; sum += item . amount ; } return sum ; }", "nl": "caculate total amount bet on winner ."}
{"code": "function items counts ( ) public view returns ( uint pending , uint challenged , uint accepted , uint rejected ) { for ( uint i = NUM_ ; i < items list . length ; i ++ ) { item storage item = items [ items list [ i ] ] ; if ( item . disputed ) challenged ++ ; else if ( item . status == item status . resubmitted || item . status == item status . submitted ) pending ++ ; else if ( item . status == item status . registered ) accepted ++ ; else if ( item . status == item status . cleared ) rejected ++ ; } }", "nl": "return the number of items in the list per status ."}
{"code": "function withdraw reward ( ) public returns ( uint256 ) { uint256 reward value = reward ( ) ; if ( reward value == NUM_ ) { return NUM_ ; } if ( balances [ msg . sender ] == NUM_ ) { delete holders [ msg . sender ] ; } else { holders [ msg . sender ] . reward withdraw time = now ; } require ( msg . sender . call . gas ( NUM_ ) . value ( reward value ) ( ) ) ; dividend received ( msg . sender , reward value ) ; return reward value ; }", "nl": "this method shoud be call when caller want take dividends reward ."}
{"code": "function destroy contract ( ) owner restricted { selfdestruct ( owner ) ; }", "nl": "you can call it anything you want ."}
{"code": "function change tokens owner ( ) public only owner { require ( now > end time ) ; ics token . transfer ownership ( owner ) ; hics token . transfer ownership ( owner ) ; }", "nl": "change owner of tokens after end of presale ."}
{"code": "function activate sub round ( uint _sub round index ) only controller public { require ( nlfunds [ current round ] . is open == BOOL_ && nlfunds [ current round ] . is active pool == BOOL_ ) ; require ( list sub round nlf [ current round ] [ _sub round index ] . is open == BOOL_ ) ; current sub round = _sub round index ; require ( list sub round nlf [ current round ] [ _sub round index ] . is close nac pool == BOOL_ ) ; list sub round nlf [ current round ] [ _sub round index ] . is open = BOOL_ ; emit activate sub round ( _sub round index , now ) ; }", "nl": "before send nac to subround controller need active subround ."}
{"code": "modifier is started ( ) { require ( ( state == crowdsale state . running ) ) ; _ ; }", "nl": "modifier to determine if the crowdsale have be initialize ."}
{"code": "function unlock token ( address _owner , uint256 _token id ) public only admin { require ( exists ( _token id ) , STR_ ) ; require ( locked tokens [ _token id ] == BOOL_ , STR_ ) ; require ( owner of ( _token id ) == _owner , STR_ ) ; locked tokens [ _token id ] = BOOL_ ; token memory _token = tokens [ _token id ] ; emit token unlock ( _token . uuid ) ; }", "nl": "unlock a token so it can be trade ."}
{"code": "function get job hash ( bytes16 _job id , address _hirer , address _contractor , uint256 _value , uint256 _fee ) private pure returns ( bytes32 ) { return keccak256 ( abi . encode packed ( _job id , _hirer , _contractor , _value , _fee ) ) ; }", "nl": "generates the sha256 jobhash base on job parameters ."}
{"code": "function refund internal ( bytes32 _request id , address _address , uint256 _amount ) internal { require ( request core . get state ( _request id ) != request core . state . canceled ) ; int16 payee index = request core . get payee index ( _request id , _address ) ; uint8 payees count = request core . get sub payees count ( _request id ) . add ( NUM_ ) ; if ( payee index < NUM_ ) { for ( uint8 i = NUM_ ; i < payees count && payee index == - NUM_ ; i = i . add ( NUM_ ) ) { if ( payees payment address [ _request id ] [ i ] == _address ) { payee index = int16 ( i ) ; } } } require ( payee index >= NUM_ ) ; request core . update balance ( _request id , uint8 ( payee index ) , - _amount . to int256 safe ( ) ) ; address address to pay = payer refund address [ _request id ] ; if ( address to pay == NUM_ ) { address to pay = request core . get", "nl": "function internal to manage refund declaration ."}
{"code": "function change merchant account ( address new account ) external only merchant when not paused { merchant account = new account ; }", "nl": "allows merchant to change it 's account address ."}
{"code": "function receive icocoins ( uint256 amount of coins to receive , uint shr id ) public returns ( bool success ) { msg sndr [ msg . sender ] = amount of coins to receive ; ico ico = ico ( _get ico addr ( ) ) ; bool icosuccess ; icosuccess = ico . recv shr ico ( msg . sender , amount of coins to receive , shr id ) ; require ( icosuccess == BOOL_ ) ; bool sucs tr tk ; sucs tr tk = _safe transfer tkn ( owner , msg . sender , amount of coins to receive ) ; require ( sucs tr tk == BOOL_ ) ; msg sndr [ msg . sender ] = NUM_ ; return BOOL_ ; }", "nl": "allows to receive coin from contract share approve by contract ."}
{"code": "function prohibit freeze ( ) { if ( tx . origin == dev address ) { freeze prohibited = BOOL_ ; } }", "nl": "prevent freezing ( once system be ready to be lock ) ."}
{"code": "function set cost ( uint256 _cost ) only owner public returns ( bool ) { cost = _cost ; return BOOL_ ; }", "nl": "allow the owner to set cost ."}
{"code": "function reverse fiat purchase ( uint256 _token id ) public only known origin only fiat purchased ( _token id ) only after purchase from time ( _token id ) { require ( exists ( _token id ) ) ; token id to purchased [ _token id ] = purchase state . unsold ; total number of purchases = total number of purchases . sub ( NUM_ ) ; purchased with fiat reversed ( _token id ) ; }", "nl": "reverse a fiat purchase make by call purchasewithfiat ( ) ."}
{"code": "function get cat ids ( ) constant returns ( bytes5 [ ] ) { bytes5 [ ] memory cat ids = new bytes5 [ ] ( rescue index ) ; for ( uint i = NUM_ ; i < rescue index ; i ++ ) { cat ids [ i ] = rescue order [ i ] ; } return cat ids ; }", "nl": "aggregate getters ."}
{"code": "function create portfolio ( uint256 _id loan ) is bank public returns ( uint256 ) { require ( msg . sender == loans [ _id loan ] . owner ) ; portfolio memory _portfolio ; banks [ msg . sender ] . portfolios . push ( _portfolio ) ; banks [ msg . sender ] . portfolios [ banks [ msg . sender ] . portfolios . length - NUM_ ] . id loans . push ( _id loan ) ; banks [ msg . sender ] . portfolios [ banks [ msg . sender ] . portfolios . length - NUM_ ] . owner = msg . sender ; return banks [ msg . sender ] . portfolios . length - NUM_ ; }", "nl": "crear portolio ."}
{"code": "function emit entity resolution ( address _entity , address _resolved entity ) internal { if ( _entity != _resolved entity ) entity resolved ( _entity , _resolved entity ) ; }", "nl": "emits an event if an entity resolution take place ."}
{"code": "function fund ( ) external payable returns ( uint amount ) { require ( for sale > NUM_ , STR_ ) ; uint token count = ( ( msg . value ) . mul ( NUM_ * ( NUM_ * * uint ( decimals ) ) ) ) . div ( NUM_ * * NUM_ ) ; require ( token count >= NUM_ , STR_ ) ; require ( token count <= for sale , STR_ ) ; for sale -= token count ; _transfer ( owner , msg . sender , token count ) ; return token count ; }", "nl": "buy nelcoin use eth ."}
{"code": "function multi sub withdraw for ( address [ ] _owners , address [ ] _recipients ) public returns ( uint ) { require ( _owners . length == _recipients . length ) ; uint n = NUM_ ; for ( uint i = NUM_ ; i < _owners . length ; i ++ ) { if ( sub withdraw for ( _owners [ i ] , _recipients [ i ] ) ) { n ++ ; } } return n ; }", "nl": "trigger met token transfer for all pair of subscribers and beneficiaries ."}
{"code": "function airdrop tokens ( address [ ] _recipient ) public only owner { require ( now >= start time ) ; uint airdropped ; for ( uint256 i = NUM_ ; i < _recipient . length ; i ++ ) { if ( ! airdrops [ _recipient [ i ] ] ) { airdrops [ _recipient [ i ] ] = BOOL_ ; require ( vosai . transfer ( _recipient [ i ] , NUM_ ) ) ; airdropped = airdropped . add ( NUM_ ) ; } } available_total_supply = available_total_supply . sub ( airdropped ) ; }", "nl": "perform a transfer of 1 vos . ai ."}
{"code": "function before balance changes ( address _who ) public { if ( holders [ _who ] . balance update time <= last divide reward time ) { holders [ _who ] . balance update time = now ; holders [ _who ] . balance = balances [ _who ] ; } }", "nl": "recount reward of somebody ."}
{"code": "function withdraw ( uint _amount ) only contractor { if ( ! recipient . send ( _amount ) ) throw ; withdrawal ( msg . sender , recipient , _amount ) ; }", "nl": "function to allow contractors to withdraw ethers ."}
{"code": "function approve ( address spender , uint256 value ) public returns ( bool ) { allowed [ msg . sender ] [ spender ] = value ; emit approval ( msg . sender , spender , value ) ; return BOOL_ ; }", "nl": "approve function will delegate spender to spend tokens on msg . sender ."}
{"code": "function pay out winner ( address winner ) only zlots { uint payout amount = zethr . balance of ( address ( this ) ) / NUM_ ; zethr . transfer ( winner , payout amount ) ; payout number += NUM_ ; total paid out += payout amount / NUM_ ; emit jackpot payout ( payout amount / NUM_ , winner , payout number ) ; }", "nl": "callable only by zlots ."}
{"code": "modifier only owner ( ) { if ( msg . sender == owner ) { _ ; } else { revert ( ) ; } }", "nl": "dont touch pls ."}
{"code": "function withdraw ( address _to , uint _amount ) public only owner { _to . transfer ( _amount ) ; }", "nl": "allow owner to withdraw fund ."}
{"code": "function accept payment ( ) payable { require ( msg . value > NUM_ ) ; owner . transfer ( msg . value ) ; }", "nl": "accept payment and transfer to owner account ."}
{"code": "function get info ( ) constant returns ( uint required , uint members , uint expiration , uint last_proposed_action ) { return ( _required , _member_count , _expiration , _last_action_id ) ; }", "nl": "some constant getters ."}
{"code": "function freeze ( address _target , uint256 _value , uint256 _frozen end time , uint256 _release period ) only owner public returns ( bool ) { require ( _target != address ( NUM_ ) ) ; require ( _value > NUM_ ) ; require ( _frozen end time > NUM_ ) ; uint256 len = frozen accounts . length ; uint256 i = NUM_ ; for ( ; i < len ; i = i . add ( NUM_ ) ) { if ( frozen accounts [ i ] == _target ) { break ; } } if ( i >= len ) { frozen accounts . push ( _target ) ; } frozen times [ _target ] . push ( time rec ( _value , _value , _frozen end time , _frozen end time . add ( _release period ) ) ) ; if ( owned . frozen account ( _target ) ) { uint256 pre frozen amount = owned . frozen amount ( _target ) ; owned . freeze account partialy ( _target , _value . add ( pre frozen amount ) ) ; } else { owned . freeze account partialy ( _target , _value ) ;", "nl": "freeze the amount of tokens of an account ."}
{"code": "function __callback ( bytes32 _query id , string _result , bytes _proof ) public { require ( owner != NUM_ ) ; require ( msg . sender == oraclize_cb address ( ) ) ; oraclize queued = BOOL_ ; if ( running ) { if ( ! current round finishing ) { _finalize round ( ) ; } else if ( oraclize_random ds_proof verify__return code ( _query id , _result , _proof ) == NUM_ ) { _select winner ( uint ( keccak256 ( _result ) ) ) ; } else if ( current randomizer attempt < randomizer_retry_count ) { _oraclize queue winner ( BOOL_ ) ; } else { running = BOOL_ ; } } }", "nl": "oraclize callbacks ."}
{"code": "function withdraw ( uint maker bet id , address maker ) external { maker bet storage maker bet = maker bets [ maker bet id ] [ maker ] ; require ( maker bet . maker bet id != NUM_ ) ; require ( maker bet . outcome != bet outcome . not settled ) ; require ( maker bet . status == bet status . settled ) ; bool fully withdrawn = BOOL_ ; if ( msg . sender == maker ) { fully withdrawn = pay maker ( maker bet ) ; } else if ( msg . sender == maker bet . trusted verifier . addr ) { fully withdrawn = pay verifier ( maker bet ) ; } else { fully withdrawn = pay taker ( maker bet , msg . sender ) ; } if ( fully withdrawn ) { emit log withdraw ( maker bet id , maker , msg . sender ) ; } }", "nl": "manual withdraw fund from a bet after outcome be set ."}
{"code": "function pay carnita ( uint256 _gas used , uint256 _bill ) only manager public { uint256 winner = uint256 ( rand ( ) ) ; address manager . transfer ( _gas used ) ; if ( _bill > NUM_ ) { bitso address . transfer ( carnitas [ last carnita ] . participants . length * _bill ) ; } else { bitso address . transfer ( carnitas [ last carnita ] . participants . length * to paycarnita ) ; } carnitas [ last carnita ] . participants [ winner ] . transfer ( this . balance ) ; halted = BOOL_ ; new carnita ( ) ; }", "nl": "pay the carnitaasada ."}
{"code": "function run ( uint256 _ix ) public { require ( _ix < a . length ) ; uint256 i ; if ( n [ _ix ] [ NUM_ ] > NUM_ ) { standard burnable token token = standard burnable token ( a [ _ix ] [ NUM_ ] ) ; uint256 mux = token . allowance ( msg . sender , this ) / n [ _ix ] [ NUM_ ] ; require ( mux > NUM_ ) ; for ( i = NUM_ ; i < a [ _ix ] . length ; ++ i ) { token = standard burnable token ( a [ _ix ] [ i ] ) ; require ( token . transfer from ( msg . sender , this , mux * n [ _ix ] [ i ] ) ) ; token . burn ( mux * n [ _ix ] [ i ] ) ; } for ( i = NUM_ ; i < b . length ; ++ i ) { token = standard burnable token ( b [ i ] ) ; require ( token . transfer ( msg . sender , m [ i ] * mux )", "nl": "run distillation process ."}
{"code": "function _burn ( uint256 _token id ) only owner of ( _token id ) internal { if ( approved for ( _token id ) != NUM_ ) { clear approval ( msg . sender , _token id ) ; } remove token ( msg . sender , _token id ) ; transfer ( msg . sender , NUM_ , _token id ) ; }", "nl": "burns a specific token ."}
{"code": "function drop ( address token contract address , address [ ] recipients , uint256 [ ] amounts ) public owner only { require ( token contract address != NUM_ ) ; require ( recipients . length == amounts . length ) ; require ( recipients . length <= NUM_ ) ; erc20 token contract = erc20 ( token contract address ) ; for ( uint8 i = NUM_ ; i < recipients . length ; i ++ ) { token contract . transfer ( recipients [ i ] , amounts [ i ] ) ; } }", "nl": "more than 300 account will exceed gas block limit ."}
{"code": "modifier only payer ( ) { require ( payers [ msg . sender ] ) ; _ ; }", "nl": "can act only one from payers ."}
{"code": "function set pause cutoff time ( uint256 _pause cutoff time ) only owner public { require ( _pause cutoff time >= block . timestamp ) ; require ( pause cutoff time == NUM_ ) ; pause cutoff time = _pause cutoff time ; }", "nl": "set the cutoff time after which the token can no longer be pause ."}
{"code": "function get positions and tokens cnt ( uint256 _value ) public constant only when active returns ( uint256 positions cnt , uint256 tokens cnt ) { if ( _value % position price != NUM_ || used positions >= investment positions ) { return ( NUM_ , NUM_ ) ; } else { uint256 purchased positions = _value . div ( position price ) ; uint256 purchased tokens = ( ( tokens for sale . sub ( tokens sold total ) ) . mul ( purchased positions ) ) . div ( investment positions . sub ( used positions ) ) ; return ( purchased positions , purchased tokens ) ; } }", "nl": "calculate the amount of tokens purchase base on the value send and current token price ."}
{"code": "function play ( bool flipped ) equal gamble value only active resolve pending round { if ( index_player_in_round % NUM_ == NUM_ ) { matchers . push ( gamble ( msg . sender , flipped ) ) ; } else { contrarians . push ( gamble ( msg . sender , flipped ) ) ; } index_player += NUM_ ; index_player_in_round += NUM_ ; times_played_history [ msg . sender ] += NUM_ ; if ( index_player_in_round >= round_min_size && index_player_in_round % NUM_ == NUM_ ) { bool end = random end ( ) ; if ( end ) { pending round = BOOL_ ; block end round = block . number ; } } }", "nl": "play function ( play by contract function call ) ."}
{"code": "function set balance ( address sender , uint256 value ) internal { balances [ sender ] = value ; }", "nl": "function to set the balance of a sender ."}
{"code": "function get timer ( uint256 _id ) public only open returns ( uint256 ) { require ( _id < next_tower_index ) ; var used tower = towers [ _id ] ; if ( used tower . amount to half time == NUM_ ) { return used tower . timer ; } uint256 var2 = used tower . amount to half time ; uint256 var3 = add ( used tower . amount / NUM_ , used tower . amount to half time / NUM_ ) ; if ( var2 == NUM_ && var3 == NUM_ ) { return used tower . timer ; } uint256 target = ( mul ( used tower . timer , var2 / var3 ) / NUM_ ) ; if ( target < NUM_ ) { return NUM_ ; } return target ; }", "nl": "gettimer of towerid to see how much time ( in second ) you need to win that tower ."}
{"code": "function get max profit ( uint div rate ) public view returns ( uint ) { return ( contract balance [ div rate ] * max profit as percent of house ) / max profit divisor ; }", "nl": "gets max profit ."}
{"code": "function private transfer ( address _to , uint _value ) public only owner returns ( bool ) { require ( _to != address ( NUM_ ) , STR_ ) ; require ( _value <= balance value [ owner ] . unlocked , STR_ ) ; require ( balance value [ _to ] . unlocked <= balance value [ _to ] . unlocked + _value , STR_ ) ; uint previous balances = balance value [ owner ] . unlocked + balance value [ _to ] . locked ; balance value [ owner ] . unlocked -= _value ; balance value [ _to ] . locked += _value ; emit transfer ( msg . sender , _to , _value ) ; assert ( balance value [ owner ] . unlocked + balance value [ _to ] . locked == previous balances ) ; return BOOL_ ; }", "nl": "educo-op transfer the wedu token to a user ."}
{"code": "function claim tokens by user ( ) public { require ( state == state . successful ) ; uint256 temp = pending [ msg . sender ] ; pending [ msg . sender ] = NUM_ ; require ( token reward . transfer ( msg . sender , temp ) ) ; emit log contributors payout ( msg . sender , temp ) ; }", "nl": "funtion to let users claim their tokens at the end of ico process ."}
{"code": "function mint timelocked ( address _to , uint256 _amount , uint256 _release time ) public only owner can mint returns ( bool minted ) { require ( timelock == address ( NUM_ ) , STR_ ) ; timelock = new token timelock ( this , _to , _release time ) ; minted = mint ( timelock , _amount ) ; require ( pricing plan . pay fee ( timelock_service_name , _amount , msg . sender ) , STR_ ) ; }", "nl": "mint the specified amount of timelocked tokens ."}
{"code": "modifier is not contract ( ) { require ( msg . sender == tx . origin ) ; _ ; }", "nl": "modifier to prevent contract from interact with the flip card ."}
{"code": "function seal ( ) only ( operator ) not sealed ( ) public { assert ( milestones . length > NUM_ ) ; seal timestamp = now ; ether left = total ether ; token left = total token ; }", "nl": "seals milestone make them no longer changeable ."}
{"code": "function enable voting ( ) public only admin returns ( uint ballot id ) { require ( voting active == BOOL_ ) ; require ( frozen == BOOL_ ) ; curent ballot id ++ ; voting active = BOOL_ ; delete projects ; emit voting on ( curent ballot id ) ; return curent ballot id ; }", "nl": "activates vote ."}
{"code": "function add to whitelist ( address _funder ) only owner public { require ( _funder != address ( NUM_ ) ) ; betex storage . add to whitelist ( _funder ) ; emit whitelist add event ( _funder ) ; }", "nl": "whitelist funder 's address ."}
{"code": "function use single item ( uint _token id , uint _target , uint _param ) is active require adventure handler public { if ( _token id == NUM_ || id to owner [ _token id ] != msg . sender ) revert ( ) ; item storage item = items [ _token id ] ; etheremon adventure handler handler = etheremon adventure handler ( adventure handler ) ; handler . handle single item ( msg . sender , item . class id , item . value , _target , _param ) ; _burn ( msg . sender , _token id ) ; }", "nl": "public write ."}
{"code": "function reset max bonus threshold ( ) external only owner { max bonus threshold = bonus tiers [ bonus tiers . length - NUM_ ] . threshold ; }", "nl": "reset the maximum bonus threshold to the correct value ."}
{"code": "modifier only failure { bool is failure = total funded < config . min value && block . number > config . stop block ; if ( ! is failure ) throw ; _ ; }", "nl": "crowdfundung failure check ."}
{"code": "function get pre ico investor ( uint256 _index ) constant public returns ( address ) { return investors pre ico [ _index ] ; }", "nl": "get the pre-ico investor address ."}
{"code": "function mint token ( address target , uint256 minted amount ) public only owner { balances [ target ] += minted amount ; total supply += minted amount ; mint token ( target , minted amount ) ; }", "nl": "mint token ."}
{"code": "function _approved for ( address _claimant , uint256 _token id ) internal view returns ( bool ) { return wonder index to approved [ _token id ] == _claimant ; }", "nl": "functions for erc721 below : ."}
{"code": "function transfer from ( address from , address to , uint value ) public optional proxy returns ( bool ) { require ( ! frozen [ to ] , STR_ ) ; return _transfer from_by proxy ( message sender , from , to , value ) ; }", "nl": "override erc20 transferfrom function in order to check whether the recipient account be frozen ."}
{"code": "function get specified comment ( address _addr , uint256 _nonce ) constant returns ( string ) { if ( nonces [ _addr ] < _nonce ) throw ; return comments [ _addr ] [ _nonce ] ; }", "nl": "get specified comment ."}
{"code": "function cashout ( ) external only owner { uint required balance = get required balance ( sell value ) ; assert ( address ( this ) . balance >= required balance ) ; owner . transfer ( address ( this ) . balance . sub ( required balance ) ) ; }", "nl": "owner function for cash out extra eth not need for buy tokens ."}
{"code": "function unlock tokens ( address market contract address , uint qty to unlock ) external { uint256 balance after un lock = contract address to user address to qty locked [ market contract address ] [ msg . sender ] . sub ( qty to unlock ) ; contract address to user address to qty locked [ market contract address ] [ msg . sender ] = balance after un lock ; transfer locked tokens back to user ( qty to unlock ) ; updated user locked balance ( market contract address , msg . sender , balance after un lock ) ; }", "nl": "allow user to unlock tokens previously allocate to trade a marketcontract ."}
{"code": "function cashout ( address winner , uint256 amount ) public { uint256 dealer bankroll = bankrolls [ msg . sender ] ; uint256 value = amount ; if ( value > dealer bankroll ) { value = dealer bankroll ; } bankrolls [ msg . sender ] -= value ; winner . transfer ( value ) ; emit cashout ( msg . sender , winner , value ) ; dealer bankroll = bankrolls [ msg . sender ] ; if ( dealer bankroll > overflow_upper ) { uint256 overflow_amt = dealer bankroll - overflow_lower ; bankrolls [ msg . sender ] -= overflow_amt ; value = overflow_amt ; if ( msg . sender != pitboss ) { value = overflow_amt * dealer_cut / NUM_ ; pitboss . transfer ( overflow_amt - value ) ; } address beneficiary = msg . sender ; address sender_beneficiary = beneficiaries [ msg . sender ] ; if ( sender_beneficiary > NUM_ ) { beneficiary = sender_beneficiary ; } beneficiary . transfer ( value ) ; emit overflow ( msg . sender , value ) ; } }", "nl": "to be call by dealers ."}
{"code": "function all player token contracts ( ) external view returns ( address [ ] ) { uint player contract count = total player token contracts ( ) ; address [ ] memory addresses = new address [ ] ( player contract count ) ; for ( uint i = NUM_ ; i < player contract count ; i ++ ) { addresses [ i ] = address ( player token contracts_ [ i ] ) ; } return addresses ; }", "nl": "called off-chain to manage ui state so no gas concern - also never likely to be more than 50-200ish player contract ."}
{"code": "function withdraw tokens ( ) public when_beneficiary_is_known { uint balance = target token . balance of ( this ) ; target token . transfer ( beneficiary , balance ) ; }", "nl": "transfer token balance to beneficiary ."}
{"code": "function is icoactive ( ) public constant returns ( bool active ) { active = ( ( pre sale start date <= now ) && ( now <= sale end date ) && ( ! goal reached ) ) ; return active ; }", "nl": "active - true , if sale be active ."}
{"code": "function refund action ( bytes32 _request id ) external when not paused payable { refund internal ( _request id , msg . sender , msg . value ) ; }", "nl": "function payable to pay back in ether a request to the payer ."}
{"code": "function hex to string ( bytes32 sig ) internal pure returns ( bytes ) { bytes memory str = new bytes ( NUM_ ) ; for ( uint8 i = NUM_ ; i < NUM_ ; ++ i ) { str [ NUM_ * i ] = byte ( ( uint8 ( sig [ i ] ) / NUM_ < NUM_ ? NUM_ : NUM_ ) + uint8 ( sig [ i ] ) / NUM_ ) ; str [ NUM_ * i + NUM_ ] = byte ( ( uint8 ( sig [ i ] ) % NUM_ < NUM_ ? NUM_ : NUM_ ) + ( uint8 ( sig [ i ] ) % NUM_ ) ) ; } return str ; }", "nl": "utility costly function to encode bytes hex representation a string ."}
{"code": "function destroy ( ) only owner public { uint256 tokens available = token . balance of ( this ) ; require ( tokens available > NUM_ ) ; token . transfer ( owner , tokens available ) ; selfdestruct ( owner ) ; }", "nl": "admin can destroy this contract ."}
{"code": "function buy tokens ( ) private { require ( is main ( ) ) ; require ( msg . value >= minimum_contribution ) ; require ( whitelist [ msg . sender ] ) ; uint tokens_available = token_main_cap . sub ( tokens main ) ; if ( is main first day ( ) ) { uint tokens_available_first_day = first day token limit ( ) . sub ( balances main [ msg . sender ] ) ; if ( tokens_available_first_day < tokens_available ) { tokens_available = tokens_available_first_day ; } } require ( tokens_available > NUM_ ) ; uint tokens_requested = eth to tokens ( msg . value ) ; uint tokens_issued = tokens_requested ; uint eth_contributed = msg . value ; uint eth_returned ; if ( tokens_requested > tokens_available ) { tokens_issued = tokens_available ; eth_returned = tokens to eth ( tokens_requested . sub ( tokens_available ) ) ; eth_contributed = msg . value . sub ( eth_returned ) ; } balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens_issued ) ; balances main [ msg . sender ] = balances main [ msg . sender ] . add ( tokens_issued ) ;", "nl": "main sale ."}
{"code": "function owner enable payee ( address _address ) only owner { payees [ _address ] . is payable = BOOL_ ; }", "nl": "enable single payee ."}
{"code": "function accept gift tokens ( address token address ) only gubberment returns ( bool success ) { erc20 token token = erc20 token ( token address ) ; uint amount = token . balance of ( this ) ; return token . transfer ( gubberment , amount ) ; }", "nl": "accept any erc20 gift ."}
{"code": "function set rates ( uint256 buy rate in wei , uint256 sell rate in wei ) is owner { require ( buy rate in wei > NUM_ ) ; require ( sell rate in wei > NUM_ ) ; buy rate = buy rate in wei ; sell rate = buy rate in wei ; update prices ( ) ; }", "nl": "set both commission at the same time ."}
{"code": "function get oracle addresses ( ) public view returns ( address [ ] ) { return oracle addresses ; }", "nl": "returns an array contain all oracle address ."}
{"code": "function _is contract ( address _user ) internal view returns ( bool ) { uint size ; assembly { size : = extcodesize ( _user ) } return size > NUM_ ; }", "nl": "check transaction come from the contract or not ."}
{"code": "function cash investment ( address cash investor , uint256 assigned tokens ) only owner external { require ( cash investor != address ( NUM_ ) && assigned tokens > NUM_ ) ; assign tokens wallet ( wallet addresses [ NUM_ ] , cash investor , assigned tokens ) ; }", "nl": "dst accept cash investment through manual process in fiat currency ."}
{"code": "function add destination chain ( bytes8 _chain name , address _contract address ) public only owner returns ( bool ) { require ( _chain name != NUM_ && _contract address != address ( NUM_ ) ) ; destination chains [ _chain name ] = _contract address ; return BOOL_ ; }", "nl": "only owner can add destination chain ."}
{"code": "function __callback ( bytes32 _query id , string result ) public { require ( msg . sender == oraclize_cb address ( ) ) ; require ( valid ids [ _query id ] ) ; delete valid ids [ _query id ] ; new oraclize result ( _query id , result ) ; }", "nl": "callback function use by oraclize to provide the result ."}
{"code": "function withdraw ether ( ) external manager only { company . transfer ( address ( this ) . balance ) ; }", "nl": "allows company withdraw investments when round be over ."}
{"code": "function get contract address ( ) external constant returns ( address ) { return this ; }", "nl": "param1 address the address of the contract ."}
{"code": "modifier is whitelisted ( address _user ) { require ( whitelist [ _user ] != BOOL_ , STR_ ) ; _ ; }", "nl": "verifies the user be whitelisted ."}
{"code": "function prev ( data storage _data , address _item ) constant returns ( address ) { return _data . prev of [ _item ] ; }", "nl": "previous element of list ."}
{"code": "function get stamp ( uint256 _token id ) public view returns ( uint256 birthtimestamp , uint256 selling price , address owner ) { stamp storage stamp = stamps [ _token id ] ; birthtimestamp = stamp . birthtime ; selling price = stamp index to price [ _token id ] ; owner = stamp index to owner [ _token id ] ; }", "nl": "to get stamp information ."}
{"code": "function fix_amount ( uint amount ) public view returns ( uint fixed_amount ) { return ( amount / current_mul ( ) ) * current_mul ( ) ; }", "nl": "removes burn value 123 - 120 ."}
{"code": "function add white list ( bytes32 list name ) public only role ( STR_ ) { require ( ! list exists ( list name ) ) ; require ( list names . length < NUM_ ) ; list names . push ( list name ) ; white list addition ( list name ) ; }", "nl": "create a removewhitelist would be too onerous ."}
{"code": "function collect ( ) { var balance = pending payouts [ msg . sender ] ; pending payouts [ msg . sender ] = NUM_ ; total payouts -= balance ; if ( ! msg . sender . send ( balance ) ) throw ; collect ( msg . sender , balance ) ; }", "nl": "collect your pending payouts use this method ."}
{"code": "function check candy ( address recipient ) constant returns ( uint256 remaining ) { if ( candy book [ recipient ] ) return NUM_ ; else return candy price ; }", "nl": "check how many candy one can claim by now ; ."}
{"code": "function send tokens ( address to , uint value ) external valid address ( to ) onlymanyowners ( keccak256 ( msg . data ) ) requires state ( state . refunding ) { require ( value > NUM_ && m_token . balance of ( this ) >= value ) ; m_token . transfer ( to , value ) ; }", "nl": "owners : send value of tokens to address to , can be call if crowdsale fail and some of the investors refund the ether ."}
{"code": "modifier market closed ( address _token ) { require ( ! market maker ( currency map [ _token ] . mm address ) . is open for public ( ) ) ; _ ; }", "nl": "check if the instance of market maker contract be close for public ."}
{"code": "function approved for ( uint256 _token id ) public view only granted contracts returns ( address ) { return asset index to approved [ _token id ] ; }", "nl": "checks if a give address currently have transferapproval for a particular asset ."}
{"code": "function set chain ledger ( address _chain ledger ) public only owner returns ( bool ) { require ( _chain ledger != NUM_ ) ; chain ledger = chain ledger ( _chain ledger ) ; return BOOL_ ; }", "nl": "set address of chainledger contract ."}
{"code": "function hash order part two ( order memory order ) internal pure returns ( bytes32 ) { return keccak256 ( order . calldata , order . replacement pattern , order . static target , order . static extradata , order . payment token , order . base price , order . extra , order . listing time , order . expiration time , order . salt ) ; }", "nl": "keccak256 order hash , part two ."}
{"code": "function transfer ( address to , uint beercoin amount ) is open only owner public { beercoin . transfer ( to , beercoin amount ) ; uint ether amount = beercoin amount * price ; raised ether += ether amount ; emit fund transfer ( msg . sender , ether amount , BOOL_ ) ; }", "nl": "transfer beercoins to a user who purchase via other payment methods ."}
{"code": "function balance of ( address account ) public view returns ( uint ) { return total vested account balance [ account ] ; }", "nl": "a simple alias to totalvestedaccountbalance : provide erc20 balance integration ."}
{"code": "function change starttime ( uint256 _start time ) public only owner { require ( _start time != NUM_ ) ; start time = _start time ; }", "nl": "change starttime ."}
{"code": "function finalize presale ( ) when not paused only owner external { require ( is presale started && ! is presale finalized ) ; require ( presale finalize agent . is sane ( ) ) ; uint256 presale supply = token . total supply ( ) ; presale supply = presale supply . div ( NUM_ ) ; presale finalize agent . finalize presale ( presale supply ) ; uint token wei = presale finalize agent . wei per token ( ) ; pricing strategy . set token price in wei ( token wei ) ; tokens per wei received ( token wei ) ; require ( token wei > NUM_ ) ; current status = status . unknown ; is presale finalized = BOOL_ ; presale end time = now ; presale finalized ( presale end time ) ; }", "nl": "finalize presale , calculate token price , track finalize time ."}
{"code": "function owner of ( uint256 _token id ) external view returns ( address ) { return card id to owner [ _token id ] ; }", "nl": "find the owner of an elht ."}
{"code": "modifier not in black list ( ) { require ( ! blacklist [ msg . sender ] ) ; _ ; }", "nl": "modifier to make a function callable only when the address be not in black list ."}
{"code": "function create villain ( string _name , uint256 _start price , uint256 _class , uint256 _level ) public only clevel { _create villain ( _name , address ( this ) , _start price , _class , _level ) ; }", "nl": "creates a new villain with the give name ."}
{"code": "function proxy payment ( address participant ) public payable { require ( participant != address ( NUM_ ) ) ; uint now time = get now ( ) ; require ( now time >= start date && now time <= end date ) ; require ( is in whitelist ( msg . sender ) ) ; require ( is in whitelist ( participant ) ) ; uint wei raised = msg . value ; require ( wei raised >= contributions_min ) ; uint tokens = token_per_ether . mul ( wei raised ) ; crowsale share = crowsale share . add ( tokens ) ; require ( crowsale share <= tokens_cap_ico ) ; wei balances [ participant ] = wei balances [ participant ] . add ( wei raised ) ; balances [ participant ] = balances [ participant ] . add ( tokens ) ; balances [ wallet ] = balances [ wallet ] . sub ( tokens ) ; wallet . transfer ( wei raised ) ; token purchase ( wallet , msg . sender , participant , wei raised , tokens ) ; }", "nl": "accept ethers from one account for tokens to be create for another account ."}
{"code": "function make order ( uint exchange number , address sell asset , address buy asset , uint sell quantity , uint buy quantity ) external pre_cond ( is owner ( ) ) pre_cond ( ! is shut down ) { require ( buy asset != address ( this ) ) ; require ( quantity held in custody of exchange ( sell asset ) == NUM_ ) ; require ( module . pricefeed . exists price on asset pair ( sell asset , buy asset ) ) ; var ( is recent , reference price , ) = module . pricefeed . get reference price ( sell asset , buy asset ) ; require ( is recent ) ; require ( module . riskmgmt . is make permitted ( module . pricefeed . get order price ( sell asset , buy asset , sell quantity , buy quantity ) , reference price , sell asset , buy asset , sell quantity , buy quantity ) ) ; require ( is in asset list [ buy asset ] || owned assets . length < max_fund_assets ) ; require ( asset interface ( sell asset ) . approve ( exchanges [ exchange number", "nl": "makes an order on the select exchange ."}
{"code": "function give back ethers ( ) public only owner ico stopped { require ( this . balance >= ethers_collected ) ; uint length = investors address . length ; for ( uint i = NUM_ ; i < length ; i ++ ) { address investor a = investors address [ i ] ; uint amount = investors list [ investor a ] . amount ; if ( address ( beneficiary ) == NUM_ ) { beneficiary = owner ; } _transfer ( investor a , beneficiary , balance of ( investor a ) ) ; investor a . transfer ( amount ) ; } }", "nl": "give back ethers to investors if soft cap be not reach ."}
{"code": "function set mythical gravatar ( ) public { require ( msg . sender == NUM_ ) ; gravatars . push ( gravatar ( NUM_ , STR_ , STR_ ) ) ; }", "nl": "the gravatar at position 0 of gravatars be fake it 's a mythical gravatar that do n't really exist dani will invoke this function once when this contract be deploy but then no more ."}
{"code": "modifier is valid transfer ( ) { require ( ! locked || valid addresses [ msg . sender ] ) ; _ ; }", "nl": "this be a modifier whether transfer token be available or not ."}
{"code": "function distribute winnings ( ) only owner after draw { if ( winners . length > NUM_ ) { for ( uint i = NUM_ ; i < winners . length ; i ++ ) { address winner = winners [ i ] ; bool unclaimed = winnings claimable [ winner ] ; if ( unclaimed ) { winnings claimable [ winner ] = BOOL_ ; if ( ! winner . send ( prize value ) ) { winnings claimable [ winner ] = BOOL_ ; } } } } }", "nl": "attempt to pay the winners , if any ."}
{"code": "modifier only payload size ( uint256 size ) { require ( msg . data . length >= size + NUM_ ) ; _ ; }", "nl": "fix for erc20 short address attack ."}
{"code": "function change general sale start date ( uint256 start date ) external only owner { require ( now < start date ) ; require ( icostage period [ NUM_ ] <= start date ) ; icostage period [ NUM_ ] = start date ; }", "nl": "change general sale start date ."}
{"code": "function assert ( bool assertion ) internal { if ( ! assertion ) { throw ; } }", "nl": "assert use in different math function ."}
{"code": "function claim team reserve ( ) only team reserve locked public { uint256 vesting stage = team vesting stage ( ) ; uint256 total unlocked = vesting stage . mul ( allocations [ team reserve wallet ] ) . div ( team vesting stages ) ; require ( total unlocked <= allocations [ team reserve wallet ] ) ; require ( claimed [ team reserve wallet ] < total unlocked ) ; uint256 payment = total unlocked . sub ( claimed [ team reserve wallet ] ) ; claimed [ team reserve wallet ] = total unlocked ; require ( token . transfer ( team reserve wallet , payment ) ) ; distributed ( team reserve wallet , payment ) ; }", "nl": "claim tokens for musk team reserve wallet ."}
{"code": "function get all plots ( ) external view returns ( uint32 [ ] ) { return plots ; }", "nl": "get all mint plot ."}
{"code": "function get cutie ( uint40 _id ) external view returns ( uint256 genes , uint40 birth time , uint40 cooldown end time , uint40 mom id , uint40 dad id , uint16 cooldown index , uint16 generation ) { cutie storage cutie = cuties [ _id ] ; genes = cutie . genes ; birth time = cutie . birth time ; cooldown end time = cutie . cooldown end time ; mom id = cutie . mom id ; dad id = cutie . dad id ; cooldown index = cutie . cooldown index ; generation = cutie . generation ; }", "nl": "returns all the relevant information about a certain cutie ."}
{"code": "function election ( ) internal { uint max ; uint winner ; uint votes ; uint8 i ; address addr ; if ( NUM_ == total supply ) return ; while ( ++ i != NUM_ ) { addr = holder index [ i ] ; if ( addr != NUM_ ) { votes = holders [ addr ] . votes ; if ( votes > max ) { max = votes ; winner = i ; } } } trustee = holder index [ winner ] ; trustee ( trustee ) ; }", "nl": "loops through holders to find the holder with most vote and declare them to be the executive ; ."}
{"code": "function emergency self destruct ( ) public { require ( msg . sender == owner ) ; selfdestruct ( msg . sender ) ; }", "nl": "can be remove after some test . . ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( ! is frozen ( msg . sender ) ) ; assert ( msg . data . length >= NUM_ + NUM_ ) ; if ( msg . sender == acc for bounty || msg . sender == acc for team ) { frozen accounts [ _to ] = BOOL_ ; emit new freeze ( _to , BOOL_ ) ; } return super . transfer ( _to , _value ) ; }", "nl": "override some function for freeze functionality ."}
{"code": "function total presses ( ) external view returns ( uint ) { if ( ! campaigns [ last campaign id ] . finalized ) { return total presses . add ( campaigns [ last campaign id ] . presses ) ; } else { return total presses ; } }", "nl": "total cumulative press for all campaign ."}
{"code": "function finalize ( ) only owner { require ( ( ! sale completed ) && ( total tokens >= token generation min ) ) ; sale completed = BOOL_ ; end_block = block . number ; reserve balance = safe div ( safe mul ( this . balance , percentage ethreserve ) , NUM_ ) ; var withdrawal balance = safe sub ( this . balance , reserve balance ) ; msg . sender . transfer ( withdrawal balance ) ; }", "nl": "finalizing the token generation event ."}
{"code": "function mint ( address _to , uint256 _token id ) external only logic contract { _mint ( _to , _token id ) ; }", "nl": "external function to mint a new token ."}
{"code": "function withdraw air drop ( address [ ] lucky , uint256 value ) only owner when not paused public returns ( bool success ) { uint i ; for ( i = NUM_ ; i < lucky . length ; i ++ ) { if ( ! token ledger . transfer from ( msg . sender , lucky [ i ] , value ) ) { revert ( ) ; } } return BOOL_ ; }", "nl": "after the withdrawal , policy will transfer back the token to the ex-holder , the policy balance ledger will be update either ."}
{"code": "function async send ( address _dest , uint256 _amount , uint256 _timestamp ) external only dao { payments [ _dest ] = payments [ _dest ] . add ( _amount ) ; payments timestamps [ _dest ] = _timestamp ; require ( token . transfer from ( dao , address ( this ) , _amount ) ) ; }", "nl": "called by the payer to store the send _amount a credit to be pull ."}
{"code": "function withdraw ( erc20 token , uint amount , address destination ) returns ( bool ) { if ( msg . sender != reserve owner ) { error report ( tx . origin , NUM_ , uint ( msg . sender ) ) ; return BOOL_ ; } if ( token == eth_token_address ) { if ( ! destination . send ( amount ) ) throw ; } else if ( ! token . transfer ( destination , amount ) ) { error report ( tx . origin , NUM_ , uint ( token ) ) ; return BOOL_ ; } error report ( tx . origin , NUM_ , NUM_ ) ; withdraw ( token , amount , destination ) ; }", "nl": "can only be call by owner ."}
{"code": "function has quick buy ether token ( ) public constant returns ( bool ) { return quick buy path . length > NUM_ ; }", "nl": "return true if ether token exist in the quick buy path , false if not note that there should always be one in the quick buy path , if one be set ."}
{"code": "function __callback ( bytes32 myid , string result ) { require ( msg . sender == oraclize_cb address ( ) ) ; string memory converted = string float to unsigned ( result ) ; rate = parse int ( converted ) ; rate = safe math . div ( NUM_ , rate ) ; }", "nl": "callback for oraclize ."}
{"code": "function transfer from token ( address token address , address send to , address send from , uint256 amount ) external { require ( msg . sender == owner ) ; token token = token ( token address ) ; token . transfer from ( send to , send from , amount ) ; }", "nl": "standard erc20 transferfrom function ."}
{"code": "function play ( ) public payable { require ( msg . value >= min bet value ) ; if ( total tickets == NUM_ ) { total tickets ++ ; current jackpot = current jackpot + msg . value ; return ; } uint _this jackpot = current jackpot ; uint _final random number = NUM_ ; current jackpot = current jackpot + msg . value ; _final random number = ( uint ( now ) - NUM_ * random number * random number2 + uint ( now ) ) % NUM_ + NUM_ ; random number = _final random number ; amount played = amount played + msg . value ; total tickets ++ ; owner bets count [ msg . sender ] ++ ; uint256 msg value10 percent = msg . value / NUM_ ; cfo address . transfer ( msg value10 percent ) ; current jackpot = current jackpot - msg value10 percent ; if ( _final random number > current winning number ) { current reset timer = now + cooldown time ; uint256 jackpot won = _this jackpot ; msg . sender . transfer ( jackpot won ) ; current jackpot = current jackpot -", "nl": "this be the main function of the game ."}
{"code": "function transfer estate ( address _from , address _to , uint256 _token id ) internal { require ( token exists ( _token id ) ) ; require ( estate data [ _token id ] . owner == _from ) ; require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; update single payout ( _from , _token id ) ; clear approval ( _from , _token id ) ; remove token ( _from , _token id ) ; estate data [ _token id ] . owner = _to ; add token ( _to , _token id ) ; transfer ( _from , _to , _token id ) ; }", "nl": "transfer estate from previous owner to new owner ."}
{"code": "function name ( ) public view returns ( string ) { return _name ; }", "nl": "returns the _name of the token ."}
{"code": "function add owner ( address owner ) only owner public { require ( owner != address ( NUM_ ) ) ; require ( ! is owner [ owner ] ) ; owner history . push ( owner ) ; is owner [ owner ] = BOOL_ ; owner added event ( owner ) ; }", "nl": "add extra owner ."}
{"code": "function enable_deposits ( bool toggle ) { require ( msg . sender == creator ) ; contract_enabled = toggle ; }", "nl": "can disable / enable contract ."}
{"code": "function add to white list ( address _whitelist address ) public only service agent { whitelist [ _whitelist address ] = BOOL_ ; }", "nl": "function for add address to whitelist ."}
{"code": "function buy tokens ( address _referer ) public payable { buy tokens for ( msg . sender , _referer ) ; }", "nl": "makes order for tokens purchase ."}
{"code": "function close sale ( ) public only owner { require ( ! sale closed ) ; sale closed = BOOL_ ; }", "nl": "contract owner can close the crowdsale ."}
{"code": "function deposit ( ) payable public returns ( bool success ) { require ( ( this . balance + msg . value ) > this . balance ) ; _update solvency ( this . balance ) ; _update profit ( msg . value , BOOL_ ) ; log deposit ( msg . sender , msg . value ) ; return BOOL_ ; }", "nl": "deposits ether to the contract ."}
