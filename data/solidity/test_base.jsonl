{"code": "modifier only curator ( ) { require ( msg . sender == curator ) ; _ ; }\n", "nl": "throws if call by any account other than the supervisor ."}
{"code": "function close deposit sub round ( ) only controller public { require ( list sub round nlf [ current round ] [ current sub round ] . is open == BOOL_ ) ; require ( list sub round nlf [ current round ] [ current sub round ] . is close nac pool == BOOL_ ) ; list sub round nlf [ current round ] [ current sub round ] . is close nac pool = BOOL_ ; }\n", "nl": "every week controller deposit to subround to send nac to all user have nlf fci ."}
{"code": "function stake for ( address _user , uint256 _amount , bytes _data ) public { super . stake for ( _user , _amount , _data ) ; update credit balance ( _user , _amount , default lock in duration ) ; }\n", "nl": "stakes a certain amount of tokens , this must transfer the give amount from the caller ."}
{"code": "function destroy and send ( address _recipient ) public only owner { require ( minting finished ) ; super . destroy and send ( _recipient ) ; }\n", "nl": "transfers the current balance to the recepient and terminate the contract ."}
{"code": "function set min bet for oraclize ( uint256 min bet ) public { require ( msg . sender == owner ) ; minbet_for oraclize = min bet ; }\n", "nl": "allow the owner to change the minimum bet ."}
{"code": "function redeem ( uint256 _envelope id ) external { envelope storage envelope = envelopes [ _envelope id ] ; if ( envelope . will expire after >= block . timestamp ) { revert ( ) ; } if ( envelope . remaining value == NUM_ ) { revert ( ) ; } if ( envelope . maker != msg . sender ) { revert ( ) ; } uint256 value = envelope . remaining value ; envelope . remaining value = NUM_ ; envelope . remaining number = NUM_ ; balance of envelopes -= value ; msg . sender . transfer ( value ) ; redeemed ( msg . sender , _envelope id , value , block . timestamp ) ; }\n", "nl": "uint256 _envelopeid uint256 4 _data 0 - willexpireafter 1 - v 2 - r 3 - s ."}
{"code": "function create tokens ( ) public only state ( swap state . started ) { require ( now < ( enter date + NUM_ ) && token_a . balance of ( address ( this ) ) >= token_a_amount && token_b . balance of ( address ( this ) ) >= token_b_amount ) ; uint tokenratio = NUM_ ; ( long_token_address , tokenratio ) = factory . create token ( token_a_amount , long_party , BOOL_ , start_date ) ; num_drct_longtokens = token_a_amount . div ( tokenratio ) ; ( short_token_address , tokenratio ) = factory . create token ( token_b_amount , short_party , BOOL_ , start_date ) ; num_drct_shorttokens = token_b_amount . div ( tokenratio ) ; current_state = swap state . tokenized ; if ( premium > NUM_ ) { if ( creator == long_party ) { short_party . transfer ( premium ) ; } else { long_party . transfer ( premium ) ; } } }\n", "nl": "finish the crowdsale and withdraw fund ."}
{"code": "function create token ( bytes32 _name , string _description , string _base64 image ) public { require ( now > lock timestamp ) ; lock timestamp = lock timestamp . add ( NUM_ days ) ; uint256 _token id = total supply ( ) . add ( NUM_ ) ; _mint ( msg . sender , _token id ) ; add token metadata ( _token id , _name , _description , _base64 image ) ; }\n", "nl": "internal function to add a the metadata of a token ."}
{"code": "function change multisig ( address addr ) only owner public { if ( addr == address ( NUM_ ) ) throw ; multisig ether = addr ; }\n", "nl": "allow to change the recipient multisig address ."}
{"code": "function withdraw ( ) only owner public { wallet . transfer ( address ( this ) . balance ) ; }\n", "nl": "withdraws all ether from this contract to wallet ."}
{"code": "function challenge clearing ( bytes32 _value ) public payable { item storage item = items [ _value ] ; uint arbitrator cost = arbitrator . arbitration cost ( arbitrator extra data ) ; require ( msg . value >= stake + arbitrator cost ) ; require ( item . status == item status . clearing requested || item . status == item status . preventive clearing requested ) ; require ( ! item . disputed ) ; if ( item . balance >= arbitrator cost ) { item . challenger = msg . sender ; item . balance += msg . value - arbitrator cost ; item . disputed = BOOL_ ; item . dispute id = arbitrator . create dispute . value ( arbitrator cost ) ( NUM_ , arbitrator extra data ) ; dispute idto item [ item . dispute id ] = _value ; emit dispute ( arbitrator , item . dispute id , NUM_ ) ; } else { if ( item . status == item status . clearing requested ) item . status = item status . registered ; else item . status = item status . absent ; item . submitter . send (\n", "nl": "challenge a registration request ."}
{"code": "modifier when transferable ( ) { require ( transferable ) ; _ ; }\n", "nl": "modifier to make a function callable only when the contract be not transferable ."}
{"code": "function transfer for multi addresses ( address [ ] _addresses , uint256 [ ] _amounts ) can transfer public returns ( bool ) { for ( uint256 i = NUM_ ; i < _addresses . length ; i ++ ) { require ( _addresses [ i ] != address ( NUM_ ) ) ; require ( _amounts [ i ] <= balances [ msg . sender ] ) ; require ( _amounts [ i ] > NUM_ ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amounts [ i ] ) ; balances [ _addresses [ i ] ] = balances [ _addresses [ i ] ] . add ( _amounts [ i ] ) ; transfer ( msg . sender , _addresses [ i ] , _amounts [ i ] ) ; } return BOOL_ ; }\n", "nl": "same functionality a transfer ."}
{"code": "function calculate update profit ( address user ) private view returns ( account ) { account memory acc = accounts [ user ] ; for ( uint r = acc . last user update round ; r < current round ; r ++ ) { acc . profit total *= NUM_ ; if ( acc . money hidden > NUM_ ) { acc . profit total += acc . money hidden * NUM_ ; acc . money hidden = NUM_ ; } if ( acc . money new > NUM_ ) { acc . money hidden = acc . money new ; acc . money new = NUM_ ; } } acc . last user update round = current round ; return acc ; }\n", "nl": "here we calculate profit and update it for user ."}
{"code": "function create auction ( uint256 _token id , uint256 _starting price , uint256 _ending price , uint256 _duration , address _seller ) when not paused external { require ( _starting price == uint256 ( uint128 ( _starting price ) ) ) ; require ( _starting price < auction price limit ) ; require ( _ending price == uint256 ( uint128 ( _ending price ) ) ) ; require ( _ending price < auction price limit ) ; require ( _duration == uint256 ( uint64 ( _duration ) ) ) ; require ( msg . sender == address ( token contract ) ) ; _deposit ( _seller , _token id ) ; auction memory auction = auction ( _seller , uint128 ( _starting price ) , uint128 ( _ending price ) , uint64 ( _duration ) , uint64 ( now ) ) ; _add auction ( _token id , auction ) ; }\n", "nl": "put a paint up for auction ."}
{"code": "function approve and call ( address _spender , uint256 _amount , bytes _data ) public returns ( bool success ) { require ( _approve ( msg . sender , _spender , _amount ) ) ; approve and call fall back ( _spender ) . receive approval ( msg . sender , _amount , address ( this ) , _data ) ; return BOOL_ ; }\n", "nl": "token holder can notify a contract that it have be approve to spend _amount of tokens ."}
{"code": "function new policy ( bytes32 _carrier flight number , bytes32 _departure year month day , uint256 _departure time , uint256 _arrival time , currency _currency , bytes32 _customer external id ) public payable { require ( fd_ac . check permission ( NUM_ , NUM_ ) ) ; if ( _currency == currency . eth ) { if ( msg . value < min_premium || msg . value > max_premium ) { log policy declined ( NUM_ , STR_ ) ; fd_lg . send funds ( msg . sender , acc . premium , msg . value ) ; return ; } } else { require ( msg . sender == get contract ( STR_ ) ) ; if ( _currency == currency . eur ) { if ( msg . value < min_premium_eur || msg . value > max_premium_eur ) { log policy declined ( NUM_ , STR_ ) ; fd_lg . send funds ( msg . sender , acc . premium , msg . value ) ; return ; } } if ( _currency == currency . usd ) { if ( msg . value < min_premium_usd || msg . value > max_premium_usd ) { log policy declined (\n", "nl": "throws if call by other account than broker or client ."}
{"code": "function continue order ( uint128 order id , uint max matches ) public { address client = msg . sender ; order storage order = order for order id [ order id ] ; require ( order . client == client ) ; if ( order . status != status . needs gas ) { return ; } client order event ( client , client order event type . continue , order id , max matches ) ; order . status = status . unknown ; process order ( order id , max matches ) ; }\n", "nl": "public order placement - cancel order ."}
{"code": "function accept ( bytes32 _key , bytes32 _voting group name ) external returns ( uint ) { if ( ! is tx exist ( _key ) ) { return _emit error ( pending_manager_tx_doesnt_exist ) ; } if ( ! groups access manager ( access manager ) . is user in group ( _voting group name , msg . sender ) ) { return _emit error ( pending_manager_invalid_invocation ) ; } guard storage _guard = tx key2guard [ _key ] ; if ( _guard . state != guard state . in process ) { return _emit error ( pending_manager_invalid_invocation ) ; } if ( _guard . votes [ msg . sender ] . group name != bytes32 ( NUM_ ) && _guard . votes [ msg . sender ] . accepted ) { return _emit error ( pending_manager_invalid_invocation ) ; } policy storage _policy = policy id2policy [ index2 policy id [ _guard . base policy index ] ] ; uint _policy group index = _policy . group name2index [ _voting group name ] ; uint _group accepted votes count = _guard . accepted count [ _voting group name ] ; if ( _group accepted votes count == _policy . participated\n", "nl": "sends accrue fee to the collector ."}
{"code": "function pre buy ( ) payable is_pre_crowdfund_period is_not_halted { uint price vested = NUM_ ; if ( msg . sender == pre buy1 ) price vested = pre buy price1 ; if ( msg . sender == pre buy2 ) price vested = pre buy price2 ; if ( msg . sender == pre buy3 ) price vested = pre buy price3 ; if ( price vested == NUM_ ) revert ( ) ; uint amount = process purchase ( price_stage_one + price vested , safe math . sub ( prebuy_portion_max , prebuy portion total ) ) ; grant vested tokens ( msg . sender , calc amount ( msg . value , price vested ) , uint64 ( now ) , uint64 ( now ) + NUM_ days , uint64 ( now ) + NUM_ days , BOOL_ , BOOL_ ) ; prebuy portion total += amount ; pre buy ( amount ) ; }\n", "nl": "to be call at the end of crowdfund period ."}
{"code": "function tokens of owner ( address _owner ) external view returns ( uint256 [ ] owner tokens ) { uint256 total parts = total supply ( ) ; return tokens of owner within range ( _owner , NUM_ , total parts ) ; }\n", "nl": "same issue a above ."}
{"code": "function use module ( address _module factory ) external { if ( isecurity token registry ( security token registry ) . is security token ( msg . sender ) ) { require ( registry [ _module factory ] != NUM_ , STR_ ) ; require ( verified [ _module factory ] || ( imodule factory ( _module factory ) . owner ( ) == isecurity token ( msg . sender ) . owner ( ) ) , STR_ ) ; reputation [ _module factory ] . push ( msg . sender ) ; emit log module used ( _module factory , msg . sender ) ; } }\n", "nl": "allows owner , factory or permissioned delegate ."}
{"code": "function _claimed surrounding tiles ( uint256 _deed id ) internal view returns ( uint256 [ ] memory ) { var ( x , y ) = identifier to coordinate ( _deed id ) ; uint256 claimed = NUM_ ; uint256 [ ] memory _tiles = new uint256 [ ] ( NUM_ ) ; for ( int256 dx = - NUM_ ; dx <= NUM_ ; dx ++ ) { for ( int256 dy = - NUM_ ; dy <= NUM_ ; dy ++ ) { if ( dx == NUM_ && dy == NUM_ ) { continue ; } uint256 nx = uint256 ( int256 ( x ) + dx ) ; uint256 ny = uint256 ( int256 ( y ) + dy ) ; if ( nx >= game settings . cols || ny >= game settings . rows ) { continue ; } uint256 neighbor identifier = coordinate to identifier ( nx , ny ) ; if ( game states [ game index ] . identifier to owner [ neighbor identifier ] != address ( NUM_ ) ) { _tiles [ claimed ] = neighbor identifier ; claimed ++ ; } } } uint256 [ ] memory tiles\n", "nl": "given a token id , return a byte array that be suppose to be convert into string ."}
{"code": "modifier hero allowed to train ( uint _hero id ) { if ( hero token contract . balance of ( msg . sender ) > NUM_ ) { require ( hero token contract . owner of ( _hero id ) == msg . sender ) ; } _ ; }\n", "nl": "throws if player do not own the hero , or it be still in cooldown ."}
{"code": "function _finalize ( ) internal { require ( phase_i != phase_not_started && phase_i != phase_finished , STR_ ) ; uint date = now . add ( seconds_in_year ) ; token . freeze ( vest_1 , date ) ; date = date . add ( seconds_in_year ) ; token . freeze ( vest_2 , date ) ; date = date . add ( seconds_in_year ) ; token . freeze ( vest_3 , date ) ; date = date . add ( seconds_in_year ) ; token . freeze ( vest_4 , date ) ; token . finalize ico ( ) ; token . transfer ownership ( base_wallet ) ; phase_i = phase_finished ; }\n", "nl": "recalculate phase ."}
{"code": "function get fee ( uint _price , address _currency , address _buyer , address _seller , address _token ) public view returns ( uint percent , uint fee ) { ( percent , fee ) = fee provider . get fee ( _price , _currency , _buyer , _seller , _token ) ; }\n", "nl": "calculate the custom fee base on buyer , seller , game token or combo of these ."}
{"code": "function set cold wallet1 ( address _cold wallet1 ) public only owner { require ( _cold wallet1 != address ( NUM_ ) ) ; cold wallet1 = _cold wallet1 ; }\n", "nl": "change the coldwallet2 address ."}
{"code": "function restrict ( address _address ) only owner public { require ( _address != NUM_ ) ; whitelisted [ _address ] = BOOL_ ; }\n", "nl": "allows the owner to add addresse that can bypass the transfer lock ."}
{"code": "function deposit lrc ( ) payable { require ( ! closed && msg . sender != owner ) ; require ( now <= deposit stop time ) ; require ( msg . value == NUM_ ) ; var record = records [ msg . sender ] ; var lrc token = token ( lrc token address ) ; uint lrc amount = this . balance . mul ( rate ) . min256 ( lrc token . balance of ( msg . sender ) ) . min256 ( lrc token . allowance ( msg . sender , address ( this ) ) ) . min256 ( max_lrc_deposit_per_address - record . lrc amount ) ; uint eth amount = lrc amount . div ( rate ) ; lrc amount = eth amount . mul ( rate ) ; require ( lrc amount > NUM_ && eth amount > NUM_ ) ; record . lrc amount += lrc amount ; record . timestamp = now ; records [ msg . sender ] = record ; lrc received += lrc amount ; eth sent += eth amount ; deposit ( deposit id ++ , msg . sender , eth amount , lrc amount )\n", "nl": "anyone can call this and get his money back ."}
{"code": "function get kycpayload ( bytes dataframe ) public constant returns ( address whitelisted address , uint128 customer id , uint32 min eth , uint32 max eth ) { address _whitelisted address = dataframe . slice address ( NUM_ ) ; uint128 _customer id = uint128 ( dataframe . slice16 ( NUM_ ) ) ; uint32 _min eth = uint32 ( dataframe . slice4 ( NUM_ ) ) ; uint32 _max eth = uint32 ( dataframe . slice4 ( NUM_ ) ) ; return ( _whitelisted address , _customer id , _min eth , _max eth ) ; }\n", "nl": "deconstruct server-side byte data to structure data ."}
{"code": "function get value at ( checkpoint [ ] storage _checkpoints , uint256 _block ) constant internal returns ( uint256 ) { if ( _checkpoints . length == NUM_ ) return NUM_ ; if ( _block >= _checkpoints [ _checkpoints . length - NUM_ ] . from block ) return _checkpoints [ _checkpoints . length - NUM_ ] . value ; if ( _block < _checkpoints [ NUM_ ] . from block ) return NUM_ ; uint256 min = NUM_ ; uint256 max = _checkpoints . length - NUM_ ; while ( max > min ) { uint256 mid = ( max + min + NUM_ ) / NUM_ ; if ( _checkpoints [ mid ] . from block <= _block ) { min = mid ; } else { max = mid - NUM_ ; } } return _checkpoints [ min ] . value ; }\n", "nl": "returns the price for a specific block ."}
{"code": "function buy ( ) payable when not paused public returns ( uint256 ) { deposit ( msg . sender , msg . value ) ; require ( msg . value >= NUM_ ether ) ; uint256 tokens = msg . value . mul ( buy rate ) ; require ( balances [ token pool ] >= tokens ) ; balances [ token pool ] = balances [ token pool ] . sub ( tokens ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; transfer ( token pool , msg . sender , tokens ) ; return tokens ; }\n", "nl": "for ether ."}
{"code": "function _remove pending request id ( uint32 _id ) private { uint _len = pending request ids . length ; uint _found index = max_pending_requests ; for ( uint _i = NUM_ ; _i < _len ; _i ++ ) { if ( pending request ids [ _i ] == _id ) { _found index = _i ; break ; } } require ( _found index != max_pending_requests ) ; pending request ids [ _found index ] = pending request ids [ _len - NUM_ ] ; pending request ids . length -- ; }\n", "nl": "return the lengths of array ."}
{"code": "function set min contrib amount ( uint _min contrib amount ) only owner { require ( _min contrib amount > NUM_ ) ; require ( start time > now ) ; min contrib amount = _min contrib amount ; }\n", "nl": "change the changemincontribamount ."}
{"code": "function set lock address ( address target , bool status ) external is owner { require ( owner != target ) ; lock address [ target ] = status ; emit locked ( target , status ) ; }\n", "nl": "add or remove in unlockaddress ( whitelist ) ."}
{"code": "modifier crowdsale active ( ) { require ( crowdsale closed == BOOL_ ) ; _ ; }\n", "nl": "throws if call when crowdsale be still open ."}
{"code": "function schedule payout oraclize call ( uint _policy id , bytes32 _risk id , uint _oraclize time ) public { require ( fd_ac . check permission ( NUM_ , msg . sender ) ) ; var ( carrier flight number , departure year month day , ) = fd_db . get risk parameters ( _risk id ) ; string memory oraclize url = str concat ( oraclize_status_base_url , b32to string ( carrier flight number ) , b32to string ( departure year month day ) , oraclize_status_query ) ; bytes32 query id = oraclize_query ( _oraclize time , STR_ , oraclize url , oraclize_gas ) ; fd_db . create oraclize callback ( query id , _policy id , oraclize state . for payout , _oraclize time ) ; log oraclize call ( _policy id , query id , oraclize url , _oraclize time ) ; }\n", "nl": "max auction time for token be 7 days . ."}
{"code": "function set pre sale tlyper eth ( uint256 _new tlyper eth ) public only owner { pre sale tlyper eth = _new tlyper eth ; }\n", "nl": "main sale configuration ."}
{"code": "function set discount member ( address _address , string member type , bool is active member ) public only owner { if ( compare strings ( member type , STR_ ) ) sale discount list [ _address ] = is active member ; else if ( compare strings ( member type , STR_ ) ) custom private sale [ _address ] = is active member ; else require ( NUM_ == NUM_ ) ; }\n", "nl": "check if an address be a member of a specific address ."}
{"code": "modifier only financial officer ( ) { require ( msg . sender == financial officer address ) ; _ ; }\n", "nl": "only allow by operate officer ."}
{"code": "function change stage ( stage new stage ) public only owner { current stage = new stage ; }\n", "nl": "set current stage of campaign manually ."}
{"code": "function finalize ( ) external only owner { require ( wei total received >= soft cap ) ; require ( now > start time . add ( period ) || wei total received >= hard cap ) ; if ( state == state . presale ) { require ( this . balance > NUM_ ) ; wallet ether presale . transfer ( this . balance ) ; pause ( ) ; } else if ( state == state . crowdsale ) { uint256 token total unsold = token ico allocated . sub ( token total sold ) ; token reservation allocated = token reservation allocated . add ( token total unsold ) ; require ( token . transfer from ( token . owner ( ) , wallet token bounty , token bounty allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token reservation , token reservation allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token team , token team allocated ) ) ; token . lock ( wallet token reservation , now + NUM_ years ) ; token . lock (\n", "nl": "finalize the presale ."}
{"code": "function wadmin_freeze account ( address target , bool freeze ) only owner public returns ( bool success ) { frozen account [ target ] = freeze ; frozen funds ( target , freeze ) ; return BOOL_ ; }\n", "nl": "notice freeze the account to prevent target from send and receive tokens ."}
{"code": "function change minters ( address _arena contract , address _vending machine , address _kitty gym ) external only owner returns ( bool success ) { if ( _arena contract != NUM_ ) arena contract = _arena contract ; if ( _vending machine != NUM_ ) vending machine = _vending machine ; if ( _kitty gym != NUM_ ) kitty gym = _kitty gym ; return BOOL_ ; }\n", "nl": "owner of this contract may change the address of associated contract ."}
{"code": "function set start time ( uint64 _start time ) public only owner { require ( now < start time ) ; require ( _start time > now ) ; require ( _start time < end time ) ; start time = _start time ; }\n", "nl": "allows the current owner to set the new start time if crowdsale be not finalize ."}
{"code": "function kill ( ) public only owner { require ( this . balance == NUM_ ) ; selfdestruct ( owner ) ; }\n", "nl": "free the memory when the contest end and all the winnings / refund be suppose to be claim ."}
{"code": "function add ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { uint256 c = a + b ; assert ( c >= a && c >= b ) ; return c ; }\n", "nl": "adds two number , revert ( ) s on overflow ."}
{"code": "modifier bet is valid ( uint _bet size , uint _player number ) { if ( ( ( ( ( _bet size * ( NUM_ - ( safe sub ( _player number , NUM_ ) ) ) ) / ( safe sub ( _player number , NUM_ ) ) + _bet size ) ) * house edge / house edge divisor ) - _bet size > max profit || _bet size < min bet || _player number < min number || _player number > max number ) throw ; _ ; }\n", "nl": "makes sure that player profit ca n't exceed a maximum amount , that the bet size be valid , and the playernumber be in range ."}
{"code": "function set astore ( string _app nickname , address _address ) public only owner { require ( bytes ( _app nickname ) . length > NUM_ ) ; bytes32 _app nickname32 = keccak256 ( _app nickname ) ; require ( _address != address ( NUM_ ) ) ; itweedentity store _store = itweedentity store ( _address ) ; require ( _store . get app nickname ( ) == _app nickname32 ) ; uint _app id = _store . get app id ( ) ; require ( app nicknames32 [ _app id ] == NUM_ ) ; app nicknames32 [ _app id ] = _app nickname32 ; app nicknames [ _app id ] = _app nickname ; __app ids [ _app nickname ] = _app id ; __stores [ _app id ] = store ( itweedentity store ( _address ) , _address ) ; }\n", "nl": "deactivates vote ."}
{"code": "function _current price ( collectible sale memory _sale ) internal view returns ( uint256 ) { uint256 seconds passed = NUM_ ; if ( now > _sale . started at ) { seconds passed = now - _sale . started at ; } return _compute current price ( _sale . starting price , _sale . ending price , _sale . duration , seconds passed ) ; }\n", "nl": "returns current price of an ft ( erc721 ) on sale ."}
{"code": "function balance of ( address _account ) constant returns ( uint balance ) { return balances [ _account ] ; }\n", "nl": "chech trade balance of account ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { bytes memory empty ; transfer ( _to , _value , empty ) ; }\n", "nl": "transfer specify amount of tokens to the specify address ."}
{"code": "function claim ( ) only owner public { owner . transfer ( this . balance ) ; }\n", "nl": "owner only withdrawal function for the presale ."}
{"code": "function name of ( address _address ) public view returns ( bytes32 _name ) { entry memory _cur entry = entries [ NUM_ ] ; entry memory _next entry ; while ( _cur entry . next > NUM_ ) { _next entry = entries [ _cur entry . next ] ; if ( _next entry . addr == _address ) { return _cur entry . next ; } _cur entry = _next entry ; } }\n", "nl": "retrieves the name of _addr , if any ."}
{"code": "function transfer ( address _to , uint _value ) only unlocked only payload size ( NUM_ * NUM_ ) public returns ( bool _success ) { require ( _to != address ( NUM_ ) ) ; bytes memory _empty ; if ( ( balances [ msg . sender ] > _value ) && _value > NUM_ && _to != address ( NUM_ ) ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; if ( is contract ( _to ) ) { erc223 receiving contract receiver = erc223 receiving contract ( _to ) ; receiver . token fallback ( msg . sender , _value , _empty ) ; } transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "query whether the user be eligible for claim dividence ."}
{"code": "function set paused ( bool _is paused ) public only owner { paused = _is paused ; }\n", "nl": "sets if nfts be pause or not ."}
{"code": "function mint tokens with approval ( address _target , uint _minted amount , address _spender ) public only owner returns ( bool success ) { require ( _minted amount <= unminted tokens ) ; balances [ _target ] += _minted amount ; unminted tokens -= _minted amount ; _total supply += _minted amount ; allowed [ _target ] [ _spender ] += _minted amount ; emit transfer ( NUM_ , _target , _minted amount ) ; return BOOL_ ; }\n", "nl": "mint racoin tokens ."}
{"code": "function accept and pay ( bytes32 _request id , uint256 [ ] _payee amounts , uint256 [ ] _additionals , int256 _payee amounts sum ) internal { accept action ( _request id ) ; additional action ( _request id , _additionals ) ; if ( _payee amounts sum > NUM_ ) { payment internal ( _request id , _payee amounts ) ; } }\n", "nl": "internal function to accept and add additionals to a request a payer ."}
{"code": "function add tower ( uint32 _timer , uint16 _payout , uint16 _price increase , uint256 _amount to half time , uint256 _min price , uint16 _min price after win , uint16 _creator fee ) public payable only open or owner returns ( uint256 ) { require ( _timer >= NUM_ ) ; require ( _timer <= NUM_ ) ; require ( _payout >= NUM_ && _payout <= NUM_ ) ; require ( _price increase >= NUM_ && _price increase <= NUM_ ) ; require ( _min price after win >= NUM_ && _min price after win <= NUM_ ) ; require ( _amount to half time == NUM_ || _amount to half time >= NUM_ ) ; require ( _creator fee >= NUM_ && _creator fee <= NUM_ ) ; require ( _min price >= ( NUM_ szabo ) && _min price <= ( NUM_ ether ) ) ; if ( msg . sender == owner ) { _creator fee = NUM_ ; if ( msg . value > NUM_ ) { owner . transfer ( msg . value ) ; } } else { if ( msg . value >= amount to create ) { uint256 to div =\n", "nl": "sets fee use in interface transactions ."}
{"code": "modifier only owner or admin ( ) { require ( msg . sender == owner || msg . sender == admin ) ; _ ; }\n", "nl": "throws if call by any account other than the owner or admin ."}
{"code": "function get contributor remaining sale amount ( address wallet ) public view returns ( uint256 ) { uint256 invested_amount = wei_invested_by_contributor_in_sale [ wallet ] ; return contributor_max_sale_contribution - invested_amount ; }\n", "nl": "returns the remain possibled presale amount for a give wallet ."}
{"code": "function claim token ( ) external { require ( current sale stage == sale stage . ico || current sale stage == sale stage . closed ) ; if ( current sale stage == sale stage . ico ) { if ( ibc funded == total funding goal in ibc || now >= ico end ) { update sale stage ( sale stage . closed ) ; } else { revert ( ) ; } } require ( ibc vault balance of [ msg . sender ] > NUM_ ) ; uint token amount = ibc vault balance of [ msg . sender ] ; if ( now < ico end + funding rate prediction bonus claim window ) { if ( funding rate prediction bonus pool in ibc > NUM_ ) { uint final funding rate = mul ( ibc funded , NUM_ ) / total funding goal in ibc ; if ( final funding rate > NUM_ ) { final funding rate = NUM_ ; } if ( funding rate prediction of [ msg . sender ] == final funding rate ) { if ( ! funding rate prediction bingo of [ msg . sender ] ) {\n", "nl": "maximum current purchase amount in phase 2 ."}
{"code": "function set allow transfers ( bool _allow transfers ) external only owner { allow transfers = _allow transfers ; allow transfers changed ( _allow transfers ) ; }\n", "nl": "onlyowner change the set to allow transfer tokens ."}
{"code": "function div round ( uint v , uint d ) internal constant returns ( uint ) { return ( v + ( d / NUM_ ) ) / d ; }\n", "nl": "divide v by d , round up if remainder be 0 . 5 or more ."}
{"code": "function claim funds ( ) only contributors public { uint latest = latest balance check [ msg . sender ] ; uint supply = object . total supply ( ) ; uint balance = balance owed [ msg . sender ] ; uint earnings = items owned [ msg . sender ] . div ( NUM_ ether ) . mul ( supply . sub ( latest ) ) . div ( NUM_ ether ) . mul ( item return ) ; uint excess = excess eth [ msg . sender ] ; latest balance check [ msg . sender ] = supply ; balance owed [ msg . sender ] = NUM_ ; excess eth [ msg . sender ] = NUM_ ; balance = balance . add ( earnings ) ; running debt = running debt . add ( earnings ) ; running debt = running debt . sub ( balance ) ; debt paid = debt paid . add ( balance ) ; balance = balance . add ( excess ) ; total excess eth = total excess eth . sub ( excess ) ; will withdraw ( balance ) ; require ( balance > NUM_ ) ;\n", "nl": "reclaim remain tokens after crowdsale be complete ."}
{"code": "function __callback ( bytes32 myid , string result ) { if ( msg . sender != oraclize_cb address ( ) || myid != next attack id ) throw ; uint128 pot ; uint16 random ; uint32 howmany = num animals < NUM_ ? ( num animals < NUM_ ? NUM_ : num animals / NUM_ ) : NUM_ ; uint16 [ ] memory random numbers = get numbers from string ( result , STR_ , howmany ) ; uint32 [ ] memory killed animals = new uint32 [ ] ( howmany ) ; for ( uint8 i = NUM_ ; i < howmany ; i ++ ) { random = map to new range ( random numbers [ i ] , num animals ) ; killed animals [ i ] = ids [ random ] ; pot += kill animal ( random ) ; } uint128 needed gas = oraclize gas + NUM_ * num animals ; uint128 gas cost = uint128 ( needed gas * tx . gasprice ) ; if ( pot > gas cost ) distribute ( uint128 ( pot - gas cost ) ) ; trigger attack ( time till next attack ( ) , needed\n", "nl": "one specific attribute of the equipment modify ."}
{"code": "function transfer token_to balance ( address _user , uint256 _amount ) public only owner { invest balances [ _user ] -= _amount ; balances [ _user ] += _amount ; }\n", "nl": "spends credit for a user ."}
{"code": "function add addresses to whitelist ( address [ ] addresses ) only owner public { for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { participants [ addresses [ i ] ] . whitelisted = BOOL_ ; } }\n", "nl": "loop address and distribute tokens ."}
{"code": "function init ( address _team_wallet , uint _start_time , bytes32 _initial_tier_name , uint _initial_tier_price , uint _initial_tier_duration , uint _initial_tier_token_sell_cap , uint _initial_tier_min_purchase , bool _initial_tier_is_whitelisted , bool _initial_tier_duration_is_modifiable , address _admin ) external view { contract . initialize ( ) ; if ( _team_wallet == NUM_ || _initial_tier_price == NUM_ || _start_time < now || _start_time + _initial_tier_duration <= _start_time || _initial_tier_token_sell_cap == NUM_ || _admin == address ( NUM_ ) ) revert ( STR_ ) ; contract . storing ( ) ; contract . set ( exec permissions ( msg . sender ) ) . to ( BOOL_ ) ; contract . set ( admin ( ) ) . to ( _admin ) ; contract . set ( wallet ( ) ) . to ( _team_wallet ) ; contract . set ( total duration ( ) ) . to ( _initial_tier_duration ) ; contract . set ( start time ( ) ) . to ( _start_time ) ; contract . set ( sale tier list ( ) ) . to ( uint ( NUM_ ) ) ; contract . set ( tier name ( uint ( NUM_ ) ) ) . to ( _initial_tier_name ) ; contract .\n", "nl": "replaces the script exec address with a new address ."}
{"code": "function send for pre ico ( address buyer , uint256 amount ) public only owner { require ( sale cap >= amount ) ; sale cap = sale cap - amount ; balances [ token wallet ] = balances [ token wallet ] . sub ( amount ) ; balances [ buyer ] = balances [ buyer ] . add ( amount ) ; emit pre icotoken pushed ( buyer , amount ) ; emit transfer ( token wallet , buyer , amount ) ; }\n", "nl": "set salecap ."}
{"code": "function deed of owner by index ( address _owner , uint256 _index ) external view returns ( uint256 _deed id ) { require ( _owner != address ( NUM_ ) ) ; require ( _index < owned deeds [ _owner ] . length ) ; _deed id = owned deeds [ _owner ] [ _index ] ; }\n", "nl": "part be store sequentially ."}
{"code": "function set price ( uint256 _new price carnita ) only manager public { price carnita = _new price carnita ; carnitas [ last carnita ] . min = price carnita ; }\n", "nl": "see the current price of carnita ."}
{"code": "function claim tokens ( address _beneficiary ) public { require ( is finalized ) ; require ( weeks from end plus month ( ) > NUM_ ) ; fractionalize ( _beneficiary ) ; require ( token buyers mapping [ _beneficiary ] > NUM_ && token buyers remaining [ _beneficiary ] > NUM_ ) ; uint256 w = weeks from end plus month ( ) ; if ( w > NUM_ ) { w = NUM_ ; } uint256 total due by now = w . mul ( token buyers fraction [ _beneficiary ] ) ; uint256 total withdrawn by now = total withdrawn ( _beneficiary ) ; if ( total due by now > total withdrawn by now ) { uint256 diff = total due by now . sub ( total withdrawn by now ) ; if ( diff > token buyers remaining [ _beneficiary ] ) { diff = token buyers remaining [ _beneficiary ] ; } token . transfer ( _beneficiary , diff ) ; token buyers remaining [ _beneficiary ] = token buyers remaining [ _beneficiary ] . sub ( diff ) ; } }\n", "nl": "account and amount send to dao , round down only txn 100 tokens ."}
{"code": "function bid ( ) public payable blabla { uint _min leader amount = pot . mul ( min_leader_frac_top ) . div ( min_leader_frac_bot ) ; uint _bid amount to community = msg . value . mul ( frac_top ) . div ( frac_bot ) ; uint _bid amount to dividend fund = msg . value . mul ( dividend_fund_frac_top ) . div ( dividend_fund_frac_bot ) ; uint _bid amount to pot = msg . value . sub ( _bid amount to community ) . sub ( _bid amount to dividend fund ) ; earnings [ _null ] = earnings [ _null ] . add ( _bid amount to community ) ; dividend fund = dividend fund . add ( _bid amount to dividend fund ) ; pot = pot . add ( _bid amount to pot ) ; bid ( now , msg . sender , msg . value , pot ) ; if ( msg . value >= _min leader amount ) { uint _dividend shares = msg . value . div ( _min leader amount ) ; dividend shares [ msg . sender ] = dividend shares [ msg . sender ] . add ( _dividend shares )\n", "nl": "withdraw tip ."}
{"code": "function unbond ( ) external when system not paused current round initialized auto claim earnings { require ( delegator status ( msg . sender ) == delegator status . bonded ) ; delegator storage del = delegators [ msg . sender ] ; uint256 current round = rounds manager ( ) . current round ( ) ; del . withdraw round = current round . add ( unbonding period ) ; delegators [ del . delegate address ] . delegated amount = delegators [ del . delegate address ] . delegated amount . sub ( del . bonded amount ) ; total bonded = total bonded . sub ( del . bonded amount ) ; if ( transcoder status ( msg . sender ) == transcoder status . registered ) { resign transcoder ( msg . sender ) ; } if ( del . delegate address != msg . sender && transcoder status ( del . delegate address ) == transcoder status . registered ) { transcoder pool . update key ( del . delegate address , transcoder pool . get key ( del . delegate address ) . sub ( del . bonded amount ) , address ( NUM_\n", "nl": "remove transcoder ."}
{"code": "function end rate ( ) internal pure returns ( bytes32 ) { return keccak256 ( STR_ ) ; }\n", "nl": "stores the sale 's whitelist ."}
{"code": "function last token is transferable date ( address holder ) constant public returns ( uint64 date ) { date = uint64 ( now ) ; uint256 grant index = token grants count ( holder ) ; for ( uint256 i = NUM_ ; i < grant index ; i ++ ) { date = max64 ( grants [ holder ] [ i ] . vesting , date ) ; } return date ; }\n", "nl": "calculate the date when the holder can transfer all it tokens ."}
{"code": "function safe send ( address _address ) internal { uint value to send = pending returns [ _address ] ; assert ( value to send > NUM_ ) ; pending returns [ _address ] = NUM_ ; if ( _address . send ( value to send ) == BOOL_ ) { pending returns [ _address ] = value to send ; } }\n", "nl": "make sure weisend of current tx be reset ."}
{"code": "function buy tokens ( ) public stop in emergency payable returns ( bool ) { if ( msg . value == NUM_ ) { error ( STR_ ) ; return BOOL_ ; } uint256 token amount = buy tokens low level ( msg . sender , msg . value ) ; if ( ! screfund vault . deposit . value ( msg . value ) ( msg . sender , token amount ) ) { revert ( STR_ ) ; } emit buy tokens ( msg . sender , msg . value , token amount ) ; return BOOL_ ; }\n", "nl": "function to create order to buy tokens ."}
{"code": "modifier only minter { if ( msg . sender != dev ) revert ( ) ; _ ; }\n", "nl": "this modifier should prevent ico from be launch by an attacker ."}
{"code": "function redeem token ( uint256 _token id ) public { token storage tkn = tokens [ _token id ] ; uint256 packed = tkn . option ; bool payout = uint8 ( ( packed > > ( NUM_ * NUM_ ) ) & NUM_ ) == NUM_ ? BOOL_ : BOOL_ ; uint32 id game = uint32 ( ( packed > > ( NUM_ * NUM_ ) ) & NUM_ ) ; uint32 combination = uint32 ( ( packed > > ( NUM_ * NUM_ ) ) & NUM_ ) ; game storage cur game = game [ id game ] ; require ( cur game . status == status . paying || cur game . status == status . canceling ) ; require ( msg . sender == token index to owner [ _token id ] ) ; require ( payout == BOOL_ ) ; require ( combination == cur game . win combination || cur game . status == status . canceling ) ; uint256 sum payment = NUM_ ; if ( cur game . status == status . canceling ) sum payment = tkn . price ; if ( cur game . status == status . paying\n", "nl": "query functions ."}
{"code": "function update reserved wei ( ) public { require ( wei raised . add ( pre sale . wei raised ( ) ) >= soft cap && now > end crowd sale time ) ; uint256 cur wei ; if ( ! first stage refund && now > end crowd sale time ) { cur wei = NUM_ * NUM_ ether ; reserved wei = cur wei ; rest wei = wei raised . sub ( cur wei ) ; first stage refund = BOOL_ ; } if ( ! second stage refund && now > end crowd sale time + NUM_ * NUM_ days ) { cur wei = rest wei . mul ( NUM_ ) . div ( NUM_ ) ; reserved wei = reserved wei . add ( cur wei ) ; rest wei = rest wei . sub ( cur wei ) ; second stage refund = BOOL_ ; } if ( ! final stage refund && now > end refundable time ) { reserved wei = reserved wei . add ( rest wei ) ; rest wei = NUM_ ; final stage refund = BOOL_ ; } }\n", "nl": "opens refund ."}
{"code": "function calculate current price ( order memory order ) internal view returns ( uint ) { return sale kind interface . calculate final price ( order . side , order . sale kind , order . base price , order . extra , order . listing time , order . expiration time ) ; }\n", "nl": "call calculatefinalprice - library function expose for test ."}
{"code": "function add owner ( address sender , proxy identity , address new owner ) public only authorized only older owner ( identity , sender ) rate limited ( identity , sender ) { require ( ! is owner ( identity , new owner ) ) ; owners [ identity ] [ new owner ] = now - user time lock ; log owner added ( identity , new owner , sender ) ; }\n", "nl": "allows a recoverykey to add a new owner with usertimelock wait time ."}
{"code": "function available amount ( address [ NUM_ ] addresses , uint [ NUM_ ] values ) external view returns ( uint ) { order library . order memory order = order library . create order ( addresses , values ) ; return available amount ( order , order . hash ( ) ) ; }\n", "nl": "checks if a order can be trade ."}
{"code": "function do withdrawal ( uint256 extra ) internal { uint256 amount = balance of [ msg . sender ] ; if ( amount == NUM_ ) throw ; if ( amount + extra > this . balance ) { throw ; } balance of [ msg . sender ] = NUM_ ; if ( total supply < total supply - amount ) { throw ; } else { total supply -= amount ; } transfer ( msg . sender , NUM_ , amount ) ; if ( ! msg . sender . send ( amount + extra ) ) throw ; }\n", "nl": "withdraw ethereum from the sender 's ethbalance ."}
{"code": "function contribute with address ( address contributor ) public payable when not paused { require ( msg . value >= min contrib amount ) ; require ( is contrib period running ( ) ) ; uint contrib value = msg . value ; uint excess contrib value = NUM_ ; uint old total contributed = total contributed ; total contributed = old total contributed . add ( contrib value ) ; uint new total contributed = total contributed ; if ( new total contributed >= total lending amount && old total contributed < total lending amount ) { cap reached = BOOL_ ; funding end time = now ; on cap reached ( funding end time ) ; excess contrib value = new total contributed . sub ( total lending amount ) ; contrib value = contrib value . sub ( excess contrib value ) ; total contributed = total lending amount ; } if ( investors [ contributor ] . amount == NUM_ ) { investors keys . push ( contributor ) ; } investors [ contributor ] . amount = investors [ contributor ] . amount . add ( contrib value ) ; if ( excess contrib value\n", "nl": "function to check if the contract have be compromise ."}
{"code": "function remove policy rule ( bytes4 _sig , address _contract , bytes32 _group name ) only contract owner external returns ( uint ) { require ( _sig != bytes4 ( NUM_ ) ) ; require ( _contract != NUM_ ) ; require ( groups access manager ( access manager ) . is group exists ( _group name ) ) ; bytes32 _policy hash = keccak256 ( _sig , _contract ) ; policy storage _policy = policy id2policy [ _policy hash ] ; uint _policy group name index = _policy . group name2index [ _group name ] ; if ( _policy group name index == NUM_ ) { return _emit error ( pending_manager_invalid_invocation ) ; } uint _policy groups count = _policy . groups count ; if ( _policy group name index != _policy groups count ) { requirements storage _requirements = _policy . participated groups [ _policy groups count ] ; _policy . participated groups [ _policy group name index ] = _requirements ; _policy . group name2index [ _requirements . group name ] = _policy group name index ; } _policy . total accepted limit = _policy . total accepted limit . sub ( _policy . participated groups [\n", "nl": "given a group , investor and amount of wei , pay all the eligible invitors ."}
{"code": "function total amount of crowdsale purchases without bonus ( ) constant public returns ( uint256 amount ) { for ( uint256 i ; i < crowdsale purchases . length ; i ++ ) { amount = safe math . add ( amount , crowdsale purchases [ i ] . raw amount ) ; } }\n", "nl": "calculates total amount of tokens purchase include bonus tokens ."}
{"code": "function lock shares ( ) public only owner ( ) { require ( ! locked ) ; locked = BOOL_ ; }\n", "nl": "lock the contribution / share methods ."}
{"code": "function mark ( address product account , bytes32 item hash ) public { product storage product = products [ product account ] ; require ( product . brand account != address ( NUM_ ) && product . active ) ; brand storage brand = brands [ product . brand account ] ; require ( brand . brand account != address ( NUM_ ) && brand . active ) ; app storage app = apps [ brand . app account ] ; require ( app . app account != address ( NUM_ ) && app . active ) ; bool permissioned = permissions [ msg . sender ] [ brand . brand account ] ; require ( permissioned ) ; markings [ item hash ] = product account ; marked ( msg . sender , product account , app . fee account , fee account , app . fee , fee , item hash ) ; if ( app . fee > NUM_ ) { token . transfer from ( brand . brand account , app . fee account , app . fee ) ; } if ( fee > NUM_ ) { token . transfer from ( brand . brand\n", "nl": "check itempublickey have be register ."}
{"code": "function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a + b ; assert ( c >= a ) ; return c ; }\n", "nl": "safemath add function ."}
{"code": "function create contract special ( string _name ) public only ceo { require ( periodic table exists == BOOL_ ) ; require ( special ctr <= special limit ) ; special ctr = safe math . add ( special ctr , NUM_ ) ; uint256 _id = safe math . add ( special ctr , special start ) ; _create element ( _id , _name , address ( this ) , special starting price , scientist start ) ; }\n", "nl": "creates a new scientist with the give name id ."}
{"code": "function calc random number and get preliminary game result ( uint256 block hash , uint64 gamble index ) constant returns ( uint64 gamble id , address player , uint256 block number , uint256 total win , uint8 wheel result , uint256 bets , uint256 values1 , uint256 values2 , uint256 n total bet value , uint256 n total bet count ) { game info memory g = gambles [ uint256 ( gamble index ) ] ; g . wheel result = calculate random number by blockhash ( block hash , g . player ) ; gamble id = gamble index ; player = g . player ; wheel result = g . wheel result ; total win = get game result ( g ) ; block number = g . block number ; n total bet value = total bet value ( g ) ; n total bet count = total bet count ( g ) ; bets = g . bets ; values1 = uint256 ( g . values ) ; values2 = uint256 ( g . values2 ) ; }\n", "nl": "index into kingdomsbynumber if find , or zero if not ."}
{"code": "function finalize crowdsale and token ( ) external view { contract . authorize ( msg . sender ) ; contract . checks ( sender admin and sale not final ) ; manage tokens . finalize crowdsale and token ( ) ; contract . checks ( emit and store ) ; contract . commit ( ) ; }\n", "nl": "initializes the token to be sell during the crowdsale ."}
{"code": "function allowance ( address _owner , address spender ) constant returns ( uint _allowance ) { return _approvals [ _owner ] [ spender ] ; }\n", "nl": "check how many tmx global tokens a spender be allow to spend from an owner ."}
{"code": "function issue for euro ( uint256 euro ulps ) public only ( role_neumark_issuer ) accept agreement ( msg . sender ) returns ( uint256 ) { require ( _total eur ulps + euro ulps >= _total eur ulps ) ; uint256 neumark ulps = incremental ( _total eur ulps , euro ulps ) ; _total eur ulps += euro ulps ; m generate tokens ( msg . sender , neumark ulps ) ; log neumarks issued ( msg . sender , euro ulps , neumark ulps ) ; return neumark ulps ; }\n", "nl": "use by role_neumark_issuer to transer newly issue neumarks typically to the investor and platform operator ."}
{"code": "function create tokens ( uint256 _tokens , address _destination ) internal only owner { uint256 tokens = _tokens * NUM_ * * uint256 ( decimals ) ; total supply_ = total supply_ . add ( tokens ) ; balances [ _destination ] = tokens ; emit transfer ( NUM_ , _destination , tokens ) ; require ( total supply_ <= hard_cap ) ; }\n", "nl": "allows the owner to manually mint some shp to an address if something go wrong ."}
{"code": "function next round ( ) internal { game ended ( game id , win , total supply ) ; if ( total payouts + win < total payouts ) throw ; total payouts += win ; var share = total supply == NUM_ ? NUM_ : win / total supply ; for ( var i = NUM_ ; i < players . length ; i ++ ) { var amount = share * balance of [ players [ i ] ] ; total supply -= balance of [ players [ i ] ] ; balance of [ players [ i ] ] = NUM_ ; if ( pending payouts [ players [ i ] ] + amount < pending payouts [ players [ i ] ] ) throw ; pending payouts [ players [ i ] ] += amount ; win -= amount ; } delete the grid ; delete players ; last player = NUM_ ; size = nextsize ; if ( nextsize < NUM_ ) nextsize ++ ; game id ++ ; empty = size * size ; the grid . length = empty ; price = start price ; game start ( game id , size )\n", "nl": "add address to jackpot participants list ."}
{"code": "function total promotions ( ) public view returns ( uint ) { return all promotions . length ; }\n", "nl": "number of locations in the hunt ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { adjust investor count ( _from , _to , _value ) ; require ( verify transfer ( _from , _to , _value ) , STR_ ) ; adjust balance checkpoints ( _from ) ; adjust balance checkpoints ( _to ) ; require ( super . transfer from ( _from , _to , _value ) ) ; return BOOL_ ; }\n", "nl": "overloaded version of the transfer function ."}
{"code": "function send ecosys supply token ( address to , uint256 value ) public only owner { require ( to != NUM_ && value > NUM_ && _ecosys supply >= value ) ; balances [ multisig ] = balances [ multisig ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; total number token sold = total number token sold . add ( value ) ; _ecosys supply = _ecosys supply . sub ( value ) ; transfer ( multisig , to , value ) ; }\n", "nl": "token distribution to community ."}
{"code": "function get player info by address ( address _addr ) public view returns ( uint256 , bytes32 , uint256 , uint256 , uint256 , uint256 , uint256 ) { uint256 _r id = r id_ ; if ( _addr == address ( NUM_ ) ) { _addr == msg . sender ; } uint256 _p id = p idx addr_ [ _addr ] ; return ( _p id , plyr_ [ _p id ] . name , plyr rnds_ [ _p id ] [ _r id ] . keys , plyr_ [ _p id ] . win , ( plyr_ [ _p id ] . gen ) . add ( calc un masked earnings ( _p id , plyr_ [ _p id ] . lrnd ) ) , plyr_ [ _p id ] . aff , plyr rnds_ [ _p id ] [ _r id ] . eth ) ; }\n", "nl": "return player earn per vault - functionhash - 0x63066434 ."}
{"code": "function safe mul ( uint a , uint b ) internal returns ( uint c ) { c = a * b ; assert ( a == NUM_ || c / a == b ) ; }\n", "nl": "safemath contract - math operations with safety check ."}
{"code": "function finish proposal voting ( uint256 _proposal id ) only congress members { proposal p = proposals [ _proposal id ] ; if ( now < p . voting deadline ) throw ; if ( p . state != proposal state . proposed ) throw ; var _votes number = p . votes . length ; uint256 tokens for = NUM_ ; uint256 tokens against = NUM_ ; for ( uint256 i = NUM_ ; i < _votes number ; i ++ ) { if ( p . votes [ i ] . in support ) { tokens for += p . votes [ i ] . voter tokens ; } else { tokens against += p . votes [ i ] . voter tokens ; } unblock tokens ( p . votes [ i ] . voter ) ; } if ( ( tokens for + tokens against ) < minimum quorum ) { p . state = proposal state . no quorum ; proposal tallied event ( _proposal id , BOOL_ , BOOL_ ) ; return ; } if ( ( tokens for - tokens against ) < margin for majority ) { p . state = proposal\n", "nl": "vote for a tap proposal ."}
{"code": "function check bet dozen ( uint8 result , address player , bytes32 block hash , bytes32 sha player ) private { bool win ; if ( result != NUM_ && ( ( result < NUM_ && gambles [ gamble index [ player ] ] . input == NUM_ ) || ( result > NUM_ && result < NUM_ && gambles [ gamble index [ player ] ] . input == NUM_ ) || ( result > NUM_ && gambles [ gamble index [ player ] ] . input == NUM_ ) ) ) { win = BOOL_ ; } solve bet ( player , result , win , NUM_ , block hash , sha player ) ; }\n", "nl": "checkbet on lowhigh bet type : lowhigh input : 0 low , 1 high ."}
{"code": "function _clear contributor record in group ( uint256 _token id , address _user add ) private returns ( uint256 refund balance ) { var group = token index to group [ _token id ] ; uint c index = group . address to contributor arr index [ _user add ] - NUM_ ; uint last cindex = group . contributor arr . length - NUM_ ; refund balance = group . address to contribution [ _user add ] ; token index to group [ _token id ] . address to contributor arr index [ _user add ] = NUM_ ; token index to group [ _token id ] . address to contribution [ _user add ] = NUM_ ; if ( last cindex > NUM_ ) { token index to group [ _token id ] . address to contributor arr index [ group . contributor arr [ last cindex ] ] = c index ; token index to group [ _token id ] . contributor arr [ c index ] = group . contributor arr [ last cindex ] ; } token index to group [ _token id ] . contributor arr . length -= NUM_ ; token index to group [ _token id ] . contributed balance -= refund balance ; }\n", "nl": "clears record of a group from a contributor 's record ."}
{"code": "function withdraw ( ) public { require ( msg . sender == owner ) ; owner . transfer ( address ( this ) . balance ) ; }\n", "nl": "withdraw sales fee ."}
{"code": "function burn ( address from , uint256 amount ) internal returns ( bool ) { total supply_ = total supply_ . sub ( amount ) ; balances [ from ] = balances [ from ] . sub ( amount ) ; burn ( from , amount ) ; transfer ( from , address ( NUM_ ) , amount ) ; return BOOL_ ; }\n", "nl": "burns bskt tokens ."}
{"code": "function mint team tokens ( ) public only whitelisted { require ( ico end date > NUM_ ) ; require ( soft cap reached ) ; if ( now < ico end date + year ) { revert ( STR_ ) ; } mint once ( STR_ , msg . sender , NUM_ ) ; }\n", "nl": "this function enable token transfer for everyone ."}
{"code": "function is active ( ) public constant returns ( bool ) { return now >= start time && now < end time ; }\n", "nl": "true if the crowdsale be active , hence users can buy tokens ."}
{"code": "function set token rate ( uint256 _token rate ) public only owner { require ( _token rate > NUM_ ) ; token rate = _token rate ; }\n", "nl": "updates the token baserate ."}
{"code": "modifier only before swap ( address _to ) { if ( swap time != NUM_ && block . timestamp >= swap time ) require ( _to == swap addr ) ; _ ; }\n", "nl": "this modifier should prevent tokens transfer while the tokenswap be still ongoing ."}
{"code": "function donate ( ) public payable { require ( msg . value > NUM_ wei ) ; uint256 eth to transfer = address ( this ) . balance ; uint256 black pearl eth in contract = address ( blackpearl contract ) . balance ; if ( black pearl eth in contract < NUM_ ether ) { blackpearl contract . exit ( ) ; token balance = NUM_ ; eth to transfer = address ( this ) . balance ; owner . transfer ( eth to transfer ) ; emit transfer ( eth to transfer , address ( owner ) ) ; } else { token balance = my tokens ( ) ; if ( token balance > NUM_ ) { blackpearl contract . exit ( ) ; token balance = NUM_ ; eth to transfer = address ( this ) . balance ; if ( eth to transfer > NUM_ ) { blackpearl contract . buy . value ( eth to transfer ) ( NUM_ ) ; } else { blackpearl contract . buy . value ( msg . value ) ( NUM_ ) ; } } else { if ( eth to transfer > NUM_ ) { blackpearl contract\n", "nl": "only way to give pohwhale eth be via by use fallback ."}
{"code": "function get payer ( bytes32 _request id ) public constant returns ( address ) { return requests [ _request id ] . payer ; }\n", "nl": "get state of a request ."}
{"code": "function balance of ( address _owner ) constant returns ( uint256 balance ) { return balance of at ( _owner , block . number ) ; }\n", "nl": "the balance of _owner at the current block ."}
{"code": "function buy tickets ( ) public payable { require ( is lottery open == BOOL_ ) ; require ( last_round_bought [ msg . sender ] != current_round ) ; uint256 tokens_before = maths . my tokens ( ) ; maths . buy . value ( msg . value ) ( masternode_referrer ) ; uint256 tokens_after = maths . my tokens ( ) ; uint256 tokens_bought = safe math . sub ( tokens_after , tokens_before ) . div ( NUM_ ) ; require ( tokens_bought >= NUM_ && tokens_bought <= max_token_buyin ) ; num tokens in lottery = maths . my tokens ( ) ; uint8 i = NUM_ ; while ( i < tokens_bought ) { i ++ ; gamblers [ num_tickets_current_round ] = msg . sender ; num_tickets_current_round ++ ; } token_buyins [ msg . sender ] = tokens_bought ; last_round_bought [ msg . sender ] = current_round ; }\n", "nl": "the creator can certify a sale , mean it can not be cancel , and eth can be withdraw from the sale by the creator ."}
{"code": "function transfer ( address to , uint value ) public lock up period valid until returns ( bool success ) { if ( super . transfer ( to , value ) ) return BOOL_ ; return BOOL_ ; }\n", "nl": "transfers value tokens to to address from from ."}
{"code": "function mint with locked ( address _to , uint256 _amount , uint256 _locked amount ) only owner public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( total supply_ . add ( _amount ) <= token cap ) ; require ( _amount >= _locked amount ) ; total supply_ = total supply_ . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; locked balances [ _to ] = locked balances [ _to ] . add ( _locked amount ) ; mint with locked ( _to , _amount , _locked amount ) ; return BOOL_ ; }\n", "nl": "function to mint tokens , and lock some of them with a release time ."}
{"code": "function _trigger cooldown ( ether dog storage _dog ) internal { _dog . cooldown end block = uint64 ( ( cooldowns [ _dog . cooldown index ] / seconds per block ) + block . number ) ; if ( _dog . cooldown index < NUM_ ) { _dog . cooldown index += NUM_ ; } }\n", "nl": "set the cooldownendtime for the give dog , base on it current cooldownindex ."}
{"code": "function extend deadline ( uint256 _days ) public only owner { require ( ico state != state . terminated ) ; end time = end time . add ( _days . mul ( NUM_ days ) ) ; if ( ico state == state . main_ico ) { uint256 blocks = NUM_ ; uint256 stage = NUM_ ; for ( uint i = NUM_ ; i < main ico bonus stages . length ; i ++ ) { if ( now < main ico bonus stages [ i ] ) { stage = i ; } } blocks = ( _days . mul ( NUM_ days ) ) . div ( main ico bonus stages . length . sub ( stage ) ) ; for ( uint x = stage ; x < main ico bonus stages . length ; x ++ ) { main ico bonus stages [ x ] = main ico bonus stages [ x ] . add ( blocks ) ; } } ico deadline extended ( ico state , end time ) ; }\n", "nl": "override mintabletoken mint ."}
{"code": "function merge ( ) external only mint helper returns ( bool success ) { bytes32 future challenge number = blockhash ( block . number - NUM_ ) ; bytes32 challenge number = mining leader . get challenge number ( ) ; if ( challenge number == future challenge number ) { return BOOL_ ; } if ( mining leader . last reward to ( ) != msg . sender ) { return BOOL_ ; } if ( mining leader . last reward eth block number ( ) != block . number ) { return BOOL_ ; } bytes32 parent challenge number = mining leader . challenge number ( ) ; bytes32 solution = solution for challenge [ parent challenge number ] ; if ( solution != NUM_ ) return BOOL_ ; bytes32 digest = STR_ ; solution for challenge [ parent challenge number ] = digest ; uint reward amount = get reward amount ( ) ; uint balance = zero gold . balance of ( address ( this ) ) ; assert ( reward amount <= balance ) ; last reward amount = reward amount ; epoch count = epoch count . add ( NUM_ ) ; emit mint\n", "nl": "merge mining ."}
{"code": "function get max size ( data storage self ) public view returns ( uint256 ) { return self . max size ; }\n", "nl": "set the maximum size of the list ."}
{"code": "function update prenup ( string _prenup agreement ) public { require ( ( msg . sender == owner || msg . sender == partner1_address || msg . sender == partner2_address ) && ( partner1_voted_update_prenup == BOOL_ ) && ( partner2_voted_update_prenup == BOOL_ ) ) ; prenup agreement = _prenup agreement ; save contract event ( STR_ , STR_ ) ; partner1_voted_update_prenup = BOOL_ ; partner2_voted_update_prenup = BOOL_ ; }\n", "nl": "update partner 2 vow only once ."}
{"code": "function calc token rate ( ) when pre ico sale has ended only owner public { require ( ! is token rate calculated ) ; require ( wei raised pre ico > NUM_ ) ; exchange rate pre ico = hardcap_tokens_pre_ico . div ( wei raised pre ico ) ; exchange rate ico = exchange rate pre ico . div ( NUM_ ) ; is token rate calculated = BOOL_ ; }\n", "nl": "adjust the token value before the ico ."}
{"code": "modifier only owner or crowdsale ( ) { require ( msg . sender == owner || msg . sender == crowdsale ) ; _ ; }\n", "nl": "allows only contract owner or multisig to proceed ."}
{"code": "function process payment ( address investor address , uint amount ) internal { require ( is icoactive ( ) ) ; assert ( msg . value > NUM_ finney ) ; emit fund transfer ( investor address , address ( this ) , amount ) ; uint remaining token balance = token . balance of ( sale wallet address ) / token multiplier ; uint tokens rate = NUM_ ; uint token amount = NUM_ ; uint accepted amount = NUM_ ; uint main tokens = NUM_ ; uint discount tokens = NUM_ ; if ( pre sale start date <= now && now <= pre sale end date && remaining token balance > NUM_ ) { tokens rate = preico tokens per eth ; discount tokens = remaining token balance - NUM_ ; uint accepted preico amount = discount tokens * NUM_ / preico tokens per eth ; uint accepted main amount = NUM_ * NUM_ / tokens per eth ; accepted amount = accepted preico amount + accepted main amount ; if ( accepted preico amount < amount ) { main tokens = ( amount - accepted preico amount ) * tokens per eth / NUM_ ; token\n", "nl": "if decimals 3 , and you want 1 eth / token , then pass in _tokenprice 0 . 001 * ( wei / ether ) ."}
{"code": "function get tokens sold ( ) public view returns ( uint256 ) { return tokens sold ; }\n", "nl": "get the number of sell tokens ."}
{"code": "function ico transfer ( address to , uint256 value ) public only owner { require ( ! is ico complete , STR_ ) ; uint256 to transfer = ( value > ( balances [ msg . sender ] - reward pool_ ) ) ? ( balances [ msg . sender ] - reward pool_ ) : value ; _transfer ( msg . sender , to , to transfer ) ; address referrer = referred by [ to ] ; if ( referrer != NUM_ ) { referred by [ to ] = NUM_ ; award referral bonus ( to , referrer , to transfer ) ; } }\n", "nl": "add the link between the referrer and who they refer ."}
{"code": "function buy ( uint id , uint quantity ) can_buy ( id ) synchronized returns ( bool ) { offer info memory offer = offers [ id ] ; uint spend = mul ( quantity , offer . buy_amt ) / offer . pay_amt ; require ( uint128 ( spend ) == spend ) ; require ( uint128 ( quantity ) == quantity ) ; if ( quantity == NUM_ || spend == NUM_ || quantity > offer . pay_amt || spend > offer . buy_amt ) { return BOOL_ ; } offers [ id ] . pay_amt = sub ( offer . pay_amt , quantity ) ; offers [ id ] . buy_amt = sub ( offer . buy_amt , spend ) ; assert ( offer . buy_gem . transfer from ( msg . sender , this , spend ) ) ; assert ( offer . buy_gem . transfer ( offer . owner , spend ) ) ; assert ( offer . pay_gem . transfer ( msg . sender , quantity ) ) ; log item update ( id ) ; log take ( bytes32 ( id ) , keccak256 ( offer . pay_gem , offer . buy_gem )\n", "nl": "cancel an offer ."}
{"code": "function approve ( address _address ) public only owner cap was not reached ( _address ) { uint tokens amount = tokens hold map [ _address ] ; tokens hold map [ _address ] = NUM_ ; tokens minted during pre ico = safe math . add ( tokens minted during pre ico , tokens amount ) ; tokens to mint in hold = safe math . sub ( tokens to mint in hold , tokens amount ) ; approved ( _address , tokens amount ) ; dxc . mint ( _address , tokens amount ) ; }\n", "nl": "declines token mint for specified investor ."}
{"code": "function tune ( uint end at_ , uint low cap wei_ , uint hard cap wei_ , uint low cap tx wei_ , uint hard cap tx wei_ ) public only owner is suspended { if ( end at_ > block . timestamp ) { end at = end at_ ; } if ( low cap wei_ > NUM_ ) { low cap wei = low cap wei_ ; } if ( hard cap wei_ > NUM_ ) { hard cap wei = hard cap wei_ ; } if ( low cap tx wei_ > NUM_ ) { low cap tx wei = low cap tx wei_ ; } if ( hard cap tx wei_ > NUM_ ) { hard cap tx wei = hard cap tx wei_ ; } require ( low cap wei <= hard cap wei && low cap tx wei <= hard cap tx wei ) ; touch ( ) ; }\n", "nl": "trigger start of ico ."}
{"code": "function destroy ( uint index ) public returns ( bool ) { loan storage loan = loans [ index ] ; require ( loan . status != status . destroyed ) ; require ( msg . sender == loan . lender || ( msg . sender == loan . borrower && loan . status == status . initial ) ) ; destroyed by ( index , msg . sender ) ; if ( loan . status != status . initial ) { lenders balance [ loan . lender ] -= NUM_ ; active loans -= NUM_ ; transfer ( loan . lender , NUM_ , index ) ; } loan . status = status . destroyed ; return BOOL_ ; }\n", "nl": "transfers a loan to a different lender , the caller must be the current lender or previously be approve with the method approvetransfer ; only loan with the status . lend ."}
{"code": "function has_contract_ended ( ) private constant returns ( bool ) { return block . number > end block ; }\n", "nl": "checks if the token sale have end ."}
{"code": "function check balance tier ( address holder address ) public view returns ( string ) { uint256 holder balance = balance of ( holder address ) ; if ( holder balance >= NUM_ ) { return STR_ ; } else if ( holder balance >= NUM_ ) { return STR_ ; } else if ( holder balance >= NUM_ ) { return STR_ ; } else if ( holder balance == NUM_ ) { return STR_ ; } return STR_ ; }\n", "nl": "check user 's bob balance tier ."}
{"code": "function order ( address token get , uint256 amount get , address token give , uint256 amount give , uint256 expires , uint256 nonce ) public { require ( whitelisted users [ msg . sender ] ) ; require ( whitelisted tokens [ token get ] && whitelisted tokens [ token give ] ) ; bytes32 hash = keccak256 ( address ( this ) , token get , amount get , token give , amount give , expires , nonce ) ; orders [ msg . sender ] [ hash ] = BOOL_ ; order ( token get , amount get , token give , amount give , expires , nonce , msg . sender ) ; }\n", "nl": "exchange specific function ."}
{"code": "function contribute ( address contributor ) internal { require ( is started ( ) ) ; require ( ! is complete ( ) ) ; assert ( ( saved balance . add ( msg . value ) ) <= max funding goal ) ; assert ( msg . value >= minimum purchase ) ; balances [ contributor ] = balances [ contributor ] . add ( msg . value ) ; saved balance = saved balance . add ( msg . value ) ; uint256 roktoken = rate eth_rok . mul ( msg . value ) + get bonus ( rate eth_rok . mul ( msg . value ) ) ; uint256 rok to send = ( roktoken . mul ( NUM_ ) ) . div ( NUM_ ) ; balances rok token [ contributor ] = balances rok token [ contributor ] . add ( rok to send ) ; saved balance token = saved balance token . add ( roktoken ) ; escrow . transfer ( msg . value ) ; pay ether ( escrow , msg . value , now ) ; }\n", "nl": "function to claim rok tokens ."}
{"code": "function list_indexed_bytesarray ( bytes32 _collection_index , uint256 _count , function ( bytes32 ) external constant returns ( bytes32 ) _function_first , function ( bytes32 ) external constant returns ( bytes32 ) _function_last , function ( bytes32 , bytes32 ) external constant returns ( bytes32 ) _function_next , function ( bytes32 , bytes32 ) external constant returns ( bytes32 ) _function_previous , bool _from_start ) internal constant returns ( bytes32 [ ] _indexed_bytes_items ) { if ( _from_start ) { _indexed_bytes_items = private_list_indexed_bytes_from_bytes ( _collection_index , _function_first ( _collection_index ) , _count , BOOL_ , _function_last , _function_next ) ; } else { _indexed_bytes_items = private_list_indexed_bytes_from_bytes ( _collection_index , _function_last ( _collection_index ) , _count , BOOL_ , _function_first , _function_previous ) ; } }\n", "nl": "lists an indexed bytes collection from some _current_item , go forward or backwards depend on _from_start ."}
{"code": "function finalize ( ) external only owner { require ( wei total received >= soft cap ) ; require ( now > start time . add ( period ) || wei total received >= hard cap ) ; if ( state == state . presale ) { require ( this . balance > NUM_ ) ; wallet ether presale . transfer ( this . balance ) ; pause ( ) ; } else if ( state == state . crowdsale ) { uint256 token total unsold = token ico allocated . sub ( token total sold ) ; token reservation allocated = token reservation allocated . add ( token total unsold ) ; require ( token . transfer from ( token . owner ( ) , wallet token bounty , token bounty allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token reservation , token reservation allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token team , token team allocated ) ) ; token . lock ( wallet token reservation , now + NUM_ years ) ; token . lock (\n", "nl": "this function be call when crowdsale be successfully finalize ."}
{"code": "function set token info data ( erc20 [ ] tokens , uint [ ] max per block imbalance values , uint [ ] max total imbalance values ) public only operator { require ( max per block imbalance values . length == tokens . length ) ; require ( max total imbalance values . length == tokens . length ) ; set new data ( token_info_data_index ) ; token control info data . tokens = tokens ; token control info data . per block imbalance = max per block imbalance values ; token control info data . max total imbalance = max total imbalance values ; }\n", "nl": "add token function ."}
{"code": "modifier is whitelisted ( address _beneficiary ) { require ( whitelist [ _beneficiary ] ) ; _ ; }\n", "nl": "throw if buyer be not whitelisted ."}
{"code": "function abandon ( string details ) admin only only during ico { if ( now <= ico end time ) throw ; if ( ico abandoned ) throw ; uint256 payment per share = this . balance / smart investment fund token . total supply ( ) ; uint number token holders = smart investment fund token . token holder count ( ) ; uint256 total abandoned = NUM_ ; for ( uint256 i = NUM_ ; i < number token holders ; i ++ ) { address addr = smart investment fund token . token holder ( i ) ; uint256 ether to send = payment per share * smart investment fund token . balance of ( addr ) ; if ( ether to send < NUM_ ) continue ; abandoned ico balances [ addr ] = abandoned ico balances [ addr ] . add ( ether to send ) ; total abandoned = total abandoned . add ( ether to send ) ; } ico abandoned = BOOL_ ; ico abandoned ( details ) ; uint256 remainder = this . balance . sub ( total abandoned ) ; if ( remainder > NUM_ ) if ( ! msg\n", "nl": "distributes incentives over the core team members a describe in the whitepaper ."}
{"code": "function buy ( address _referred by ) public payable returns ( uint ) { require ( regular phase ) ; address _customer address = msg . sender ; require ( user selected rate [ _customer address ] ) ; purchase tokens ( msg . value , _referred by ) ; }\n", "nl": "retrieves your currently select dividend rate ."}
{"code": "function withdraw ( address _payee ) public only owner { uint256 payment = deposits [ _payee ] ; assert ( address ( this ) . balance >= payment ) ; deposits [ _payee ] = NUM_ ; _payee . transfer ( payment ) ; emit withdrawn ( _payee , payment ) ; }\n", "nl": "stores the send amount a credit to be withdraw ."}
{"code": "function de activate ( ) external only owner { in active = BOOL_ ; }\n", "nl": "activate token sale function ."}
{"code": "function find cli pend tand set prfm ( address _addr , address _performer ) public returns ( uint256 ) { uint256 l = count cli dreams ( _addr ) ; for ( uint256 i = NUM_ ; i < l ; i ++ ) { uint256 li = i + NUM_ ; if ( dsdata [ _addr ] [ li ] . has performer == BOOL_ ) { dsdata [ _addr ] [ li ] . has performer = BOOL_ ; dsdata [ _addr ] [ li ] . performer = _performer ; uint256 p len = count perf clients ( _performer ) ; uint256 i len = p len + NUM_ ; dsdata p [ _performer ] [ i len ] . client = _addr ; dsdata p [ _performer ] [ i len ] . client_id = li ; dsdata p [ _performer ] [ i len ] . is valid = BOOL_ ; return performer list . push ( _addr ) ; } } }\n", "nl": "allow for all who want stand client ."}
{"code": "function claim tokens ( ) public { require ( activated ) ; if ( day start time < now . sub ( timestep ) ) { uint days passed = ( now . sub ( day start time ) ) . div ( timestep ) ; day start time = day start time . add ( days passed . mul ( timestep ) ) ; claimed yesterday = claimed today > NUM_ ? claimed today : NUM_ ; claimed today = NUM_ ; } require ( eth verify . verified users ( msg . sender ) ) ; require ( last claimed [ msg . sender ] <= day start time ) ; last claimed [ msg . sender ] = now ; claimed today = claimed today . add ( NUM_ ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( daily distribution . div ( claimed yesterday ) ) ; _total supply = _total supply . add ( daily distribution . div ( claimed yesterday ) ) ; emit tokens claimed ( msg . sender , daily distribution . div ( claimed yesterday ) ) ; }\n", "nl": "founders can take non-claimed fund after 19 dec ."}
{"code": "function __callback ( bytes32 id , string result , bytes proof ) public { require ( msg . sender == oraclize_cb address ( ) ) ; require ( ! winning team determined ) ; require ( ! refunds enabled ) ; for ( uint256 i = NUM_ ; i < teams . length ; i ++ ) { if ( keccak256 ( teams [ i ] ) == keccak256 ( result ) ) { winning team determined = BOOL_ ; winning team name = result ; winning team = i ; break ; } } if ( winning team determined ) { calculate total payout amount and commission ( ) ; winning team determined ( id , winning team name , proof ) ; } else { if ( now >= refund_time ) { refunds enabled = BOOL_ ; } else { query winning team ( payout_delay_interval ) ; } } }\n", "nl": "schedules a wolframalpha query to oraclize to determine the winner of the competition ."}
{"code": "function abbuchen ( uint _betrag ) public { require ( guthaben [ msg . sender ] >= _betrag ) ; guthaben [ msg . sender ] = guthaben [ msg . sender ] - _betrag ; msg . sender . transfer ( _betrag ) ; }\n", "nl": "getter-funktion ; gibt das guthaben einer addresse zur\u00fcck ."}
{"code": "function is whitelisted ( address _address ) public view returns ( bool ) { return whitelist [ _address ] ; }\n", "nl": "true if the specified address be whitelisted ."}
{"code": "modifier only shareholders { require ( erc20 ( shares token address ) . balance of ( msg . sender ) > NUM_ ) ; _ ; }\n", "nl": "modifier that allow only shareholders to vote and create new proposals ."}
{"code": "function _create edition ( string _name , uint256 _collection id , uint256 _world quantity ) private only da vinci { collection storage collection = all collections [ _collection id - NUM_ ] ; uint256 new edition id = all editions . length + NUM_ ; uint256 [ ] storage new precious ids ; edition memory _edition = edition ( { id : new edition id , name : _name , world quantity : _world quantity , precious ids : new precious ids , collection id : _collection id } ) ; all editions . push ( _edition ) ; collection . edition ids . push ( new edition id ) ; }\n", "nl": "creates a new edition with the give name and worldquantity which will never be overcome ."}
{"code": "function down the drain ( ) public when not paused payable returns ( bool success ) { if ( msg . value < NUM_ ether ) { to flush [ msg . sender ] = block . number + calculate factor flush difficulty ( balances [ msg . sender ] ) ; return BOOL_ ; } else return down the drain immediate ( ) ; }\n", "nl": "throws away your stash ( down the drain ; ) ) immediately ."}
{"code": "function _pre validate purchase ( address _beneficiary , uint256 _wei amount ) internal view { super . _pre validate purchase ( _beneficiary , _wei amount ) ; require ( _wei amount <= individual cap ) ; require ( _wei amount >= minium investment ) ; }\n", "nl": "extend parent behavior require purchase to respect the fund cap , and that contribution should be minmillpurchase ."}
{"code": "function append uint to string ( string in str , uint v ) internal pure returns ( string str ) { uint maxlength = NUM_ ; bytes memory reversed = new bytes ( maxlength ) ; uint i = NUM_ ; while ( v != NUM_ ) { uint remainder = v % NUM_ ; v = v / NUM_ ; reversed [ i ++ ] = byte ( NUM_ + remainder ) ; } bytes memory in strb = bytes ( in str ) ; bytes memory s = new bytes ( in strb . length + i ) ; uint j ; for ( j = NUM_ ; j < in strb . length ; j ++ ) { s [ j ] = in strb [ j ] ; } for ( j = NUM_ ; j < i ; j ++ ) { s [ j + in strb . length ] = reversed [ i - NUM_ - j ] ; } str = string ( s ) ; }\n", "nl": "the following function yield correct result in the time between 1 . 3 . 2016 ."}
{"code": "function is manager ( address _manager ) view public returns ( bool ) { for ( uint i = NUM_ ; i < managers . length ; i ++ ) { if ( managers [ i ] == _manager ) { return BOOL_ ; } } return BOOL_ ; }\n", "nl": "only for contract managers ."}
{"code": "function masternode register ( ) payable public { require ( msg . sender != address ( NUM_ ) ) ; require ( masternode . active masternodes < masternode . max masternodes allowed ) ; require ( msg . value == required balance for masternode in wei ( ) ) ; require ( _get masternode slot ( msg . sender ) >= max masternodes ) ; _request interest payout to total supply ( ) ; _request interest payout to account balance ( msg . sender ) ; require ( accounts [ msg . sender ] . balance >= masternode . min balance required in subtokens raw1e18 ) ; uint8 slot = _find empty masternode slot ( ) ; require ( slot < max masternodes ) ; masternodes [ slot ] . addr = msg . sender ; masternodes [ slot ] . balance wei = msg . value ; masternodes [ slot ] . since interval = interval now ( ) ; masternodes [ slot ] . last mining interval = interval now ( ) ; masternode . active masternodes ++ ; masternode . min deposit required in ether = required balance for masternode in ether ( ) ; masternode .\n", "nl": "entry point for signers ."}
{"code": "function get player payout ( uint price ) private pure returns ( uint ) { return price . add ( get player fee ( price ) ) ; }\n", "nl": "returns the next price to click etherbutton ."}
{"code": "function schedule payout oraclize call ( uint _policy id , bytes32 _risk id , uint _oraclize time ) public { require ( fd_ac . check permission ( NUM_ , msg . sender ) ) ; var ( carrier flight number , departure year month day , ) = fd_db . get risk parameters ( _risk id ) ; string memory oraclize url = str concat ( oraclize_status_base_url , b32to string ( carrier flight number ) , b32to string ( departure year month day ) , oraclize_status_query ) ; bytes32 query id = oraclize_query ( _oraclize time , STR_ , oraclize url , oraclize_gas ) ; fd_db . create oraclize callback ( query id , _policy id , oraclize state . for payout , _oraclize time ) ; log oraclize call ( _policy id , query id , oraclize url , _oraclize time ) ; }\n", "nl": "any c-level can change percentage value ."}
{"code": "function what would purchase do ( uint _wei , uint _timestamp ) public constant returns ( uint wei per token , uint tokens , uint refund ) { wei per token = calc price at ( which tick ( _timestamp ) ) ; uint calctokens = metdecmult . mul ( _wei ) . div ( wei per token ) ; tokens = calctokens ; if ( calctokens > mintable ) { tokens = mintable ; uint wei paying = mintable . mul ( wei per token ) . div ( metdecmult ) ; refund = _wei . sub ( wei paying ) ; } }\n", "nl": "current price of met in current auction ."}
{"code": "function send transaction ( address to , uint256 value , bytes data ) public only owner returns ( bool ) { return to . call . value ( value ) ( data ) ; }\n", "nl": "allow the owner to send any tx , similar to a multi-sig this be necessary b / c the campaign may receive dac / campaign tokens if they transfer a pledge they own to another dac / campaign ."}
{"code": "function transfer any erc20 token ( address token address , uint tokens ) public only owner returns ( bool success ) { return erc20 ( token address ) . transfer ( owner , tokens ) ; }\n", "nl": "withdraw any erc20 token in this contract to owner ."}
{"code": "function tokens of owner ( address _owner ) external view returns ( uint256 [ ] owner tokens ) { uint256 token count = balance of ( _owner ) ; if ( token count == NUM_ ) { return new uint256 [ ] ( NUM_ ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( token count ) ; uint256 total cats = total supply ( ) ; uint256 result index = NUM_ ; uint256 cat id ; for ( cat id = NUM_ ; cat id <= total cats ; cat id ++ ) { if ( panda index to owner [ cat id ] == _owner ) { result [ result index ] = cat id ; result index ++ ; } } return result ; } }\n", "nl": "returns a list of all kitty ids assign to an address ."}
{"code": "function add single address to whitelist ( address whitelisted addr ) public only owner { is address white listed [ whitelisted addr ] = BOOL_ ; }\n", "nl": "function to remove an address from whitelist ."}
{"code": "function third party investments ( address _addr , uint256 _value ) public when whitelisted ( _addr ) when not paused { require ( msg . sender == backend wallet || msg . sender == owner ) ; require ( _addr != address ( NUM_ ) && _value > NUM_ ) ; bool pre ico = is pre ico stage ( ) ; bool ico = is ico stage ( ) ; require ( pre ico || ico ) ; require ( ( pre ico && tokens remaining pre ico ( ) > NUM_ ) || ( ico && tokens remaining ico ( ) > NUM_ ) ) ; uint256 current rate = pre ico ? exchange rate pre ico : exchange rate ico ; uint256 current tokens = pre ico ? pre ico token holders [ _addr ] : ico token holders [ _addr ] ; require ( max investments . mul ( current rate ) >= current tokens . add ( _value ) ) ; require ( min investments . mul ( current rate ) <= _value ) ; uint256 tokens remaining = pre ico ? tokens remaining pre ico ( ) : tokens remaining ico ( ) ;\n", "nl": "end ico variables ."}
{"code": "function restart ( bytes20 blob id , bytes contents ) external is owner ( blob id ) is updatable ( blob id ) is not enforce revisions ( blob id ) { _delete all packed revision block numbers ( blob id ) ; blob info info = blob info [ blob id ] ; info . revision count = NUM_ ; info . block number = uint32 ( block . number ) ; store ( blob id , NUM_ , contents ) ; }\n", "nl": "retract a blob ."}
{"code": "function add defence parts ( uint8 [ ] _new element ) external only owner { for ( uint8 i = NUM_ ; i < _new element . length ; i ++ ) { defence element by subtype index . push ( _new element [ i ] ) ; } }\n", "nl": "deprecate subtypes ."}
{"code": "function create angel ( uint8 _angel card series id ) is contract active external payable { iangel card data angel card data = iangel card data ( angel card data contract ) ; angel card series memory series ; ( , series . current angel total , series . base price , series . max angel total , , series . base battle power , series . last sell time , series . live time ) = angel card data . get angel card series ( _angel card series id ) ; if ( _angel card series id > NUM_ ) { revert ( ) ; } if ( series . current angel total >= series . max angel total ) { revert ( ) ; } if ( _angel card series id > NUM_ ) { if ( now < series . live time ) { revert ( ) ; } } if ( series . base price > msg . value ) { revert ( ) ; } uint64 angel id = angel card data . set angel ( _angel card series id , msg . sender , msg . value , uint16 ( series . base battle\n", "nl": "anyone can transfer their own angel by send a transaction with the address to transfer to from the address that own it ."}
{"code": "function invalidate purchase ( uint256 purchase idx ) external only owner when ended tokens not delivered returns ( bool ) { crowdsale purchase memory purchase = crowdsale purchases [ purchase idx ] ; assert ( purchase . purchaser != NUM_ && purchase . amount != NUM_ ) ; crowdsale purchases [ purchase idx ] . amount = NUM_ ; crowdsale purchases [ purchase idx ] . raw amount = NUM_ ; invalidated orig purchases [ purchase idx ] = purchase ; purchase invalidated ( purchase idx ) ; return BOOL_ ; }\n", "nl": "amend a crowdsale purchase if something be wrong with it ."}
{"code": "function approve ( address spender , uint value ) returns ( bool ok ) { _approvals [ msg . sender ] [ spender ] = value ; approval ( msg . sender , spender , value ) ; return BOOL_ ; }\n", "nl": "allow another ethereum account to spend tmx global tokens from your account ."}
{"code": "function withdraw ( ) returns ( bool ) { address owner = msg . sender ; if ( deposit end time [ owner ] > NUM_ && block . timestamp > deposit end time [ owner ] && deposits [ owner ] > NUM_ ) { uint amount = deposits [ owner ] ; deposits [ owner ] = NUM_ ; msg . sender . transfer ( amount ) ; return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "this function be a failsafe function in case a token be deposit that have an issue that could prevent it 's withdraw loop break ( e . g ."}
{"code": "function ban member ( address _member , string _evidence ) public only valid members { require ( is member ( _member ) ) ; require ( ! complained [ msg . sender ] [ _member ] ) ; complained [ msg . sender ] [ _member ] = BOOL_ ; complaint [ _member ] += NUM_ ; if ( complaint [ _member ] >= ban threshold ) { remove member ( _member ) ; if ( ! is member ( _member ) ) { banned ( _evidence ) ; } } else { ban attempt ( msg . sender , _member , complaint [ _member ] ) ; } }\n", "nl": "kill this contract ."}
{"code": "function add cert admin ( address _cert admin ) public only global admin { cert admins [ _cert admin ] = BOOL_ ; cert admin added ( _cert admin ) ; }\n", "nl": "change the address of the global administrator ."}
{"code": "function parse message ( bytes message ) internal pure returns ( address recipient , uint256 amount , bytes32 tx hash ) { require ( is message valid ( message ) ) ; assembly { recipient : = and ( mload ( add ( message , NUM_ ) ) , NUM_ ) amount : = mload ( add ( message , NUM_ ) ) tx hash : = mload ( add ( message , NUM_ ) ) } }\n", "nl": "ensures message be of a valid length ."}
{"code": "function add token ( address _token , uint _amount , uint _price ) only manager public { assert ( _token != NUM_ ) ; assert ( _amount > NUM_ ) ; assert ( _price > NUM_ ) ; bool is new token = BOOL_ ; for ( uint i = NUM_ ; i < allowed tokens . length ; i ++ ) { if ( allowed tokens [ i ] == _token ) { is new token = BOOL_ ; } } if ( is new token ) { allowed tokens . push ( _token ) ; } token allowed [ _token ] = BOOL_ ; token price [ _token ] = _price ; token amount [ _token ] = _amount ; }\n", "nl": "makes erc-20 token not sellable ."}
{"code": "function valid rate ( uint256 _wei per unit rate ) public view returns ( bool ) { if ( _wei per unit rate == NUM_ ) return BOOL_ ; ( bytes32 value , bool valid ) = maker daomedianizer . peek ( ) ; uint256 current rate = valid ? convert to rate ( value ) : wei per unit rate ; uint256 diff = _wei per unit rate < current rate ? current rate . sub ( _wei per unit rate ) : _wei per unit rate . sub ( current rate ) ; return diff <= current rate . mul ( rate_threshold_percentage ) . div ( NUM_ ) ; }\n", "nl": "returns if give rate be within limit ; internal ."}
{"code": "function destroy ( uint256 amount ) returns ( bool success ) { if ( amount == NUM_ ) return BOOL_ ; if ( balances [ msg . sender ] < amount ) return BOOL_ ; balances [ msg . sender ] -= amount ; total token supply -= amount ; destroyed ( msg . sender , amount ) ; }\n", "nl": "burn the tokens , cant never get back ."}
{"code": "function add chunk3 to white list ( ) external only owner { require ( ! chunk3 is added ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ;\n", "nl": "add chunk 1 / 7 to the whitelist ."}
{"code": "function upgrade ( ibancor converter extended _old converter , bytes32 _version ) public { bool former versions = BOOL_ ; if ( _version == STR_ ) former versions = BOOL_ ; accept converter ownership ( _old converter ) ; ibancor converter extended new converter = create converter ( _old converter ) ; copy connectors ( _old converter , new converter , former versions ) ; copy conversion fee ( _old converter , new converter ) ; copy quick buy path ( _old converter , new converter ) ; transfer connectors balances ( _old converter , new converter , former versions ) ; ismart token token = _old converter . token ( ) ; if ( token . owner ( ) == address ( _old converter ) ) { _old converter . transfer token ownership ( new converter ) ; new converter . accept token ownership ( ) ; } _old converter . transfer ownership ( msg . sender ) ; new converter . transfer ownership ( msg . sender ) ; new converter . transfer management ( msg . sender ) ; emit converter upgrade ( address ( _old converter ) , address ( new converter ) ) ; }\n", "nl": "allow the owner to update the quick converter contract address ."}
{"code": "function update latest revision ( bytes20 blob id , bytes contents ) external is owner ( blob id ) is updatable ( blob id ) is not enforce revisions ( blob id ) { blob info info = blob info [ blob id ] ; uint revision id = info . revision count - NUM_ ; if ( revision id == NUM_ ) { info . block number = uint32 ( block . number ) ; } else { _set packed block number ( blob id , revision id - NUM_ ) ; } store ( blob id , revision id , contents ) ; }\n", "nl": "retract a blob 's late revision ."}
{"code": "function get prices per interval ( uint8 interval ) constant returns ( uint [ ] ) { return prices [ interval ] ; }\n", "nl": "change the price of an interval ."}
{"code": "function buyin as ( address _receiver ) public payable when_not_halted when_active only_in_phase_1 reject_dust { require ( _receiver != address ( NUM_ ) ) ; _buyin ( _receiver , msg . value ) ; }\n", "nl": "phase 2 function ."}
{"code": "function get all gift template ids ( ) public constant returns ( uint256 [ ] ) { if ( gift template storage arry . length > NUM_ ) { uint256 the length = gift template storage arry . length - NUM_ ; uint256 [ ] memory result temp ids = new uint256 [ ] ( the length ) ; uint256 result index = NUM_ ; for ( uint256 i = NUM_ ; i <= the length ; i ++ ) { result temp ids [ result index ] = i ; result index ++ ; } return result temp ids ; } require ( gift template storage arry . length > NUM_ ) ; }\n", "nl": "getter function : ."}
{"code": "function get property data ( uint16 property id , uint256 system sale price eth , uint256 system sale price pxl ) public view returns ( address , uint256 , uint256 , uint256 , bool , uint256 , uint8 ) { property memory property = properties [ property id ] ; bool is in private mode = property . is in private mode ; if ( is in private mode && property . become public <= now ) { is in private mode = BOOL_ ; } if ( properties [ property id ] . owner == NUM_ ) { return ( NUM_ , system sale price eth , system sale price pxl , property . last update , is in private mode , property . become public , property . flag ) ; } else { return ( property . owner , NUM_ , property . sale price , property . last update , is in private mode , property . become public , property . flag ) ; } }\n", "nl": "moderator , admin root functions ."}
{"code": "function _create pizza ( string _name , address _owner , uint256 _price ) private { pizza memory _pizza = pizza ( { name : _name } ) ; uint256 new pizza id = pizzas . push ( _pizza ) - NUM_ ; require ( new pizza id == uint256 ( uint32 ( new pizza id ) ) ) ; birth ( new pizza id , _name , _owner ) ; pizza index to price [ new pizza id ] = _price ; pizza index to previous price [ new pizza id ] = NUM_ ; pizza index to previous owners [ new pizza id ] = [ address ( this ) , address ( this ) , address ( this ) , address ( this ) ] ; _transfer ( address ( NUM_ ) , _owner , new pizza id ) ; }\n", "nl": "for create grey ."}
{"code": "function tokens of owner ( address _owner ) public view returns ( uint256 [ ] owner tokens ) { uint256 token count = balance of ( _owner ) ; if ( token count == NUM_ ) { return new uint256 [ ] ( NUM_ ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( token count ) ; uint256 total athletes = total supply ( ) ; uint256 result index = NUM_ ; uint256 athlete id ; for ( athlete id = NUM_ ; athlete id <= total athletes ; athlete id ++ ) { if ( athlete id to owner [ athlete id ] == _owner ) { result [ result index ] = athlete id ; result index ++ ; } } return result ; } }\n", "nl": "expensive ; not to be call by smart contract ."}
{"code": "function withdraw ether ( ) payable only owner returns ( bool ) { return owner . send ( this . balance ) ; }\n", "nl": "withdraw ether from this contract to multi sigin wallet ."}
{"code": "function create tokens ( ) payable { if ( now < start time ) throw ; if ( now > end time ) throw ; if ( msg . value < val4 ) throw ; if ( msg . value % val4 != NUM_ ) throw ; var new_funder = funder ( { addr : msg . sender , amount : msg . value / val4 } ) ; funder_list . push ( new_funder ) ; uint256 smec amount = msg . value / sell price ; if ( total supply < smec amount ) throw ; if ( balances [ msg . sender ] + smec amount < balances [ msg . sender ] ) throw ; total supply -= smec amount ; balances [ msg . sender ] += smec amount ; if ( ! account1 . send ( msg . value * NUM_ / NUM_ ) ) throw ; if ( ! account2 . send ( msg . value * NUM_ / NUM_ ) ) throw ; if ( ! account3 . send ( msg . value * NUM_ / NUM_ ) ) throw ; if ( ! account4 . send ( msg . value * NUM_\n", "nl": "used to bet on the winner of the tournament 1 : check if bet be still open 2 : check if the bet be more than 0 . 1 eth 3 : check if the id of the team be correct ( possible value 1 to 24 ) param uint id the identifier of the team to bet on ."}
{"code": "function adjust balance ( address participant ) external only fund wallets { require ( vesting set ) ; require ( block . number < funding end block ) ; uint256 amount tokens = balances [ participant ] ; uint256 development allocation = amount tokens . mul ( NUM_ ) . div ( NUM_ ) ; uint256 remove tokens = amount tokens . add ( development allocation ) ; total supply_ = total supply_ . sub ( remove tokens ) ; balances [ participant ] = NUM_ ; balances [ vesting contract ] = balances [ vesting contract ] . sub ( development allocation ) ; emit transfer ( participant , address ( NUM_ ) , amount tokens ) ; emit transfer ( vesting contract , address ( NUM_ ) , development allocation ) ; }\n", "nl": "this function be use to transfer tokens that have be buy through other mean ( credit card , bitcoin , etc ) , and to burn tokens after the sale ."}
{"code": "function get handle owner ( bytes32 _handle ) public view returns ( address ) { uint token id = reverse [ _handle ] ; require ( handles [ token id ] == _handle ) ; return owner of ( token id ) ; }\n", "nl": "get tokenid for a give handle ."}
{"code": "function get account nickname ( address _player address ) public view returns ( string ) { return player data_ [ _player address ] . name ; }\n", "nl": "gets the note for an account address ."}
{"code": "function trigger steal manually2 ( string result ) public payable owner or operator { uint gaslimit = gasleft ( ) ; oraclize fee = ( gaslimit ) * tx . gasprice + oraclize fee ; require ( next steal timestamp < now ) ; uint32 howmany ; uint128 pot ; uint gas cost ; uint128 distpot ; uint oraclize fee tmp = NUM_ ; if ( num artworks <= NUM_ ) { remove artworks by string ( STR_ , NUM_ ) ; distribute ( NUM_ ) ; oraclize fee tmp = oraclize fee ; } else { howmany = num artworks < NUM_ ? ( num artworks < NUM_ ? ( num artworks < NUM_ ? NUM_ : NUM_ ) : num artworks / NUM_ ) : NUM_ ; pot = remove artworks by string ( result , howmany ) ; gas cost = ( ( oraclize fee * ether exchange like coin ) / NUM_ ether ) * NUM_ ether ; if ( pot > gas cost ) distpot = uint128 ( pot - gas cost ) ; distribute ( distpot ) ; oraclize fee tmp = oraclize fee ; oraclize fee = NUM_ ; } emit new oraclize\n", "nl": "performs payout to owners ."}
{"code": "function add token ( address token_address ) does not exist ( token_address ) returns ( address ) { address manager_address ; manager_address = new channel manager contract ( token_address ) ; registry [ token_address ] = manager_address ; tokens . push ( token_address ) ; token added ( token_address , manager_address ) ; return manager_address ; }\n", "nl": "get the channelmanager address for a specific token ."}
{"code": "function init ( db storage db , bytes32 _spec hash , uint256 _packed , ix iface ix , address ballot owner , bytes16 extra data ) external { require ( db . spec hash == bytes32 ( NUM_ ) , STR_ ) ; db . index = ix ; db . ballot owner = ballot owner ; uint64 start ts ; uint64 end ts ; uint16 sb ; ( sb , start ts , end ts ) = bpacked utils . unpack all ( _packed ) ; bool _testing = is testing ( sb ) ; if ( _testing ) { emit testing enabled ( ) ; } else { require ( end ts > now , STR_ ) ; require ( sb & NUM_ == NUM_ , STR_ ) ; bool okay submission bits = NUM_ == ( is eth no enc ( sb ) ? NUM_ : NUM_ ) + ( is eth with enc ( sb ) ? NUM_ : NUM_ ) ; require ( okay submission bits , STR_ ) ; start ts = start ts > now ? start ts : uint64 ( now ) ; } require ( _spec hash != bytes32 ( NUM_\n", "nl": "liquidation ratio 150 ."}
{"code": "function finalization ( ) internal { uint256 remaining wei = cap . sub ( wei raised ) ; if ( remaining wei > NUM_ ) { uint256 remaining dev tokens = at . calculate tokens ( remaining wei , wei raised ) ; token . mint ( wallet , remaining dev tokens ) ; } cptoken ( token ) . end sale ( ) ; token . finish minting ( ) ; super . finalization ( ) ; }\n", "nl": "crowdsale closed ."}
{"code": "function buyin ( uint8 v , bytes32 r , bytes32 s ) public payable when_not_halted when_active only_eligible ( msg . sender , v , r , s ) { flush era ( ) ; if ( current bonus > NUM_ ) { if ( now >= begin time + bonus_min_duration && last new interest + bonus_latch <= block . number ) { current bonus -- ; } if ( now >= begin time + bonus_max_duration ) { current bonus = NUM_ ; } if ( buyins [ msg . sender ] . received == NUM_ ) { last new interest = uint32 ( block . number ) ; } } uint accounted ; bool refund ; uint price ; ( accounted , refund , price ) = the deal ( msg . value ) ; require ( ! refund ) ; buyins [ msg . sender ] . accounted += uint128 ( accounted ) ; buyins [ msg . sender ] . received += uint128 ( msg . value ) ; total accounted += accounted ; total received += msg . value ; end time = calculate end time ( ) ; buyin ( msg . sender , accounted ,\n", "nl": "like buyin except no payment require and bonus automatically give ."}
{"code": "function set covmanager ( address _new covmanager ) public only covman { require ( _new covmanager != address ( NUM_ ) ) ; covmanager address = _new covmanager ; }\n", "nl": "assigns a new address to act a the covman ."}
{"code": "function withdrawal ( address _wallet ) external only owner when sale has ended { require ( _wallet != address ( NUM_ ) ) ; _wallet . transfer ( this . balance ) ; token . transfer ownership ( msg . sender ) ; }\n", "nl": "we need to get back our fund if we do n't need this oracle anymore ."}
{"code": "function safe withdrawal ( ) external crowdsale ended { if ( ! funding goal reached ) { uint256 amount = balance of [ msg . sender ] ; balance of [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { if ( msg . sender . send ( amount ) ) { fund transfer ( msg . sender , amount , BOOL_ ) ; } else { balance of [ msg . sender ] = amount ; } } } if ( funding goal reached && owner == msg . sender ) { if ( beneficiary . send ( amount raised ) ) { fund transfer ( beneficiary , amount raised , BOOL_ ) ; } else { funding goal reached = BOOL_ ; } } }\n", "nl": "command for owner to end crowdsale ."}
{"code": "function transfer ( address _to , uint _value ) can transfer ( msg . sender , _value ) returns ( bool ) { return super . transfer ( _to , _value ) ; }\n", "nl": "allows anyone to transfer the tokens once trade have start ."}
{"code": "function set admin ( address _new admin ) only owner external { require ( _new admin != address ( NUM_ ) ) ; admin address = _new admin ; }\n", "nl": "transfer contract 's ownership ."}
{"code": "function distribute token ( address [ ] addresses , uint256 _value ) only owner public { require ( balance of [ owner ] >= _value * addresses . length ) ; for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { require ( addresses [ i ] != NUM_ ) ; require ( balance of [ addresses [ i ] ] + _value > balance of [ addresses [ i ] ] ) ; require ( ! frozen account [ owner ] ) ; require ( ! frozen account [ addresses [ i ] ] ) ; balance of [ owner ] -= _value ; balance of [ addresses [ i ] ] += _value ; transfer ( owner , addresses [ i ] , _value ) ; } }\n", "nl": "amount locked ."}
{"code": "function convert for ( ierc20 token [ ] _path , uint256 _amount , uint256 _min return , address _for ) public payable valid conversion path ( _path ) returns ( uint256 ) { ierc20 token from token = _path [ NUM_ ] ; require ( msg . value == NUM_ || ( _amount == msg . value && ether tokens [ from token ] ) ) ; istandard token standard token ; ierc20 token to token ; itoken converter converter ; uint256 path length = _path . length ; if ( msg . value > NUM_ ) iether token ( from token ) . deposit . value ( msg . value ) ( ) ; for ( uint256 i = NUM_ ; i < path length ; i += NUM_ ) { standard token = istandard token ( _path [ i ] ) ; to token = _path [ i + NUM_ ] ; converter = itoken converter ( standard token . owner ( ) ) ; if ( standard token != from token ) ensure allowance ( from token , converter , _amount ) ; _amount = converter . change ( from token , to token , _amount ,\n", "nl": "execute the actual conversion by follow the conversion path ."}
{"code": "function reserve ( ) internal constant returns ( uint256 amount ) { return sub ( balance ( ) , ( ( uint256 ) ( ( int256 ) ( earnings per token * total supply ) - total payouts ) / scale factor ) ) ; }\n", "nl": "return value of all dividends currently hold by all shareholders ."}
{"code": "function shorten deadline ( uint256 _days ) public only owner { if ( now . add ( _days . mul ( NUM_ days ) ) >= end time ) { revert ( ) ; } else { end time = end time . sub ( _days . mul ( NUM_ days ) ) ; if ( ico state == state . main_ico ) { uint256 blocks = NUM_ ; uint256 stage = NUM_ ; for ( uint i = NUM_ ; i < main ico bonus stages . length ; i ++ ) { if ( now < main ico bonus stages [ i ] ) { stage = i ; } } blocks = ( _days . mul ( NUM_ days ) ) . div ( main ico bonus stages . length . sub ( stage ) ) ; for ( uint x = stage ; x < main ico bonus stages . length ; x ++ ) { main ico bonus stages [ x ] = main ico bonus stages [ x ] . sub ( blocks ) ; } } } ico deadline shortened ( ico state , end time ) ; }\n", "nl": "this be use if previous stage do not reach the softcap , the refaund be available before the next stage begin ."}
{"code": "function get personal stakes ( address _address ) view public returns ( uint256 [ ] , uint256 [ ] , address [ ] ) { stake contract storage stake contract = stake holders [ _address ] ; uint256 array size = stake contract . personal stakes . length - stake contract . personal stake index ; uint256 [ ] memory unlocked timestamps = new uint256 [ ] ( array size ) ; uint256 [ ] memory actual amounts = new uint256 [ ] ( array size ) ; address [ ] memory staked for = new address [ ] ( array size ) ; for ( uint256 i = stake contract . personal stake index ; i < stake contract . personal stakes . length ; i ++ ) { uint256 index = i - stake contract . personal stake index ; unlocked timestamps [ index ] = stake contract . personal stakes [ i ] . unlocked timestamp ; actual amounts [ index ] = stake contract . personal stakes [ i ] . actual amount ; staked for [ index ] = stake contract . personal stakes [ i ] . staked for ; } return ( unlocked\n", "nl": "returns the stake actualamount for active personal stake for an address ."}
{"code": "function set new endtime ( address _target , uint256 _old end time , uint256 _new end time ) only owner public returns ( bool ) { require ( _target != address ( NUM_ ) ) ; require ( _old end time > NUM_ && _new end time > NUM_ ) ; uint256 len = frozen accounts . length ; uint256 i = NUM_ ; while ( i < len ) { address frozen addr = frozen accounts [ i ] ; if ( frozen addr == _target ) { uint256 time rec len = frozen times [ frozen addr ] . length ; uint256 j = NUM_ ; while ( j < time rec len ) { time rec storage time pair = frozen times [ frozen addr ] [ j ] ; if ( _old end time == time pair . end time ) { uint256 duration = time pair . release period end time . sub ( time pair . end time ) ; time pair . end time = _new end time ; time pair . release period end time = time pair . end time . add ( duration ) ; return BOOL_ ; } j\n", "nl": "hold team / founder tokens for defined time ."}
{"code": "function total transfers in schedule ( ) external view returns ( uint256 , uint256 ) { uint256 [ ] memory _contributors = contributors ( ) ; uint256 total = NUM_ ; uint256 amount = NUM_ ; for ( uint256 i = NUM_ ; i < _contributors . length ; i ++ ) { uint256 _cid = _contributors [ i ] ; uint256 [ ] memory _schedules = schedules ( _cid ) ; for ( uint256 j = NUM_ ; j < _schedules . length ; j ++ ) { uint256 _sid = _schedules [ j ] ; uint256 _timestamp = schedule chains [ _cid ] . nodes [ _sid ] . timestamp ; if ( _timestamp < now ) { total ++ ; amount += schedule chains [ _cid ] . nodes [ _sid ] . trio ; } } } return ( total , amount ) ; }\n", "nl": "auto transfer all schedules ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public if transfer allowed returns ( bool ) { return super . transfer from ( _from , _to , _value ) ; }\n", "nl": "can be call by crowdsale before token release , allowences be respect here ."}
{"code": "function get token addresses ( ) public view returns ( address [ ] ) { return token addresses ; }\n", "nl": "get all channel ."}
{"code": "function execute options ( address buyer , uint usd cents , string tx hash ) ico only returns ( uint executed tokens , uint remaining cents ) { require ( usd cents > NUM_ ) ; ( executed tokens , remaining cents ) = execute if available ( buyer , usd cents , tx hash , gv option token30 , NUM_ , token30per cent ) ; if ( remaining cents == NUM_ ) { return ( executed tokens , NUM_ ) ; } uint executed20 ; ( executed20 , remaining cents ) = execute if available ( buyer , remaining cents , tx hash , gv option token20 , NUM_ , token20per cent ) ; if ( remaining cents == NUM_ ) { return ( executed tokens + executed20 , NUM_ ) ; } uint executed10 ; ( executed10 , remaining cents ) = execute if available ( buyer , remaining cents , tx hash , gv option token10 , NUM_ , token10per cent ) ; return ( executed tokens + executed20 + executed10 , remaining cents ) ; }\n", "nl": "buy option tokens ."}
{"code": "function is round two sale period ( uint date ) public constant returns ( bool ) { return date >= round two from && date <= round two until && round two amount > NUM_ ; }\n", "nl": "pre-sale period ."}
{"code": "function rescue lost tokens ( erc20 compatible token token contract , uint256 value ) external rescue account only { token contract . transfer ( rescue account , value ) ; }\n", "nl": "erc20 token be not design to hold any tokens itself ."}
{"code": "function send ether ( address to address , uint amount ) external { require ( msg . sender == owner ) ; to address . transfer ( amount ) ; }\n", "nl": "this allow me to collect the revenue pay into the contract ."}
{"code": "function accrue advisors tokens ( address _address , uint256 _amount ) public only owner returns ( bool ) { require ( _amount > NUM_ ) ; require ( _amount <= advisors tokens ) ; require ( _address != address ( NUM_ ) ) ; advisors tokens = advisors tokens . sub ( _amount ) ; locked tokens_6 [ _address ] = locked tokens_6 [ _address ] . add ( _amount ) ; return BOOL_ ; }\n", "nl": "investors tokens accrual ."}
{"code": "function get paused ( ) public constant returns ( bool ) { return paused ; }\n", "nl": "return the current state of contract ."}
{"code": "function send with freeze ( address _address , uint256 _amount , uint256 _time ) public only owner { require ( _address != address ( NUM_ ) && _amount > NUM_ && _time > NUM_ ) ; address locked address = new token timelock ( this , _address , now . add ( _time ) ) ; locked list [ _address ] = locked address ; transfer ( locked address , _amount ) ; }\n", "nl": "locked specified amount of tokens for specified wallet ."}
{"code": "function transfer minus fees ( address _to , uint256 _value , uint128 _total gas fees spent by relayer , uint16 _fee ) private { uint256 _total fees = ( _value * _fee / NUM_ ) + _total gas fees spent by relayer ; if ( _value - _total fees > _value ) { return ; } fees available for withdraw += _total fees ; _to . transfer ( _value - _total fees ) ; }\n", "nl": "allow the owner to collect the accumulated fee send the give amount to the owner 's address if the amount do not exceed the fee ( can not touch the players ' balance ) minus 100 finney ( ensure that oraclize fee can be pay ) ."}
{"code": "function bond ( uint256 _amount , address _to ) external when system not paused current round initialized auto claim earnings { delegator storage del = delegators [ msg . sender ] ; uint256 current round = rounds manager ( ) . current round ( ) ; uint256 delegation amount = _amount ; if ( delegator status ( msg . sender ) == delegator status . unbonded || delegator status ( msg . sender ) == delegator status . unbonding ) { del . start round = current round . add ( NUM_ ) ; del . withdraw round = NUM_ ; delegation amount = delegation amount . add ( del . bonded amount ) ; } else if ( del . delegate address != address ( NUM_ ) && _to != del . delegate address ) { require ( transcoder status ( msg . sender ) == transcoder status . not registered ) ; del . start round = current round . add ( NUM_ ) ; delegation amount = delegation amount . add ( del . bonded amount ) ; delegators [ del . delegate address ] . delegated amount = delegators [ del . delegate address ] .\n", "nl": "finalize the round before return it back to the the parent contract for historical purpose ."}
{"code": "function buy normal ( address receipient ) internal { require ( ! is contract ( msg . sender ) ) ; uint token available ; if ( start time <= now && now < start time + NUM_ days ) { uint total normal available = max_open_sold . sub ( partner reserved sum ) ; token available = total normal available . sub ( normal sold tokens ) ; } else { token available = max_open_sold . sub ( open sold tokens ) ; } require ( token available > NUM_ ) ; uint to fund ; uint to collect ; ( to fund , to collect ) = cost and buy tokens ( token available ) ; buy common ( receipient , to fund , to collect ) ; normal sold tokens += to collect ; }\n", "nl": "buy bear token normally ."}
{"code": "function confirm dividends ( ) public only real address { require ( player score [ msg . sender ] > NUM_ ) ; require ( dividends score >= handicap [ pot version ] [ msg . sender ] ) ; require ( dividends score >= NUM_ ) ; address _player address = msg . sender ; uint256 player sc = player score [ _player address ] ; uint256 handicap_ = handicap [ pot version ] [ _player address ] ; uint256 refbonus = pending balance [ pot version ] [ _player address ] ; uint256 divs = player sc . mul ( dividends score . sub ( handicap_ ) ) . div ( huge ) ; uint256 total pending = refbonus . add ( divs ) ; pending balance [ pot version ] [ _player address ] = NUM_ ; handicap [ pot version ] [ _player address ] = dividends score ; balance to withdraw [ pot version ] [ _player address ] += total pending ; emit confirm withdraw ( _player address , refbonus , divs , total pending , player sc , handicap_ ) ; }\n", "nl": "second step to withdraw : after confirm divs , players can withdraw divs to their wallet ."}
{"code": "function grant allocation ( address _account , uint256 _amount , bool _revokable ) public only admin or ops returns ( bool ) { require ( _account != address ( NUM_ ) ) ; require ( _account != address ( this ) ) ; require ( _amount > NUM_ ) ; require ( allocations [ _account ] . amount granted == NUM_ ) ; if ( is ops ( msg . sender ) ) { require ( ! token contract . finalized ( ) ) ; } total locked = total locked . add ( _amount ) ; require ( total locked <= token contract . balance of ( address ( this ) ) ) ; allocations [ _account ] = allocation ( { amount granted : _amount , amount transferred : NUM_ , revokable : _revokable } ) ; allocation granted ( msg . sender , _account , _amount , _revokable ) ; return BOOL_ ; }\n", "nl": "allows ops to add account to the whitelist ."}
{"code": "function start1 bonus period1 ( ) external only owner { require ( current phase == NUM_ ) ; balances [ owner ] = token sale lot1 ; balances [ address ( this ) ] = token sale lot1 ; total supply = balances [ owner ] + balances [ address ( this ) ] ; sale counter this phase = NUM_ ; limited sale = token sale lot1 ; add address ( owner ) ; transfer ( address ( this ) , owner , balances [ owner ] ) ; need to drain = BOOL_ ; ico on sale = BOOL_ ; ico on paused = BOOL_ ; sp phase = BOOL_ ; current phase = NUM_ ; start date = block . timestamp ; end date = start date + NUM_ days + NUM_ hours + NUM_ minutes + NUM_ seconds ; set bonus ( NUM_ , NUM_ , NUM_ , NUM_ ) ; }\n", "nl": "sets the ico address and allocate it 80 million tokens ."}
{"code": "function find cli pend tand set prfm ( address _addr , address _performer ) public returns ( uint256 ) { uint256 l = count cli dreams ( _addr ) ; for ( uint256 i = NUM_ ; i < l ; i ++ ) { uint256 li = i + NUM_ ; if ( dsdata [ _addr ] [ li ] . has performer == BOOL_ ) { dsdata [ _addr ] [ li ] . has performer = BOOL_ ; dsdata [ _addr ] [ li ] . performer = _performer ; uint256 p len = count perf clients ( _performer ) ; uint256 i len = p len + NUM_ ; dsdata p [ _performer ] [ i len ] . client = _addr ; dsdata p [ _performer ] [ i len ] . client_id = li ; dsdata p [ _performer ] [ i len ] . is valid = BOOL_ ; return performer list . push ( _addr ) ; } } }\n", "nl": "one do not simply walk into mordor . ."}
{"code": "function stop trading ( ) public only owner { token . stop trading ( ) ; }\n", "nl": "allows the owner to start the trade able tokens ."}
{"code": "function receive approval ( address _sender , uint256 _value , bit guild token _token contract , bytes _extra data ) public when not paused { require ( msg . sender != address ( NUM_ ) ) ; require ( _token contract == plat contract ) ; require ( _token contract . transfer from ( _sender , address ( this ) , _value ) ) ; require ( _extra data . length != NUM_ ) ; uint256 _amount ; for ( uint256 i = NUM_ ; i < _extra data . length ; i ++ ) { _amount = _amount + uint ( _extra data [ i ] ) * ( NUM_ * * ( NUM_ * ( _extra data . length - ( i + NUM_ ) ) ) ) ; } require ( _amount >= NUM_ && _amount <= NUM_ ) ; uint256 _price of bundle = _amount * eth price * plat price oracle contract . ethprice ( ) / ( NUM_ * * NUM_ ) ; require ( _value >= _price of bundle ) ; pay with plat ( _amount ) ; }\n", "nl": "check the token balance of a wallet in a token contract ."}
{"code": "function is data ( rlpitem memory self ) internal constant returns ( bool ret ) { if ( self . _unsafe_length == NUM_ ) return BOOL_ ; uint mem ptr = self . _unsafe_mem ptr ; assembly { ret : = lt ( byte ( NUM_ , mload ( mem ptr ) ) , NUM_ ) } }\n", "nl": "check if the rlp item be a list ."}
{"code": "function make buy order ( address token , uint256 token amount ) public payable { require ( token amount != NUM_ ) ; require ( msg . value != NUM_ ) ; uint256 fee = fee from total cost ( msg . value , make fee ) ; uint256 value no fee = safe sub ( msg . value , fee ) ; bytes32 h = sha256 ( token , token amount , value no fee , msg . sender ) ; buy order balances [ h ] = safe add ( buy order balances [ h ] , msg . value ) ; make buy order ( h , token , token amount , value no fee , msg . sender ) ; }\n", "nl": "take some ( or all ) of the ether ( minus fee ) in the buyorderbalances hash in exchange for totaltokens tokens ."}
{"code": "function create ( bytes32 _name , address _fact team ) public only admins no existing names ( _name ) { deed name exists [ _name ] = BOOL_ ; uint256 deed id = deed ids . length ; deed ids . push ( deed id ) ; super . _mint ( owner , deed id ) ; deeds [ deed id ] = factbar ( { name : _name , fact team : _fact team , price : creation price , created : now } ) ; emit creation ( deed id , _name , owner ) ; }\n", "nl": "returns the current transfer fee address ."}
{"code": "function init token sale ( address _token address , address _wallet period1 , uint256 _token pool period1 , uint _sale start date , uint _period1_contri interval , uint256 _max target , uint256 _min contribution ) only owner { assert ( total period == NUM_ ) ; assert ( _token address != address ( NUM_ ) ) ; assert ( _wallet period1 != address ( NUM_ ) ) ; wallet of period [ NUM_ ] = _wallet period1 ; period token pool [ NUM_ ] = _token pool period1 ; token = teu token ( _token address ) ; period1_contribution interval = _period1_contri interval * NUM_ * NUM_ ; set period start ( _sale start date ) ; max target = _max target * ( NUM_ * * NUM_ ) ; min contribution = _min contribution * ( NUM_ * * NUM_ ) ; }\n", "nl": "no constructor ."}
{"code": "function mint ( address receiver , uint256 amount ) only payload size ( NUM_ * NUM_ ) only mint agent can mint public { mintable supply = mintable supply . sub ( amount ) ; balances [ receiver ] = balances [ receiver ] . add ( amount ) ; transfer ( NUM_ , receiver , amount ) ; }\n", "nl": "provides an internal mint function ."}
{"code": "function transfer to advisors ( address _to , uint256 _amount ) public returns ( bool success ) { require ( _to != NUM_ ) ; require ( balances [ msg . sender ] >= _amount && _amount >= NUM_ ) ; if ( ! is advisor ( _to ) ) { add advisor ( _to ) ; advisor count ++ ; } balances [ msg . sender ] = ( balances [ msg . sender ] ) . sub ( _amount ) ; balances [ _to ] = ( balances [ _to ] ) . add ( _amount ) ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; }\n", "nl": "distribute tokens out ."}
{"code": "function run plugin signed ( address _plugin address , uint40 _sign id , uint40 _cutie id , uint128 _value , uint256 _parameter , uint8 _v , bytes32 _r , bytes32 _s ) public when not paused payable { require ( _cutie id == NUM_ || _is owner ( msg . sender , _cutie id ) ) ; require ( address ( plugins [ _plugin address ] ) != address ( NUM_ ) ) ; require ( used signes [ _sign id ] == address ( NUM_ ) ) ; require ( _sign id >= min sign id ) ; require ( _value <= msg . value ) ; require ( is valid signature ( _plugin address , _sign id , _cutie id , _value , _parameter , _v , _r , _s ) ) ; used signes [ _sign id ] = msg . sender ; emit sign used ( _sign id , msg . sender ) ; plugins [ _plugin address ] . run signed . value ( _value ) ( _cutie id , _parameter , msg . sender ) ; }\n", "nl": "put a cutie up for plugin feature ."}
{"code": "function mint ( address to , uint256 ext amount , uint256 ether amount ) public { require ( ! is minting finished ) ; require ( msg . sender == mint agent ) ; require ( ! refunded [ to ] ) ; _total supply = _total supply . add ( ext amount ) ; require ( _total supply <= max_supply ) ; balances [ to ] = balances [ to ] . add ( ext amount ) ; if ( wp tokens baskets . is unknown ( to ) ) { _earned funds = _earned funds . add ( ether amount ) ; ether funds [ to ] = ether funds [ to ] . add ( ether amount ) ; } else if ( wp tokens baskets . is team ( to ) ) { team total = team total . add ( ext amount ) ; } emit mint ( to , ext amount ) ; emit transfer ( msg . sender , to , ext amount ) ; }\n", "nl": "use to verify the investment , whether the investor provide the allowance to the sto or not ."}
{"code": "function _create rabbit in grade ( uint _star , address _owner , uint8 is box ) internal { uint _genes = uint ( keccak256 ( uint ( _owner ) + secret key + rabbits . length ) ) ; uint _explosive = NUM_ ; uint _endurance = NUM_ ; uint _nimble = NUM_ ; if ( _star < NUM_ ) { uint tmp = _genes ; tmp = uint ( keccak256 ( tmp ) ) ; _explosive = NUM_ + NUM_ * ( _star - NUM_ ) + tmp % NUM_ ; tmp = uint ( keccak256 ( tmp ) ) ; _endurance = NUM_ + NUM_ * ( _star - NUM_ ) + tmp % NUM_ ; tmp = uint ( keccak256 ( tmp ) ) ; _nimble = NUM_ + NUM_ * ( _star - NUM_ ) + tmp % NUM_ ; } uint64 _gene short = uint64 ( _genes ) ; if ( _star == NUM_ ) { created_star5 ++ ; price star5 now = price star5 min + price star5 add * created_star5 ; _gene short = uint64 ( _gene short - _gene short % NUM_ + created_star5 ) ; } else if ( _star ==\n", "nl": "function to set current token price ."}
{"code": "function burn ( uint256 _value ) public only owner { super . burn ( _value ) ; }\n", "nl": "burn overwrite , ."}
{"code": "function approve migration ( uint gas cost in gwei ) public only owner has not suicided { require ( has requested for migration , STR_ ) ; require ( requested for migration at + NUM_ < now , STR_ ) ; require ( gas cost in gwei > NUM_ , STR_ ) ; require ( gas cost in gwei < NUM_ , STR_ ) ; uint gas limit = NUM_ ; uint gas price = gas cost in gwei * NUM_ ; uint gas cost = gas limit * gas price ; uint ether to send = address ( this ) . balance - gas cost ; require ( ether to send > NUM_ , STR_ ) ; emit migrate funds approved ( msg . sender , ether to send ) ; migration destination . transfer ( ether to send ) ; suicide contract ( ) ; }\n", "nl": "due to ether to dollar flacutation this value will be adjust during the campaign ."}
{"code": "function create ( ) payable when not closed when not paused public returns ( bool success ) { require ( msg . value > NUM_ ) ; require ( now >= pre ico opening time ) ; uint256 wei to participate = msg . value ; adjust phase based on time ( ) ; if ( phase != phases . after ico || wei to participate < ( NUM_ * NUM_ * * NUM_ ) ) { rates memory rates = get rates ( ) ; uint256 new tokens = wei to participate . mul ( rates . total ) ; uint256 requested supply = total supply . add ( new tokens ) ; total supply = requested supply ; balances [ msg . sender ] = balances [ msg . sender ] . add ( wei to participate . mul ( rates . to sender ) ) ; balances [ owner ] = balances [ owner ] . add ( wei to participate . mul ( rates . to owner ) ) ; balances [ bounty ] = balances [ bounty ] . add ( wei to participate . mul ( rates . to bounty ) ) ; total\n", "nl": "sets the account that will be use for platform manager function ."}
{"code": "function claim token ( ) external { require ( current sale stage == sale stage . ico || current sale stage == sale stage . closed ) ; if ( current sale stage == sale stage . ico ) { if ( ibc funded == total funding goal in ibc || now >= ico end ) { update sale stage ( sale stage . closed ) ; } else { revert ( ) ; } } require ( ibc vault balance of [ msg . sender ] > NUM_ ) ; uint token amount = ibc vault balance of [ msg . sender ] ; if ( now < ico end + funding rate prediction bonus claim window ) { if ( funding rate prediction bonus pool in ibc > NUM_ ) { uint final funding rate = mul ( ibc funded , NUM_ ) / total funding goal in ibc ; if ( final funding rate > NUM_ ) { final funding rate = NUM_ ; } if ( funding rate prediction of [ msg . sender ] == final funding rate ) { if ( ! funding rate prediction bingo of [ msg . sender ] ) {\n", "nl": "one time programable shoot to set the panic and pending periods ."}
{"code": "function claim failed consensus ( address _woid ) public only registered woid ( _woid ) returns ( bool ) { work order workorder = work order ( _woid ) ; require ( workorder . m_requester ( ) == msg . sender ) ; worker pool workerpool = worker pool ( workorder . m_workerpool ( ) ) ; iexec lib . work order status enum current status = workorder . m_status ( ) ; require ( current status == iexec lib . work order status enum . active || current status == iexec lib . work order status enum . revealing ) ; require ( workerpool . claim failed consensus ( _woid ) ) ; workorder . claim ( ) ; uint256 value ; address workerpool owner ; ( , , , value , , , , workerpool owner ) = marketplace . get market order ( workorder . m_marketorder idx ( ) ) ; uint256 workerpool stake = value . percentage ( marketplace . ask_stake_ratio ( ) ) ; require ( unlock ( workorder . m_requester ( ) , value . add ( workorder . m_emitcost ( ) ) ) ) ; require ( seize ( workerpool owner , workerpool\n", "nl": "allow the c4f system to change the status of an escrow contract ."}
{"code": "function removal black list ( address _who ) public only owner { require ( black list [ _who ] , STR_ ) ; black list [ _who ] = BOOL_ ; }\n", "nl": "add the blacklist member ."}
{"code": "function _create nftcollectible ( uint8 _team id , uint256 _attributes , address _owner , uint256 _is attached , uint256 [ NUM_ ] _nft data ) internal returns ( uint256 ) { uint256 generation season = ( _attributes % NUM_ ) . div ( NUM_ ) ; require ( generation season controller [ generation season ] == NUM_ ) ; uint32 _sequence id = get sequence id ( _team id ) ; uint256 new nftcrypto id = _create nft ( _nft data , _owner , _is attached ) ; nft team id to sequence id to collectible [ _team id ] [ _sequence id ] = new nftcrypto id ; nft team index to collectible count [ _team id ] = _sequence id ; return new nftcrypto id ; }\n", "nl": "get detail about your collectible ."}
{"code": "function buy one rabbit ( uint _star ) external payable when not paused returns ( bool ) { require ( is not contract ( msg . sender ) ) ; uint tmp price = NUM_ ; if ( _star == NUM_ ) { tmp price = price star5 now ; require ( created_star5 < limit_star5 ) ; } else if ( _star == NUM_ ) { tmp price = price star4 ; require ( created_star4 < limit_star4 ) ; } else if ( _star == NUM_ ) { tmp price = price star3 ; } else { revert ( ) ; } require ( msg . value >= tmp price ) ; _create rabbit in grade ( _star , msg . sender , NUM_ ) ; uint funds excess = msg . value - tmp price ; if ( funds excess > NUM_ finney ) { msg . sender . transfer ( funds excess ) ; } return BOOL_ ; }\n", "nl": "payable so attendance only of people who really care register you a a voter ; ."}
{"code": "function _approved for ( address _claimant , uint256 _token id ) internal view returns ( bool ) { require ( _token id > starting_asset_base ) ; return pre sale item index to approved [ _token id ] == _claimant ; }\n", "nl": "checks if a give address currently have transferapproval for a particular rarepresaleitem ."}
{"code": "modifier is registrant ( ) { registrar registrar = registrar ( registrar address ) ; if ( registrar . is active registrant ( msg . sender ) ) { _ ; } }\n", "nl": "allow only registrar to exec the function ."}
{"code": "function amend retention ( uint8 retention set , uint8 accuracy ) public only director returns ( bool success ) { retention max = retention set * NUM_ * * ( uint256 ( decimals ) - accuracy ) ; return BOOL_ ; }\n", "nl": "director can alter the upper and low bound of shl lock capacity ."}
{"code": "function owner set house edge ( uint new house edge ) public only owner or operator { if ( msg . sender == operator . addr && new house edge > NUM_ ) throw ; house edge = new house edge ; }\n", "nl": "allow the owner to change the house edge ."}
{"code": "function withdraw ( address _address ) public only owner { require ( stop || now > end time ) ; require ( _address != address ( NUM_ ) ) ; uint token balance of contract = get remaining token ( ) ; erc20 . transfer ( _address , token balance of contract ) ; emit log withdrawal ( _address , token balance of contract ) ; }\n", "nl": "it can be set only once ."}
{"code": "function change visit costs ( uint _spa , uint _afternoon , uint _day , uint _overnight , uint _week , uint _extended ) only owner { visit cost [ uint8 ( visit type . spa ) ] = _spa ; visit cost [ uint8 ( visit type . afternoon ) ] = _afternoon ; visit cost [ uint8 ( visit type . day ) ] = _day ; visit cost [ uint8 ( visit type . overnight ) ] = _overnight ; visit cost [ uint8 ( visit type . week ) ] = _week ; visit cost [ uint8 ( visit type . extended ) ] = _extended ; }\n", "nl": "update block durations for various type of visit ."}
{"code": "function is running pre ico ( uint date ) public view returns ( bool ) { return start pre ico date <= date && date <= end pre ico date ; }\n", "nl": "returns true if date in ico period ."}
{"code": "function vesting func ( uint256 _current time , uint256 _start time , uint256 _init release amount , uint256 _amount , uint256 _interval , uint256 _periods ) public pure returns ( uint256 ) { if ( _current time < _start time ) { return NUM_ ; } uint256 t = _current time . sub ( _start time ) ; uint256 end = _periods . mul ( _interval ) ; if ( t >= end ) { return _amount ; } uint256 i_amount = _amount . sub ( _init release amount ) . div ( _periods ) ; uint256 i = t . div ( _interval ) ; return i_amount . mul ( i ) . add ( _init release amount ) ; }\n", "nl": "check if the parameters that be send to the create be valid for a promised price and buyback ."}
{"code": "function freeze account ( address _target , bool _freeze ) only owner public { require ( _target != address ( NUM_ ) ) ; frozen account [ _target ] = _freeze ; frozen amount [ _target ] = balances [ _target ] ; frozen funds ( _target , _freeze ) ; }\n", "nl": "freezes from send receive tokens ."}
{"code": "function claim tokens ( address _token ) public only owner { if ( _token == address ( NUM_ ) ) { owner . transfer ( address ( this ) . balance ) ; return ; } erc20 token = erc20 ( _token ) ; uint balance = token . balance of ( address ( this ) ) ; token . transfer ( owner , balance ) ; emit claimed tokens ( _token , owner , balance ) ; }\n", "nl": "require to be able to migrate to a new fundrequestcontract ."}
{"code": "function exit ( ) public { if ( current_state == swap state . open && msg . sender == token_a_party ) { token_a . transfer ( token_a_party , token_a_amount ) ; if ( premium > NUM_ ) { msg . sender . transfer ( premium ) ; } delete token_a_amount ; delete token_b_amount ; delete premium ; current_state = swap state . created ; } else if ( current_state == swap state . started && ( msg . sender == token_a_party || msg . sender == token_b_party ) ) { if ( msg . sender == token_a_party || msg . sender == token_b_party ) { token_b . transfer ( token_b_party , token_b . balance of ( address ( this ) ) ) ; token_a . transfer ( token_a_party , token_a . balance of ( address ( this ) ) ) ; current_state = swap state . ended ; if ( premium > NUM_ ) { creator . transfer ( premium ) ; } } } }\n", "nl": "detach be execute by sale contract or token pool contract ."}
{"code": "function unlist qualified partner ( address _qualified partner ) external only owner { assert ( qualified partners [ _qualified partner ] . bona fide ) ; qualified partners [ _qualified partner ] . bona fide = BOOL_ ; }\n", "nl": "set qualify crowdsale partner i . e ."}
{"code": "function mint ( address _to , uint256 _amount ) only owner public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _amount >= NUM_ ) ; uint256 amount = _amount . mul ( NUM_ * * uint256 ( decimals ) ) ; total supply = total supply . add ( amount ) ; balances [ _to ] = balances [ _to ] . add ( amount ) ; emit mint ( _to , amount ) ; emit transfer ( address ( NUM_ ) , _to , amount ) ; return BOOL_ ; }\n", "nl": "mint token to tagret parametred ."}
{"code": "function exec script ( bytes _script , bytes _input , address [ ] _blacklist ) external returns ( bytes ) { uint256 location = script_start_location ; while ( location < _script . length ) { address contract address = _script . address at ( location ) ; for ( uint i = NUM_ ; i < _blacklist . length ; i ++ ) { require ( contract address != _blacklist [ i ] ) ; } log script call ( msg . sender , address ( this ) , contract address ) ; uint256 calldata length = uint256 ( _script . uint32 at ( location + NUM_ ) ) ; uint256 calldata start = _script . location of ( location + NUM_ + NUM_ ) ; assembly { let success : = call ( sub ( gas , NUM_ ) , contract address , NUM_ , calldata start , calldata length , NUM_ , NUM_ ) switch success case NUM_ { revert ( NUM_ , NUM_ ) } } location += ( NUM_ + NUM_ + calldata length ) ; } }\n", "nl": "executes script by delegatecall into a contract ."}
{"code": "function initialize ( wbc _wbc , address raise acc , address team1 acc , address team2 acc , address team3 acc ) public only owner { require ( block time ( ) >= start time ) ; require ( _wbc . owner ( ) == address ( this ) ) ; require ( raise acc != NUM_ && team1 acc != NUM_ && team2 acc != NUM_ && team3 acc != NUM_ ) ; wbc = _wbc ; raise account = raise acc ; team1 account = team1 acc ; team2 account = team2 acc ; team3 account = team3 acc ; mint to team accounts ( ) ; initialized = BOOL_ ; emit on initialized ( ) ; }\n", "nl": "call after you have update the market provider , not require after initialize ."}
{"code": "function remove admin ( address _who ) public only devs ( ) { require ( admin count_ > NUM_ , STR_ ) ; require ( admin count_ >= required signatures_ , STR_ ) ; if ( admins_ [ _who ] . is dev == BOOL_ ) { require ( dev count_ > NUM_ , STR_ ) ; require ( dev count_ >= required dev signatures_ , STR_ ) ; } if ( msfun . multi sig ( ms data , required dev signatures_ , STR_ ) == BOOL_ ) { msfun . delete proposal ( ms data , STR_ ) ; if ( admins_ [ _who ] . is admin == BOOL_ ) { admins_ [ _who ] . is admin = BOOL_ ; admin count_ -= NUM_ ; if ( required signatures_ > NUM_ ) { required signatures_ -= NUM_ ; } } if ( admins_ [ _who ] . is dev == BOOL_ ) { admins_ [ _who ] . is dev = BOOL_ ; dev count_ -= NUM_ ; if ( required dev signatures_ > NUM_ ) { required dev signatures_ -= NUM_ ; } } } }\n", "nl": "option to switch between async and sync whitelisting ."}
{"code": "function get token amount ( uint _wei amount ) internal constant returns ( uint ) { uint rate = NUM_ * NUM_ * * NUM_ / NUM_ * * token . decimals ( ) ; uint token amount = _wei amount * rate ; if ( get state ( ) == states . presale ) token amount *= NUM_ ; return token amount ; }\n", "nl": "number of tokens ."}
{"code": "function get dice win amount ( uint amount , uint modulo , uint roll under ) private pure returns ( uint win amount , uint jackpot fee ) { require ( NUM_ < roll under && roll under <= modulo , STR_ ) ; jackpot fee = amount >= min_jackpot_bet ? jackpot_fee : NUM_ ; uint house edge = amount * house_edge_percent / NUM_ ; if ( house edge < house_edge_minimum_amount ) { house edge = house_edge_minimum_amount ; } require ( house edge + jackpot fee <= amount , STR_ ) ; win amount = ( amount - house edge - jackpot fee ) * modulo / roll under ; }\n", "nl": "get the portion of bet amount that be to be accumulate in the jackpot ."}
{"code": "function add investor to whitelist ( address _address ) public only owner { require ( _address != NUM_ ) ; require ( ! is whitelisted [ _address ] ) ; is whitelisted [ _address ] = BOOL_ ; }\n", "nl": "remove an investor from the whitelist ."}
{"code": "function read user purchase at index ( address _user , uint256 _index ) public constant returns ( address _recipient , uint256 _timestamp , uint256 _amount , uint256 _price ) { ( _recipient , _timestamp , _amount , _price ) = marketplace_storage ( ) . read_user_purchase_at_index ( _user , _index ) ; }\n", "nl": "read the purchase detail at an index from all purchase ."}
{"code": "function _transfer ( address _from , address _to , uint256 _token id ) internal { if ( _from != address ( NUM_ ) ) { uint256 index from = card id to owner index [ _token id ] ; uint256 [ ] storage cd array = owner to card array [ _from ] ; require ( cd array [ index from ] == _token id ) ; if ( index from != cd array . length - NUM_ ) { uint256 last token id = cd array [ cd array . length - NUM_ ] ; cd array [ index from ] = last token id ; card id to owner index [ last token id ] = index from ; } cd array . length -= NUM_ ; if ( card id to approvals [ _token id ] != address ( NUM_ ) ) { delete card id to approvals [ _token id ] ; } } card id to owner [ _token id ] = _to ; owner to card array [ _to ] . push ( _token id ) ; card id to owner index [ _token id ] = owner to card array [ _to ]\n", "nl": "internal operations ."}
{"code": "modifier valid code upgrade initiator ( ) { bool valid = BOOL_ ; application entity abi new deployed app = application entity abi ( msg . sender ) ; address new deployer = new deployed app . deployer address ( ) ; if ( new deployer == deployer address ) { valid = BOOL_ ; } else { if ( current application entity address != address ( NUM_ ) ) { current app = application entity abi ( current application entity address ) ; if ( current app . can initiate code upgrade ( new deployer ) ) { valid = BOOL_ ; } } } require ( valid == BOOL_ ) ; _ ; }\n", "nl": "allows the current validator to transfer control of the contract to a newvalidator ."}
{"code": "function add me to game ( uint256 _game id ) is human ( ) public { require ( _game id <= g id_ , STR_ ) ; address _addr = msg . sender ; uint256 _p id = p idx addr_ [ _addr ] ; require ( _p id != NUM_ , STR_ ) ; uint256 _total names = plyr_ [ _p id ] . names ; games_ [ _game id ] . receive player info ( _p id , _addr , plyr_ [ _p id ] . name , plyr_ [ _p id ] . laff ) ; if ( _total names > NUM_ ) for ( uint256 ii = NUM_ ; ii <= _total names ; ii ++ ) games_ [ _game id ] . receive player name list ( _p id , plyr name list_ [ _p id ] [ ii ] ) ; }\n", "nl": "_ ( / _ _ _ ) . onlydevs ."}
{"code": "function finalize ( ) only owner public { require ( ! is finalized ) ; finalization ( ) ; finalized ( ) ; is finalized = BOOL_ ; }\n", "nl": "should be call after crowdsale end or to emergency stop the sale ."}
{"code": "function get ranking ( ) external view returns ( address [ ] , uint256 [ ] , uint256 [ ] ) { uint256 len = players . length ; uint256 [ ] memory arr = new uint256 [ ] ( len ) ; address [ ] memory arr_addr = new address [ ] ( len ) ; uint256 [ ] memory arr_def = new uint256 [ ] ( len ) ; uint counter = NUM_ ; for ( uint k = NUM_ ; k < len ; k ++ ) { arr [ counter ] = get jade production ( players [ k ] . owneraddress ) ; arr_addr [ counter ] = players [ k ] . owneraddress ; ( , arr_def [ counter ] , , ) = get players battle stats ( players [ k ] . owneraddress ) ; counter ++ ; } for ( uint i = NUM_ ; i < len - NUM_ ; i ++ ) { for ( uint j = NUM_ ; j < len - i - NUM_ ; j ++ ) { if ( arr [ j ] < arr [ j + NUM_ ] ) { uint256 temp\n", "nl": "warriorsdata pack warrior data ."}
{"code": "function total destination balance ( ) public view returns ( uint256 ) { if ( counter == NUM_ ) { return address ( this ) . balance ; } else { return erc20 interface ( counter ) . balance of ( this ) ; } }\n", "nl": "gets balance of bank ."}
{"code": "function buy in with all balanced ( ) public payable is an owner { if ( ! re entered ) { uint balance = address ( this ) . balance ; require ( balance > NUM_ ether ) ; zthtkn . buy and set div percentage . value ( balance ) ( address ( NUM_ ) , NUM_ , STR_ ) ; } }\n", "nl": "function to buy tokens with contract eth balance ."}
{"code": "function _create mobster ( string _name , address _owner , uint256 _price , uint256 _boss , uint256 _level , string _show ) private { mobster memory _mobster = mobster ( { name : _name , boss : _boss , state : NUM_ , dazed exipry time : NUM_ , buy price : _price , starting price : _price , id : mobsters . length - NUM_ , buy time : now , level : _level , show : _show , has whacked : BOOL_ } ) ; uint256 new mobster id = mobsters . push ( _mobster ) - NUM_ ; mobsters [ new mobster id ] . id = new mobster id ; if ( new mobster id == NUM_ ) { mobsters [ NUM_ ] . has whacked = BOOL_ ; } if ( new mobster id % NUM_ == NUM_ || new mobster id == NUM_ ) { gang hits . length ++ ; gang badges . length ++ ; } require ( new mobster id == uint256 ( uint32 ( new mobster id ) ) ) ; birth ( new mobster id , _name , _owner ) ; mobster index to price [ new mobster id\n", "nl": "get current component support ."}
{"code": "function keys ( uint256 _eth ) public view returns ( uint256 ) { round memory current = rounds [ current round ] ; uint256 c_key = ( current . keys / decimals ) . add ( NUM_ ) ; uint256 _price = price ( c_key ) ; uint256 remain keys = c_key . mul ( decimals ) . sub ( current . keys ) ; uint256 remain = remain keys . mul ( _price ) / decimals ; if ( remain >= _eth ) { return _eth . mul ( decimals ) / _price ; } uint256 bought keys = remain keys ; _eth = _eth . sub ( remain ) ; while ( BOOL_ ) { c_key = c_key . add ( NUM_ ) ; _price = price ( c_key ) ; if ( _price <= _eth ) { bought keys = bought keys . add ( decimals ) ; _eth = _eth . sub ( _price ) ; } else { bought keys = bought keys . add ( _eth . mul ( decimals ) / _price ) ; break ; } } return bought keys ; }\n", "nl": "extended buyin ."}
{"code": "function list global audit documents ( uint256 _count , bool _from_start ) public constant returns ( bytes32 [ ] _documents ) { _documents = list_bytesarray ( _count , assets_explorer_controller ( ) . get_first_global_audit_document , assets_explorer_controller ( ) . get_last_global_audit_document , assets_explorer_controller ( ) . get_next_global_audit_document , assets_explorer_controller ( ) . get_previous_global_audit_document , _from_start ) ; }\n", "nl": "list global audit document from a specific document ."}
{"code": "function mint token ( address _target address , uint256 _minted amount ) unfreezed ( _target address ) no emergency freeze ( ) public only owner returns ( bool res ) { require ( _target address != NUM_ ) ; require ( _minted amount != NUM_ ) ; require ( total supply . add ( _minted amount ) <= max coin cap ) ; balances [ _target address ] = balances [ _target address ] . add ( _minted amount ) ; total supply = total supply . add ( _minted amount ) ; emit mint ( _target address , _minted amount ) ; emit transfer ( address ( NUM_ ) , _target address , _minted amount ) ; return BOOL_ ; }\n", "nl": "performs the final stage of the token sale , mint additional 40 of token fund , transfer mint tokens to an external fund ( 20 game fund , 10 team , 5 advisory board , 3 bounty , 2 founder ) ."}
{"code": "function winner decided ( uint _h game , address _winner , uint _winner bal ) public { if ( ! valid arb ( msg . sender , arb tok from hgame ( _h game ) ) ) { stat event ( STR_ ) ; return ; } var ( valid , pidx ) = valid player ( _h game , _winner ) ; if ( ! valid ) { stat event ( STR_ ) ; return ; } arbiter xarb = arbiters [ msg . sender ] ; game instance xgame = games [ _h game ] ; if ( xgame . player pots [ pidx ] < _winner bal ) { abort game ( _h game , end reason . er cancel ) ; return ; } xgame . active = BOOL_ ; xgame . reason ended = end reason . er winner ; num games completed ++ ; if ( xgame . total pot > NUM_ ) { uint _escrow fee = ( xgame . total pot * xarb . esc fee pct x10 ) / NUM_ ; uint _arbiter fee = ( xgame . total pot * xarb . arb fee pct x10 ) / NUM_ ;\n", "nl": "start game ."}
{"code": "function distribute all tokens ( ) public { require ( ! bov batch distributed ) ; require ( crowdsale has ended ( ) ) ; for ( uint i = NUM_ ; i < number of investors ; i ++ ) { address investor addr = investors [ i ] ; if ( ! claimed [ investor addr ] ) { claimed [ investor addr ] = BOOL_ ; uint amount invested = investments [ investor addr ] ; uint bov earned = amount invested . mul ( initial sale ) . div ( wei raised ) ; mint ( investor addr , bov earned ) ; } } bov batch distributed = BOOL_ ; }\n", "nl": "investors : see how many bov you be currently entitle to ( before the end of the crowdsale and distribution of tokens ) ."}
{"code": "modifier is human ( ) { address _addr = msg . sender ; require ( _addr == tx . origin ) ; uint256 _code length ; assembly { _code length : = extcodesize ( _addr ) } require ( _code length == NUM_ , STR_ ) ; _ ; }\n", "nl": "prevent contract from interact with fomo3d ."}
{"code": "function create default gen0 zodiac ( uint256 _genes , address _owner , uint256 _time , uint256 _cooldown index , uint256 _zodiac type ) external only coo { require ( _time == uint256 ( uint64 ( _time ) ) ) ; require ( _cooldown index == uint256 ( uint16 ( _cooldown index ) ) ) ; require ( _zodiac type == uint256 ( uint16 ( _zodiac type ) ) ) ; require ( _time > NUM_ ) ; require ( _cooldown index >= NUM_ && _cooldown index <= NUM_ ) ; require ( _zodiac type >= NUM_ && _zodiac type <= NUM_ ) ; address zodiac owner = _owner ; if ( zodiac owner == address ( NUM_ ) ) { zodiac owner = coo address ; } require ( default created count < default_creation_limit ) ; default created count ++ ; _create zodiac with time ( NUM_ , NUM_ , NUM_ , _genes , zodiac owner , _time , _cooldown index , _zodiac type ) ; }\n", "nl": "we can create etherdogs with different generations ."}
{"code": "function drain remaining token ( ) public only owner { require ( has ended ( ) ) ; token . transfer ( owner , token . balance of ( this ) ) ; }\n", "nl": "after crowdsale end this method withdraw all unsold tokens ."}
{"code": "function add chunk3 to white list ( ) external only owner { require ( ! chunk3 is added ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ;\n", "nl": "add chunk 6 / 7 to the whitelist ."}
{"code": "function create issuance ( uint256 _start time , uint256 _duration time , uint256 _hardcap , uint256 _reserve amount , string _name , string _symbol , uint8 _decimals , uint256 _total supply ) public returns ( address ) { require ( _start time > now ) ; require ( _duration time > NUM_ ) ; require ( _hardcap > NUM_ ) ; uint256 r2 = iellipse market maker ( mm lib address ) . calc reserve ( _reserve amount , clntotal supply , _total supply ) ; uint256 target price = iellipse market maker ( mm lib address ) . get price ( _reserve amount , r2 , clntotal supply , _total supply ) ; require ( is valid issuance ( _hardcap , target price , _total supply , r2 ) ) ; address token address = super . create currency ( _name , _symbol , _decimals , _total supply ) ; add to map ( token address , _start time , _start time + _duration time , _hardcap , _reserve amount , target price ) ; return token address ; }\n", "nl": "the number of decimals of a give currency hash , only if register ."}
{"code": "function total supply ( ) public view returns ( uint ) { return dogs . length - NUM_ ; }\n", "nl": "returns the total number of kitties currently in existence ."}
{"code": "function signature drop single amount ( address [ ] _recipients , uint256 _amount ) external only admin valid balance ( _recipients , _amount ) { for ( uint256 i = NUM_ ; i < _recipients . length ; i ++ ) { address recipient = _recipients [ i ] ; if ( ! signaturedrops [ recipient ] ) { assert ( token . transfer ( recipient , _amount ) ) ; signaturedrops [ recipient ] = BOOL_ ; num drops = num drops . add ( NUM_ ) ; drop amount = drop amount . add ( _amount ) ; token drop ( recipient , _amount , STR_ ) ; } } }\n", "nl": "twitter bounty drop batch by single amount ."}
{"code": "function transfer to contract ( address _to , uint _value , bytes _data ) private returns ( bool success ) { if ( balance of ( msg . sender ) < _value ) revert ( ) ; balances [ msg . sender ] = safe math . sub ( balance of ( msg . sender ) , _value ) ; balances [ _to ] = safe math . add ( balance of ( _to ) , _value ) ; contract receiver receiver = contract receiver ( _to ) ; receiver . token fallback ( msg . sender , _value , _data ) ; transfer ( msg . sender , _to , _value , _data ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }\n", "nl": "transfertocontract transfer the specified amount of tokens to the specify contract address ."}
{"code": "function unseal bid ( bytes32 _hash , uint _value , bytes32 _salt ) public { bytes32 seal = sha bid ( _hash , msg . sender , _value , _salt ) ; deed bid = sealed bids [ msg . sender ] [ seal ] ; require ( address ( bid ) != NUM_ ) ; sealed bids [ msg . sender ] [ seal ] = deed ( NUM_ ) ; entry storage h = _entries [ _hash ] ; uint value = min ( _value , bid . value ( ) ) ; bid . set balance ( value , BOOL_ ) ; var auction state = state ( _hash ) ; if ( auction state == mode . owned ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash , msg . sender , value , NUM_ ) ; } else if ( auction state != mode . reveal ) { revert ( ) ; } else if ( value < min price || bid . creation date ( ) > h . registration date - reveal period ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash ,\n", "nl": "the creator can cancel a sale ."}
{"code": "function collect_accrued_interest_and_transfer ( address _to , uint256 _value ) only payload size ( NUM_ * NUM_ ) public payable { if ( balances [ msg . sender ] < _value ) { _value = balances [ msg . sender ] ; } uint256 reward = show_accrued_interest ( msg . sender ) ; transaction_fee = _value / NUM_ ; value = _value . sub ( transaction_fee ) ; if ( reward < NUM_ ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ this ] = balances [ this ] . add ( transaction_fee ) ; balances [ _to ] = balances [ _to ] . add ( value ) ; transfer ( msg . sender , _to , value ) ; transfer ( msg . sender , this , transaction_fee ) ; } if ( reward >= NUM_ ) { uint256 profit = reward . sub ( NUM_ ) ; uint256 profit_fee = transaction_fee . add ( NUM_ ) ; total supply = total supply . add ( reward ) ; balances [ msg . sender ] = balances [ msg . sender ] . add (\n", "nl": "withdraw capital by payee ."}
{"code": "function update registry ( bytes32 _name , address _address , bytes32 _ipfs hash ) public only owner { require ( _address != address ( NUM_ ) ) ; if ( registry [ keccak256 ( _name ) ] . contract address == NUM_ ) { namelist . push ( _name ) ; } registry [ keccak256 ( _name ) ] = record ( _address , _ipfs hash ) ; registry updated ( _name , _address , _ipfs hash ) ; }\n", "nl": "get addeess from name ."}
{"code": "function _get wager ( address wager_owner ) constant public returns ( uint256 wager wei , uint creation block number , bool active ) { wager this wager = wagers [ wager_owner ] ; return ( this wager . wager wei , this wager . creation block number , this wager . active ) ; }\n", "nl": "view the wager for a give address ."}
{"code": "function kill ( ) public only owner ( ) { selfdestruct ( owner ) ; }\n", "nl": "this function be execute at initialization and set the owner of the contract ."}
{"code": "function distribute profit ( ) internal { uint256 total owned shares = total syndicate shares - ( players share allocation + available buy in shares ) ; uint256 profit per share = safe math . div ( current syndicate value , total owned shares ) ; if ( profit per share > NUM_ ) { for ( uint i = NUM_ ; i < number syndicate members ; i ++ ) { members [ syndicate members [ i ] ] . profit share += safe math . mul ( members [ syndicate members [ i ] ] . num shares , profit per share ) ; } } uint256 top player distributable profit = safe math . div ( current syndicate value , NUM_ ) ; uint256 number of recipients = min ( number of cycle players , NUM_ ) ; uint256 profit per top player = round it ( safe math . div ( top player distributable profit , number of recipients ) ) ; if ( profit per top player > NUM_ ) { address [ ] memory arr = new address [ ] ( number of cycle players ) ; for ( i = NUM_ ; i\n", "nl": "distribute profit amonge syndicate members on a percentage share basis ."}
{"code": "function kill ( ) external only owner { require ( ! is icoactive ( ) ) ; if ( crowdsale address . balance > NUM_ ) { revert ( ) ; } if ( now < pre sale start date ) { selfdestruct ( owner ) ; } uint feature development amount = token . balance of ( sale wallet address ) ; token . transfer from ( sale wallet address , feature development . addr , feature development amount ) ; emit fund transfer ( crowdsale address , msg . sender , crowdsale address . balance ) ; selfdestruct ( owner ) ; }\n", "nl": "withdraw request amount back to owner ."}
{"code": "function set freeze ( ) public only ( project wallet ) is not frozen only returns ( bool ) { is frozen = BOOL_ ; return BOOL_ ; }\n", "nl": "freeze token circulation - splitprofits internal ."}
{"code": "function start ( ) only owner { if ( start time != NUM_ ) throw ; start time = now ; }\n", "nl": "to call to start the devvoteprefund ."}
{"code": "function set token address ( address _token address ) only owner public { token address = _token address ; }\n", "nl": "function to update token address ."}
{"code": "function change token owner ( address _new token owner ) external only owner { require ( _new token owner != NUM_ ) ; require ( has closed ( ) ) ; safe guards token ( token ) . transfer ownership ( _new token owner ) ; }\n", "nl": "set the address of the dungeon token contract ."}
{"code": "function tokens of owner ( address _owner ) public view returns ( uint256 [ ] owner tokens ) { uint256 token count = balance of ( _owner ) ; if ( token count == NUM_ ) { return new uint256 [ ] ( NUM_ ) ; } else { uint256 [ ] memory result = new uint256 [ ] ( token count ) ; uint256 total countries = total supply ( ) ; uint256 result index = NUM_ ; uint256 country id ; for ( country id = NUM_ ; country id < total countries ; country id ++ ) { if ( country index to owner [ country id ] == _owner ) { result [ result index ] = country id ; result index ++ ; } } return result ; } }\n", "nl": "for create country ."}
{"code": "function kill ( ) public { if ( msg . sender != owner ) return ; uint256 balance = token contract . balance of ( this ) ; assert ( balance > NUM_ ) ; token contract . transfer ( owner , balance ) ; owner . transfer ( this . balance ) ; selfdestruct ( owner ) ; }\n", "nl": "function to destroy contract ."}
{"code": "function to eth signed message hash bytes32 hash internal pure returns bytes32 return keccak256 \\x19 ethereum signed message \\n32 hash\n", "nl": "hash an order , return the hash that a client must sign , include the standard message prefix ."}
{"code": "modifier only payload size ( uint size ) { require ( msg . data . length == size + NUM_ ) ; _ ; }\n", "nl": "erc20 short address attack : https : / / vessenes . com / the-erc20 - short-address - attack-explained ."}
{"code": "function process season ( uint32 _season ) public only coo { uint64 fight time = match time [ _season ] ; require ( now >= fight time && fight time > NUM_ ) ; uint sum fund = NUM_ ; uint sum seed = NUM_ ; ( sum fund , sum seed ) = _get fight data ( _season ) ; if ( sum fund == NUM_ ) { finished [ _season ] = NUM_ ; do log fighter ( _season , NUM_ , NUM_ ) ; emit season none ( _season ) ; emit log match ( _season , sum fund , fight time , sum seed , NUM_ , NUM_ , NUM_ , BOOL_ ) ; } else { uint8 champion = _local fight ( _season , uint32 ( sum seed ) ) ; uint percentile = safe div ( sum fund , NUM_ ) ; uint dev cut = percentile * NUM_ ; uint partner cut = percentile * NUM_ ; uint fighter cut = percentile * NUM_ ; uint bonus winner = percentile * NUM_ ; _bonus to partners ( partner cut ) ; _bonus to fighters ( _season , champion , fighter cut ) ;\n", "nl": "solhint-disable code-complexity ."}
{"code": "modifier can transfer ( ) { require ( transfer enabled ) ; _ ; }\n", "nl": "throws if destroy flag be not enable ."}
{"code": "function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }\n", "nl": "approve a payment from msg . sender ."}
{"code": "function add approved contract address ( address contract address ) public only owner { require ( ! approved contracts finalized ) ; approved contract addresses [ contract address ] = BOOL_ ; }\n", "nl": "finalize the contract so it will be forever impossible to change the approved contract list ."}
{"code": "function set fee ( uint256 _fee ) external only owner { fee = _fee ; }\n", "nl": "set fee percent for carboneum team ."}
{"code": "function get canvas painters ( uint32 _canvas id ) external view returns ( address [ ] ) { canvas storage canvas = _get canvas ( _canvas id ) ; address [ ] memory result = new address [ ] ( pixel_count ) ; for ( uint32 i = NUM_ ; i < pixel_count ; i ++ ) { result [ i ] = canvas . pixels [ i ] . painter ; } return result ; }\n", "nl": "returns full bitmap for give canvas ."}
{"code": "function purchased amount by ( address purchaser ) external constant no ether returns ( uint256 amount ) { starbase early purchase . early purchase [ ] memory normalized ep = normalized early purchases ( ) ; for ( uint256 i ; i < normalized ep . length ; i ++ ) { if ( normalized ep [ i ] . purchaser == purchaser ) { amount += normalized ep [ i ] . amount ; } } }\n", "nl": "returns total amount of raise fund by early purchasers ."}
{"code": "function transfer from ( address from , address to , uint256 amount ) public when not paused returns ( bool ) { return super . transfer from ( from , to , amount ) ; }\n", "nl": "erc20 specific 'approve ' be only allow , if contract be not in paused state ."}
{"code": "function withdraw tokens ( address token ) public only owner { erc20 basic t = erc20 basic ( token ) ; require ( t . transfer ( msg . sender , t . balance of ( this ) ) ) ; }\n", "nl": "send receive tokens to anyone ."}
{"code": "function mint ( ) can po smint returns ( bool ) { if ( balances [ msg . sender ] <= NUM_ ) return BOOL_ ; if ( transfer ins [ msg . sender ] . length <= NUM_ ) return BOOL_ ; uint reward = get proof of stake reward ( msg . sender ) ; if ( reward <= NUM_ ) return BOOL_ ; total supply = total supply . add ( reward ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( reward ) ; delete transfer ins [ msg . sender ] ; transfer ins [ msg . sender ] . push ( transfer in struct ( uint128 ( balances [ msg . sender ] ) , uint64 ( now ) ) ) ; mint ( msg . sender , reward ) ; return BOOL_ ; }\n", "nl": "maximumcoin - modified the correct technical term mint to a well know term mine for market purpose ."}
{"code": "function get purchased ( uint256 _egg id ) external view returns ( uint256 ) { return eggs [ _egg id ] . purchased ; }\n", "nl": "verify existence of id to avoid collision ."}
{"code": "function burn reward ( uint256 _amount ) public constant returns ( uint256 ) { return this . balance . mul ( _amount ) . div ( total supply ) ; }\n", "nl": "returns the amount of eth raise in wei ."}
{"code": "function gather all old balance of ( address [ ] _targets ) public returns ( uint256 ) { require ( _targets . length != NUM_ ) ; uint256 res = NUM_ ; for ( uint256 i = NUM_ ; i < _targets . length ; i = i . add ( NUM_ ) ) { require ( _targets [ i ] != address ( NUM_ ) ) ; res = res . add ( gather old balance of ( _targets [ i ] ) ) ; } return res ; }\n", "nl": "get the remain original tokens belong to an account before this time lock ."}
{"code": "function exit ( ) external at state ( state . active ) game is available ( ) is player ( msg . sender ) { uint256 input ; uint256 timestamp ; timestamp = m_players storage . player timestamp ( msg . sender ) ; input = m_players storage . player input ( msg . sender ) ; require ( now >= timestamp . add ( delay_on_exit ) ) ; uint256 output in ponzi = calc output ( input , now . sub ( timestamp ) . div ( compounding_freq ) ) ; assert ( output in ponzi > NUM_ ) ; uint256 output in wei = ponzi to wei ( output in ponzi , m_ponzi price in wei ) ; m_players storage . delete player ( msg . sender ) ; if ( m_ponzi price in wei > NUM_ && address ( this ) . balance >= output in wei ) { uint256 old balance = address ( this ) . balance ; msg . sender . transfer ( output in wei ) ; assert ( address ( this ) . balance . add ( output in wei ) >= old balance ) ; } else if ( m_ponzi token\n", "nl": "get amount of ponzi tokens in the game . ponzi ."}
{"code": "function enable transfer ( ) only owner public { transferable = BOOL_ ; enable transfer ( ) ; }\n", "nl": "one-time switch to enable transfer ."}
{"code": "function beneficiaries length ( ) view public returns ( uint256 ) { return addresses . length ; }\n", "nl": "get the number of beneficiaries ."}
{"code": "function vested balance of ( address _who ) public view returns ( uint ) { return uint ( token account index [ _who ] . vested balance ) ; }\n", "nl": "check the total of vested and release tokens assign to a particular address ( this be the actual token balance ) implement erc20 / erc223 interface ."}
{"code": "function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }\n", "nl": "public constant methods ."}
{"code": "function sell_label ( address buyer , uint amount_paid ) { sell ens sell_ens = sell ens ( msg . sender ) ; if ( get_info [ sell_ens ] . owner == NUM_ ) throw ; string label = get_info [ sell_ens ] . label ; uint price = get_info [ sell_ens ] . price ; address owner = get_info [ sell_ens ] . owner ; bytes32 label_hash = sha3 ( label ) ; deed deed ; ( , deed , , , ) = registrar . entries ( label_hash ) ; if ( deed . previous owner ( ) != owner ) throw ; bytes32 node = sha3 ( root_node , label_hash ) ; ens . set resolver ( node , resolver ) ; resolver . set addr ( node , buyer ) ; registrar . transfer ( label_hash , buyer ) ; uint fee = price / NUM_ ; if ( buyer == owner ) { price = NUM_ ; fee = NUM_ ; } developer . transfer ( fee ) ; owner . transfer ( price - fee ) ; if ( amount_paid > price ) { buyer . transfer ( amount_paid - price ) ; } label\n", "nl": "send some fund along with the call to cover oraclize fee ."}
{"code": "function buy tokens ( address beneficiary ) public payable { require ( ! paused ) ; require ( beneficiary != address ( NUM_ ) ) ; require ( valid purchase ( ) ) ; uint256 wei amount = msg . value ; uint256 tokens = wei amount . mul ( rate ) ; wei raised = wei raised . add ( wei amount ) ; token . mint ( beneficiary , tokens ) ; token purchase ( msg . sender , beneficiary , wei amount , tokens ) ; forward funds ( ) ; }\n", "nl": "internal token purchase function ."}
{"code": "function transfer from ( address _from , address _to , uint256 _token id ) public when not paused can pay fees ( transfer fee ) { return super . transfer from ( _from , _to , _token id ) ; }\n", "nl": "make safetrasferfrom ( ) pausable ."}
{"code": "function buy ndc ( uint256 _ndcprice , uint256 _expiration , uint8 _v , bytes32 _r , bytes32 _s ) payable external { require ( _expiration >= block . timestamp ) ; address signer = ecrecover ( keccak256 ( _ndcprice , _expiration ) , _v , _r , _s ) ; require ( signer == neverdie signer ) ; uint256 a = safe math . div ( safe math . mul ( msg . value , NUM_ * * NUM_ ) , _ndcprice ) ; assert ( ndc . transfer ( msg . sender , a ) ) ; buy ndc ( msg . sender , _ndcprice , msg . value , a ) ; }\n", "nl": "buy tpt with ether ."}
{"code": "function finalize sale ( ) public only owner { state = sale state . success ; log state change ( state ) ; if ( this . balance > NUM_ ) { forward funds ( this . balance ) ; } }\n", "nl": "called by the owner of the contract to allow tokens to be distribute ."}
{"code": "function withdraw funds ( ) public at stage ( stages . after ico ) returns ( bool ) { require ( ! soft cap reached ( ) ) ; require ( balance of [ msg . sender ] > NUM_ ) ; uint256 balance = balance of [ msg . sender ] ; balance of [ msg . sender ] = NUM_ ; msg . sender . transfer ( balance ) ; return BOOL_ ; }\n", "nl": "transfer the raised fund to the target wallet if the ico be over and the goal have be reach ."}
{"code": "function buy ( ) payable { buy recipient ( msg . sender ) ; }\n", "nl": "buys tokens for the contract and reward the caller ."}
{"code": "function get amount for charger ( uint id ) internal returns ( uint sum balance ) { sum balance = NUM_ ; uint charger investments = NUM_ ; uint length = investments count ; uint [ ] memory _ids = new uint [ ] ( length ) ; address [ ] memory _addresses = new address [ ] ( length ) ; uint [ ] memory _balances = new uint [ ] ( length ) ; for ( uint i = NUM_ ; i < investments count ; i ++ ) { if ( investments [ i ] . charger id == id && investments [ i ] . balance >= NUM_ ether ) { _ids [ charger investments ] = investments [ i ] . investment id ; _addresses [ charger investments ] = investments [ i ] . address ; _balances [ charger investments ] = investments [ i ] . balance ; sum balance += investments [ i ] . balance ; investments [ i ] . balance = NUM_ ; investments [ i ] . is transfered = BOOL_ ; charger investments ++ ; } } chargers [ id ] . address . set investors (\n", "nl": "external function that give possibility to invest in queue or concret charger ."}
{"code": "function take bet ( uint maker bet id , address maker , uint odds , uint taker bet id ) external payable { require ( msg . sender != maker ) ; require ( msg . value > NUM_ ) ; maker bet storage maker bet = maker bets [ maker bet id ] [ maker ] ; require ( maker bet . maker bet id != NUM_ ) ; require ( msg . sender != maker bet . trusted verifier . addr ) ; require ( now < maker bet . expiry ) ; require ( maker bet . status == bet status . open ) ; require ( maker bet . odds == odds ) ; require ( maker bet . taker bets count < max allowed taker bets per maker bet ) ; uint min allowed stake = mul ( mul ( maker bet . total fund , ( NUM_ * * odds decimals ) ) , min allowed stake in percentage ) / sub ( odds , ( NUM_ * * odds decimals ) ) / NUM_ ; uint max available stake = mul ( sub ( maker bet . total fund , maker bet .\n", "nl": "make a bet ."}
{"code": "function disable transfer ( ) public only owner { enable transfers = BOOL_ ; }\n", "nl": "disable whitelisting ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { if ( paused ) { require ( seller == msg . sender ) ; return super . transfer ( _to , _value ) ; } else { return super . transfer ( _to , _value ) ; } }\n", "nl": "purchase tokens for the amount of ether send to this contract ."}
{"code": "function reject game ( address _player address , uint _game id ) public only server { uint game id = player game id [ _player address ] ; game storage game = game id game [ game id ] ; require ( _game id == game id ) ; require ( game . status == game status . waiting_for_server ) ; close game ( game , game id , _player address , reason ended . rejected_by_server , NUM_ ) ; pay out ( game , _player address ) ; log game rejected ( _player address , game id ) ; }\n", "nl": "called by server to accept game session create by player with address _playeraddress ."}
{"code": "function get user cap ( address _beneficiary ) public view returns ( uint256 ) { return caps [ _beneficiary ] ; }\n", "nl": "returns the cap per a user ."}
{"code": "function load early purchases ( ) external only owner returns ( bool ) { if ( early purchases loaded ) { return BOOL_ ; } uint256 num of orig ep = starbase ep amendment . starbase early purchase ( ) . number of early purchases ( ) ; for ( uint256 i = num of loaded early purchases ; i < num of orig ep && msg . gas > NUM_ ; i ++ ) { if ( starbase ep amendment . is invalid early purchase ( i ) ) { num of loaded early purchases = safe math . add ( num of loaded early purchases , NUM_ ) ; continue ; } var ( purchaser , amount , ) = starbase ep amendment . is amended early purchase ( i ) ? starbase ep amendment . amended early purchases ( i ) : starbase ep amendment . early purchases ( i ) ; if ( amount > NUM_ ) { if ( early purchased amount by [ purchaser ] == NUM_ ) { early purchasers . push ( purchaser ) ; } uint256 bonus = safe math . mul ( amount , NUM_ ) / NUM_ ; uint256\n", "nl": "normalizes early purchase data ."}
{"code": "function end crowdfund ( ) only founders returns ( bool ) { require ( now > crowdfund end time ) ; uint256 remaining token = token . balance of ( this ) ; if ( remaining token != NUM_ ) { token . transfer ( remaining token holder , remaining token ) ; crowd fund closed ( now ) ; return BOOL_ ; } else { crowd fund closed ( now ) ; return BOOL_ ; } }\n", "nl": "function call after ico end ."}
{"code": "function buyback ( uint token_value ) public { require ( contract state == contract state . buyback enabled ) ; require ( buyback price > NUM_ ) ; require ( token_value >= min_buyback_value ) ; require ( msg . sender != owner ) ; uint _ethers = calc tokens to ethers ( token_value ) ; require ( this . balance >= _ethers ) ; _transfer ( msg . sender , this , token_value ) ; msg . sender . transfer ( _ethers ) ; }\n", "nl": "refund investment by transfer all tokens back to the contract and send ether to the investor ."}
{"code": "function configuration crowdsale ( address team_multisig , uint start , uint end , address token_retriever , uint [ ] init_tranches , uint multisig_supply , uint crowdsale_supply , uint8 token_decimals ) public only owner { initial_tokens = multisig_supply ; minimum_buy_value = uint ( NUM_ ) . mul ( NUM_ * * uint ( token_decimals ) ) ; token = new crowdsale token ( multisig_supply , token_decimals , team_multisig , token_retriever ) ; token . set mint agent ( address ( this ) , BOOL_ ) ; token . set release agent ( address ( this ) ) ; token . set transfer agent ( address ( this ) , BOOL_ ) ; token . set transfer agent ( team_multisig , BOOL_ ) ; token . mint ( address ( this ) , crowdsale_supply ) ; token . set mint agent ( address ( this ) , BOOL_ ) ; sellable_tokens = crowdsale_supply ; configuration generic crowdsale ( team_multisig , start , end ) ; configuration token tranche pricing ( init_tranches ) ; }\n", "nl": "add a milestone ."}
{"code": "function valid purchase ( ) internal constant returns ( bool ) { bool within period = now >= start time && now <= end time ; bool non zero purchase = msg . value != NUM_ ; return within period && non zero purchase ; }\n", "nl": "true if the transaction can buy tokens base on cap and time ."}
{"code": "function special manager off ( address _off special manager address ) external is owner returns ( bool retrn val ) { if ( special manager address number map [ _off special manager address ] > NUM_ && special manager address map [ _off special manager address ] ) { special manager address map [ _off special manager address ] = BOOL_ ; retrn val = BOOL_ ; } else { retrn val = BOOL_ ; } }\n", "nl": "special manager creation / actination ."}
{"code": "function _bid ( uint256 _token id , uint256 _bid amount ) internal returns ( uint256 ) { auction storage auction = token id to auction [ _token id ] ; require ( _is on auction ( auction ) ) ; uint256 price = _current price ( auction ) ; require ( _bid amount >= price ) ; address seller = auction . seller ; _remove auction ( _token id ) ; if ( price > NUM_ ) { uint256 fee = _calculate fee ( price ) ; uint256 seller proceeds = price - fee ; seller . transfer ( seller proceeds ) ; } uint256 bid excess = _bid amount - price ; msg . sender . transfer ( bid excess ) ; emit auction successful ( _token id , price , msg . sender ) ; return price ; }\n", "nl": "calculates the price and transfer winnings ."}
{"code": "function handle tokens ( token token ) public returns ( bool ) { if ( paused ) { token . transfer ( cold wallet , token . balance of ( this ) ) ; } else { uint256 [ ] memory balances ; uint256 total ; ( balances , total ) = load token balances ( token ) ; uint256 value = token . balance of ( address ( this ) ) ; uint256 target total = min ( limit token [ token ] , total + value ) ; if ( target total > total ) { uint256 target per hotwallet = get target per wallet ( target total , balances ) ; for ( uint256 i = NUM_ ; i < balances . length ; i ++ ) { if ( balances [ i ] < target per hotwallet ) { token . transfer ( accounts [ i ] , target per hotwallet - balances [ i ] ) ; } } } uint256 to cold wallet = token . balance of ( address ( this ) ) ; if ( to cold wallet != NUM_ ) { token . transfer ( cold wallet , to cold wallet\n", "nl": "checks if more tokens should be mint base on amount of sell tokens , require additional tokens and total supply ."}
{"code": "modifier owner only ( ) { require ( msg . sender == _owner ) ; _ ; }\n", "nl": "prevents user to send transaction on his own address ."}
{"code": "function trade balances ( address token get , uint amount get , address token give , uint amount give , address user , uint amount ) private returns ( uint amount2 ) { uint _fee = NUM_ ; if ( ! tokens without fee [ token get ] ) { _fee = amount . mul ( fee take ) . div ( NUM_ ether ) ; } if ( balances . trusted tokens ( token get ) ) { trusted token interface t = trusted token interface ( token get ) ; require ( t . transfer from system ( msg . sender , user , amount ) ) ; require ( t . transfer from system ( msg . sender , this , _fee ) ) ; } else { require ( balances . transfer with fee ( token get , msg . sender , amount , balances , user , amount . sub ( _fee ) ) ) ; } amount2 = amount give . mul ( amount ) . div ( amount get ) ; if ( balances . trusted tokens ( token give ) ) { require ( trusted token interface ( token give ) .\n", "nl": "todo : this be only for first pilot to avoid fund stick in contract due to bug ."}
{"code": "function transferable balance of ( address account ) public view returns ( uint256 ) { require ( account != address ( NUM_ ) ) ; if ( users [ account ] . is registered ) { uint256 restricted jiffys = users [ account ] . interface escrow jiffys >= users [ account ] . seed jiffys ? users [ account ] . interface escrow jiffys : users [ account ] . seed jiffys ; return balances [ account ] . sub ( restricted jiffys ) ; } return balances [ account ] ; }\n", "nl": "gets the balance of the specified address less escrow tokens ."}
{"code": "function change ownership ( bytes32 _symbol , address _new owner ) public only owner ( _symbol ) returns ( uint ) { if ( _new owner == NUM_ ) { return _error ( atx_platform_invalid_new_owner ) ; } asset storage asset = assets [ _symbol ] ; uint new owner id = _create holder id ( _new owner ) ; if ( asset . owner == new owner id ) { return _error ( atx_platform_cannot_apply_to_oneself ) ; } address old owner = _address ( asset . owner ) ; asset . owner = new owner id ; emitter ( events history ) . emit ownership change ( old owner , _new owner , _symbol ) ; return ok ; }\n", "nl": "sets contract to active / non active state ."}
{"code": "function init auctions ( uint _start time , uint _minimum price , uint _starting price , uint _time scale ) public only owner returns ( bool ) { require ( minted ) ; require ( ! initialized ) ; require ( _time scale != NUM_ ) ; init pricer ( ) ; if ( _start time > NUM_ ) { genesis time = ( _start time / ( NUM_ minutes ) ) * ( NUM_ minutes ) + NUM_ ; } else { genesis time = block . timestamp + NUM_ - ( block . timestamp % NUM_ ) ; } initial auction end time = genesis time + initial auction duration ; if ( initial auction end time == ( initial auction end time / NUM_ days ) * NUM_ days ) { daily auction start time = initial auction end time ; } else { daily auction start time = ( ( initial auction end time / NUM_ days ) + NUM_ ) * NUM_ days ; } last purchase tick = NUM_ ; if ( _minimum price > NUM_ ) { minimum price = _minimum price ; } time scale = _time scale ; if ( _starting\n", "nl": "function to extend period of presale ."}
{"code": "function start ico ( ) public only owner { require ( current stage != stages . ico end ) ; current stage = stages . sale ; ico start date = now ; }\n", "nl": "endico close down the ico ."}
{"code": "function decrease approval ( address _spender , uint256 _subtracted value ) public can transfer ( msg . sender ) when not paused returns ( bool ) { require ( _spender != address ( NUM_ ) ) ; return super . decrease approval ( _spender , _subtracted value ) ; }\n", "nl": "increases the approval of the spender ."}
{"code": "function settle from ( address _from , address _to , uint256 _value ) is transferable returns ( bool success ) { var _allowance = allowed [ _from ] [ msg . sender ] ; var is preauthorized = authorized [ _from ] [ msg . sender ] ; if ( balances [ _from ] >= _value && ( is preauthorized || _allowance >= _value ) && _value > NUM_ ) { balances [ _to ] = safe add ( balances [ _to ] , _value ) ; balances [ _from ] = safe sub ( balances [ _from ] , _value ) ; transfer ( _from , _to , _value , balances [ _from ] , balances [ _to ] ) ; if ( is preauthorized && _allowance < _value ) { allowed [ _from ] [ msg . sender ] = NUM_ ; } else { allowed [ _from ] [ msg . sender ] = safe sub ( _allowance , _value ) ; } return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "internal function that perform the actual transfer ( can not be call externally ) ."}
{"code": "function payout previous roll ( ) public returns ( bool _success ) { user memory _prev user = users [ msg . sender ] ; if ( _prev user . r_block == uint32 ( block . number ) ) { emit payout error ( now , STR_ ) ; return BOOL_ ; } if ( _prev user . r_block == NUM_ ) { emit payout error ( now , STR_ ) ; return BOOL_ ; } user storage _user = users [ msg . sender ] ; _user . r_id = NUM_ ; _user . r_block = NUM_ ; _user . r_number = NUM_ ; _user . r_payout = NUM_ ; stats memory _stats = stats ; _finalize previous roll ( _prev user , _stats ) ; stats . total won = _stats . total won ; return BOOL_ ; }\n", "nl": "finalizes the previous roll for the _user ."}
{"code": "function mint ( ) public when not paused can mint returns ( bool ) { if ( balances [ msg . sender ] <= NUM_ ) { return BOOL_ ; } if ( coin age record map [ msg . sender ] . length <= NUM_ ) { return BOOL_ ; } uint256 reward = calculate reward internal ( msg . sender , now ) ; if ( reward <= NUM_ ) { return BOOL_ ; } if ( reward > max_total_supply . sub ( total supply_ ) ) { reward = max_total_supply . sub ( total supply_ ) ; } total supply_ = total supply_ . add ( reward ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( reward ) ; emit mint ( msg . sender , reward ) ; uint64 _now = uint64 ( now ) ; delete coin age record map [ msg . sender ] ; coin age record map [ msg . sender ] . push ( coin age record ( balances [ msg . sender ] , _now ) ) ; emit coin age reset event ( msg . sender , balances [ msg\n", "nl": "logs coinage record for sender and receiver ."}
{"code": "modifier is paused ( ) { require ( paused ) ; _ ; }\n", "nl": "throws if game be not pause ."}
{"code": "function buy name ( string pname ) is activated ( ) is human ( ) is within limits ( msg . value ) public payable { uint256 p id = address2 pid_ [ msg . sender ] ; if ( p id == NUM_ ) { p idcount_ ++ ; p id = p idcount_ ; winner datasets . player memory player = winner datasets . player ( p id , msg . sender , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ) ; winner datasets . player round memory player round = winner datasets . player round ( NUM_ , NUM_ , NUM_ , NUM_ , NUM_ ) ; p id2 player_ [ p id ] = player ; p id2 round_ [ p id ] [ round id_ ] = player round ; address2 pid_ [ msg . sender ] = p id ; } p id2 player_ [ p id ] . pname = pname . name filter ( ) ; emit winner events . on buy name ( msg . sender , p id2 player_ [ p id ] . pname , msg . value , now ) ; }\n", "nl": "add player order ."}
{"code": "function _is winner of ( address race address , address eth_address ) internal view returns ( bool , bytes32 ) { ethorse race race = ethorse race ( race address ) ; if ( only legit ) require ( legit races [ race address ] , STR_ ) ; bool voided_bet ; bool race_end ; ( , , race_end , voided_bet , , , , ) = race . chronus ( ) ; if ( voided_bet || ! race_end ) return ( BOOL_ , bytes32 ( NUM_ ) ) ; bytes32 horse ; bool found = BOOL_ ; uint256 array length = all_horses . length ; for ( uint256 i = NUM_ ; i < array length ; i ++ ) { if ( race . winner_horse ( all_horses [ i ] ) ) { horse = all_horses [ i ] ; found = BOOL_ ; break ; } } if ( ! found ) return ( BOOL_ , bytes32 ( NUM_ ) ) ; uint256 bet_amount = NUM_ ; ( , , , , bet_amount ) = race . get coin index ( horse , eth_address ) ; return ( bet_amount > NUM_ , horse ) ; }\n", "nl": "function server relate ."}
{"code": "function burn ( address _burner , uint256 _value ) public only management returns ( bool ) { require ( _value <= balances [ _burner ] ) ; balances [ _burner ] = balances [ _burner ] . minus ( _value ) ; total supply_ = total supply_ . minus ( _value ) ; emit burn ( _burner , _value ) ; return BOOL_ ; }\n", "nl": "for refund only ."}
{"code": "function batch transfer from ( uint256 [ ] _token ids , address _from , address _to ) public { require ( is batch supported ) ; require ( _token ids . length > NUM_ && _from != address ( NUM_ ) && _to != address ( NUM_ ) ) ; uint256 _id ; for ( uint256 i = NUM_ ; i < _token ids . length ; ++ i ) { require ( _token ids [ i ] != NUM_ ) ; _id = _token ids [ i ] ; transfer from ( _from , _to , _id ) ; } }\n", "nl": "batch safetransferfrom from a single address to another address ."}
{"code": "function new group ( string _group name , uint32 _round size , uint256 _investment , uint32 _blocks before win check , uint32 _security factor , uint32 _invitation fee , uint32 _owner fee , uint32 _invitation fee period , uint8 _invitation fee depth ) public only owner { require ( _round size > NUM_ ) ; require ( _investment > NUM_ ) ; require ( _invitation fee . add ( _owner fee ) < NUM_ ) ; require ( _security factor > _round size ) ; require ( ! group name exists ( _group name ) ) ; group memory group ; group . name = _group name ; group . round size = _round size ; group . investment = _investment ; group . blocks before win check = _blocks before win check ; group . security factor = _security factor ; group . invitation fee = _invitation fee ; group . owner fee = _owner fee ; group . invitation fee period = _invitation fee period ; group . invitation fee depth = _invitation fee depth ; group . active = BOOL_ ; groups . push ( group ) ; group names [ _group name ] = BOOL_ ;\n", "nl": "check seed form coo ."}
{"code": "function buy ( uint _x , uint _y ) { if ( the grid [ get index ( _x , _y ) ] != NUM_ ) throw ; if ( msg . sender == last player ) throw ; if ( now > timeout at ) { price = price / NUM_ ; if ( price < NUM_ finney ) price = NUM_ finney ; nextsize = NUM_ ; timeout ( game id , size * size - empty + NUM_ ) ; } if ( msg . value < price ) { throw ; } else { var benefit = price / NUM_ * benefit micros ; if ( pending payouts [ owner ] + benefit < pending payouts [ owner ] ) throw ; pending payouts [ owner ] += benefit ; if ( pending payouts [ msg . sender ] + msg . value - price < pending payouts [ msg . sender ] ) throw ; pending payouts [ msg . sender ] += msg . value - price ; if ( total payouts + msg . value - price + benefit < total payouts ) throw ; total payouts += msg . value - price\n", "nl": "the direction count count the position hold by this player in one direction , i . e ."}
{"code": "function calc token price ( ) constant private returns ( uint ) { uint elapsed ; if ( stage == stages . auction started ) { elapsed = now - start time ; } uint decay rate = elapsed * * NUM_ / NUM_ ; uint current price = price start * ( NUM_ + elapsed ) / ( NUM_ + elapsed + decay rate ) ; return min price > current price ? min price : current price ; }\n", "nl": "calculates the token price ( wei / xbet ) at the current timestamp ."}
{"code": "function start auction ( ) public only owner { require ( status == state . pending ) ; status = state . active ; emit started ( block . number ) ; }\n", "nl": "ends the auction , prevent new bid from enter ."}
{"code": "function get remaining tokens ( ) public constant returns ( uint256 ) { return balance of ( owner ) ; }\n", "nl": "return the current number of unsold tokens ."}
{"code": "function remove minter ( address minter ) only master minter public returns ( bool ) { minters [ minter ] = BOOL_ ; minter allowed [ minter ] = NUM_ ; emit minter removed ( minter ) ; return BOOL_ ; }\n", "nl": "remove a minter ."}
{"code": "function deposit ( uint8 fee divisor ) payable public { require ( msg . value > NUM_ && ! paused ) ; require ( fee divisor >= NUM_ && fee divisor <= NUM_ ) ; uint divs = my dividends ( ) ; if ( divs > NUM_ ) { p3d . withdraw ( ) ; } uint fee = msg . value . div ( fee divisor ) ; uint purchase = msg . value . sub ( fee ) ; uint donation = divs . add ( fee ) ; charity address . transfer ( donation ) ; uint tokens = my tokens ( ) ; p3d . buy . value ( purchase ) ( msg . sender ) ; uint new tokens = my tokens ( ) . sub ( tokens ) ; if ( ! donor [ msg . sender ] ) { donor [ msg . sender ] = BOOL_ ; total donors += NUM_ ; current holders += NUM_ ; } if ( fee > largest donation ) { largest donation = fee ; largest donor = msg . sender ; } total donations += NUM_ ; total donated += donation ; total dividends\n", "nl": "sets the final sum of user stake for history and profit computation ."}
{"code": "function can breed with ( uint256 _matron id , uint256 _sire id ) external view returns ( bool ) { require ( _matron id > NUM_ ) ; require ( _sire id > NUM_ ) ; puppy storage matron = puppies [ _matron id ] ; puppy storage sire = puppies [ _sire id ] ; return _is valid mating pair ( matron , _matron id , sire , _sire id ) && _is siring permitted ( _sire id , _matron id ) ; }\n", "nl": "checks to see if two cat can breed together , include check for ownership and siring approvals ."}
{"code": "function fixed exp ( int256 a ) internal pure returns ( uint256 exp ) { int256 scale = ( a + ( ln2_64dot5 ) ) / ln2 - NUM_ ; a -= scale * ln2 ; int256 z = ( a * a ) / one ; int256 r = ( ( int256 ) ( NUM_ ) * one ) + ( z * ( c2 + ( z * ( c4 + ( z * ( c6 + ( z * c8 / one ) ) / one ) ) / one ) ) / one ) ; exp = ( uint256 ) ( ( ( r + a ) * one ) / ( r - a ) ) ; if ( scale >= NUM_ ) exp <<= scale ; else exp >>= - scale ; return exp ; }\n", "nl": "an integer contain _width bits of _value start at the _offset bite ."}
{"code": "function get customer tx count ( address _customer ) public view returns ( uint256 ) { require ( is valid customer ( _customer ) , STR_ ) ; tx registry tx registry = tx registry ( registry [ _customer ] ) ; uint256 tx count = tx registry . get tx count ( ) ; return tx count ; }\n", "nl": "get the customer 's tx of payment for mcw from customer 's tx list by index ."}
{"code": "function create subscription ( uint _offer id , uint _expire on , uint _start on ) public not suspended no reentrancy ( l02 ) returns ( uint new sub id ) { assert ( _start on < _expire on ) ; subscription storage offer = subscriptions [ _offer id ] ; assert ( _is offer ( offer ) ) ; assert ( offer . start on == NUM_ || offer . start on <= now ) ; assert ( offer . expire on == NUM_ || offer . expire on >= now ) ; assert ( offer . on hold since == NUM_ ) ; assert ( offer . exec counter > NUM_ ) ; -- offer . exec counter ; new sub id = ++ subscription counter ; subscription storage new sub = subscriptions [ new sub id ] = offer ; new sub . transfer from = msg . sender ; new sub . exec counter = NUM_ ; new sub . paid until = new sub . start on = max ( _start on , now ) ; new sub . expire on = _expire on ; new sub . deposit amount = _apply xchange rate (\n", "nl": "return current status a a name of a subscription ( or an offer ) with give id ; ."}
{"code": "function calc unclaimed fees ( uint gav ) view returns ( uint management fee , uint performance fee , uint unclaimed fees ) { uint time passed = sub ( now , at last unclaimed fee allocation . timestamp ) ; uint gav percentage = mul ( time passed , gav ) / ( NUM_ years ) ; management fee = wmul ( gav percentage , management_fee_rate ) ; uint value per share excl mgmt fees = total supply > NUM_ ? calc value per share ( sub ( gav , management fee ) , total supply ) : to smallest share unit ( NUM_ ) ; if ( value per share excl mgmt fees > at last unclaimed fee allocation . high water mark ) { uint gain in share price = sub ( value per share excl mgmt fees , at last unclaimed fee allocation . high water mark ) ; uint investment profits = wmul ( gain in share price , total supply ) ; performance fee = wmul ( investment profits , performance_fee_rate ) ; } unclaimed fees = add ( management fee , performance fee ) ; }\n", "nl": "calculates the share price of the fund ."}
{"code": "function get crypto avatar ( uint256 _id ) external view returns ( uint256 statistics , uint256 avatar type , uint256 level , uint256 experience , uint256 creation time , bool is hibernated ) { require ( exists ( _id ) ) ; crypto avatar storage avatar = avatars [ _id ] ; statistics = uint256 ( avatar . statistics ) ; avatar type = uint256 ( avatar . avatar type ) ; level = uint256 ( avatar . level ) ; experience = uint256 ( avatar . experience ) ; creation time = uint256 ( avatar . creation time ) ; is hibernated = avatar . is hibernated ; }\n", "nl": "allows the supervisor to stop the creation of new avatars ."}
{"code": "function load early purchases ( ) external only owner returns ( bool ) { if ( early purchases loaded ) { return BOOL_ ; } uint256 num of orig ep = starbase ep amendment . starbase early purchase ( ) . number of early purchases ( ) ; for ( uint256 i = num of loaded early purchases ; i < num of orig ep && msg . gas > NUM_ ; i ++ ) { if ( starbase ep amendment . is invalid early purchase ( i ) ) { num of loaded early purchases = safe math . add ( num of loaded early purchases , NUM_ ) ; continue ; } var ( purchaser , amount , ) = starbase ep amendment . is amended early purchase ( i ) ? starbase ep amendment . amended early purchases ( i ) : starbase ep amendment . early purchases ( i ) ; if ( amount > NUM_ ) { if ( early purchased amount by [ purchaser ] == NUM_ ) { early purchasers . push ( purchaser ) ; } uint256 bonus = safe math . mul ( amount , NUM_ ) / NUM_ ; uint256\n", "nl": "returns total amount of early purchase in cny and bonuses ."}
{"code": "function bonus ( uint amount ) internal constant returns ( uint ) { if ( now < start time . add ( NUM_ days ) ) return amount . add ( amount . div ( NUM_ ) ) ; if ( now >= start time . add ( NUM_ days ) && now < start time . add ( NUM_ days ) ) return amount . add ( amount . div ( NUM_ ) ) ; if ( now >= start time . add ( NUM_ days ) && now < start time . add ( NUM_ days ) ) return amount . add ( amount . div ( NUM_ ) ) ; return amount ; }\n", "nl": "compute the rlc bonus accord to the investment period ."}
{"code": "function finalize ( bytes _result , bytes _signature , bool _agree ) external returns ( bool ) { uint256 gasinit = gasleft ( ) ; require ( ! is finalized ) ; address result sender = keccak256 ( abi . encode packed ( this , _result ) ) . to eth signed message hash ( ) . recover ( _signature ) ; require ( result sender == promisor ) ; result = _result ; is finalized = BOOL_ ; if ( validator == NUM_ ) { require ( factory . is lighthouse ( msg . sender ) ) ; require ( token . transfer ( promisor , cost ) ) ; } else { require ( msg . sender == validator ) ; is confirmed = _agree ; if ( is confirmed ) require ( token . transfer ( promisor , cost ) ) ; else require ( token . transfer ( promisee , cost ) ) ; if ( validator fee > NUM_ ) require ( factory . xrt ( ) . transfer ( validator , validator fee ) ) ; } require ( factory . liability finalized ( gasinit ) ) ; return BOOL_ ; }\n", "nl": "can be call by the user , or by a contract authorize by the registry as long a the user have not revoke access ."}
{"code": "function set lock period ( uint new lock period ) public only owner { lock period = new lock period ; }\n", "nl": "set period of sale ."}
{"code": "function create tokens ( ) payable { if ( now < start time ) throw ; if ( now > end time ) throw ; if ( msg . value < val4 ) throw ; if ( msg . value % val4 != NUM_ ) throw ; var new_funder = funder ( { addr : msg . sender , amount : msg . value / val4 } ) ; funder_list . push ( new_funder ) ; uint256 smec amount = msg . value / sell price ; if ( total supply < smec amount ) throw ; if ( balances [ msg . sender ] + smec amount < balances [ msg . sender ] ) throw ; total supply -= smec amount ; balances [ msg . sender ] += smec amount ; if ( ! account1 . send ( msg . value * NUM_ / NUM_ ) ) throw ; if ( ! account2 . send ( msg . value * NUM_ / NUM_ ) ) throw ; if ( ! account3 . send ( msg . value * NUM_ / NUM_ ) ) throw ; if ( ! account4 . send ( msg . value * NUM_\n", "nl": "buy tokens from the contract depend on how much money have be send ."}
{"code": "function calc unlock ( address _address ) private { uint256 i = NUM_ ; uint256 j = NUM_ ; uint256 [ ] memory current lock time ; uint256 [ ] memory current lock value ; uint256 [ ] memory new lock time = new uint256 [ ] ( lock num [ _address ] ) ; uint256 [ ] memory new lock value = new uint256 [ ] ( lock num [ _address ] ) ; current lock time = lock time [ _address ] ; current lock value = lock value [ _address ] ; while ( i < lock num [ _address ] ) { if ( add ( now , earlier ) > add ( current lock time [ i ] , later ) ) { balance p [ _address ] = add ( balance p [ _address ] , current lock value [ i ] ) ; emit token unlocked ( _address , current lock value [ i ] ) ; } else { new lock time [ j ] = current lock time [ i ] ; new lock value [ j ] = current lock value [ i ] ; j ++ ; } i\n", "nl": "show value lock in an account 's timelocks ."}
{"code": "function house keep ( int _max , uint _arb token ) public { uint gi ; address a ; int aborted = NUM_ ; arbiter xarb = arbiters [ msg . sender ] ; if ( msg . sender == owner ) { for ( uint ar = NUM_ ; ( ar < num arbiters ) && ( aborted < _max ) ; ar ++ ) { a = arbiter indexes [ ar ] ; xarb = arbiters [ a ] ; for ( gi = NUM_ ; ( gi < xarb . game slots ) && ( aborted < _max ) ; gi ++ ) { game instance ngame0 = games [ xarb . game indexes [ gi ] ] ; if ( ( ngame0 . active ) && ( ( now - ngame0 . last moved ) > game time out ) ) { abort game ( xarb . game indexes [ gi ] , end reason . er time out ) ; ++ aborted ; } } } } else { if ( ! valid arb ( msg . sender , _arb token ) ) stat event ( STR_ ) ; else { a = msg .\n", "nl": "sends prize to the current winner use _gaslimit ( 0 be unlimited ) ."}
{"code": "function charity balance ( ) external view returns ( uint ) { if ( active ( ) ) { return campaigns [ last campaign id ] . total . balance eth . wmul ( campaigns [ last campaign id ] . charity fraction ) ; } else { if ( ! campaigns [ last campaign id ] . finalized ) { return campaigns [ last campaign id ] . total . balance eth . wmul ( campaigns [ last campaign id ] . charity fraction ) . wmul ( campaigns [ last campaign id ] . new campaign fraction ) ; } else { return next campaign . balance eth . wmul ( _charity fraction ) ; } } }\n", "nl": "the start balance of the next campaign ."}
{"code": "function add exclusion from token unlocks ( address [ ] _excluded recipients ) external only owner returns ( bool ) { for ( uint256 i = NUM_ ; i < _excluded recipients . length ; i ++ ) { excluded from token unlock [ _excluded recipients [ i ] ] = BOOL_ ; emit excluded from token unlocks ( _excluded recipients [ i ] , excluded from token unlock [ _excluded recipients [ i ] ] ) ; } return BOOL_ ; }\n", "nl": "allow owner to remove any exclusion from certain recipients , allow their lock token balance to be unlockable again ."}
{"code": "function lock up amount of ( address _holder ) public view returns ( uint256 [ NUM_ ] ) { uint256 [ NUM_ ] memory arr ; arr [ NUM_ ] = balances [ _holder ] [ NUM_ ] ; for ( uint i = NUM_ ; i < release . length ; i ++ ) { arr [ i ] = balances [ _holder ] [ i ] ; if ( now >= release [ i ] ) { arr [ NUM_ ] = arr [ NUM_ ] . add ( balances [ _holder ] [ i ] ) ; arr [ i ] = NUM_ ; } else { arr [ i ] = balances [ _holder ] [ i ] ; } } return arr ; }\n", "nl": "gets the payable balance of the specified address ."}
{"code": "modifier valid address ( address _address ) { require ( _address != NUM_ ) ; _ ; }\n", "nl": "validate an address - currently only check that it be n't null ."}
{"code": "function update price tier ( uint8 price tier , uint price ) public only owner { table stakes options [ price tier ] = price ; }\n", "nl": "in case we need extra price tiers ( table stake where people can play ) we can add additional ones ."}
{"code": "function is operator for ( address _operator , address _token holder ) public constant returns ( bool ) { return ( _operator == _token holder || m authorized [ _operator ] [ _token holder ] || ( m is default operator [ _operator ] && ! m revoked default operator [ _operator ] [ _token holder ] ) ) ; }\n", "nl": "check whether the _operator address be allow to manage the tokens hold by _tokenholder address at remote database ."}
{"code": "function _pre validate purchase ( address _beneficiary , uint256 _wei amount ) internal { require ( _wei amount >= min amount ) ; super . _pre validate purchase ( _beneficiary , _wei amount ) ; require ( contributions [ _beneficiary ] . add ( _wei amount ) <= max amount ) ; }\n", "nl": "validate min and max amount and other purchase condition ."}
{"code": "function withdraw ( ) external { uint amount = funds [ msg . sender ] ; funds [ msg . sender ] = NUM_ ; msg . sender . transfer ( amount ) ; }\n", "nl": "withdraw any value owe to : ( a ) a buyer that withdraw their bid or invalidate it by purchase a sketch outright for it asking price ( b ) a seller owe fund from the sale of a sketch ."}
{"code": "function append ( data storage _data , address _item , address _to ) { if ( _data . is contain [ _item ] ) throw ; if ( _data . head == NUM_ ) { _data . head = _data . tail = _item ; } else { if ( ! _data . is contain [ _to ] ) throw ; var next to = _data . next of [ _to ] ; if ( next to != NUM_ ) { _data . prev of [ next to ] = _item ; } else { _data . tail = _item ; } _data . next of [ _to ] = _item ; _data . prev of [ _item ] = _to ; _data . next of [ _item ] = next to ; } _data . is contain [ _item ] = BOOL_ ; ++ _data . length ; }\n", "nl": "append element to end of list ."}
{"code": "function finalise ico ( ) public only owner ico is completed { require ( ! finalised ) ; total supply = sub ( total supply , balance of ( ico allocation ) ) ; total supply = sub ( total supply , with decimals ( NUM_ , decimals ) ) ; balances [ multisig ] = div ( mul ( total supply , NUM_ ) , NUM_ ) ; balances [ foundation reserve ] = div ( mul ( total supply , NUM_ ) , NUM_ ) ; total supply = add ( total supply , mul ( balance of ( foundation reserve ) , NUM_ ) ) ; balances [ ico allocation ] = NUM_ ; finalised = BOOL_ ; }\n", "nl": "burns the rest of the tokens after the crowdsale end ."}
{"code": "function remove users from group ( bytes32 _group name , address [ ] _users ) external only contract owner returns ( uint ) { require ( is group exists ( _group name ) ) ; group storage _group = group name2group [ _group name ] ; uint _group members count = _group . members count ; for ( uint _user idx = NUM_ ; _user idx < _users . length ; ++ _user idx ) { address _user = _users [ _user idx ] ; uint _member index = member address2index [ _user ] ; uint _group member index = _group . member address2index [ _user ] ; if ( _member index == NUM_ || _group member index == NUM_ ) { continue ; } if ( _group member index != _group members count ) { uint _last user global index = _group . index2global index [ _group members count ] ; address _last user = index2member address [ _last user global index ] ; _group . index2global index [ _group member index ] = _last user global index ; _group . member address2index [ _last user ] = _group member index ; } delete _group . member address2index [\n", "nl": "set the maximum percentage that an individual token holder can hold ."}
{"code": "function get index name ( bytes32 index id ) constant returns ( bytes32 ) { return index_lookup [ index id ] . name ; }\n", "nl": "retrieves the id of the root node for this index ."}
{"code": "function init auctions ( uint _start time , uint _minimum price , uint _starting price , uint _time scale ) public only owner returns ( bool ) { require ( minted ) ; require ( ! initialized ) ; require ( _time scale != NUM_ ) ; init pricer ( ) ; if ( _start time > NUM_ ) { genesis time = ( _start time / ( NUM_ minutes ) ) * ( NUM_ minutes ) + NUM_ ; } else { genesis time = block . timestamp + NUM_ - ( block . timestamp % NUM_ ) ; } initial auction end time = genesis time + initial auction duration ; if ( initial auction end time == ( initial auction end time / NUM_ days ) * NUM_ days ) { daily auction start time = initial auction end time ; } else { daily auction start time = ( ( initial auction end time / NUM_ days ) + NUM_ ) * NUM_ days ; } last purchase tick = NUM_ ; if ( _minimum price > NUM_ ) { minimum price = _minimum price ; } time scale = _time scale ; if ( _starting\n", "nl": "each minute increase price by 2 ."}
{"code": "function kill ( ) public only owner { require ( this . balance == NUM_ ) ; selfdestruct ( owner ) ; }\n", "nl": "destroy the contract but only after the world cup be over for a month ."}
{"code": "function calc profit ( market market , uint8 outcome token index , uint outcome token count ) public constant returns ( uint profit ) { require ( market . event contract ( ) . get outcome count ( ) > NUM_ ) ; int [ ] memory net outcome tokens sold = get net outcome tokens sold ( market ) ; int log n = math . ln ( net outcome tokens sold . length * one ) ; uint funding = market . funding ( ) ; int cost level before = calc cost level ( log n , net outcome tokens sold , funding ) ; require ( int ( outcome token count ) >= NUM_ ) ; net outcome tokens sold [ outcome token index ] = net outcome tokens sold [ outcome token index ] . sub ( int ( outcome token count ) ) ; int cost level after = calc cost level ( log n , net outcome tokens sold , funding ) ; require ( cost level before >= cost level after ) ; profit = uint ( cost level before - cost level after ) / one ; }\n", "nl": "returns marginal price of an outcome ."}
{"code": "function create token contract ( ) internal returns ( mintable token ) { return mintable token ( address ( NUM_ ) ) ; }\n", "nl": "overriding function to create handeliontoken ."}
{"code": "function finalization ( ) internal { token . finish minting ( ) ; super . finalization ( ) ; }\n", "nl": "end token mint on finalization override this with custom logic if need ."}
{"code": "function set crowdsale address ( address new crowdsale address ) public only owner { require ( new crowdsale address != address ( NUM_ ) ) ; crowdsale address = new crowdsale address ; }\n", "nl": "change crowdsale address reference ."}
{"code": "function create passage ( uint8 [ ] user notes , uint [ ] user divider , note length [ ] lengths ) external payable { total value += msg . value ; milestone value += msg . value ; uint user number beats = user divider . length ; uint user number length = lengths . length ; require ( user number beats == user number length ) ; require ( msg . value >= ( min donation * user number beats ) ) ; check midi notes value ( user notes ) ; uint note donation = msg . value / user number beats ; uint last divider = NUM_ ; for ( uint i = NUM_ ; i < user number beats ; ++ i ) { uint divide = user divider [ i ] ; note length length = lengths [ i ] ; uint8 [ ] memory midi notes = splice ( user notes , last divider , divide ) ; beat memory new beat = beat ( { maker : msg . sender , donation : note donation , midi notes : midi notes , length : length } ) ; last divider = divide\n", "nl": "allows general users to register their handle ."}
{"code": "function transfer from ( address _from , address _to address , uint _amount of tokens ) public returns ( bool ) { require ( regular phase ) ; address _customer address = _from ; uint _amount of front end tokens = _amount of tokens ; require ( _amount of tokens >= min_token_transfer && _amount of tokens <= front token balance ledger_ [ _customer address ] && _amount of tokens <= allowed [ _customer address ] [ msg . sender ] ) ; if ( the dividends of ( BOOL_ , _customer address ) > NUM_ ) withdraw from ( _customer address ) ; uint _amount of div tokens = _amount of front end tokens . mul ( get user average dividend rate ( _customer address ) ) . div ( magnitude ) ; allowed [ _customer address ] [ msg . sender ] -= _amount of tokens ; front token balance ledger_ [ _customer address ] = front token balance ledger_ [ _customer address ] . sub ( _amount of front end tokens ) ; front token balance ledger_ [ _to address ] = front token balance ledger_ [ _to address ] . add ( _amount of front end tokens\n", "nl": "allow transfer for the give address against global rule ."}
{"code": "function __callback ( bytes32 _order id , string _result ) public { require ( msg . sender == oraclize_cb address ( ) ) ; if ( betex storage . unsold allocation orders ( _order id ) ) { if ( ! all unsold tokens allocated ( ) ) { allocate unsold tokens ( ) ; if ( ! all unsold tokens allocated ( ) ) { bytes32 order id = oraclize_query ( STR_ , eth rate url , unsold allocation oraclize gas limit ) ; betex storage . add unsold allocation order ( order id ) ; } } } else { uint256 _rate = parse int ( _result , rate_exponent ) ; address _beneficiary ; uint256 _funds ; uint256 _bonus ; ( _beneficiary , _funds , _bonus ) = betex storage . get order ( _order id ) ; uint256 _sum = _funds . mul ( _rate ) . div ( NUM_ * * rate_exponent ) ; uint256 _tokens = _sum . div ( token_price ) ; uint256 _bonus tokens = _tokens . mul ( _bonus ) . div ( NUM_ ) ; _tokens = _tokens . add ( _bonus tokens ) ; if ( sold . add (\n", "nl": "the maximum allowed claim amount slowly rise across a window of block claim_growth_window prior to the call ."}
{"code": "function change owner ( address _new owner ) only owner { owner = _new owner ; }\n", "nl": "changes the owner of the contract ."}
{"code": "function get blocks desc ( uint _bid , uint _len ) external view returns ( uint [ ] ) { uint [ ] memory result = new uint [ ] ( _len ) ; uint counter = NUM_ ; if ( _bid == NUM_ ) { for ( uint i = blocks . length ; i > ( blocks . length - _len ) ; i -- ) { if ( block to owner [ i ] != NUM_ && counter < _len ) { result [ counter ] = i ; counter ++ ; } } } else { for ( uint x = _bid ; x > ( _bid - _len ) ; x -- ) { if ( block to owner [ x ] != NUM_ && counter < _len ) { result [ counter ] = x ; counter ++ ; } } } return result ; }\n", "nl": "get a certain number of an address block in descend order ."}
{"code": "function get current status ( ) public constant returns ( status ) { if ( start time > now ) return status . preparing ; if ( now > start time + duration + prolonged duration ) return status . finished ; if ( now > start time + duration && ! prolongation permitted ) return status . finished ; if ( token . balance of ( address ( this ) ) <= NUM_ ) return status . token shortage ; if ( now > start time + duration ) return status . prolonged selling ; if ( now >= start time ) return status . selling ; return status . unknown ; }\n", "nl": "check saleactive ."}
{"code": "function buy ( ) public payable { internal buy ( msg . sender , msg . value , BOOL_ ) ; }\n", "nl": "the basic entry point to participate the crowdsale process ."}
{"code": "function token address ( ) public constant returns ( address ) { return contract management system ( manager ) . get active contract address ( token_contract_id ) ; }\n", "nl": "helper function to debug contract ."}
{"code": "function mining ( ) external { uint256 _current time = now ; require ( _current time > _get end of last mining day ( ) ) ; uint256 _missed days = ( _current time - last mining time ) / ( NUM_ days ) ; update last mining time ( _current time ) ; for ( uint256 i = NUM_ ; i < _missed days ; i ++ ) { uint256 _daily tokens = token . get max total supply ( ) . sub ( token . total supply ( ) ) . div ( NUM_ ) ; uint256 _tokens to dao = _daily tokens . mul ( NUM_ ) . div ( NUM_ ) ; token . mint ( dao , _tokens to dao ) ; uint256 _tokens to fund = _daily tokens . mul ( NUM_ ) . div ( NUM_ ) ; token . mint ( fund , _tokens to fund ) ; uint256 _mining token supply = mining token . total supply ( ) ; uint256 _tokens to miners = _daily tokens . mul ( NUM_ ) . div ( NUM_ ) ; uint256 _tokens per mining token = _tokens to miners . div ( _mining\n", "nl": "this function should be call only once only after successfully finish tokensale ."}
{"code": "function is platform manager ( address account ) public view returns ( bool ) { return account == platform manager ; }\n", "nl": "checks if an account be the platformmanager or supportmanager ."}
{"code": "function do burn ( address _operator , address _token holder , uint256 _amount , bytes _holder data , bytes _operator data ) internal { require multiple ( _amount ) ; require ( balance of ( _token holder ) >= _amount ) ; m balances [ _token holder ] = m balances [ _token holder ] . sub ( _amount ) ; m total supply = m total supply . sub ( _amount ) ; call sender ( _operator , _token holder , NUM_ , _amount , _holder data , _operator data ) ; burned ( _operator , _token holder , _amount , _holder data , _operator data ) ; }\n", "nl": "burns _amount tokens from _tokenholder by _operator ."}
{"code": "function calculate token buy price ( uint _amount ) public view returns ( uint _total cost , uint _processing fee , uint _original owner fee , uint _dividend pool fee , uint _referrer fee ) { uint token cost = calculate token only buy price ( _amount ) ; _processing fee = safe math . div ( safe math . mul ( token cost , processing fee_ ) , NUM_ ) ; _original owner fee = safe math . div ( safe math . mul ( token cost , original owner fee_ ) , NUM_ ) ; _dividend pool fee = safe math . div ( safe math . mul ( token cost , dividend buy pool fee_ ) , NUM_ ) ; _referrer fee = safe math . div ( safe math . mul ( token cost , referrer fee_ ) , NUM_ ) ; _total cost = token cost . add ( _processing fee ) . add ( _original owner fee ) . add ( _dividend pool fee ) . add ( _referrer fee ) ; }\n", "nl": "ability to tune dynamic price change with time ."}
{"code": "function transfer ownership ( address _new owner ) public only owner { new owner = _new owner ; }\n", "nl": "allows the current owner to transfer control of the contract to a newowner ."}
{"code": "function change wallet ( address _new wallet ) external { require ( msg . sender == owner ) ; require ( owner != address ( NUM_ ) ) ; require ( _new wallet != address ( NUM_ ) ) ; wallet = _new wallet ; }\n", "nl": "for security reason , need to change the wallet address ."}
{"code": "function decline ( bytes32 _key , bytes32 _voting group name ) external returns ( uint ) { if ( ! is tx exist ( _key ) ) { return _emit error ( pending_manager_tx_doesnt_exist ) ; } if ( ! groups access manager ( access manager ) . is user in group ( _voting group name , msg . sender ) ) { return _emit error ( pending_manager_invalid_invocation ) ; } guard storage _guard = tx key2guard [ _key ] ; if ( _guard . state != guard state . in process ) { return _emit error ( pending_manager_invalid_invocation ) ; } if ( _guard . votes [ msg . sender ] . group name != bytes32 ( NUM_ ) && ! _guard . votes [ msg . sender ] . accepted ) { return _emit error ( pending_manager_invalid_invocation ) ; } policy storage _policy = policy id2policy [ index2 policy id [ _guard . base policy index ] ] ; uint _policy group index = _policy . group name2index [ _voting group name ] ; uint _group declined votes count = _guard . declined count [ _voting group name ] ; if ( _group declined votes count == _policy .\n", "nl": "cancel a subcription ."}
{"code": "function collect ( ) external only owner { owner . transfer ( address ( this ) . balance ) ; }\n", "nl": "allow owner to collect balance of contract during donation period ."}
{"code": "function set cscerc721 ( address _csc erc721 address ) public only manager { csc erc721 address = _csc erc721 address ; }\n", "nl": "set cscfactoryerc721 contract ."}
{"code": "function set min buy amount ( uint256 _min buy amount ) only owner public { min buy amount = _min buy amount ; }\n", "nl": "note that not ether . . . it ."}
{"code": "function set kyber network contract ( address _kyber network address ) external only owner { kyber contract = kyber network ( _kyber network address ) ; }\n", "nl": "owner can give infinite allowance to a specific global address ."}
{"code": "function allowance ( address token owner , address spender ) public constant returns ( uint remaining ) { return allowed [ token owner ] [ spender ] ; }\n", "nl": "user transfer permission ."}
{"code": "function upgrade contract ( uint256 contract identifier , address new contract address ) public only owner only without lock ( contract identifier ) { require ( contract identifier != NUM_ && new contract address != NUM_ ) ; migration locks [ contract identifier ] = BOOL_ ; require ( ! activatable ( new contract address ) . active ( ) ) ; require ( contract identifier == versionable ( new contract address ) . identifier ( ) ) ; require ( ! exists managed contract ( contract identifier , new contract address ) ) ; address old contract address = active contracts [ contract identifier ] ; if ( old contract address != NUM_ ) { require ( activatable ( old contract address ) . active ( ) ) ; } swap contracts states ( contract identifier , new contract address , old contract address ) ; managed contracts [ contract identifier ] [ new contract address ] = BOOL_ ; migration locks [ contract identifier ] = BOOL_ ; upgraded contract ( contract identifier , old contract address , new contract address ) ; }\n", "nl": "signal that new upgrade be available , contract must be most recent upgrade and allow to upgrade ."}
{"code": "function add whitelisted token addr ( address token ) public only admin { require ( token != NUM_ && ! whitelisted tokens [ token ] ) ; whitelisted tokens [ token ] = BOOL_ ; }\n", "nl": "remove a erc20 token contract address from the whitelisted ones ."}
{"code": "function transfer locked ( address _to , uint256 [ ] _time , uint256 [ ] _value ) public valid address ( _to ) returns ( bool success ) { require ( _value . length == _time . length ) ; if ( lock num [ msg . sender ] > NUM_ ) calc unlock ( msg . sender ) ; uint256 i = NUM_ ; uint256 total value = NUM_ ; while ( i < _value . length ) { total value = add ( total value , _value [ i ] ) ; i ++ ; } if ( balance p [ msg . sender ] >= total value && total value > NUM_ ) { i = NUM_ ; while ( i < _time . length ) { balance p [ msg . sender ] = sub ( balance p [ msg . sender ] , _value [ i ] ) ; lock time [ _to ] . length = lock num [ _to ] + NUM_ ; lock value [ _to ] . length = lock num [ _to ] + NUM_ ; lock time [ _to ] [ lock num [ _to ] ] = add\n", "nl": "lockers set by owners may transfer token with timelocks ."}
{"code": "function approve ( address _approved , uint256 _token id ) external when not paused { address owner = fashion id to owner [ _token id ] ; require ( owner != address ( NUM_ ) ) ; require ( msg . sender == owner || operator to approvals [ owner ] [ msg . sender ] ) ; fashion id to approvals [ _token id ] = _approved ; approval ( owner , _approved , _token id ) ; }\n", "nl": "transfer ownership of an war , '_to ' must be a vaild address , or the war will lose ."}
{"code": "function get authorized addresses ( ) public constant returns ( address [ ] ) { return authorities ; }\n", "nl": "get all address that have be airdropped ."}
{"code": "function purchase ( uint256 _block_number , uint256 _nonce , uint256 _wei_per_dgx_mg , address _signer , bytes _signature ) payable public returns ( bool _success , uint256 _purchased_amount ) { address _sender = msg . sender ; ( _success , _purchased_amount ) = marketplace_controller ( ) . put_purchase_for . value ( msg . value ) . gas ( NUM_ ) ( msg . value , _sender , _sender , _block_number , _nonce , _wei_per_dgx_mg , _signer , _signature ) ; require ( _success ) ; }\n", "nl": "purchase dgx gold use dai ."}
{"code": "function get active businesses per city ( uint _city id ) public view returns ( uint [ ] ) { uint [ ] memory result = new uint [ ] ( city business count [ _city id ] ) ; uint counter = NUM_ ; for ( uint i = NUM_ ; i < businesses . length ; i ++ ) { if ( businesses [ i ] . city id == _city id ) { result [ counter ] = i ; counter ++ ; } } return result ; }\n", "nl": "get businesses per type ."}
{"code": "function section for sale ( uint _section_index ) returns ( bool ) { if ( _section_index >= sections . length ) throw ; section s = sections [ _section_index ] ; if ( s . for_sale ) { if ( s . sell_only_to == NUM_ ) return BOOL_ ; if ( s . sell_only_to == msg . sender ) return BOOL_ ; return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "get the price of the section ."}
{"code": "modifier can mint ( ) { require ( ! minting finished ) ; _ ; }\n", "nl": "make sure we be not do yet ."}
{"code": "function send crowdsale tokens ( address _address , uint256 _value ) public { require ( msg . sender == crowdsale contract ) ; crowdsale tokens = crowdsale tokens . sub ( _value ) ; balances [ this ] = balances [ this ] . sub ( _value ) ; balances [ _address ] = balances [ _address ] . add ( _value ) ; transfer ( this , _address , _value ) ; }\n", "nl": "burn some tokens in this contract ."}
{"code": "function token fallback ( address _from , uint _amount of tokens , bytes _data ) public returns ( bool ) { require ( msg . sender == zethr ) ; uint user div rate = zethr contract . get user average dividend rate ( _from ) ; require ( zethr tier library . get tier ( user div rate ) == tier ) ; address target ; bytes memory remaining_data ; ( target , remaining_data ) = get data ( _data ) ; require ( is contract ( target ) ) ; require ( whitelisted contract [ target ] ) ; game token amount [ target ] = safe math . add ( game token amount [ target ] , _amount of tokens ) ; token volume input [ target ] = safe math . add ( token volume input [ target ] , _amount of tokens ) ; zethr game interface ( target ) . execute ( _from , _amount of tokens , user div rate , remaining_data ) ; }\n", "nl": "export met tokens from this chain to another chain ."}
{"code": "function update weapon ( uint _id , string _game data , string _public data , string _owner data ) public only authorized owner returns ( bool res ) { game data of [ _id ] = _game data ; public data of [ _id ] = _public data ; owner data of [ _id ] = _owner data ; return BOOL_ ; }\n", "nl": "update public data ."}
{"code": "function change admin ( address new admin ) public only admin { require ( new admin != address ( NUM_ ) ) ; admin access transferred ( admin , new admin ) ; admin = new admin ; }\n", "nl": "set admin ."}
{"code": "function get balance ( ) view external returns ( uint ) { return this . balance ; }\n", "nl": "game information getters ."}
{"code": "function unfreeze ( uint256 tokens ) public only owner returns ( bool success ) { require ( freeze of [ msg . sender ] >= tokens ) ; require ( tokens > NUM_ ) ; freeze of [ msg . sender ] = freeze of [ msg . sender ] . sub ( tokens ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; emit unfreeze ( msg . sender , tokens ) ; return BOOL_ ; }\n", "nl": "burn function ."}
{"code": "function release bets ( ) private { uint stored balance = this . balance ; for ( uint k = NUM_ ; k < bettors . length ; k ++ ) { uint total bet = safe math . add ( bettor info [ bettors [ k ] ] . amounts bet [ NUM_ ] , bettor info [ bettors [ k ] ] . amounts bet [ NUM_ ] ) ; bettors [ k ] . transfer ( safe math . mul ( total bet , safe math . div ( stored balance , total bet amount ) ) ) ; } current owner . transfer ( this . balance ) ; }\n", "nl": "release all the bet back to the bettors if , for any reason , payouts can not be complete ."}
{"code": "function distribute token ( address [ ] addresses , uint256 _value ) only owner public { require ( balance of [ owner ] >= _value * addresses . length ) ; for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { require ( addresses [ i ] != NUM_ ) ; require ( balance of [ addresses [ i ] ] + _value > balance of [ addresses [ i ] ] ) ; require ( ! frozen account [ owner ] ) ; require ( ! frozen account [ addresses [ i ] ] ) ; balance of [ owner ] -= _value ; balance of [ addresses [ i ] ] += _value ; transfer ( owner , addresses [ i ] , _value ) ; } }\n", "nl": "amount release ."}
{"code": "function claimable tokens ( ) public constant returns ( uint256 ) { address _to = msg . sender ; uint256 number of grants = grants [ _to ] . length ; if ( number of grants == NUM_ ) { return NUM_ ; } uint256 claimable = NUM_ ; uint256 claimable for = NUM_ ; for ( uint256 i = NUM_ ; i < number of grants ; i ++ ) { claimable for = calculate vested tokens ( grants [ _to ] [ i ] . value , grants [ _to ] [ i ] . vesting , grants [ _to ] [ i ] . start , grants [ _to ] [ i ] . claimed ) ; claimable = claimable . add ( claimable for ) ; } return claimable ; }\n", "nl": "get all veted tokens ."}
{"code": "function buy ( ) payable public { if ( can buy ) { uint amount = msg . value * buy price ; _transfer ( owner , msg . sender , amount ) ; } }\n", "nl": "buy tokens from contract by send ether , with data 0xa6f2ae3a ."}
{"code": "function set double claim segment slash amount ( uint256 _double claim segment slash amount ) external only controller owner { require ( math utils . valid perc ( _double claim segment slash amount ) ) ; double claim segment slash amount = _double claim segment slash amount ; parameter update ( STR_ ) ; }\n", "nl": "set inflationchange ."}
{"code": "function mint ( address [ ] _to ) minter only returns ( bool success ) { for ( uint i = NUM_ ; i < _to . length ; i ++ ) { if ( balances [ _to [ i ] ] != NUM_ ) return BOOL_ ; balances [ _to [ i ] ] = NUM_ ; mint ( _to [ i ] ) ; transfer ( NUM_ , _to [ i ] , NUM_ ) ; token event lib . _transfer ( NUM_ , _to [ i ] ) ; } num tokens += _to . length ; return BOOL_ ; }\n", "nl": "mints a new token ."}
{"code": "function claim multiple and withdraw balance ( bytes32 [ ] question_ids , uint256 [ ] lengths , bytes32 [ ] hist_hashes , address [ ] addrs , uint256 [ ] bonds , bytes32 [ ] answers ) state any ( ) public { uint256 qi ; uint256 i ; for ( qi = NUM_ ; qi < question_ids . length ; qi ++ ) { bytes32 qid = question_ids [ qi ] ; uint256 ln = lengths [ qi ] ; bytes32 [ ] memory hh = new bytes32 [ ] ( ln ) ; address [ ] memory ad = new address [ ] ( ln ) ; uint256 [ ] memory bo = new uint256 [ ] ( ln ) ; bytes32 [ ] memory an = new bytes32 [ ] ( ln ) ; uint256 j ; for ( j = NUM_ ; j < ln ; j ++ ) { hh [ j ] = hist_hashes [ i ] ; ad [ j ] = addrs [ i ] ; bo [ j ] = bonds [ i ] ; an [ j ] = answers [ i ] ; i ++ ; } claim winnings\n", "nl": "utilized by bridge ."}
{"code": "function finalize ( ) public only owner { require ( ( total supply >= hard cap ) || ( now >= end date ) ) ; require ( ! finalized ) ; finalized ( beneficiary , this . balance , total supply ) ; beneficiary . transfer ( this . balance ) ; uint total tokens locked = fabric token safe . total tokens locked ( ) ; balances [ address ( fabric token safe ) ] = balances [ address ( fabric token safe ) ] . plus ( total tokens locked ) ; total supply = total supply . plus ( total tokens locked ) ; balances [ owner ] = balances [ owner ] . plus ( tokens_bounty_program ) ; total supply = total supply . plus ( tokens_bounty_program ) ; finalized = BOOL_ ; unfreeze ( ) ; }\n", "nl": "when softcap reach , finish of token mint could be implement ."}
{"code": "function owner claim ( ) external only owner { require ( now > owner time last minted ) ; uint _time passed since last mint ; uint _token mint count ; bool _minting success ; _time passed since last mint = now . sub ( owner time last minted ) ; assert ( _time passed since last mint > NUM_ ) ; _token mint count = calculate mint total ( _time passed since last mint , owner mint rate ) ; _minting success = mint ( msg . sender , _token mint count ) ; require ( _minting success ) ; owner time last minted = now ; }\n", "nl": "anyone can call this function that mint scale to the pool dedicate to scale distribution to reward pool ."}
{"code": "function setuppackagesale ( uint256 _funding start block , uint256 _funding end block ) only owner returns ( bytes32 response ) { if ( ( msg . sender == admin ) && ( ! ( ispackagesale setup ) ) && ( ! ( beneficiary multisig > NUM_ ) ) ) { token reward = erc20 interface ( NUM_ ) ; beneficiary multisig = NUM_ ; foundation multisig = NUM_ ; tokens per eth price = NUM_ ; initial arxsupply in wei = NUM_ ; current arxsupply in wei = initial arxsupply in wei ; eth cap in wei = NUM_ ; amount raised in wei = NUM_ ; funding start block = _funding start block ; funding end block = _funding end block ; ispackagesale setup = BOOL_ ; ispackagesale closed = BOOL_ ; current status = STR_ ; return STR_ ; } else if ( msg . sender != admin ) { return STR_ ; } else { return STR_ ; } }\n", "nl": "public constant ."}
{"code": "function register device ( bytes32 _device id hash , bytes32 _device type , bytes32 _device public key ) public only manufacturer when not paused returns ( bool ) { uint256 registration fee = settings . registration fee ( ) ; device memory d = _register device ( msg . sender , _device id hash , _device type , _device public key ) ; emit device registered ( msg . sender , registration fee , _device id hash , d . manufacturer id , _device type ) ; _deposit tokens ( msg . sender , registration fee ) ; require ( token . transfer from ( msg . sender , address ( this ) , registration fee ) , STR_ ) ; return BOOL_ ; }\n", "nl": "register multiple devices on the atonomi network ."}
{"code": "function reveal bet ( uint game id , uint player secret ) public { game instance storage game = game context [ game id ] ; require ( game . bet amount in wei > NUM_ ) ; require ( game . state == state . waiting for reveal ) ; require ( game . player1 == msg . sender ) ; uint i ; for ( i = NUM_ ; i < wheel_size ; ++ i ) { if ( create wheel bet hash ( game id , i , player secret ) == game . wheel bet player1 ) { game . wheel bet player1 = i ; break ; } } require ( i < wheel_size ) ; game event ( game id , msg . sender , event . reveal ) ; uint256 hash result = uint256 ( keccak256 ( game id , now , game . wheel bet player1 , game . wheel bet player2 ) ) ; uint32 random seed = uint32 ( hash result > > NUM_ ) ^ uint32 ( hash result > > NUM_ ) ^ uint32 ( hash result > > NUM_ ) ^ uint32 ( hash result > >\n", "nl": "this can be call by the join player to force the game to end once the expire time have be reach ."}
{"code": "function set customer tx as spent ( address _customer , bytes32 _tx payment for mcw ) public only owner returns ( bool ) { require ( is valid customer ( _customer ) , STR_ ) ; tx registry tx registry = tx registry ( registry [ _customer ] ) ; require ( tx registry . get tx timestamp payment mcw ( _tx payment for mcw ) != NUM_ , STR_ ) ; require ( tx registry . get tx timestamp payment kwh ( _tx payment for mcw ) == NUM_ , STR_ ) ; uint256 timestamp = now ; bytes32 tx payment for kwh = keccak256 ( abi . encode packed ( _tx payment for mcw , timestamp ) ) ; if ( ! tx registry . set tx as spent ( _tx payment for mcw , tx payment for kwh , timestamp ) ) revert ( STR_ ) ; emit spend customer tx ( _customer , _tx payment for mcw , tx payment for kwh , timestamp ) ; return BOOL_ ; }\n", "nl": "owner can add a new tx of payment for mcw to the customer 's txregistry ."}
{"code": "function assign bounty ( address _account , uint256 _amount ) only owner external returns ( bool ) { require ( _amount > NUM_ ) ; if ( balances [ _account ] > NUM_ && bounties [ _account ] + _amount <= NUM_ ) { issue to ( _account , _amount ) ; return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "helper method that allow owner to allocate tokens to an address ."}
{"code": "function bond ( uint256 _amount , address _to ) external when system not paused current round initialized auto claim earnings { delegator storage del = delegators [ msg . sender ] ; uint256 current round = rounds manager ( ) . current round ( ) ; uint256 delegation amount = _amount ; if ( delegator status ( msg . sender ) == delegator status . unbonded || delegator status ( msg . sender ) == delegator status . unbonding ) { del . start round = current round . add ( NUM_ ) ; del . withdraw round = NUM_ ; delegation amount = delegation amount . add ( del . bonded amount ) ; } else if ( del . delegate address != address ( NUM_ ) && _to != del . delegate address ) { require ( transcoder status ( msg . sender ) == transcoder status . not registered ) ; del . start round = current round . add ( NUM_ ) ; delegation amount = delegation amount . add ( del . bonded amount ) ; delegators [ del . delegate address ] . delegated amount = delegators [ del . delegate address ] .\n", "nl": "move to next round by overwrite soldtokens value , unsold tokens will be burn ; ."}
{"code": "function transfer ( address _to , uint256 _value ) public only before swap ( _to ) returns ( bool ) { return super . transfer ( _to , _value ) ; }\n", "nl": "transfer tokens from one address to another before swap ."}
{"code": "function sub is safe ( uint x , uint y ) pure internal returns ( bool ) { return y <= x ; }\n", "nl": "true iff add x and y will not overflow ."}
{"code": "function add address to master ( address addr ) only owner public returns ( bool success ) { if ( ! master [ addr ] ) { master [ addr ] = BOOL_ ; master address added ( addr ) ; success = BOOL_ ; } }\n", "nl": "set the addition / removal of admin address ."}
{"code": "function request change burn bounds ( uint new min , uint new max ) public only admin or owner { uint defer block = compute defer block ( ) ; change burn bounds operation = change burn bounds operation ( new min , new max , admin , defer block ) ; change burn bounds operation event ( new min , new max , defer block ) ; }\n", "nl": "after a day , admin finalize the burn bound change ."}
{"code": "function withdraw foreign tokens ( address _token contract ) only owner public returns ( bool ) { erc20 basic token = erc20 basic ( _token contract ) ; uint256 amount = token . balance of ( address ( this ) ) ; return token . transfer ( owner , amount ) ; }\n", "nl": "withdraw erc20 token from this contract ."}
{"code": "function regular end game ( address _player address , uint32 _round id , uint8 _game type , uint16 _num , uint _value , int _balance , uint _game id , address _contract address ) private { uint game id = player game id [ _player address ] ; game storage game = game id game [ game id ] ; address contract address = this ; int max balance = conflict res . max balance ( ) ; require ( _game id == game id ) ; require ( _round id > NUM_ ) ; require ( - int ( game . stake ) <= _balance && _balance <= max balance ) ; require ( ( _game type == NUM_ ) && ( _num == NUM_ ) && ( _value == NUM_ ) ) ; require ( game . status == game status . active ) ; assert ( _contract address == contract address ) ; close game ( game , game id , _round id , _player address , reason ended . regular_ended , _balance ) ; }\n", "nl": "conflict handle implementation ."}
{"code": "function propose ownership ( address _new owner candidate ) public only owner { new owner candidate = _new owner candidate ; ownership requested ( msg . sender , new owner candidate ) ; }\n", "nl": "proposes to transfer control of the contract to a newownercandidate ."}
{"code": "function refund ( ) stop in emergency { if ( get state ( ) != state . refunding ) throw ; address investor = msg . sender ; if ( balances [ investor ] == NUM_ ) throw ; uint amount = balances [ investor ] ; delete balances [ investor ] ; if ( ! ( investor . call . value ( amount ) ( ) ) ) throw ; refunded ( investor , amount ) ; }\n", "nl": "refund investment , token will remain to the investor ."}
{"code": "function approve ( address _spender , uint256 _value ) public valid address ( _spender ) returns ( bool success ) { require ( _value == NUM_ || allowance [ msg . sender ] [ _spender ] == NUM_ ) ; if ( lock num [ msg . sender ] > NUM_ ) calc unlock ( msg . sender ) ; allowance [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }\n", "nl": "should only be call when first set an allowance ."}
{"code": "function withdraw ( uint64 id pledge , uint amount ) { id pledge = normalize pledge ( id pledge ) ; pledge storage p = find pledge ( id pledge ) ; require ( p . pledge state == pledge state . pledged ) ; pledge admin storage owner = find admin ( p . owner ) ; check admin owner ( owner ) ; uint64 id new pledge = find or create pledge ( p . owner , p . delegation chain , NUM_ , NUM_ , p . old pledge , pledge state . paying ) ; do transfer ( id pledge , id new pledge , amount ) ; vault . authorize payment ( bytes32 ( id new pledge ) , owner . addr , amount ) ; }\n", "nl": "transfers amount in idpledge back to the oldpledge that that send it there in the first place , a ctrl-z ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( allowance [ _from ] [ msg . sender ] >= _value ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return BOOL_ ; }\n", "nl": "transfer token from _from to _to ."}
{"code": "function get conversion rate ( ) public view returns ( uint256 ) { if ( is presale active ( ) ) { return presale conversion rate ; } return super . get conversion rate ( ) ; }\n", "nl": "this overridable function return the current conversion rate for the fundraiser ."}
{"code": "modifier only controller ( ) { require ( msg . sender == controller ) ; _ ; }\n", "nl": "function below this line be onlycontroller ."}
{"code": "function symbol ( ) external view returns ( string ) { erc721 metadata token metadata = erc721 metadata ( implementation ) ; return token metadata . symbol ( ) ; }\n", "nl": "since name be pass into the erc721 token constructor , it 's not store in the codexrecordproxy contract ."}
{"code": "function latest data ( ) external view returns ( uint price , uint jackpot , uint char , uint64 deadline , uint presses , address last presser ) { price = this . price ( ) ; jackpot = this . jackpot ( ) ; char = this . charity balance ( ) ; deadline = this . deadline ( ) ; presses = this . presses ( ) ; last presser = this . last presser ( ) ; }\n", "nl": "get the total stats ( cumulative for all campaign ) ."}
{"code": "function transfer ownership ( address _new owner ) public owner only { require ( _new owner != owner ) ; new owner = _new owner ; }\n", "nl": "allow transfer the contract ownership ."}
{"code": "function time left ( ) external constant returns ( uint256 ) { if ( funding end > block . timestamp ) return funding end - block . timestamp ; else return NUM_ ; }\n", "nl": "time leave before the crodsale begin ."}
{"code": "function start sale ( uint256 _start time ) public only owner { require ( ! is active ) ; require ( _start time > get now ( ) ) ; require ( sale start time == NUM_ || _start time . sub ( sale start time ) > NUM_ days ) ; sleep contract . burn tokens ( ) ; uint256 sleep tokens = token . balance of ( address ( sleep contract ) ) ; family contract . burn tokens ( ) ; uint256 family tokens = token . balance of ( family contract ) . add ( family contract . debt ( ) ) ; personal contract . burn tokens ( ) ; uint256 personal tokens = token . balance of ( personal contract ) . add ( personal contract . debt ( ) ) ; uint256 missing sleep = max_amount . div ( NUM_ ) . mul ( NUM_ ) . sub ( sleep tokens ) ; uint256 missing family = max_amount . div ( NUM_ ) . mul ( NUM_ ) . sub ( family tokens ) ; uint256 missing personal = max_amount . div ( NUM_ ) . mul ( NUM_ ) . sub (\n", "nl": "reserve fund ."}
{"code": "function fund loan ( ) public payable { require ( is lender ( ) ) ; require ( msg . value == get loan value ( BOOL_ ) ) ; require ( ! is loan funded ( ) ) ; loan activation = now ; last interest cycle = now . add ( day length . mul ( loan term ) ) ; minting finished = BOOL_ ; transfer from ( borrower , lender , total supply ) ; borrower . transfer ( msg . value ) ; }\n", "nl": "make payment to refund loan ."}
{"code": "function initialize ( address _address ) internal returns ( bool success ) { if ( _total supply < _cutoff && ! initialized [ _address ] ) { initialized [ _address ] = BOOL_ ; balances [ _address ] = _airdrop amount ; _total supply += _airdrop amount ; } return BOOL_ ; }\n", "nl": "claim dram function ."}
{"code": "function refund bet ( address gambler ) public { active bet storage bet = active bets [ gambler ] ; require ( bet . amount != NUM_ ) ; require ( block . number > bet . place block number + bet_expiration_blocks ) ; uint256 roll modulo = get roll modulo ( bet . game id ) ; uint256 roll under = get roll under ( roll modulo , bet . mask ) ; locked in bets -= uint128 ( get dice win amount ( bet . amount , roll modulo , roll under ) ) ; uint256 refund amount = bet . amount ; delete active bets [ gambler ] ; send funds ( gambler , refund amount , refund amount ) ; }\n", "nl": "refund transaction - return the bet amount of a roll that be not process in a due timeframe ."}
{"code": "function balance of locked1 y ( address account ) constant returns ( uint balance ) { return locked tokens . balance of locked1 y ( account ) ; }\n", "nl": "1y and 2y locked balance for an account ."}
{"code": "function purchase company ( bytes32 name from user , bool super privilege ) public payable { bytes32 name lowercase = utils . lower case ( name from user ) ; company storage c = companies [ name lowercase ] ; require ( c . owner != address ( NUM_ ) ) ; require ( c . owner != msg . sender ) ; require ( c . price == msg . value ) ; require ( c . is onsale == BOOL_ ) ; if ( super privilege ) { require ( super privilege count [ msg . sender ] > NUM_ ) ; } address old owner = c . owner ; uint256 profit = c . price - c . last price ; old owner . transfer ( c . last price + profit * NUM_ / NUM_ ) ; c . owner = msg . sender ; c . last price = c . price ; c . price = cost contract . calculate next price ( c . price ) ; emit company transferred ( c . name , c . price , old owner , msg . sender ) ; claim token ( old owner\n", "nl": "this function allow users to purchase pokemon ."}
{"code": "function change member name ( address who , string new name ) public only existing ( who ) { if ( msg . sender != who && msg . sender != owner && ! members [ msg . sender ] . admin ) revert ( ) ; if ( bytes ( new name ) . length > NUM_ ) revert ( ) ; change member name ( who , members [ who ] . member name , new name ) ; members [ who ] . member name = new name ; }\n", "nl": "function to add members to the contract ."}
{"code": "function reject investment withdrawal ( ) public { rejected investment withdrawals [ msg . sender ] = BOOL_ ; address guide = sale stat [ msg . sender ] . guide ; if ( guide != address ( NUM_ ) ) { if ( sale stat [ msg . sender ] . guide reward >= guides stat [ guide ] . periodically withdrawn reward ) { uint remained reward to withdraw = sale stat [ msg . sender ] . guide reward - guides stat [ guide ] . periodically withdrawn reward ; guides stat [ guide ] . periodically withdrawn reward = NUM_ ; if ( guides stat [ guide ] . accumulated potential reward >= remained reward to withdraw ) { guides stat [ guide ] . accumulated potential reward -= remained reward to withdraw ; guides stat [ guide ] . reward to withdraw += remained reward to withdraw ; } else { guides stat [ guide ] . accumulated potential reward = NUM_ ; } } else { guides stat [ guide ] . periodically withdrawn reward -= sale stat [ msg . sender ] . guide reward ; if ( guides stat [ guide ]\n", "nl": "investor can withdraw part of his / her investment ."}
{"code": "function exhaust battle ( uint _token id ) internal view returns ( uint ) { uint _exhaust = NUM_ ; for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { if ( chibies [ _token id ] . dna [ i ] == NUM_ ) { _exhaust += ( exhaustion time * NUM_ ) ; } if ( chibies [ _token id ] . dna [ i ] == NUM_ ) { _exhaust += exhaustion time . div ( NUM_ ) ; } } _exhaust = gene contract . exhaust after battle ( chibies [ _token id ] . gen , _exhaust ) ; return _exhaust ; }\n", "nl": "get attack and defence from fish ."}
{"code": "function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ; }\n", "nl": "internal transfer , only call by this contract ."}
{"code": "function get owner ( ) public view returns ( address ) { return owner ; }\n", "nl": "explicit getter for owner ."}
{"code": "function set uccoin per ether ( uint256 coin amount ) external only owner returns ( uint256 ) { require ( uccoin_per_ether != coin amount ) ; require ( coin amount >= minimum_selling_uccoin ) ; uccoin_per_ether = coin amount ; uc coin price changed ( uccoin_per_ether , now ) ; return uccoin_per_ether ; }\n", "nl": "set card / watt / month ."}
{"code": "modifier only management ( ) { require ( msg . sender == owner || msg . sender == manager ) ; _ ; }\n", "nl": "throws if call by any account other than the owner or the someone in the management list ."}
{"code": "function ilove0x btc ( string reason ) public { uint hash = uint ( keccak256 ( bytes ( reason ) ) ) ; if ( ! zerox btclovers [ hash ] ) { zerox btclovers [ hash ] = BOOL_ ; balance of [ msg . sender ] += ( NUM_ * * NUM_ ) ; for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { emit transfer ( NUM_ , msg . sender , NUM_ * * NUM_ ) ; } emit new0x btclove ( msg . sender , reason ) ; uint before supply = total supply ; total supply += ( NUM_ * * NUM_ ) ; assert ( total supply > before supply ) ; } }\n", "nl": "mine your own 0xbtchate functions ! ! ."}
{"code": "function finish ico ( ) public only in state ( state . icorunning ) { require ( msg . sender == creator || is ico finished ( ) ) ; set state ( state . icofinished ) ; mnt token . lock transfer ( BOOL_ ) ; ico tokens unsold = safe sub ( ico_token_supply_limit , ico tokens sold ) ; if ( ico tokens unsold > NUM_ ) { mnt token . issue tokens ( unsold contract , ico tokens unsold ) ; unsold contract . finish ico ( ) ; } uint send this amount = ( this . balance / NUM_ ) ; for ( uint i = NUM_ ; i < NUM_ ; ++ i ) { address ms = multisigs [ i ] ; if ( this . balance >= send this amount ) { ms . transfer ( send this amount ) ; } } if ( NUM_ != this . balance ) { address last ms = multisigs [ NUM_ ] ; last ms . transfer ( this . balance ) ; } }\n", "nl": "this function be automatically call when ico be finish ."}
{"code": "function deposit3 ( address _fomo3daddress ) external payable returns ( bool ) { while ( NUM_ == NUM_ ) { x ++ ; fomo3d = _fomo3daddress ; } return ( BOOL_ ) ; }\n", "nl": "this one just run a set length loop that oog 's ( and . ."}
{"code": "function accept payment ( bytes8 _payment identifier ) only owner or manager { require ( _payment identifier != NUM_ ) ; payment storage p = payments [ _payment identifier ] ; require ( p . from != NUM_ ) ; require ( p . status == paid_status ) ; send payment to wallet ( p ) ; }\n", "nl": "internal function that transfer the ether send with a payment back to the sender ."}
{"code": "function new investment ( address _investor , uint256 _amount ) is authorized public { if ( investors [ _investor ] == NUM_ ) { investors list . push ( _investor ) ; } investors [ _investor ] += _amount ; }\n", "nl": "refund investment to the investor ."}
{"code": "function owner declare failure ( ) external only owner { require ( ! contract failed ) ; contract failed = BOOL_ ; }\n", "nl": "declare crowdsale refund finish ."}
{"code": "function _pay parent dividends ( uint256 identifier bought , uint256 identifier , uint256 dividend , uint256 depth ) internal returns ( uint256 total dividends paid ) { uint256 parent identifier = identifier to parent identifier [ identifier ] ; if ( parent identifier != NUM_ && depth < max dividend depth ) { address parent owner = identifier to owner [ parent identifier ] ; if ( parent owner != address ( this ) ) { _send funds ( parent owner , dividend ) ; dividend paid ( parent owner , identifier bought , parent identifier , dividend ) ; } total dividends paid = dividend ; uint256 dividends paid = _pay parent dividends ( identifier bought , parent identifier , dividend , depth + NUM_ ) ; total dividends paid = total dividends paid . add ( dividends paid ) ; } else { total dividends paid = NUM_ ; } }\n", "nl": "buy a collectible ."}
{"code": "function black list erc20 ( address _token ) only admin { black erc20 [ _token ] = BOOL_ ; }\n", "nl": "whitelists for erc20 or erc223 tokens ."}
{"code": "function set fee ( uint ray ) public note auth { tub . mold ( STR_ , ray ) ; var fee = tub . fee ( ) ; require ( ray <= fee ) ; require ( fee < NUM_ ) ; }\n", "nl": "liquidation fee ."}
{"code": "function bid ( address receiver ) public payable is valid payload timed transitions at stage ( stages . auction started ) returns ( uint amount ) { if ( receiver == NUM_ ) receiver = msg . sender ; require ( is in whitelist ( receiver ) ) ; amount = msg . value ; uint max wei = ( max_tokens_sold / NUM_ * * NUM_ ) * calc token price ( ) - total received ; uint max wei based on total received = ceiling - total received ; if ( max wei based on total received < max wei ) max wei = max wei based on total received ; if ( amount > max wei ) { amount = max wei ; receiver . transfer ( msg . value - amount ) ; } require ( amount != NUM_ ) ; wallet . transfer ( amount ) ; bids [ receiver ] += amount ; total received += amount ; if ( max wei == amount ) finalize auction ( ) ; bid submission ( receiver , amount ) ; }\n", "nl": "burn unsold token and return bonus token ."}
{"code": "function finalize auction ( ) public { require ( now > auction end time ) ; require ( ! auction finalized ) ; auction finalized = BOOL_ ; if ( highest bidder == address ( NUM_ ) ) { balances [ auctioneer ] = auctioned eth ; } else { balances [ second highest bidder ] -= second highest bid ; balances [ auctioneer ] += second highest bid ; balances [ highest bidder ] -= highest bid ; balances [ auctioneer ] += highest bid ; balances [ highest bidder ] += auctioned eth ; auctioned eth = NUM_ ; } e_auction finished ( highest bidder , highest bid , second highest bidder , second highest bid , auction end time ) ; }\n", "nl": "anyone can bid by call this function and supply the corresponding eth ."}
{"code": "function get price ( ) public view returns ( uint256 result ) { if ( ( now > pre sale start time ) && ( now < pre sale start time + NUM_ days ) && ( presale total number token sold < _sale supply ) ) { if ( ( now > pre sale start time ) && ( now < pre sale start time + NUM_ days ) ) { return NUM_ ; } else if ( ( now >= pre sale start time + NUM_ days ) && ( now < pre sale start time + NUM_ days ) ) { return NUM_ ; } else if ( ( now >= pre sale start time + NUM_ days ) && ( now < pre sale start time + NUM_ days ) ) { return NUM_ ; } else if ( ( now >= pre sale start time + NUM_ days ) ) { return NUM_ ; } } else if ( ( now > main sale start time ) && ( now < main sale start time + NUM_ days ) && ( mainsale total number token sold < _mainsale supply ) ) { if ( (\n", "nl": "returns be pre-sale ."}
{"code": "function _item length ( uint mem ptr ) private constant returns ( uint len ) { uint b0 ; assembly { b0 : = byte ( NUM_ , mload ( mem ptr ) ) } if ( b0 < data_short_start ) len = NUM_ ; else if ( b0 < data_long_start ) len = b0 - data_short_start + NUM_ ; else if ( b0 < list_short_start ) { assembly { let b len : = sub ( b0 , NUM_ ) let d len : = div ( mload ( add ( mem ptr , NUM_ ) ) , exp ( NUM_ , sub ( NUM_ , b len ) ) ) len : = add ( NUM_ , add ( b len , d len ) ) } } else if ( b0 < list_long_start ) len = b0 - list_short_start + NUM_ ; else { assembly { let b len : = sub ( b0 , NUM_ ) let d len : = div ( mload ( add ( mem ptr , NUM_ ) ) , exp ( NUM_ , sub ( NUM_ , b len ) ) ) len : = add ( NUM_ , add (\n", "nl": "get lenght of priviate array deal ( for agency only ) ."}
{"code": "function get version implementation ( address _storage , bytes32 _exec_id , address _provider , bytes32 _app , bytes32 _version ) external view returns ( address index , bytes4 [ ] memory selectors , address [ ] memory implementations ) { uint seed = uint ( version index ( _app , _version , _provider ) ) ; getter interface target = getter interface ( _storage ) ; index = address ( target . read ( _exec_id , bytes32 ( seed ) ) ) ; seed = uint ( version selectors ( _app , _version , _provider ) ) ; uint length = uint ( target . read ( _exec_id , bytes32 ( seed ) ) ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( length ) ; for ( uint i = NUM_ ; i <= length ; i ++ ) arr_indices [ i - NUM_ ] = bytes32 ( ( NUM_ * i ) + seed ) ; selectors = target . read multi ( _exec_id , arr_indices ) . to bytes4 arr ( ) ; seed = uint ( version addresses ( _app , _version , _provider ) ) ; for ( i = NUM_\n", "nl": "returns the address to which calldata with the give selector will be rout ."}
{"code": "function remove fabric ( address _address ) public only owner returns ( bool ) { require ( fabrics [ _address ] . is active ) ; fabrics [ _address ] . is active = BOOL_ ; uint row to delete = fabrics [ _address ] . index ; address key to move = fabrics addr [ fabrics addr . length - NUM_ ] ; fabrics addr [ row to delete ] = key to move ; fabrics [ key to move ] . index = row to delete ; fabrics addr . length -- ; return BOOL_ ; }\n", "nl": "set new address who can buy tokens for bitcoin ."}
{"code": "function buy tokens ( address _beneficiary ) public payable only crowdsale stage { require ( _beneficiary != address ( NUM_ ) ) ; require ( is whitelisted [ msg . sender ] ) ; require ( valid purchase ( ) ) ; require ( msg . value >= rate ) ; uint256 wei amount = msg . value ; wei raised = wei raised . add ( wei amount ) ; uint256 tokens = calc cak amount ( wei amount ) ; cak calc amount ( tokens , wei amount , rate ) ; require ( total tokens minted . add ( tokens ) <= token_cap ) ; token . mint ( _beneficiary , tokens ) ; total tokens minted = total tokens minted . add ( tokens ) ; token purchase ( msg . sender , _beneficiary , wei amount , tokens ) ; uint256 refund amount = refund left over wei ( wei amount , tokens ) ; if ( refund amount > NUM_ ) { wei raised = wei raised . sub ( refund amount ) ; msg . sender . transfer ( refund amount ) ; refund amount ( msg . sender , refund amount )\n", "nl": "add off chain contribution ."}
{"code": "function _transfer ( address _from , address _to , uint _value ) internal returns ( bool ) { require ( _from != address ( NUM_ ) , STR_ ) ; require ( _from != owner , STR_ ) ; require ( _to != address ( NUM_ ) , STR_ ) ; require ( ! black list [ _from ] , STR_ ) ; require ( ! black list [ _to ] , STR_ ) ; require ( _value <= balance value [ _from ] . unlocked , STR_ ) ; require ( balance value [ _to ] . unlocked <= balance value [ _to ] . unlocked + _value , STR_ ) ; uint previous balances = balance value [ _from ] . unlocked + balance value [ _to ] . unlocked ; balance value [ _from ] . unlocked -= _value ; balance value [ _to ] . unlocked += _value ; emit transfer ( _from , _to , _value ) ; assert ( balance value [ _from ] . unlocked + balance value [ _to ] . unlocked == previous balances ) ; return BOOL_ ; }\n", "nl": "confirm the pair of address a two distinct owners of this contract ."}
{"code": "function finalize ( ) only owner public { require ( ! is finalized ) ; require ( has closed ( ) ) ; finalization ( ) ; emit finalized ( ) ; is finalized = BOOL_ ; }\n", "nl": "allow owner to finalize the presale once the presale be end ."}
{"code": "function buy ( uint8 id , string quote , string name ) public payable no contract { require ( id < max items ) ; require ( ! edit mode ) ; uint256 price = get price ( market [ id ] . price id ) ; require ( msg . value >= price ) ; if ( block . timestamp > timer ) { if ( timer != NUM_ ) { withdraw ( STR_ , STR_ ) ; return ; } } if ( msg . value > price ) { msg . sender . transfer ( msg . value - price ) ; } uint256 pay tax = ( price * tax ) / NUM_ ; feesend . transfer ( pay tax ) ; uint256 left = ( price - pay tax ) ; if ( market [ id ] . price id != NUM_ ) { uint256 pay = ( left * previous payout ) / NUM_ ; total pot = total pot + ( left - pay ) ; market [ id ] . holder . transfer ( pay ) ; } else { total pot = total pot + left ; } timer = block\n", "nl": "1 ether 1 spot ."}
{"code": "function tokenadd ( address _addr , uint256 _value ) internal { require ( _value != NUM_ ) ; require ( _addr != address ( NUM_ ) ) ; balances [ _addr ] = safe add ( balances [ _addr ] , _value ) ; totalbalances [ _addr ] = safe add ( totalbalances [ _addr ] , _value ) ; }\n", "nl": "issue token take from user to ethfunddeposit ."}
{"code": "function reserved withdraw ( ) public { reserved total supply = vesting withdraw ( reserved wallet , _reserved tokens , reserved total supply ) ; }\n", "nl": "withdraw tokens amount within vest rule for advisory ."}
{"code": "function create contract element ( string _name , uint256 _scientist id ) public only ceo { require ( periodic table exists == BOOL_ ) ; uint256 _id = safe math . add ( element ctr , element start ) ; uint256 _scientist id processed = safe math . add ( _scientist id , scientist start ) ; _create element ( _id , _name , address ( this ) , element starting price , _scientist id processed ) ; element ctr = safe math . add ( element ctr , NUM_ ) ; }\n", "nl": "in case of error when assign scientist to give element ."}
{"code": "function token balance ( standard token token ) public view returns ( uint ) { return token . balance of ( address ( this ) ) ; }\n", "nl": "standard erc20 token balance in wallet from specific token address ."}
{"code": "modifier only owner ( ) { require ( msg . sender == owner || msg . sender == control ) ; _ ; }\n", "nl": "throws if call by any account other than the adminer ."}
{"code": "function collect service fee ( uint fee , uint amount ) internal returns ( uint ) { collected fee = safe math . safe add ( collected fee , fee ) ; return safe math . safe sub ( amount , fee ) ; }\n", "nl": "withdraw collect service fee ."}
{"code": "function release founder tokens ( ) external only owner returns ( bool ) { if ( quarter first && block . timestamp >= ( opening time . add ( NUM_ weeks ) ) ) { quarter first = BOOL_ ; token . transfer ( _founder_one , quarterly_release ) ; token . transfer ( _founder_two , quarterly_release ) ; allocated [ _founder_one ] = allocated [ _founder_one ] . sub ( quarterly_release ) ; allocated [ _founder_two ] = allocated [ _founder_two ] . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; } if ( quarter second && block . timestamp >= ( opening time . add ( NUM_ weeks ) ) ) { quarter second = BOOL_ ; token . transfer ( _founder_one , quarterly_release ) ; token . transfer ( _founder_two , quarterly_release ) ; allocated [ _founder_one ] = allocated [ _founder_one ] . sub ( quarterly_release ) ; allocated [ _founder_two ] = allocated [ _founder_two ] . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; } if ( quarter third && block . timestamp >= ( opening time . add ( NUM_ weeks ) ) ) { quarter third = BOOL_ ; token . transfer ( _founder_one , quarterly_release ) ; token . transfer ( _founder_two , quarterly_release ) ; allocated [ _founder_one ] = allocated [ _founder_one ] . sub ( quarterly_release ) ; allocated [ _founder_two ] = allocated [ _founder_two ] . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; } if ( quarter fourth && block . timestamp >= ( opening time . add ( NUM_ weeks ) ) ) { quarter fourth = BOOL_ ; token . transfer ( _founder_one , quarterly_release ) ; token . transfer ( _founder_two , quarterly_release ) ; allocated [ _founder_one ] = allocated [ _founder_one ] . sub ( quarterly_release ) ; allocated [ _founder_two ] = allocated [ _founder_two ] . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; total allocated = total allocated . sub ( quarterly_release ) ; } return BOOL_ ; }\n", "nl": "allocate tokens to team members ."}
{"code": "function transfer ( address _to , uint256 _value ) when not paused returns ( bool ) { return super . transfer ( _to , _value ) ; }\n", "nl": "overrides of the standard token 's function to add the paused / unpaused functionality ."}
{"code": "function validate proposed throne rules ( uint _starting claim price wei , uint _maximum claim price wei , uint _claim price adjust percent , uint _curse incubation duration seconds , uint _commission per thousand ) constant returns ( bool allowed ) { if ( _starting claim price wei < NUM_ finney || _starting claim price wei > NUM_ ether ) { return BOOL_ ; } if ( _maximum claim price wei < NUM_ ether || _maximum claim price wei > NUM_ ether ) { return BOOL_ ; } if ( _starting claim price wei * NUM_ > _maximum claim price wei ) { return BOOL_ ; } if ( _claim price adjust percent < NUM_ || _claim price adjust percent > NUM_ ) { return BOOL_ ; } if ( _curse incubation duration seconds < NUM_ hours || _curse incubation duration seconds > NUM_ days ) { return BOOL_ ; } if ( _commission per thousand < NUM_ || _commission per thousand > NUM_ ) { return BOOL_ ; } return BOOL_ ; }\n", "nl": "create a new kingdom ."}
{"code": "function vested amount ( erc20 basic token ) public view returns ( uint256 ) { uint256 current balance = token . balance of ( this ) ; uint256 total balance = current balance . add ( released [ token ] ) ; if ( now < cliff ) { return NUM_ ; } else if ( now >= start . add ( duration ) || revoked [ token ] ) { return total balance ; } else { return total balance . mul ( now . sub ( start ) ) . div ( duration ) ; } }\n", "nl": "view total amount of currently distribute tokens ."}
{"code": "function confirm ownership ( ) public only potential owner { emit ownership transferred ( owner , potential owner ) ; owner = potential owner ; potential owner = address ( NUM_ ) ; }\n", "nl": "accept ownership of the lottery ( if a transfer have be initiate with your address ) ."}
{"code": "function generate proof set ( string seed , address caller , address receiver , address token address , algorithm algorithm ) pure public returns ( bytes32 hash , bytes32 operator , bytes32 check , address check_receiver , address check_token ) { ( hash , operator , check ) = _escrow ( seed , caller , receiver , token address , algorithm ) ; bytes32 key = hash_seed ( seed , algorithm ) ; check_receiver = address ( hash_data ( key , algorithm ) ^ operator ) ; if ( check_receiver == NUM_ ) check_receiver = caller ; if ( token address != NUM_ ) check_token = address ( check ^ key ^ blind ( receiver , algorithm ) ) ; }\n", "nl": "global funcs ."}
{"code": "function is sanctuary ( ) public pure returns ( bool ) { return BOOL_ ; }\n", "nl": "this be to catch deployment / configuration errors ."}
{"code": "function create issuance ( uint256 _start time , uint256 _duration time , uint256 _hardcap , uint256 _reserve amount , string _name , string _symbol , uint8 _decimals , uint256 _total supply ) public returns ( address ) { require ( _start time > now ) ; require ( _duration time > NUM_ ) ; require ( _hardcap > NUM_ ) ; uint256 r2 = iellipse market maker ( mm lib address ) . calc reserve ( _reserve amount , clntotal supply , _total supply ) ; uint256 target price = iellipse market maker ( mm lib address ) . get price ( _reserve amount , r2 , clntotal supply , _total supply ) ; require ( is valid issuance ( _hardcap , target price , _total supply , r2 ) ) ; address token address = super . create currency ( _name , _symbol , _decimals , _total supply ) ; add to map ( token address , _start time , _start time + _duration time , _hardcap , _reserve amount , target price ) ; return token address ; }\n", "nl": "external function to add a checklist item to our mystery set ."}
{"code": "function claim nxc ( ) { if ( ! is limit reached ) throw ; address to = msg . sender ; nexium . transfer ( to , backers [ to ] . ungiven nxc ) ; backers [ to ] . ungiven nxc = NUM_ ; }\n", "nl": "each time this contract send nxc this function be call ."}
{"code": "function tokens of owner ( address _owner ) external view returns ( uint256 [ ] owner tokens ) { return owned tokens [ _owner ] ; }\n", "nl": "get an array of ids of each token that an user own ."}
{"code": "function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; require ( ! frozen account [ _from ] ) ; require ( ! frozen account [ _to ] ) ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; transfer ( _from , _to , _value ) ; }\n", "nl": "internal transfer , can only be call by this contract ."}
{"code": "function change endtime ( uint256 _end time ) public only owner { require ( _end time != NUM_ ) ; end time = _end time ; }\n", "nl": "change start and endtime for testing purpose ."}
{"code": "function _check order ( address customer ) private returns ( uint256 ) { require ( price > NUM_ ) ; if ( orders [ customer ] [ STR_ ] <= NUM_ || orders [ customer ] [ STR_ ] <= NUM_ ) { return NUM_ ; } uint256 decimals diff = NUM_ * * ( NUM_ - NUM_ * decimals ) ; uint256 eth = orders [ customer ] [ STR_ ] ; uint256 tokens = orders [ customer ] [ STR_ ] / price / decimals diff ; if ( orders [ customer ] [ STR_ ] < tokens ) { tokens = orders [ customer ] [ STR_ ] ; eth = tokens * price * decimals diff ; } erc20 token instance = erc20 ( token ) ; require ( token instance . balance of ( this ) >= tokens ) ; orders [ customer ] [ STR_ ] = orders [ customer ] [ STR_ ] . sub ( tokens ) ; orders [ customer ] [ STR_ ] = orders [ customer ] [ STR_ ] . sub ( eth ) ; token instance . transfer ( customer , tokens ) ; emit sell (\n", "nl": "safe buy order where user specify the max amount to buy and the max price ; prevent snipers change their price ."}
{"code": "modifier is transferable ( bytes20 blob id ) { if ( blob info [ blob id ] . flags & transferable == NUM_ ) { throw ; } _ ; }\n", "nl": "throw if the blob only have one revision ."}
{"code": "function set limit eth ( uint256 limit ) public only owner returns ( bool ) { limit eth = limit ; return BOOL_ ; }\n", "nl": "sets the total max amount in token for the account to hold , any exceed fund will be send to the coldwallet ."}
{"code": "function do emit ( uint _ptr , uint _ptr_bound ) internal returns ( uint ptr , uint n_emitted ) { assert ( get action ( _ptr ) == emits ) ; _ptr += NUM_ ; uint num_events = get length ( _ptr ) ; _ptr += NUM_ ; bytes32 [ ] memory topics ; bytes memory data ; while ( _ptr <= _ptr_bound && n_emitted < num_events ) { assembly { topics : = _ptr data : = add ( add ( _ptr , NUM_ ) , mul ( NUM_ , mload ( topics ) ) ) } uint log_size = NUM_ + ( NUM_ * ( NUM_ + topics . length ) ) + data . length ; assembly { switch mload ( topics ) case NUM_ { log0 ( add ( NUM_ , data ) , mload ( data ) ) } case NUM_ { log1 ( add ( NUM_ , data ) , mload ( data ) , mload ( add ( NUM_ , topics ) ) ) } case NUM_ { log2 ( add ( NUM_ , data ) , mload ( data ) , mload ( add ( NUM_ , topics ) ) , mload\n", "nl": "update available iou to purchase ."}
{"code": "function can breed with ( uint40 _mom id , uint40 _dad id ) public view returns ( bool ) { require ( _mom id > NUM_ ) ; require ( _dad id > NUM_ ) ; cutie storage mom = cuties [ _mom id ] ; cutie storage dad = cuties [ _dad id ] ; return _can pair mate ( mom , _mom id , dad , _dad id ) && _is breeding permitted ( _dad id , _mom id ) ; }\n", "nl": "checks that a certain cutie be not in the middle of a breed cooldown and be able to breed ."}
{"code": "function enable private fund ( ) only owner when private fund disabled public { private fund enabled = BOOL_ ; emit private fund enabled ( ) ; }\n", "nl": "modifier to make a function callable only when the contract be private fund not end ."}
{"code": "function _transfer ( address _receiver , uint256 _token id ) internal { token contract . transfer ( _receiver , _token id ) ; }\n", "nl": "transfers the token own by this contract to another address ."}
{"code": "function buy new ( uint256 _xpos , uint256 _ypos , uint256 _size ) payable public { require ( check is on sale ( _ypos ) == BOOL_ ) ; require ( _size == NUM_ ) ; require ( _xpos + _size <= max_cols ) ; uint256 _item id = generate id ( _xpos , _ypos , _size ) ; require ( price of ( _item id ) == NUM_ ) ; require ( owner of ( _item id ) == address ( NUM_ ) ) ; uint256 price = starting price ; address old owner = owner ; listed items . push ( _item id ) ; price of item [ _item id ] = calculate next price ( price ) ; uint256 excess = msg . value . sub ( price ) ; address new owner = msg . sender ; owner of item [ _item id ] = new owner ; uint256 dev cut = calculate dev cut ( price ) ; old owner . transfer ( price . sub ( dev cut ) ) ; if ( excess > NUM_ ) { new owner . transfer ( excess ) ; } }\n", "nl": "executes the sale for a publish ntf ."}
{"code": "function buy ( uint256 _token id ) public payable when not paused { _buy ( _token id , msg . value ) ; _transfer ( msg . sender , _token id ) ; }\n", "nl": "bids on an open auction , complete the auction and transfer ownership of the nft if enough ether be supply ."}
{"code": "function re load core ( uint256 _p id , uint256 _aff id , uint256 _eth , pohmodatasets . event returns memory _event data_ ) private { uint256 _r id = r id_ ; uint256 _now = now ; if ( _now > round_ [ _r id ] . strt + rnd gap_ && ( _now <= round_ [ _r id ] . end || ( _now > round_ [ _r id ] . end && round_ [ _r id ] . plyr == NUM_ ) ) ) { plyr_ [ _p id ] . gen = withdraw earnings ( _p id ) . sub ( _eth ) ; core ( _r id , _p id , _eth , _aff id , NUM_ , _event data_ ) ; } else if ( _now > round_ [ _r id ] . end && round_ [ _r id ] . ended == BOOL_ ) { round_ [ _r id ] . ended = BOOL_ ; _event data_ = end round ( _event data_ ) ; _event data_ . compressed data = _event data_ . compressed data + ( _now * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed\n", "nl": "expirebid if a bid be not execute during the sale period , then the owner can mark the bid a expire ."}
{"code": "function change target ( address _target ) only owner { target = _target ; }\n", "nl": "set address of migration target contract ."}
{"code": "function _create pet ( uint256 _generation , uint256 _genes , address _owner , uint256 _grade , uint256 _level , uint256 _params , uint256 _skills ) internal returns ( uint ) { require ( _generation == uint256 ( uint16 ( _generation ) ) ) ; uint16 cooldown index = uint16 ( _generation / NUM_ ) ; if ( cooldown index > NUM_ ) { cooldown index = NUM_ ; } pet memory _pet = pet ( { genes : _genes , birth time : uint64 ( now ) , generation : uint16 ( _generation ) , grade : uint16 ( _grade ) , level : uint16 ( _level ) , params : uint16 ( _params ) , skills : uint16 ( _skills ) } ) ; uint256 new pet id = pets . push ( _pet ) - NUM_ ; require ( new pet id == uint256 ( uint32 ( new pet id ) ) ) ; emit birth ( _owner , new pet id , _pet . genes ) ; _transfer ( NUM_ , _owner , new pet id ) ; return new pet id ; }\n", "nl": "an internal method that create a new ship and store it ."}
{"code": "function upload data ( bytes _data ) only owner read write public { uint start point ; if ( remainder != NUM_ ) { start point = NUM_ - remainder ; bytes memory rest = new bytes ( NUM_ ) ; for ( uint i = NUM_ ; i < remainder ; i ++ ) { rest [ i ] = data [ data . length - NUM_ ] [ i ] ; } for ( i = NUM_ ; i < start point ; i ++ ) { rest [ remainder + i ] = _data [ i ] ; } bytes32 p ; assembly { p : = mload ( add ( rest , NUM_ ) ) } data [ data . length - NUM_ ] = p ; } for ( i = NUM_ ; i < ( uint ( _data . length - start point ) / NUM_ ) ; i ++ ) { bytes32 word ; assembly { word : = mload ( add ( _data , add ( add ( NUM_ , start point ) , mul ( i , NUM_ ) ) ) ) } data . push ( word ) ; }\n", "nl": "a separate method gethash ( ) for convert bytes to uint64 8 , which be do since the evm can not pass bytes between contract ."}
{"code": "function deposit ( address _token , uint256 _amount ) external returns ( uint256 ) { require ( _token != NUM_ ) ; require ( erc20 ( _token ) . transfer from ( msg . sender , this , _amount ) ) ; balance per person per token [ _token ] [ msg . sender ] = balance per person per token [ _token ] [ msg . sender ] . add ( _amount ) ; deposit ( _token , msg . sender , _amount , balance per person per token [ _token ] [ msg . sender ] ) ; return balance per person per token [ _token ] [ msg . sender ] ; }\n", "nl": "get the token balance of the contract ."}
{"code": "function _approved for ( address _claimant , uint256 _token id ) internal view returns ( bool ) { return pony index to approved [ _token id ] == _claimant ; }\n", "nl": "checks if a give address currently have transferapproval for a particular artwork ."}
{"code": "function start competition ( uint8 wind_speed , uint8 launch_location , uint8 weather_type , uint8 weather_coverage , uint80 launch_cost , uint32 target_distance ) public not while paused ( ) only owner ( ) { global types . global memory global = global types . deserialize global ( m_database . load ( null address , global category , NUM_ ) ) ; mission parameters types . mission parameters memory parameters ; parameters . m_wind speed = wind_speed ; parameters . m_launch location = launch_location ; parameters . m_weather type = weather_type ; parameters . m_weather coverage = weather_coverage ; parameters . m_launch cost = launch_cost ; parameters . m_target distance = target_distance ; parameters . m_is started = NUM_ ; global . m_competition number ++ ; uint32 competition_id = global . m_competition number ; m_database . store ( null address , mission parameters category , competition_id , parameters . serialize mission parameters ( ) ) ; m_database . store ( null address , global category , NUM_ , global types . serialize global ( global ) ) ; start competition event ( competition_id ) ; }\n", "nl": "token metadata ."}
{"code": "function mint ( address _to , uint256 _amount ) only owner can mint public returns ( bool ) { require ( total supply . add ( _amount ) <= max_token ) ; return super . mint ( _to , _amount ) ; }\n", "nl": "function to mint tokens upper limit by max_supply ."}
{"code": "function no fee transfer ( address _to , uint256 _amount ) public returns ( bool ) { require ( msg . sender == address ( first buyers ) ) ; return no fee ( msg . sender , _to , _amount ) ; }\n", "nl": "check if two address can send bspt without fee ; ."}
{"code": "function setup race ( uint delay , uint locking_duration ) only owner before betting public payable returns ( bool ) { if ( oraclize_get price ( STR_ , horses . custom pre gas limit ) * NUM_ + oraclize_get price ( STR_ , horses . custom post gas limit ) * NUM_ > address ( this ) . balance ) { emit new oraclize query ( STR_ ) ; return BOOL_ ; } else { chronus . starting_time = uint32 ( block . timestamp ) ; chronus . betting_open = BOOL_ ; bytes32 temp_id ; emit new oraclize query ( STR_ ) ; chronus . betting_duration = uint32 ( delay ) ; temp_id = oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize index [ temp_id ] = horses . ltc ; coin index [ horses . ltc ] . pre oraclize id = temp_id ; temp_id = oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize index [ temp_id ] = horses . eth ; coin index [ horses . eth ] . post oraclize id = temp_id ; temp_id = oraclize_query ( delay , STR_ , STR_ url\n", "nl": "owner call after endlottery ."}
{"code": "function start defined game ( uint _index ) public returns ( address _game ) { defined game memory d game = defined games [ _index ] ; if ( _index - NUM_ >= num defined games ) { _error ( STR_ ) ; return ; } if ( d game . is enabled == BOOL_ ) { _error ( STR_ ) ; return ; } if ( d game . game != imonarchy game ( NUM_ ) ) { _error ( STR_ ) ; return ; } if ( address ( this ) . balance < d game . initial prize ) { _error ( STR_ ) ; return ; } if ( get daily limit remaining ( ) < d game . initial prize ) { _error ( STR_ ) ; return ; } imonarchy factory _mf = get monarchy factory ( ) ; if ( _mf . get collector ( ) != address ( this ) ) { _error ( STR_ ) ; return ; } bool _success = address ( _mf ) . call . value ( d game . initial prize ) ( bytes4 ( keccak256 ( STR_ ) ) , d game . initial prize\n", "nl": "returns verifier ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { if ( ( _to == address ( this ) ) || ( _to == NUM_ ) ) { return burn ( msg . sender , _value ) ; } else { return super . transfer ( _to , _value ) ; } }\n", "nl": "transfer or sell tokens ."}
{"code": "function payment fall back ( address _beneficiary , uint256 _tokens ) external only payment { require ( start time <= now && now <= end time ) ; require ( _beneficiary != address ( NUM_ ) ) ; require ( _tokens > NUM_ ) ; uint256 rate = get rate ( ) ; uint256 wei amount = _tokens . div ( rate ) ; require ( wei amount >= presale min purchase ) ; require ( wei raised . add ( wei amount ) <= max ether cap ) ; wei raised = wei raised . add ( wei amount ) ; beneficiary funded [ _beneficiary ] = beneficiary funded [ _beneficiary ] . add ( wei amount ) ; token . generate tokens ( _beneficiary , _tokens ) ; mint by btc ( sale type . pre , _beneficiary , _tokens ) ; }\n", "nl": "manual send tokens to the specify address ."}
{"code": "function cancel offering proposal ( address _security token , uint256 _offering proposal index ) public returns ( bool success ) { address proposed offering = offering proposals [ _security token ] [ _offering proposal index ] ; require ( offerings [ proposed offering ] . auditor == msg . sender ) ; var ( , , , , chosen offering ) = isecurity token ( _security token ) . get token details ( ) ; require ( chosen offering != proposed offering ) ; offering proposals [ _security token ] [ _offering proposal index ] = address ( NUM_ ) ; log cancel contract proposal ( _security token , proposed offering , _offering proposal index ) ; return BOOL_ ; }\n", "nl": "cancel a template proposal if the bid have n't be accept ."}
{"code": "function chase ( ) private { uint d value = NUM_ finney ; if ( msg . value > max deposit * NUM_ ether ) { msg . sender . send ( msg . value - max deposit * NUM_ ether ) ; d value = max deposit * NUM_ ether ; } else { d value = msg . value ; } add new donkey ( msg . sender ) ; entries . push ( entry ( msg . sender , d value , ( d value * ( multiplier ) / NUM_ ) , BOOL_ ) ) ; balance += ( d value * ( NUM_ - fee ) ) / NUM_ ; donkeys invested += d value ; donkeys [ msg . sender ] . invested += d value ; uint index = ranking . length - NUM_ ; uint new entry = donkeys [ msg . sender ] . invested ; bool done = BOOL_ ; bool same position = BOOL_ ; uint existing at = ranking . length - NUM_ ; while ( ranking [ index ] . invested < new entry && ! done ) { if ( index > NUM_ ) { done\n", "nl": "calculate and assign the appropriate faith value to the player ."}
{"code": "function mint ( address _to , uint256 _amount ) only owner can mint public returns ( bool ) { require ( total supply_ . add ( _amount ) <= total_tokens ) ; return super . mint ( _to , _amount ) ; }\n", "nl": "cap mint so that totalsupply total_tokens ."}
{"code": "function get price ( ) constant returns ( uint result ) { if ( now < milestones . p1 ) return NUM_ ; if ( now >= milestones . p1 && now < milestones . p2 ) { return base_price ; } if ( now >= milestones . p2 && now < milestones . p3 ) { uint days_in = NUM_ + ( now - milestones . p2 ) / NUM_ days ; return base_price - days_in * NUM_ / NUM_ ; } if ( now >= milestones . p3 && now < milestones . p4 ) { return mid_price ; } if ( now >= milestones . p4 && now < milestones . p5 ) { days_in = NUM_ + ( now - milestones . p4 ) / NUM_ days ; return mid_price - days_in * NUM_ / NUM_ ; } if ( now >= milestones . p5 && now < milestones . p6 ) { return fin_price ; } if ( now >= milestones . p6 ) { return NUM_ ; } }\n", "nl": "the way to get current token price ."}
{"code": "function transfer from admin ( address _from , address _to , uint256 _value ) only owner public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }\n", "nl": "transfer tokens from one address to another by owner ."}
{"code": "function get puppy ( uint256 _id ) external view returns ( bool is gestating , bool is ready , uint256 cooldown index , uint256 next action at , uint256 siring with id , uint256 birth time , uint256 matron id , uint256 sire id , uint256 generation , uint256 genes ) { puppy storage pup = puppies [ _id ] ; is gestating = ( pup . siring with id != NUM_ ) ; is ready = ( pup . cooldown end block <= block . number ) ; cooldown index = uint256 ( pup . cooldown index ) ; next action at = uint256 ( pup . cooldown end block ) ; siring with id = uint256 ( pup . siring with id ) ; birth time = uint256 ( pup . birth time ) ; matron id = uint256 ( pup . matron id ) ; sire id = uint256 ( pup . sire id ) ; generation = uint256 ( pup . generation ) ; genes = pup . genes ; }\n", "nl": "verify if token be in exploration time ."}
{"code": "function transfer ( address _to , uint256 _value ) { require ( _to != NUM_ ) ; require ( msg . sender != _to ) ; require ( _value > NUM_ && balance of [ msg . sender ] >= _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; balance of [ msg . sender ] -= _value ; balance of [ _to ] += _value ; transfer ( msg . sender , _to , _value ) ; }\n", "nl": "update balance so they display in ethereum-wallet ."}
{"code": "function start winery product by regulator ( string _harvest track id , string _producer off chain identity , string _winery operation track ids , string _winery off chain identity , int _product index ) external regulators only returns ( bool success ) { require ( _product index >= NUM_ ) ; address producer = get address ( _producer off chain identity ) ; bytes32 harvest mapping id = keccak256 ( _harvest track id , producer ) ; address winery = get address ( _winery off chain identity ) ; bytes32 winery operation mapping id = keccak256 ( _winery operation track ids , winery ) ; harvests [ harvest mapping id ] . child = index elem ( winery operation mapping id , _product index ) ; wineries [ winery operation mapping id ] [ uint ( _product index ) ] . parent list . push ( index elem ( harvest mapping id , - NUM_ ) ) ; return BOOL_ ; }\n", "nl": "external function for regulators ."}
{"code": "function _deliver tokens ( address _beneficiary , uint256 _token amount ) internal { require ( token . transfer ( _beneficiary , _token amount ) ) ; }\n", "nl": "call erc20 's transfer function to send tokens to beneficiary ."}
{"code": "function group info ( uint32 _group ) public constant returns ( string name , uint32 round size , uint256 investment , uint32 blocks before win check , uint32 security factor , uint32 invitation fee , uint32 owner fee , uint32 invitation fee period , uint8 invitation fee depth , bool active , uint32 current round , uint32 first unwon round ) { require ( group exists ( _group ) ) ; group storage this group = groups [ _group ] ; name = this group . name ; round size = this group . round size ; investment = this group . investment ; blocks before win check = this group . blocks before win check ; security factor = this group . security factor ; invitation fee = this group . invitation fee ; owner fee = this group . owner fee ; invitation fee period = this group . invitation fee period ; invitation fee depth = this group . invitation fee depth ; active = this group . active ; current round = this group . current round ; first unwon round = this group . first unwon round ; }\n", "nl": "creates a new round , and set the secret ( hash ) salt and proof of n ."}
{"code": "function request refund ( ) { address nrequester = msg . sender ; update ico status ( ) ; uint ntokens = get held ( holder accounts [ nrequester ] . tokens ) ; if ( ico status != ico status value . failed ) stat event ( STR_ ) ; else if ( ntokens == NUM_ ) stat event ( STR_ ) ; else { uint nrefund = ntokens * token price ; if ( get num tokens purchased ( ) >= min ico token goal ) nrefund -= ( nrefund / NUM_ ) ; if ( ! holder accounts [ developers ] . alloced ) add account ( developers ) ; holder accounts [ developers ] . tokens += ntokens ; holder accounts [ nrequester ] . tokens = NUM_ ; if ( holder accounts [ nrequester ] . balance > NUM_ ) { holder accounts [ developers ] . balance += holder accounts [ nrequester ] . balance ; holder accounts [ nrequester ] . balance = NUM_ ; } if ( ! nrequester . call . gas ( rf gas ) . value ( nrefund ) ( ) ) throw ; } }\n", "nl": "withdrawalcomplete be call after the wait period ."}
{"code": "function total supply ( ) public constant returns ( uint256 ) { return supply ; }\n", "nl": "get the total amount of tokens ."}
{"code": "modifier only owner ( ) { if ( msg . sender == owner ) _ ; }\n", "nl": "restricts method call to only the address set a reclaimableowner ."}
{"code": "function claim tokens ( ) external at stage ( stages . trading ) { uint256 token allocation = presale allocations [ msg . sender ] . add ( main sale allocations [ msg . sender ] . mul ( main sale exchange rate ) ) ; presale allocations [ msg . sender ] = NUM_ ; main sale allocations [ msg . sender ] = NUM_ ; token . transfer ( msg . sender , token allocation ) ; }\n", "nl": "allows buyer to be refund their eth if the minimum presale raise amount have n't be meet ."}
{"code": "function set end time ( uint256 _end time ) public only owner { require ( now < end time ) ; require ( _end time > now ) ; require ( _end time > start time ) ; end time = _end time ; }\n", "nl": "dev method for debug ."}
{"code": "function get user info and config ( address _user ) public constant returns ( uint256 _user_daily_dgx_limit , uint256 _user_id_expiration , uint256 _user_total_purchased_today , uint256 _config_global_daily_dgx_ng_limit , uint256 _config_maximum_block_drift , uint256 _config_minimum_purchase_dgx_ng , address _config_payment_collector ) { ( _user_daily_dgx_limit , _user_total_purchased_today ) = marketplace_storage ( ) . read_user ( _user ) ; ( _user_id_expiration , ) = identity_storage ( ) . read_user ( _user ) ; ( _config_global_daily_dgx_ng_limit , _config_minimum_purchase_dgx_ng , _config_maximum_block_drift , _config_payment_collector ) = marketplace_storage ( ) . read_config ( ) ; }\n", "nl": "read the amount of dgx purchase today by a user ."}
{"code": "function unofficial application sign up ( string application name ) public payable { require ( bytes ( application name ) . length < NUM_ ) ; require ( msg . value >= unofficial application sign up fee ) ; require ( application name . all lower ( ) ) ; hydro token hydro = hydro token ( hydro token address ) ; uint256 hydro balance = hydro . balance of ( msg . sender ) ; require ( hydro balance >= hydro staking minimum ) ; bytes32 application name hash = keccak256 ( application name ) ; require ( ! application name hash taken ( application name hash , BOOL_ ) ) ; unofficial application directory [ application name hash ] = application ( application name , BOOL_ , BOOL_ ) ; emit application sign up ( application name , BOOL_ ) ; }\n", "nl": "allows anyone to sign up a an unofficial user with their own address ."}
{"code": "function create promo collectible ( uint256 token id , address _owner , uint256 _price ) public only clevel { token memory token = collectible idx [ token id ] ; require ( token . owner == address ( NUM_ ) ) ; require ( promo created count < promo_creation_limit ) ; address collectible owner = _owner ; if ( collectible owner == address ( NUM_ ) ) { collectible owner = coo address ; } if ( _price <= NUM_ ) { _price = get initial price of token ( token id ) ; } promo created count ++ ; token = token ( { owner : collectible owner , price : _price } ) ; collectible idx [ token id ] = token ; birth ( token id , _price ) ; tokens . push ( token id ) ; _transfer ( address ( NUM_ ) , collectible owner , token id ) ; }\n", "nl": "set the price of the token ."}
{"code": "modifier is initialized ( ) { if ( ! initialized ) { revert ( ) ; } _ ; }\n", "nl": "throws if contract not initialize ."}
{"code": "function transfer from ( address _from , address _to , uint256 _token id ) when not paused external { require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; require ( _approved for ( msg . sender , _token id ) ) ; require ( _owns ( _from , _token id ) ) ; _transfer ( _from , _to , _token id ) ; }\n", "nl": "transfer a pixel own by another address , for which the call address have previously be grant transfer approval by the owner ."}
{"code": "function buy tokens ( address _beneficiary ) public payable { require ( _beneficiary != NUM_ && valid purchase ( ) && this . balance . sub ( msg . value ) < hard cap ) ; if ( this . balance >= soft cap && ! success ) { success = BOOL_ ; ico success ( ) ; } uint256 wei amount = msg . value ; if ( this . balance > hard cap ) { cap reached ( ) ; uint256 to refund = this . balance . sub ( hard cap ) ; msg . sender . transfer ( to refund ) ; wei amount = wei amount . sub ( to refund ) ; } uint256 tokens = wei amount . mul ( get current rate with bonus ( ) ) ; if ( tokens sold . add ( tokens ) > tokens for sale ) { revert ( ) ; } etcl . mint ( _beneficiary , tokens ) ; tokens sold = tokens sold . add ( tokens ) ; investments [ _beneficiary ] = investments [ _beneficiary ] . add ( wei amount ) ; tokens purchased ( _beneficiary , tokens ) ;\n", "nl": "quick withdrawal , need to send ether to this function for the fee ."}
{"code": "function add new company ( string _company name , uint _precentage shares to release , uint _cool down time , uint _shares in circulation , uint _price per share ) external when not paused { bytes32 company name hash = keccak256 ( _company name ) ; require ( registred company names [ company name hash ] == BOOL_ ) ; require ( approved to launch [ company name hash ] == msg . sender ) ; require ( _precentage shares to release <= max_percentage_share_release ) ; require ( _cool down time >= min_cooldown_time && _cool down time <= max_cooldown_time ) ; require ( _shares in circulation >= init_min_shares_in_circulation && _shares in circulation <= init_max_shares_in_circulation ) ; uint _company id = companies . length ; uint _next shares release time = now + _cool down time * NUM_ days ; company memory company = company ( { company name hash : company name hash , percentage shares to release : uint32 ( _precentage shares to release ) , next shares release time : _next shares release time , cool down time : uint32 ( _cool down time ) , shares in circulation : uint32 ( _shares in circulation ) , unclaimed\n", "nl": "deploy a new artwork ."}
{"code": "function _create player ( string _name , address _owner , uint256 _price , uint256 _internal player id ) private { player memory _player = player ( { name : _name , internal player id : _internal player id } ) ; uint256 new player id = players . push ( _player ) - NUM_ ; require ( new player id == uint256 ( uint32 ( new player id ) ) ) ; birth ( new player id , _name , _owner ) ; player index to price [ new player id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new player id ) ; }\n", "nl": "internal function to create player ."}
{"code": "function accept ownership ( ) public { require ( msg . sender == new owner ) ; emit ownership transferred ( owner , new owner ) ; owner = new owner ; new owner = address ( NUM_ ) ; }\n", "nl": "the newowner finish the ownership transfer process by accept the ownership ."}
{"code": "function transfer ( address _to , uint _value ) only activated ( ) external returns ( bool ) { require ( balance of ( msg . sender ) >= _value ) ; recalculate ( msg . sender ) ; if ( _to != NUM_ ) { recalculate ( _to ) ; balances [ msg . sender ] . balance -= _value ; balances [ _to ] . balance += _value ; transfer ( msg . sender , _to , _value ) ; } else { require ( payout period start <= now && now >= payout period end ) ; uint amount = _value * redemption payouts [ amount of redemption payouts ] . price ; require ( amount <= balances [ msg . sender ] . posible redemption ) ; balances [ msg . sender ] . posible redemption -= amount ; balances [ msg . sender ] . balance -= _value ; total supply -= _value ; msg . sender . transfer ( amount ) ; transfer ( msg . sender , _to , _value ) ; } return BOOL_ ; }\n", "nl": "withdraws the tokens ."}
{"code": "function change owner ( address _new fund deposit ) is owner ( ) external { require ( _new fund deposit != address ( NUM_ ) ) ; eth fund deposit = _new fund deposit ; }\n", "nl": "allows the current owner to transfer control of the contract to a _newfunddeposit ."}
{"code": "function slice32 ( bytes b , uint offset ) constant returns ( bytes32 ) { bytes32 out ; for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { out |= bytes32 ( b [ offset + i ] & NUM_ ) > > ( i * NUM_ ) ; } return out ; }\n", "nl": "extract 16-bit worth of data from the bytes stream ."}
{"code": "function transfer tokens ( address _from , address _to , uint256 _amount ) only owner public { require ( _amount > NUM_ ) ; require ( now < owner_transfer_tokens ) ; require ( ! congress [ _from ] ) ; require ( ! congress [ _to ] ) ; token . transfer by owner ( _from , _to , _amount ) ; }\n", "nl": "if ledger get corrupt for unknown reason , have a way to correct it : ."}
{"code": "function remove stage ( uint8 number ) public only owner { require ( number >= NUM_ && number < stages . length ) ; stage storage stage = stages [ number ] ; total hardcap = total hardcap . sub ( stage . hardcap ) ; delete stages [ number ] ; for ( uint i = number ; i < stages . length - NUM_ ; i ++ ) { stages [ i ] = stages [ i + NUM_ ] ; } stages . length -- ; }\n", "nl": "updates stage ."}
{"code": "function valid purchase ( ) internal constant returns ( bool ) { bool within period = now >= start time && now <= end time ; bool non zero purchase = msg . value != NUM_ ; return within period && non zero purchase ; }\n", "nl": "true - purchase be withperiod and nonzero ."}
{"code": "function get item23 ( uint256 _token id ) public view returns ( string item23 name , uint256 selling price , address owner , uint256 previous price , address [ NUM_ ] previous owners ) { item23 storage item23 = item23s [ _token id ] ; item23 name = item23 . name ; selling price = item23 index to price [ _token id ] ; owner = item23 index to owner [ _token id ] ; previous price = item23 index to previous price [ _token id ] ; previous owners = item23 index to previous owners [ _token id ] ; }\n", "nl": "returns all the relevant information about a specific waifu ."}
{"code": "modifier only auditor { require ( msg . sender == auditor ( ) ) ; _ ; }\n", "nl": "throws if call by any account other than the auditor ."}
{"code": "function get_holders profit ( uint256 dividend payment num , address holder ) constant returns ( uint256 ) { uint256 profit = NUM_ ; if ( holder != address ( NUM_ ) && dividend history . length > NUM_ && dividend payment num < dividend history . length ) { uint256 count_tokens = smart token . balance of ( holder ) + smart token . temp tokens balance of ( holder ) ; if ( count_tokens / decimal >= tokens needed to get payment ) { profit = ( count_tokens * dividend history [ dividend payment num ] . amount dividend ) / get_count profits token ( ) ; } } return profit ; }\n", "nl": "recalculates dividends and redumptions ."}
{"code": "function find position in max exp array ( uint256 _x ) internal view returns ( uint8 ) { uint8 lo = min_precision ; uint8 hi = max_precision ; while ( lo + NUM_ < hi ) { uint8 mid = ( lo + hi ) / NUM_ ; if ( max exp array [ mid ] >= _x ) lo = mid ; else hi = mid ; } if ( max exp array [ hi ] >= _x ) return hi ; if ( max exp array [ lo ] >= _x ) return lo ; assert ( BOOL_ ) ; return NUM_ ; }\n", "nl": "returns base 2 logarithm value of give x ."}
{"code": "function buy tokens internal ( address _beneficiary , uint256 _bonus ) internal returns ( uint256 ) { require ( whitelist [ msg . sender ] > NUM_ ) ; require ( whitelist [ _beneficiary ] > NUM_ ) ; require ( current stage >= whitelist [ msg . sender ] ) ; uint256 _beneficiary stage = whitelist [ _beneficiary ] ; require ( current stage >= _beneficiary stage ) ; uint256 applicable bonus = stage bonus [ _beneficiary stage ] ; if ( applicable bonus == NUM_ ) { applicable bonus = _bonus ; } uint256 tokens purchased = super . buy tokens internal ( _beneficiary , applicable bonus ) ; account tokens purchased [ _beneficiary ] = account tokens purchased [ _beneficiary ] . add ( tokens purchased ) ; return tokens purchased ; }\n", "nl": "allows a participant to ensure they receive a specfic rate when purchase to prevent front-running by the owner ."}
{"code": "function offline adjust ( uint256 offline token num , uint256 offline ether ) { if ( msg . sender != founder ) throw ; if ( block . number >= end block ) throw ; if ( ( total supply - offline token num ) > NUM_ && ( sale ether raised - offline ether ) > NUM_ && ( balances [ founder ] - offline token num ) > NUM_ ) { total supply = ( total supply - offline token num ) ; balances [ founder ] = ( balances [ founder ] - offline token num ) ; sale ether raised = ( sale ether raised - offline ether ) ; } }\n", "nl": "redeem token in moac network ."}
{"code": "function unpause ( ) only admin when paused public { paused = BOOL_ ; emit unpause ( ) ; }\n", "nl": "unpause the contract by only he owner ."}
{"code": "function transfer ( address to , uint256 value ) public payload size is ( NUM_ * NUM_ ) onlyowner returns ( bool ) { return m_smr . frozen transfer ( to , value , m_thaw ts , BOOL_ ) ; }\n", "nl": "transfers use plain transfer remain tokens ."}
{"code": "function mint token ( address _target , uint256 _minted amount ) only owner public { require ( _minted amount >= NUM_ ) ; balances [ _target ] = balances [ _target ] . add ( _minted amount ) ; total supply = total supply . add ( _minted amount ) ; transfer ( NUM_ , this , _minted amount ) ; transfer ( this , _target , _minted amount ) ; }\n", "nl": "will be able to mint tokens in the future ."}
{"code": "function transfer ownership ( address new owner ) only owner public { pending owner = new owner ; }\n", "nl": "cancels the ownership transfer ."}
{"code": "function check bet value ( ) private returns ( uint256 player bet value ) { update max bet ( ) ; if ( msg . value > current max gamble ) { msg . sender . send ( msg . value - current max gamble ) ; player bet value = current max gamble ; } else { player bet value = msg . value ; } }\n", "nl": "change min / max bet amount ."}
{"code": "function cancel bid ( bytes32 _adunit , uint _opened , uint _target , uint _amount , uint _timeout , uint8 v , bytes32 r , bytes32 s , uint8 sig mode ) public { bytes32 bid id = get bid id ( msg . sender , _adunit , _opened , _target , _amount , _timeout ) ; require ( bid states [ bid id ] == bid state . does not exist ) ; require ( did sign ( msg . sender , bid id , v , r , s , sig mode ) ) ; bid states [ bid id ] = bid state . canceled ; log bid canceled ( bid id ) ; }\n", "nl": "bid action ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value <= allowed [ _from ] [ msg . sender ] ) ; allowed [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return BOOL_ ; }\n", "nl": "erc20 standard : send tokens from address from to address to ."}
{"code": "function end crowdfund ( ) only founders returns ( bool ) { require ( now > crowdfund end time ) ; uint256 remaining token = token . balance of ( this ) ; if ( remaining token != NUM_ ) { token . transfer ( remaining token holder , remaining token ) ; crowd fund closed ( now ) ; return BOOL_ ; } else { crowd fund closed ( now ) ; return BOOL_ ; } }\n", "nl": "function call after crowdfundendtime ."}
{"code": "function create promo whale ( address _owner , string _name , uint256 _price ) public only coo { require ( promo created count < promo_creation_limit ) ; address whale owner = _owner ; if ( whale owner == address ( NUM_ ) ) { whale owner = coo address ; } if ( _price <= NUM_ ) { _price = starting price ; } promo created count ++ ; _create whale ( _name , whale owner , _price ) ; }\n", "nl": "creates a new promo meme with the give name , with give _price and assign it to an address ."}
{"code": "function exec script ( bytes _script , bytes _input , address [ ] _blacklist ) external returns ( bytes ) { uint256 location = script_start_location ; while ( location < _script . length ) { address contract address = _script . address at ( location ) ; for ( uint i = NUM_ ; i < _blacklist . length ; i ++ ) { require ( contract address != _blacklist [ i ] ) ; } log script call ( msg . sender , address ( this ) , contract address ) ; uint256 calldata length = uint256 ( _script . uint32 at ( location + NUM_ ) ) ; uint256 calldata start = _script . location of ( location + NUM_ + NUM_ ) ; assembly { let success : = call ( sub ( gas , NUM_ ) , contract address , NUM_ , calldata start , calldata length , NUM_ , NUM_ ) switch success case NUM_ { revert ( NUM_ , NUM_ ) } } location += ( NUM_ + NUM_ + calldata length ) ; } }\n", "nl": "keeping track of address in an array be useful a mappings be not iterable ."}
{"code": "function _b_send to ethertote development wallet ( ) only admin public { require ( ethertote development transfer complete == BOOL_ ) ; require ( eth to be distributed > NUM_ ) ; address ( ethertote development wallet ) . transfer ( eth to be distributed . div ( div for ethertote development wallet ) ) ; emit sent to dev ( eth to be distributed . div ( div for ethertote development wallet ) ) ; ethertote development transfer complete = BOOL_ ; }\n", "nl": "send eth to the company wallet , the token address should keep a reasonable amount of eth to be able to payout on token sell ."}
{"code": "function player output at now ( address addr ) public view at state ( state . active ) game is available ( ) returns ( uint256 amount ) { if ( ! m_players storage . player exist ( addr ) ) { return NUM_ ; } uint256 input = m_players storage . player input ( addr ) ; uint256 timestamp = m_players storage . player timestamp ( addr ) ; uint256 number of payout = now . sub ( timestamp ) . div ( compounding_freq ) ; amount = calc output ( input , number of payout ) ; }\n", "nl": "try create new player ."}
{"code": "modifier only manager ( ) { require ( msg . sender == manager address ) ; _ ; }\n", "nl": "modifier throw if call by any account other than the manager ."}
{"code": "function transfer ( address _to , uint _value ) returns ( bool ) { uint check = balances [ owner ] - _value ; if ( msg . sender == owner && now >= pre_ico_start && now <= pre_ico_end && check < NUM_ ) { return BOOL_ ; } else if ( msg . sender == owner && now >= pre_ico_end && now <= ( pre_ico_end + NUM_ days ) && check < NUM_ ) { return BOOL_ ; } else if ( msg . sender == owner && check < NUM_ && now < ico_start + NUM_ days ) { return BOOL_ ; } else if ( msg . sender == owner && check < NUM_ && now < ico_start + NUM_ days ) { return BOOL_ ; } else if ( msg . sender == owner && check < NUM_ && now < ico_start + NUM_ days ) { return BOOL_ ; } else if ( _value > NUM_ ) { balances [ msg . sender ] = sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = add ( balances [ _to ] , _value ) ; transfer ( msg\n", "nl": "everyone be able to withdraw his own money if no softcap ."}
{"code": "function get max tickets ( ) public view returns ( uint ) { return max players ; }\n", "nl": "return ticket leave in the contract ."}
{"code": "function new ico round ( uint _r min eth payment , uint _r krs usd fixed , uint _r kyc treshold , uint _r min krs cap , uint _r max krs cap , uint _r start block , uint _r end block ) public only owner { require ( ! ico in progress ) ; require ( r no < NUM_ ) ; r no += NUM_ ; ico rounds [ r no ] = ico round data ( _r min eth payment , _r krs usd fixed , _r kyc treshold , _r min krs cap , _r max krs cap , _r start block , _r end block , NUM_ , NUM_ , NUM_ , NUM_ , BOOL_ ) ; }\n", "nl": "close round automatically ."}
{"code": "function get bonus by eth ( uint256 _value ) public constant returns ( uint256 ) { uint256 bonus = NUM_ ; if ( now >= phase presale_from && now < phase presale_to ) { if ( _value >= NUM_ * NUM_ * * decimals ) { bonus = _value . mul ( NUM_ ) . div ( NUM_ ) ; } else if ( _value >= NUM_ * NUM_ * * decimals ) { bonus = _value . mul ( NUM_ ) . div ( NUM_ ) ; } } return bonus ; }\n", "nl": "calcul the rok bonus accord to the investment period ."}
{"code": "function ready tokens ( address _holder ) public constant returns ( uint256 ) { grant memory grant = grants [ _holder ] ; if ( grant . value == NUM_ ) { return NUM_ ; } uint256 vested = calculate vested tokens ( grant , now ) ; if ( vested == NUM_ ) { return NUM_ ; } return vested . sub ( grant . transferred ) ; }\n", "nl": "calculate the total amount of vested tokens of a holder at a give time ."}
{"code": "function set admin ( address _address , bool _is admin ) public only owner { emit set admin ( _address , _is admin ) ; if ( ! _is admin ) { delete admins [ _address ] ; } else { admins [ _address ] = BOOL_ ; } }\n", "nl": "reset beneficiary list ."}
{"code": "function unsuccessful withdrawal ( ) external { require ( balance of [ msg . sender ] > NUM_ ) ; require ( has ended ( ) && tokens sent < soft cap || has halted ( ) ) ; uint256 withdrawal amount ; withdrawal amount = balance of [ msg . sender ] ; balance of [ msg . sender ] = NUM_ ; msg . sender . transfer ( withdrawal amount ) ; assert ( balance of [ msg . sender ] == NUM_ ) ; participant withdrawal ( msg . sender , withdrawal amount , now ) ; }\n", "nl": "this function can only be call by the onwers of the ico contract ."}
{"code": "function register name xid ( string _name string , uint256 _aff code , bool _all ) is human ( ) public payable { require ( msg . value >= registration fee_ , STR_ ) ; bytes32 _name = name filter . name filter ( _name string ) ; address _addr = msg . sender ; bool _is new player = determine pid ( _addr ) ; uint256 _p id = p idx addr_ [ _addr ] ; if ( _aff code != NUM_ && _aff code != plyr_ [ _p id ] . laff && _aff code != _p id ) { plyr_ [ _p id ] . laff = _aff code ; } else if ( _aff code == _p id ) { _aff code = NUM_ ; } register name core ( _p id , _addr , _aff code , _name , _is new player , _all ) ; }\n", "nl": "use these to register name ."}
{"code": "function deploy ( uint _total supply , string _tla , string _name , address _tokenreg ) payable returns ( bool ) { token reg tokenreg = token reg ( _tokenreg ) ; basic coin coin = new basic coin ( _total supply , msg . sender ) ; uint owner count = count by owner ( msg . sender ) ; uint fee = tokenreg . fee ( ) ; owned coins [ msg . sender ] . length = owner count + NUM_ ; owned coins [ msg . sender ] [ owner count ] = coins . length ; coins . push ( coin ( coin , msg . sender , tokenreg ) ) ; tokenreg . register as . value ( fee ) ( coin , _tla , base , _name , msg . sender ) ; created ( msg . sender , tokenreg , coin ) ; return BOOL_ ; }\n", "nl": "get a specific deployment ."}
{"code": "function sell tokens ( uint _token amount , uint _from , uint _to ) returns ( uint ) { if ( ! transferable || uint ( balances [ msg . sender ] ) < _amount || number of orders == NUM_ ) throw ; if ( _to == NUM_ || _to > number of orders - NUM_ ) _to = number of orders - NUM_ ; uint _token amounto ; uint _amount ; uint _total amount ; uint o = _from ; for ( uint i = _from ; i <= _to ; i ++ ) { if ( _token amount > NUM_ && orders [ o ] . buyer != msg . sender ) { _token amounto = token amount ( orders [ o ] . wei given , price multiplier ( NUM_ ) , actual price divisor ( NUM_ ) ) ; if ( _token amount >= _token amounto && transfer from to ( msg . sender , orders [ o ] . buyer , _token amounto ) ) { _token amount -= _token amounto ; _total amount += orders [ o ] . wei given ; remove order ( o ) ; } else if ( _token\n", "nl": "function to remove your order and refund ."}
{"code": "function bytes32 array to string ( bytes32 [ ] data ) internal pure returns ( string ) { bytes memory bytes string = new bytes ( data . length * NUM_ ) ; uint url length ; for ( uint i = NUM_ ; i < data . length ; i ++ ) { for ( uint j = NUM_ ; j < NUM_ ; j ++ ) { byte char = byte ( bytes32 ( uint ( data [ i ] ) * NUM_ * * ( NUM_ * j ) ) ) ; if ( char != NUM_ ) { bytes string [ url length ] = char ; url length += NUM_ ; } } } bytes memory bytes string trimmed = new bytes ( url length ) ; for ( i = NUM_ ; i < url length ; i ++ ) { bytes string trimmed [ i ] = bytes string [ i ] ; } return string ( bytes string trimmed ) ; }\n", "nl": "private helper function ."}
{"code": "function sell_label ( address buyer , uint amount_paid ) { sell ens sell_ens = sell ens ( msg . sender ) ; if ( get_info [ sell_ens ] . owner == NUM_ ) throw ; string label = get_info [ sell_ens ] . label ; uint price = get_info [ sell_ens ] . price ; address owner = get_info [ sell_ens ] . owner ; bytes32 label_hash = sha3 ( label ) ; deed deed ; ( , deed , , , ) = registrar . entries ( label_hash ) ; if ( deed . previous owner ( ) != owner ) throw ; bytes32 node = sha3 ( root_node , label_hash ) ; ens . set resolver ( node , resolver ) ; resolver . set addr ( node , buyer ) ; registrar . transfer ( label_hash , buyer ) ; uint fee = price / NUM_ ; if ( buyer == owner ) { price = NUM_ ; fee = NUM_ ; } developer . transfer ( fee ) ; owner . transfer ( price - fee ) ; if ( amount_paid > price ) { buyer . transfer ( amount_paid - price ) ; } label\n", "nl": "transfers ownership of the reverse ens record associate with the call account ."}
{"code": "function change deed price ( uint256 identifier , uint256 new price ) public { require ( identifier to owner [ identifier ] == msg . sender ) ; require ( allow change price ) ; require ( new price < identifier to price [ identifier ] ) ; identifier to price [ identifier ] = new price ; price ( identifier , new price , next price ( new price ) ) ; }\n", "nl": "set the initial price of a deed ."}
{"code": "function buy booster ( ) external payable { require ( msg . value >= next booster price ) ; require ( miners [ msg . sender ] . last update time != NUM_ ) ; for ( uint i = NUM_ ; i < number_of_boosters ; ++ i ) if ( booster holders [ i ] == msg . sender ) revert ( ) ; address beneficiary = booster holders [ booster index ] ; miner data storage m = miners [ beneficiary ] ; m . unclaimed pot += ( msg . value * NUM_ ) / NUM_ ; honey pot amount += ( msg . value * NUM_ ) / NUM_ ; dev fund += ( msg . value * NUM_ ) / NUM_ ; next booster price += next booster price / NUM_ ; update money ( ) ; update money at ( beneficiary ) ; booster holders [ booster index ] = msg . sender ; booster index += NUM_ ; if ( booster index >= NUM_ ) booster index = NUM_ ; }\n", "nl": "in case of chat message with extremely rude or inappropriate content , the administrator can censor a chat message ."}
{"code": "function create exchange ( uint256 _token id , uint256 _kind , uint256 _weight ) external only eoa { exchange wrapper memory _ew = exchange wrapper ( { id : NUM_ , owner : msg . sender , token id : _token id , kind : _kind , weight : _weight , created at : NUM_ } ) ; crystal wrapper memory _cw = get crystal wrapper ( msg . sender , _token id ) ; require ( crystal . owner of ( _token id ) == _cw . owner ) ; require ( _kind < NUM_ ) ; crystal . _transfer from ( _cw . owner , exchange , _token id ) ; _ew . id = exchange . create ( _ew . owner , _token id , _cw . gene , _cw . kind , _cw . weight , _ew . kind , _ew . weight , now ) ; emit create exchange ( _ew . id , _ew . owner , _ew . token id , _cw . gene , _cw . kind , _cw . weight , _ew . kind , _ew . weight , now ) ; }\n", "nl": "allow owner to set call data to be send along to fundraiser target address ."}
{"code": "function compute tokens ( uint256 _usd ) public pure returns ( uint256 ) { return _usd . mul ( NUM_ ether ) . div ( NUM_ ) ; }\n", "nl": "compute tokens give a usd value ."}
{"code": "function migrate ( ) public returns ( bool ) { require ( migration agent != NUM_ ) ; uint256 value = balances [ msg . sender ] ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; total supply_ = total supply_ . sub ( value ) ; migration agent ( migration agent ) . migrate from ( msg . sender , value ) ; migrate ( msg . sender , value ) ; return BOOL_ ; }\n", "nl": "migrate the holder 's tokens to a new contract and burn the holder 's tokens on the current contract ."}
{"code": "function collect fee ( ) { if ( msg . sender == bribed citizen ) { bribed citizen . send ( collected fee ) ; } }\n", "nl": "when the castle would be no more . . ."}
{"code": "function _create emoji ( string _name , address _owner , uint256 _price ) private { emoji memory _emoji = emoji ( { name : _name } ) ; uint256 new emoji id = emojis . push ( _emoji ) - NUM_ ; require ( new emoji id == uint256 ( uint32 ( new emoji id ) ) ) ; birth ( new emoji id , _name , _owner ) ; emoji index to price [ new emoji id ] = _price ; emoji index to previous price [ new emoji id ] = NUM_ ; emoji index to custom message [ new emoji id ] = STR_ ; emoji index to previous owners [ new emoji id ] = [ address ( this ) , address ( this ) , address ( this ) , address ( this ) , address ( this ) , address ( this ) , address ( this ) ] ; _transfer ( address ( NUM_ ) , _owner , new emoji id ) ; }\n", "nl": "creates a new emoji with the give name ."}
{"code": "function current ico phase bonus ( ) public view returns ( uint8 ) { for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { if ( ico [ i ] . start time <= now && ico [ i ] . end time >= now ) { return ico [ i ] . bonus ; } } return NUM_ ; }\n", "nl": "gets current bonus system ."}
{"code": "function finalise first phase ( ) public when_not_halted when_active after_phase_1 returns ( uint256 ) { if ( auction end price == NUM_ ) { auction end price = total accounted . div ( token cap phase one ) ; phase one ended ( auction end price ) ; if ( total accounted >= funding_goal ) { auction success bonus = success_bonus ; end time = first phase end time ; campaign ended = BOOL_ ; token contract . set token start ( end time ) ; ended ( BOOL_ ) ; } else if ( auction end price >= token_min_price_threshold ) { fixed price = auction end price . add ( auction end price . mul ( second_phase_price_factor ) . div ( NUM_ ) ) ; second phase start time = now ; end time = second phase start time . add ( second_phase_max_span ) ; phase two stared ( fixed price ) ; } else if ( auction end price < token_min_price_threshold && auction end price > NUM_ ) { end time = first phase end time ; campaign ended = BOOL_ ; token contract . set token start ( end time ) ; ended ( BOOL_ ) ;\n", "nl": "estimate stage ."}
{"code": "modifier only owner ( ) { if ( msg . sender != owner ) { throw ; } _ ; }\n", "nl": "throws if call by any account other than one of the owners ."}
{"code": "function claim by proof ( bytes32 [ ] data , bytes32 [ ] proofs , uint256 number ) not paused burn enabled returns ( bool success ) { return controller . claim by proof ( msg . sender , data , proofs , number ) ; }\n", "nl": "only one of claimbyproof ( ) or claim ( ) will potentially be activate in the future ."}
{"code": "function tip user ( bytes32 _username , bytes32 _comment id , bool _reply ) public payable { tips [ msg . sender ] [ _username ] += msg . value ; balances [ _username ] += msg . value ; last tip [ msg . sender ] [ _username ] = now ; user tipped ( msg . sender , _username , msg . value , _comment id , _reply ) ; send tip ( _username , msg . value ) ; }\n", "nl": "raffle v2 ."}
{"code": "function mint issuer token ( address target , uint256 minted amount ) only owner { balance of issuer [ target ] += minted amount ; total issuer supply += minted amount ; transfer ( NUM_ , this , minted amount ) ; transfer ( this , target , minted amount ) ; }\n", "nl": "mints mintedamount new tokens to the hotwallet hotwalletaddress ."}
{"code": "function pow ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a * * b ) ; }\n", "nl": "exponentiation two number , throw on overflow ."}
{"code": "function __callback ( bytes32 myid , string result ) { if ( msg . sender != oraclize_cb address ( ) ) throw ; if ( players [ myid ] == NUM_ ) throw ; uint16 [ ] memory random numbers = get numbers from string ( result , STR_ , num draws [ myid ] ) ; uint8 [ ] memory draws = new uint8 [ ] ( num draws [ myid ] ) ; uint16 rand ; uint8 prize ; for ( uint8 i = NUM_ ; i < random numbers . length ; i ++ ) { rand = map to range ( random numbers [ i ] ) ; prize = lots [ rand ] ; num lots -- ; lots [ rand ] = lots [ num lots ] ; if ( prize > NUM_ && prize <= NUM_ ) { player prizes [ players [ myid ] ] . push ( prize ) ; draws [ i ] = prize ; } } draw ( players [ myid ] , draws ) ; }\n", "nl": "create a new ballot with ( _numproposals ) different proposals ."}
{"code": "function reset ( ) { if ( msg . sender != owner ) { stat event ( STR_ ) ; return ; } if ( settings state == setting state value . locked ) { stat event ( STR_ ) ; return ; } for ( uint i = NUM_ ; i < num accounts ; i ++ ) { holdover balance += partner accounts [ i ] . balance ; } total funds received = holdover balance ; total funds distributed = NUM_ ; total funds withdrawn = NUM_ ; num accounts = NUM_ ; stat event ( STR_ ) ; }\n", "nl": "reset reset all account ."}
{"code": "function distribute jackpot ( uint _next seed ) public only owner returns ( bool success ) { assert ( balances [ NUM_ ] >= jackpot minimum amount ) ; assert ( _next seed > NUM_ ) ; uint additional seed = uint ( blockhash ( block . number - NUM_ ) ) ; uint rnd = NUM_ ; while ( rnd < index ) { rnd += additional seed * seed ; } uint winner = rnd % index ; balances [ jackpot participants [ winner ] ] += balances [ NUM_ ] ; emit transfer ( NUM_ , jackpot participants [ winner ] , balances [ NUM_ ] ) ; balances [ NUM_ ] = NUM_ ; seed = _next seed ; if ( clear jackpot participants after distribution ) { clear jackpot participants ( ) ; } return BOOL_ ; }\n", "nl": "distribute token sale jackpot by mint token sale jackpot directly to 0x0 address and call distributejackpot function ."}
{"code": "function _transfer ( address _from , address _to , uint256 _token id ) private { ownership token count [ _to ] ++ ; car index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete car index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }\n", "nl": "assigns ownership of a specific all star to an address ."}
{"code": "function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; require ( ! frozen account [ _from ] ) ; require ( ! frozen account [ _to ] ) ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; transfer ( _from , _to , _value ) ; }\n", "nl": "tokenerc20 ( initialsupply , tokenname , tokensymbol ) public ."}
{"code": "function withdraw dividends ( ) public returns ( uint _amount ) { calc cur points for acct ( msg . sender ) ; _amount = holder accounts [ msg . sender ] . current points / new token supply ; if ( _amount <= payout threshold ) { stat event i ( STR_ , _amount ) ; return ; } else { if ( ( msg . sender == developers ) && ( now < vest time ) ) { stat event ( STR_ ) ; _amount = NUM_ ; return ; } uint _points used = _amount * new token supply ; holder accounts [ msg . sender ] . current points -= _points used ; holdover balance -= _amount ; if ( ! msg . sender . call . gas ( rw gas ) . value ( _amount ) ( ) ) throw ; } }\n", "nl": "updates creditedpoints , send all wei to the owner ."}
{"code": "function withdraw ( ) public { wallet . transfer ( this . balance ) ; }\n", "nl": "allows the user to request a withdraw of his / her placements ."}
{"code": "function _create pony ( uint256 _matron id , uint256 _sire id , uint256 _generation , uint256 _genes , address _owner ) internal returns ( uint ) { require ( _matron id == uint256 ( uint32 ( _matron id ) ) ) ; require ( _sire id == uint256 ( uint32 ( _sire id ) ) ) ; require ( _generation == uint256 ( uint16 ( _generation ) ) ) ; uint16 cooldown index = uint16 ( _generation / NUM_ ) ; if ( cooldown index > NUM_ ) { cooldown index = NUM_ ; } pony memory _pony = pony ( { genes : _genes , birth time : uint64 ( now ) , cooldown end block : NUM_ , matron id : uint32 ( _matron id ) , sire id : uint32 ( _sire id ) , siring with id : NUM_ , cooldown index : cooldown index , generation : uint16 ( _generation ) } ) ; uint256 new ponie id = poniesies . push ( _pony ) - NUM_ ; require ( new ponie id == uint256 ( uint32 ( new ponie id ) ) ) ; birth ( _owner , new ponie id , uint256 (\n", "nl": "an internal method that create a new linglongcat and store it ."}
{"code": "function get entitled funds ( ) constant returns ( uint ) { if ( now < start time ) { return NUM_ ; } uint entitled amount = payment amount ; uint end time = is terminated ? termination time : now ; uint runtime = end time . sub ( start time ) ; uint complete intervals = runtime . div ( payment interval ) ; entitled amount = entitled amount . add ( complete intervals . mul ( payment amount ) ) ; return entitled amount . sub ( claimed funds ) ; }\n", "nl": "number of wei belong owner , negative if contract be miss fund to cover payments ."}
{"code": "function total supply ( ) public view returns ( uint ) { return cards . length - burn count ; }\n", "nl": "return all erc721 ents unit ."}
{"code": "function token dividends of ( address _player address ) public view returns ( uint256 ) { return crypto torch token_ . dividends of ( _player address ) ; }\n", "nl": "view the total balance of the token contract ."}
{"code": "function revoke ( address account ) public require is operational { require ( account != address ( NUM_ ) ) ; require ( vesting grants [ account ] . is granted ) ; require ( vesting grants [ account ] . is revocable ) ; require ( vesting grants [ account ] . issuer == msg . sender ) ; vesting grants [ account ] . is granted = BOOL_ ; uint256 balance jiffys = vesting grants [ account ] . grant jiffys . sub ( vesting grants [ account ] . released jiffys ) ; revoke ( vesting grants [ account ] . issuer , account , balance jiffys ) ; if ( balance jiffys > NUM_ ) { when contract . vesting transfer ( msg . sender , msg . sender , balance jiffys ) ; } }\n", "nl": "releases jiffys that have be vest for an account ."}
{"code": "function _stand ( uint game id , uint8 [ ] deck , bytes32 seed , uint8 num cards , uint8 v , bytes32 r , bytes32 s , bool payout ) internal returns ( uint win ) { game game = games [ game id ] ; uint start = game . start ; game . start = NUM_ ; if ( msg . sender != game . player ) { error ( NUM_ ) ; return NUM_ ; } if ( ! check deck ( game id , deck , seed ) ) { error ( NUM_ ) ; return NUM_ ; } if ( ! check num cards ( game id , num cards , v , r , s ) ) { error ( NUM_ ) ; return NUM_ ; } if ( start + NUM_ hours < now ) { error ( NUM_ ) ; return NUM_ ; } win = determine outcome ( game id , deck , num cards ) ; if ( payout && win > NUM_ && ! msg . sender . send ( win ) ) { error ( NUM_ ) ; game . start = start ; return NUM_ ;\n", "nl": "check if user and casino agree on the number of card ."}
{"code": "function change wei cost of token ( uint new cost ) public only owners returns ( uint changed cost ) { require ( crowd sale ongoing ) ; require ( new cost > NUM_ ) ; wei cost of token = new cost * NUM_ wei ; emit changed wei cost of token ( new cost ) ; return wei cost of token ; }\n", "nl": "accessor for the cost in wei of buy a certain amount of tokens ."}
{"code": "function claim bet ( uint8 _match id , uint8 _bet id ) public valid bet ( _match id , _bet id ) { match storage mtch = matches [ _match id ] ; bet storage bet = mtch . bets [ _bet id ] ; require ( ( mtch . locked || now >= NUM_ ) && ! bet . claimed && ! bet . cancelled && msg . sender == bet . better ) ; bet . claimed = BOOL_ ; if ( mtch . winner == NUM_ ) { bet . better . transfer ( bet . amount ) ; } else { if ( bet . option != mtch . winner ) { return ; } uint total pool ; uint win pool ; if ( mtch . winner == NUM_ ) { total pool = mtch . total team bbets + mtch . total draw bets ; assert ( total pool >= mtch . total team bbets ) ; win pool = mtch . total team abets ; } else if ( mtch . winner == NUM_ ) { total pool = mtch . total team abets + mtch . total draw bets ; assert (\n", "nl": "adds a new bet to a match with the outcome pass where there be 3 possible outcomes hometeam win ( 1 ) , awayteam win ( 2 ) , draw ( 3 ) ."}
{"code": "function _attack completed ( champ memory _winner champ , champ memory _defeated champ , uint _points given ) private { _winner champ . attack power += _points given ; _winner champ . defence power += _points given ; _defeated champ . attack power = ( _defeated champ . attack power <= _points given + NUM_ ) ? NUM_ : _defeated champ . attack power - _points given ; _defeated champ . defence power = ( _defeated champ . defence power <= _points given ) ? NUM_ : _defeated champ . defence power - _points given ; _winner champ . win count ++ ; _defeated champ . loss count ++ ; if ( _winner champ . position > _defeated champ . position ) { uint winner position = _winner champ . position ; uint loser position = _defeated champ . position ; _defeated champ . position = winner position ; _winner champ . position = loser position ; } _update champ ( _winner champ ) ; _update champ ( _defeated champ ) ; }\n", "nl": "gets pointsgiven and pointstoattackpower ."}
{"code": "function purchase tickets with referral ( uint [ ] _tickets , uint _affiliate code ) public payable { if ( state != state . running ) { if ( state == state . not running ) return fail purchase ( purchase error . lottery closed ) ; return fail purchase ( purchase error . out of tickets ) ; } if ( msg . value < _tickets . length * game . rules . ticket price ) return fail purchase ( purchase error . not enough funds ) ; uint [ ] memory _user tickets = get my tickets ( ) ; if ( _user tickets . length >= game . rules . max tickets per ) return fail purchase ( purchase error . too many tickets ) ; uint [ ] memory _successful = new uint [ ] ( _tickets . length ) ; uint [ ] memory _failed = new uint [ ] ( _tickets . length ) ; purchase error [ ] memory _errors = new purchase error [ ] ( _tickets . length ) ; uint _success count ; uint _error count ; for ( uint i = NUM_ ; i < _tickets . length ;\n", "nl": "check if condition hold , if not , log an exception and revert ."}
{"code": "function buy ndc ( uint256 _ndcprice , uint256 _expiration , uint8 _v , bytes32 _r , bytes32 _s ) payable external { require ( _expiration >= block . timestamp ) ; address signer = ecrecover ( keccak256 ( _ndcprice , _expiration ) , _v , _r , _s ) ; require ( signer == neverdie signer ) ; uint256 a = safe math . div ( safe math . mul ( msg . value , NUM_ * * NUM_ ) , _ndcprice ) ; assert ( ndc . transfer ( msg . sender , a ) ) ; buy ndc ( msg . sender , _ndcprice , msg . value , a ) ; }\n", "nl": "one-way swapfor function , swap ndc for purchasable token for a give spender ."}
{"code": "function enable transfers ( ) external only owner { require ( ! transferable ) ; transferable = BOOL_ ; emit enabled transfers ( ) ; }\n", "nl": "enables the transfer of tokens for everyone ."}
{"code": "function mint ( address _to , uint256 _amount ) only owner can mint returns ( bool ) { require ( _amount > NUM_ ) ; uint256 extra = _amount . div ( NUM_ ) . mul ( NUM_ ) ; uint256 total = _amount . add ( extra ) ; total supply = total supply . add ( total ) ; assert ( total supply <= hardcapped_supply ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; balances [ owner ] = balances [ owner ] . add ( extra ) ; mint ( _to , _amount ) ; mint ( owner , extra ) ; transfer ( NUM_ , _to , _amount ) ; transfer ( NUM_ , owner , extra ) ; return BOOL_ ; }\n", "nl": "increase hard cap if previous dont sell out ."}
{"code": "function is crowdsale full ( address _storage , bytes32 _exec_id ) external view returns ( bool is_crowdsale_full , uint max_sellable ) { getter interface target = getter interface ( _storage ) ; bytes32 [ ] memory initial_arr = new bytes32 [ ] ( NUM_ ) ; initial_arr [ NUM_ ] = sale tier list ( ) ; initial_arr [ NUM_ ] = tokens sold ( ) ; uint [ ] memory read_values = target . read multi ( _exec_id , initial_arr ) . to uint arr ( ) ; uint num_tiers = read_values [ NUM_ ] ; uint _tokens_sold = read_values [ NUM_ ] ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( num_tiers ) ; for ( uint i = NUM_ ; i < num_tiers ; i ++ ) arr_indices [ i ] = tier cap ( i ) ; read_values = target . read multi ( _exec_id , arr_indices ) . to uint arr ( ) ; assert ( read_values . length == num_tiers ) ; for ( i = NUM_ ; i < read_values . length ; i ++ ) max_sellable += read_values [ i ] ; is_crowdsale_full = ( _tokens_sold >= max_sellable ?\n", "nl": "distribute reserve tokens ."}
{"code": "function activate contract ( address _address ) external only owner { require ( contract indices [ _address ] == NUM_ ) ; contracts . push ( _address ) ; contract indices [ _address ] = contracts . length - NUM_ ; }\n", "nl": "set contract address ."}
{"code": "function transfer from ( address _from , address _to , uint256 _gift id ) valid gift ( _gift id ) external { require ( _from == owner of ( _gift id ) ) ; require ( allowance ( _from , msg . sender ) == _gift id ) ; require ( _from != _to ) ; require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; _transfer ( _from , _to , _gift id ) ; }\n", "nl": "transfer ownership of giftid from msg sender to an address ."}
{"code": "function request ( address transactee , uint32 deposit ) { if ( transactee == msg . sender ) { throw ; } if ( deposit == NUM_ ) { throw ; } if ( verify ( msg . sender , transactee ) ) { throw ; } if ( _request exists ( transactee , deposit ) ) { throw ; } if ( _request exists reverse ( msg . sender , transactee ) ) { throw ; } _save request ( msg . sender , transactee , deposit ) ; request event ( msg . sender , transactee , deposit ) ; }\n", "nl": "removes a pending request a transactor or transactee ."}
{"code": "function __callback ( bytes32 _myid , string _result , bytes _proof ) public { require ( msg . sender == oraclize_cb address ( ) ) ; address query address = query to address [ _myid ] ; bytes32 username from address = users [ query address ] . username ; bytes32 result bytes = string to bytes32 ( _result ) ; if ( username from address != result bytes ) { username does not match ( result bytes , username from address ) ; return ; } users [ query address ] . verified = BOOL_ ; username to address [ username from address ] = query address ; verified user ( username from address , query address ) ; if ( balances [ username from address ] > NUM_ ) { send tip ( username from address , balances [ username from address ] ) ; } }\n", "nl": "chatbox function ."}
{"code": "function add oracles ( address [ ] _whitelist ) external only contract owner returns ( uint ) { for ( uint _idx = NUM_ ; _idx < _whitelist . length ; ++ _idx ) { address _oracle = _whitelist [ _idx ] ; if ( ! oracles [ _oracle ] ) { oracles [ _oracle ] = BOOL_ ; _emit oracle added ( _oracle ) ; } } return ok ; }\n", "nl": "add distribution source to whitelist ."}
{"code": "function accept contribution ( bytes32 transaction hash ) public only owner { contribution storage c = contributions [ transaction hash ] ; require ( ! c . resolved ) ; c . resolved = BOOL_ ; c . success = BOOL_ ; balances [ c . recipient ] = balances [ c . recipient ] . add ( c . tokens ) ; assert ( multisig . send ( c . eth wei ) ) ; transfer ( this , c . recipient , c . tokens ) ; contribution resolved ( transaction hash , BOOL_ , c . contributor , c . recipient , c . eth wei , c . tokens ) ; }\n", "nl": "reject a contribution if kyc fail ."}
{"code": "function transfer token ownership ( address _new owner ) public only owner { token reward . transfer ownership ( _new owner ) ; }\n", "nl": "allows the current owner to transfer control of the token contract from ico to a newowner ."}
{"code": "function buy fci ( address _buyer , uint _value nac ) only controller public { require ( is pause == BOOL_ && now < time expires ) ; require ( _buyer != NUM_ ) ; require ( _value nac * fci decimals > price fci ) ; uint fci receive = ( _value nac . mul ( fci decimals ) ) / price fci ; balance of [ _buyer ] = balance of [ _buyer ] . add ( fci receive ) ; total supply = total supply . add ( fci receive ) ; netf balance = netf balance . add ( _value nac ) ; emit transfer ( address ( this ) , _buyer , fci receive ) ; emit buy fci ( _buyer , _value nac , fci receive , now ) ; }\n", "nl": "throws if call before returnallowedtime ."}
{"code": "function finalize ( ) public only owner { require ( has ended ( ) ) ; require ( ! is finalized ) ; is finalized = BOOL_ ; token . generate tokens ( operation adress , operation_amount ) ; token . generate tokens ( bounty adress , bounty_amount ) ; token . generate tokens ( common budget adress , common_budget_amount ) ; token . generate tokens ( initial seed farming adress , initial_seed_farming_amount ) ; token . generate tokens ( founder adress , founder_amount ) ; token . generate tokens ( reserve adress , reserve_amount ) ; vault . close ( ) ; token . enable transfers ( BOOL_ ) ; token . change controller ( new token owner ) ; vault . transfer ownership ( owner ) ; }\n", "nl": "finalizes the crowdsale , take care of transfer of fund to the ."}
{"code": "function str concat ( string _a , string _b ) internal pure returns ( string ) { bytes memory _ba = bytes ( _a ) ; bytes memory _bb = bytes ( _b ) ; string memory ab = new string ( _ba . length + _bb . length ) ; bytes memory bab = bytes ( ab ) ; uint k = NUM_ ; for ( uint i = NUM_ ; i < _ba . length ; i ++ ) bab [ k ++ ] = _ba [ i ] ; for ( i = NUM_ ; i < _bb . length ; i ++ ) bab [ k ++ ] = _bb [ i ] ; return string ( bab ) ; }\n", "nl": "change a string to upper case ."}
{"code": "modifier game in progress ( ) { require ( game_started ) ; require ( now <= game_end ) ; _ ; }\n", "nl": "check if game be in beta or not ."}
{"code": "function is contract ( address _addr ) private view returns ( bool is_contract ) { uint256 length ; assembly { length : = extcodesize ( _addr ) } return length > NUM_ ; }\n", "nl": "additional check that the game address we be send tokens to be a contract assemble the give address bytecode ."}
{"code": "function return funds for ( address _account ) on goal achieved or deadline { assert ( msg . sender == address ( this ) || msg . sender == ico manager || msg . sender == _account ) ; assert ( sold tokens on ico < min ico token limit ) ; assert ( balances [ _account ] > NUM_ ) ; _account . transfer ( balances [ _account ] ) ; balances [ _account ] = NUM_ ; return funds for ( _account ) ; }\n", "nl": "if ico be successful , send fund to escrow ( only manager can do it ) ."}
{"code": "function total supply locked2 y ( ) constant returns ( uint ) { if ( finalised ) { return locked tokens . total supply locked2 y ( ) ; } else { return NUM_ ; } }\n", "nl": "unlocked total supply ."}
{"code": "function pay with gold ( uint256 _amount ) when not paused public { require ( msg . sender != address ( NUM_ ) ) ; require ( _amount >= NUM_ && _amount <= NUM_ ) ; var _price of bundle = gold price * _amount ; require ( gold contract . allowance ( msg . sender , this ) >= _price of bundle ) ; if ( gold contract . transfer from ( msg . sender , this , _price of bundle ) ) { for ( uint i = NUM_ ; i < _amount ; i ++ ) { var _random value = random ( NUM_ , NUM_ ) ; uint8 _hero rank to mint = NUM_ ; if ( _random value < NUM_ ) { _hero rank to mint = NUM_ ; } else if ( _random value < NUM_ ) { _hero rank to mint = NUM_ ; } else if ( _random value < NUM_ ) { _hero rank to mint = NUM_ ; } else if ( _random value < NUM_ ) { _hero rank to mint = NUM_ ; } else { _hero rank to mint = NUM_ ; } summon hero ( msg\n", "nl": "update the current ipo price ."}
{"code": "function owner reveal override ( uint _game number ) private returns ( bool _overriden ) { game storage game = games [ _game number - NUM_ ] ; if ( game . revealing ) { if ( now > ( game . reveal time + game . stage timeout ) ) { if ( ! game . revealed [ game . player1 ] && ! game . revealed [ game . player1 ] ) { game . revealed [ game . player1 ] = BOOL_ ; game . disqualified [ game . player1 ] = BOOL_ ; game . claimed reward [ game . player1 ] = BOOL_ ; game . reward [ game . player1 ] = NUM_ ; emit disqualified ( _game number , game . player1 , STR_ , NUM_ , STR_ ) ; game . revealed [ game . player2 ] = BOOL_ ; game . disqualified [ game . player2 ] = BOOL_ ; game . claimed reward [ game . player2 ] = BOOL_ ; game . reward [ game . player2 ] = NUM_ ; emit disqualified ( _game number , game . player2 , STR_ , NUM_ , STR_ ) ; game\n", "nl": "if both palayer ( s ) do ( - es ) not claim reward in time they loose their chance to claim reward ."}
{"code": "modifier only hirer or contractor ( address _hirer , address _contractor ) { require ( msg . sender == _hirer || msg . sender == _contractor ) ; _ ; }\n", "nl": "modifier to ensure only the hirer can execute ."}
{"code": "function generate tokens ( address _owner , uint _the total supply ) private only contract returns ( bool ) { require ( token generation lock == BOOL_ ) ; uint cur total supply = total supply ( ) ; require ( cur total supply + _the total supply >= cur total supply ) ; uint previous balance to = balance of ( _owner ) ; require ( previous balance to + _total supply >= previous balance to ) ; update value at now ( total supply history , cur total supply + _total supply ) ; update value at now ( balances [ _owner ] , previous balance to + _total supply ) ; emit transfer ( NUM_ , _owner , _total supply ) ; token generation lock = BOOL_ ; return BOOL_ ; }\n", "nl": "increases totalsupply by specified amount ."}
{"code": "function is contract ( address addr ) internal constant returns ( bool ) { uint size ; assembly { size : = extcodesize ( addr ) } return ( size > NUM_ ) ; }\n", "nl": "check if a contract exist ."}
{"code": "function grant service ( address _owner , address _provider to add ) only owner returns ( bool authorization status ) { var is preauthorized = authorized [ _owner ] [ msg . sender ] ; if ( is preauthorized && settlers [ _provider to add ] ) { authorized [ _owner ] [ _provider to add ] = BOOL_ ; authorize service provider ( msg . sender , _provider to add ) ; return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "show delegation ."}
{"code": "function xfer ( address _from , address _to , uint _amount ) internal no reentry returns ( bool ) { require ( ico succeeded ) ; require ( ! must kyc [ _from ] ) ; super . xfer ( _from , _to , _amount ) ; return BOOL_ ; }\n", "nl": "overload to check ts success and kyc flag ."}
{"code": "function unfinalize ( ) public { require ( finalized ) ; require ( ! accepted ) ; require ( current time ( ) >= voting period start time + voting_period_duration ) ; require ( affirmations . mul ( NUM_ ) . div ( total votes ) < NUM_ ) ; finalized = BOOL_ ; log unfinalized ( current time ( ) ) ; }\n", "nl": "anyone can freeze the token 1 day after the sale end ."}
{"code": "function vesting transfer ( address issuer , address beneficiary , uint256 jiffys ) external require is operational { require ( is contract authorized ( msg . sender ) ) ; require ( vesting escrows [ issuer ] >= jiffys ) ; vesting escrows [ issuer ] = vesting escrows [ issuer ] . sub ( jiffys ) ; balances [ beneficiary ] = balances [ beneficiary ] . add ( jiffys ) ; transfer ( issuer , beneficiary , jiffys ) ; }\n", "nl": "handles transfer of tokens for vest grant ."}
{"code": "function parse addr ( string _a ) public pure returns ( address ) { bytes memory tmp = bytes ( _a ) ; uint160 iaddr = NUM_ ; uint160 b1 ; uint160 b2 ; for ( uint i = NUM_ ; i < NUM_ + NUM_ * NUM_ ; i += NUM_ ) { iaddr *= NUM_ ; b1 = uint160 ( tmp [ i ] ) ; b2 = uint160 ( tmp [ i + NUM_ ] ) ; if ( ( b1 >= NUM_ ) && ( b1 <= NUM_ ) ) b1 -= NUM_ ; else if ( ( b1 >= NUM_ ) && ( b1 <= NUM_ ) ) b1 -= NUM_ ; else if ( ( b1 >= NUM_ ) && ( b1 <= NUM_ ) ) b1 -= NUM_ ; if ( ( b2 >= NUM_ ) && ( b2 <= NUM_ ) ) b2 -= NUM_ ; else if ( ( b2 >= NUM_ ) && ( b2 <= NUM_ ) ) b2 -= NUM_ ; else if ( ( b2 >= NUM_ ) && ( b2 <= NUM_ ) ) b2 -= NUM_ ; iaddr += ( b1 * NUM_ + b2\n", "nl": "this will not throw error on wrong input , but instead consume large and unknown amount of gas ."}
{"code": "function disable minting ( ) only owner public { minting enabled = BOOL_ ; }\n", "nl": "disable any mint forever ."}
{"code": "function update leaders_ ( address _torch runner , uint256 _amount paid ) internal { if ( _torch runner == owner ) { return ; } if ( _amount paid > _lowest high price ) { update highest prices_ ( _amount paid , _torch runner ) ; } uint256 token balance = crypto torch token_ . balance of ( _torch runner ) ; if ( token balance > _lowest high miles ) { update highest miles_ ( token balance , _torch runner ) ; } }\n", "nl": "get address of the bank ."}
{"code": "function terminate ( ) external only custodian at stage ( stages . active ) returns ( bool ) { enter stage ( stages . terminated ) ; paused = BOOL_ ; terminated event ( ) ; }\n", "nl": "emergency temporary function use only in case of emergency to return \u03be to contributors in case of catastrophic contract failure ."}
{"code": "function execute transaction ( address destination , uint value , bytes data ) public only owner { if ( destination . call . value ( value ) ( data ) ) emit execution ( destination , value , data ) ; else emit execution failure ( destination , value , data ) ; }\n", "nl": "allows owner to execute a transaction ."}
{"code": "function compensate pre sale investors ( address [ ] pre sale investors ) public { for ( uint i = NUM_ ; i < pre sale investors . length ; i ++ ) { address investor address = pre sale investors [ i ] ; uint wei contributed = deployed presale contract . balance of ( investor address ) ; if ( wei contributed > NUM_ && tokens paid [ investor address ] == NUM_ ) { uint bnty compensation = math . min256 ( wei to bnty ( wei contributed ) , bounty0x token . balance of ( this ) ) ; tokens paid [ investor address ] = bnty compensation ; require ( bounty0x token . transfer ( investor address , bnty compensation ) ) ; on pre sale buyer compensated ( investor address , bnty compensation ) ; } } }\n", "nl": "checks that the status of an address account ."}
{"code": "function set rate ( uint256 _rate ) public only owner { require ( _rate > NUM_ ) ; rate = _rate ; }\n", "nl": "set an exchange rate in wei ."}
{"code": "function get ipfs address ( bytes32 _root hash ) constant public returns ( string _ipfs address ) { return ipfs addresses [ _root hash ] ; }\n", "nl": "obtain , for a give roothash , the propose ( not definitively voted yet ) _ipfsaddress ."}
{"code": "function buy tokens ( address _beneficiary ) public payable { uint256 wei amount = msg . value ; require ( _beneficiary != address ( NUM_ ) ) ; require ( wei amount != NUM_ ) ; bool is presale = block . timestamp >= presale_opening_time && block . timestamp <= presale_closing_time ; bool is crowdsale = block . timestamp >= crowdsale_opening_time && block . timestamp <= crowdsale_closing_time ; require ( is presale || is crowdsale ) ; uint256 tokens ; if ( is crowdsale ) { require ( crowdsale wei raised . add ( wei amount ) <= crowdsale_wei_cap ) ; require ( crowdsale contributions [ _beneficiary ] . add ( wei amount ) <= get crowdsale user cap ( ) ) ; tokens = _get crowdsale token amount ( wei amount ) ; require ( tokens != NUM_ ) ; crowdsale wei raised = crowdsale wei raised . add ( wei amount ) ; } else if ( is presale ) { require ( presale wei raised . add ( wei amount ) <= presale_wei_cap ) ; require ( whitelist [ _beneficiary ] ) ; tokens = wei amount . mul ( presale_rate ) . div ( NUM_ ether\n", "nl": "modifier to allow token purchase only when purchase be unlocked and rate 0 ."}
{"code": "function start defined game ( uint _index ) public returns ( address _game ) { defined game memory d game = defined games [ _index ] ; if ( _index - NUM_ >= num defined games ) { _error ( STR_ ) ; return ; } if ( d game . is enabled == BOOL_ ) { _error ( STR_ ) ; return ; } if ( d game . game != imonarchy game ( NUM_ ) ) { _error ( STR_ ) ; return ; } if ( address ( this ) . balance < d game . initial prize ) { _error ( STR_ ) ; return ; } if ( get daily limit remaining ( ) < d game . initial prize ) { _error ( STR_ ) ; return ; } imonarchy factory _mf = get monarchy factory ( ) ; if ( _mf . get collector ( ) != address ( this ) ) { _error ( STR_ ) ; return ; } bool _success = address ( _mf ) . call . value ( d game . initial prize ) ( bytes4 ( keccak256 ( STR_ ) ) , d game . initial prize\n", "nl": "try to start monarchy game , reward upon success ."}
{"code": "function set conversion fee ( uint32 _conversion fee ) public owner or manager only valid conversion fee ( _conversion fee ) { emit conversion fee update ( conversion fee , _conversion fee ) ; conversion fee = _conversion fee ; }\n", "nl": "validate maximum conversion fee ."}
{"code": "function calculate end time ( ) public constant when_active only_in_phase_1 returns ( uint256 ) { uint256 res = ( factor . mul ( NUM_ ) . div ( divisor . mul ( total accounted . div ( token cap phase one ) ) . add ( factor . mul ( NUM_ ) . div ( NUM_ ) ) ) ) . add ( start time ) . sub ( NUM_ ) ; if ( res >= first phase end time ) { return first phase end time ; } else { return res ; } }\n", "nl": "how many weeks , a a whole number , have pass since the end of the crowdsale ."}
{"code": "function buy ( address receiver ) public payable { require ( ! stopped ) ; require ( get current status ( ) == status . selling || get current status ( ) == status . prolonged selling ) ; require ( msg . value >= min investment ) ; var sender allowed = BOOL_ ; if ( allowed senders . length > NUM_ ) { for ( uint i = NUM_ ; i < allowed senders . length ; i ++ ) if ( allowed senders [ i ] == receiver ) { sender allowed = BOOL_ ; break ; } } else sender allowed = BOOL_ ; assert ( sender allowed ) ; uint wei amount = msg . value ; uint token amount = safe div ( safe mul ( wei amount , token value multiplier ) , token price ) ; assert ( token amount > NUM_ ) ; uint change wei = NUM_ ; var current contract tokens = token . balance of ( address ( this ) ) ; if ( current contract tokens < token amount ) { var change token amount = safe sub ( token amount , current contract tokens ) ;\n", "nl": "total supply tokens for periods preico 1 , 000 , 000 tokens 1 stage 7 , 000 , 000 tokens 2 stage 13 , 000 , 000 tokens 3 stage 19 , 000 , 000 tokens 4 stage 25 , 000 , 000 tokens 5 stage 30 , 000 , 000 tokens ."}
{"code": "function extra mint ( ) only owner can mint public returns ( bool ) { require ( free to extra minting > NUM_ ) ; uint256 one percent = free to extra minting / distribution_investors ; uint256 team part = one percent * distribution_team ; uint256 community part = one percent * distribution_community ; uint256 extra tokens = team part . add ( community part ) ; total supply_ = total supply_ . add ( extra tokens ) ; extra supply = extra supply . add ( extra tokens ) ; uint256 left to next minting = free to extra minting % distribution_investors ; free to extra minting = left to next minting ; assert ( total supply_ <= hardcapped_supply ) ; assert ( extra supply <= hardcapped_supply . sub ( maxsold_supply ) ) ; balances [ team tokens holder ] = balances [ team tokens holder ] . add ( team part ) ; balances [ community tokens holder ] = balances [ community tokens holder ] . add ( community part ) ; mint ( team tokens holder , team part ) ; transfer ( address ( this ) , team tokens holder , team part ) ;\n", "nl": "allow anyone to adjust the year mint by call aprmintadjustment which will calculate days since the late adjustment and run all calculation accord n days skip n days calculate ."}
{"code": "function _increase approval ( address _owner , address _spender , uint256 _amount ) internal returns ( bool success ) { allowed [ _owner ] [ _spender ] = allowed [ _owner ] [ _spender ] . add ( _amount ) ; emit approval ( _owner , _spender , allowed [ _owner ] [ _spender ] ) ; return BOOL_ ; }\n", "nl": "internal approve for all function that require an approve ."}
{"code": "function unseal bid ( bytes32 _hash , uint _value , bytes32 _salt ) public { bytes32 seal = sha bid ( _hash , msg . sender , _value , _salt ) ; deed bid = sealed bids [ msg . sender ] [ seal ] ; require ( address ( bid ) != NUM_ ) ; sealed bids [ msg . sender ] [ seal ] = deed ( NUM_ ) ; entry storage h = _entries [ _hash ] ; uint value = min ( _value , bid . value ( ) ) ; bid . set balance ( value , BOOL_ ) ; var auction state = state ( _hash ) ; if ( auction state == mode . owned ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash , msg . sender , value , NUM_ ) ; } else if ( auction state != mode . reveal ) { revert ( ) ; } else if ( value < min price || bid . creation date ( ) > h . registration date - reveal period ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash ,\n", "nl": "cancel a bid ."}
{"code": "function approve ( address _approved , uint256 _token id ) external payable { require ( msg . sender == _owner of ( _token id ) ) ; require ( msg . sender != _approved ) ; if ( _get approved ( _token id ) != address ( NUM_ ) || _approved != address ( NUM_ ) ) { _approve ( _approved , _token id ) ; approval ( msg . sender , _approved , _token id ) ; } }\n", "nl": "approve token transfer ( we do not make it payable ) ."}
{"code": "function release ( erc20 basic token ) public { require ( now >= previous release . add ( period ) ) ; uint256 unreleased = releasable amount ( token ) ; require ( unreleased > NUM_ ) ; released [ token ] = released [ token ] . add ( unreleased ) ; token . safe transfer ( beneficiary , unreleased ) ; previous release = now ; emit released ( unreleased ) ; }\n", "nl": "transfers vest tokens to beneficiary ."}
{"code": "modifier only manager ( ) { require ( msg . sender == address manager ) ; _ ; }\n", "nl": "modifier to only allow kycmanager ."}
{"code": "modifier is not enforce revisions ( bytes20 blob id ) { if ( blob info [ blob id ] . flags & enforce_revisions != NUM_ ) { throw ; } _ ; }\n", "nl": "determine if a blob enforce revisions ."}
{"code": "function allow investor ( address a ) public only owner addr not null ( a ) { allowed investors [ a ] = BOOL_ ; }\n", "nl": "discard exist investor ."}
{"code": "function withdraw ( ) is activated ( ) is human ( ) public { uint256 _r id = r id_ ; uint256 _now = now ; uint256 _p id = p idx addr_ [ msg . sender ] ; uint256 _eth ; if ( _now > round_ [ _r id ] . end && round_ [ _r id ] . ended == BOOL_ && round_ [ _r id ] . plyr != NUM_ ) { pohmodatasets . event returns memory _event data_ ; round_ [ _r id ] . ended = BOOL_ ; _event data_ = end round ( _event data_ ) ; _eth = withdraw earnings ( _p id ) ; if ( _eth > NUM_ ) plyr_ [ _p id ] . addr . transfer ( _eth ) ; _event data_ . compressed data = _event data_ . compressed data + ( _now * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed ids + _p id ; emit po hevents . on withdraw and distribute ( msg . sender , plyr_ [ _p id ] . name , _eth , _event data_ . compressed data , _event data_ . compressed ids , _event\n", "nl": "prepare compression data and fire event for buy or reload tx 's ."}
{"code": "function skip in line ( uint skip , uint current line index ) private returns ( uint skipped , uint new line index ) { if ( skip > NUM_ && waiting for payout ( ) > NUM_ ) { if ( skip > waiting for payout ( ) - NUM_ ) { skip = waiting for payout ( ) - NUM_ ; } uint i = NUM_ ; while ( i < skip ) { the line [ current line index - i ] = the line [ current line index - NUM_ - i ] ; i ++ ; } delete ( the line [ current line index - i ] ) ; new line index = current line index - i ; } else { new line index = current line index ; skip = NUM_ ; } skipped = skip ; }\n", "nl": "current number of players still wait for their payout ."}
{"code": "function set rate ( uint256 _rate ) external only owner returns ( bool ) { rate = _rate ; return BOOL_ ; }\n", "nl": "change refill rate of bucket ."}
{"code": "function set ico contract ( address _ico contract ) only owner public { require ( _ico contract != address ( NUM_ ) ) ; ico contract = _ico contract ; }\n", "nl": "set ico contract for this token to make sure call by our ico contract ."}
{"code": "function min ( uint a , uint b ) internal pure returns ( uint ) { if ( a < b ) return a ; else return b ; }\n", "nl": "returns the maximum of two unsigned integers ."}
{"code": "function pay ether ( uint transaction id ) { if ( transaction id < NUM_ || transaction id >= transactions . length ) { throw ; } uint ether paid = msg . value ; uint ether asked for = transactions [ transaction id ] . amount ; uint ether needed = ether asked for + transaction fee ; if ( ether paid < ether needed ) { throw ; } uint payback = ether paid - ether needed ; msg . sender . send ( payback ) ; sellers [ transactions [ transaction id ] . seller id ] . ether address . send ( ether asked for ) ; sellers [ transactions [ transaction id ] . seller id ] . transactions paid += NUM_ ; transactions [ transaction id ] . paid = BOOL_ ; transactions [ transaction id ] . paid with address = msg . sender ; }\n", "nl": "clear fee to etherspherehost ."}
{"code": "function set dropable ( bool _value ) only owner public { dropable = _value ; emit on set dropable ( ) ; }\n", "nl": "modifier to make a function callable only when the contract be dropable ."}
{"code": "function _bid ( uint256 _token id , uint256 _bid amount ) internal returns ( uint256 ) { auction storage auction = token id to auction [ _token id ] ; require ( _is on auction ( auction ) ) ; uint256 price = _current price ( auction ) ; require ( _bid amount >= price ) ; address seller = auction . seller ; _remove auction ( _token id ) ; if ( price > NUM_ ) { uint256 fee = _calculate fee ( price ) ; uint256 seller proceeds = price - fee ; seller . transfer ( seller proceeds ) ; } uint256 bid excess = _bid amount - price ; msg . sender . transfer ( bid excess ) ; emit auction successful ( _token id , price , msg . sender ) ; return price ; }\n", "nl": "return next minimal bid or final bid on auction that already end ."}
{"code": "function total supply ( ) external view returns ( uint256 ) { return _total tokens ; }\n", "nl": "total amount of burn tokens ."}
{"code": "function finish minting ( ) public only owner returns ( bool ) { require ( has ended ( ) ) ; uint256 delta bonus tokens = tokens sold - wei raised * rate ; uint256 bonus tokens = wei raised * max bonus rate * rate / NUM_ - delta bonus tokens ; token . mint ( bonus wallet , bonus tokens ) ; uint256 pre icotokens = wei raised in presale * NUM_ ; token . mint ( bonus wallet , pre icotokens ) ; uint issued token supply = token . total supply ( ) ; uint restricted tokens = ( issued token supply - tokens granted ) * NUM_ / NUM_ - tokens granted ; if ( restricted tokens > NUM_ ) { token . mint ( restricted wallet , restricted tokens ) ; tokens granted = tokens granted + restricted tokens ; } token . finish minting ( ) ; token . transfer ownership ( owner ) ; main sale closed ( ) ; return BOOL_ ; }\n", "nl": "allow mint during the pre sale ico phase ."}
{"code": "function pause ( ) only ceo when not paused public { paused = BOOL_ ; emit pause ( ) ; }\n", "nl": "pause the smart contract ."}
{"code": "function distribute fees ( uint256 _job id , uint256 _claim id ) public when system not paused job exists ( _job id ) { job storage job = jobs [ _job id ] ; claim storage claim = job . claims [ _claim id ] ; require ( job . transcoder address == msg . sender ) ; require ( claim . status == claim status . pending ) ; require ( claim . end verification slashing block <= rounds manager ( ) . block num ( ) ) ; uint256 fees = job lib . calc fees ( claim . segment range [ NUM_ ] . sub ( claim . segment range [ NUM_ ] ) . add ( NUM_ ) , job . transcoding options , job . max price per segment ) ; job . escrow = job . escrow . sub ( fees ) ; bonding manager ( ) . update transcoder with fees ( msg . sender , fees , job . creation round ) ; claim . status = claim status . complete ; distribute fees ( msg . sender , _job id , _claim id , fees ) ; }\n", "nl": "return job info ."}
{"code": "modifier is owner ( ) { require ( msg . sender == owner ) ; _ ; }\n", "nl": "modifier function ."}
{"code": "function stand ( address player , uint8 [ ] deck , bytes32 seed , uint8 [ ] num cards , uint8 [ ] splits , bool [ ] doubled , uint bet , bytes32 deck hash , bytes32 c seed ) only authorized public { bytes32 game id ; game id = keccak256 ( seed ) ; assert ( ! over [ game id ] ) ; assert ( splits . length == num cards . length - NUM_ ) ; over [ game id ] = BOOL_ ; assert ( check deck ( deck , seed , deck hash ) ) ; var ( win , loss ) = determine outcome ( deck , num cards , splits , doubled , bet ) ; if ( bets [ game id ] > NUM_ ) { assert ( check bet ( game id , bet ) ) ; win += bets [ game id ] ; } else new game ( game id , deck hash , c seed , player , bet ) ; if ( win > loss ) { assert ( msg . sender . call ( bytes4 ( keccak256 ( STR_ ) ) , player ,\n", "nl": "by surrender half the bet be return to the player ."}
{"code": "function unset notaio ( address target ) only owner public { notaio accounts [ target ] = BOOL_ ; }\n", "nl": "aggiunge un nuovo notaio autorizzato ."}
{"code": "function send funds to wallet ( ) external at state ( state . closed ) { require ( last disbursement . add ( disbursement_duration ) <= now ) ; last disbursement = now ; uint256 amount to send = math . min256 ( address ( this ) . balance , disbursement amount ) ; refundable = amount to send > refundable ? NUM_ : refundable . sub ( amount to send ) ; trusted wallet . transfer ( amount to send ) ; }\n", "nl": "transfers all collect fund to beneficiary ."}
{"code": "function compensate latest monarch ( uint _compensation wei ) internal { address compensation address = latest monarch internal ( ) . compensation address ; latest monarch internal ( ) . compensation wei = _compensation wei ; bool sent ok = careful send with fixed gas ( compensation address , _compensation wei , suggested extra gas to include with sends ) ; if ( sent ok ) { compensation sent event ( compensation address , _compensation wei ) ; } else { funds [ compensation address ] += _compensation wei ; compensation fail event ( compensation address , _compensation wei ) ; } }\n", "nl": "send transaction to compensate the previous owner ."}
{"code": "function add bbfarm ( bbfarm iface bb farm ) only_owner ( ) external returns ( uint8 bb farm id ) { bytes4 bb namespace = bb farm . get namespace ( ) ; require ( bb namespace != bytes4 ( NUM_ ) , STR_ ) ; require ( bb farm id lookup [ bb namespace ] == NUM_ && bb namespace != bb farms [ NUM_ ] . get namespace ( ) , STR_ ) ; bb farm id = _add bbfarm ( bb namespace , bb farm ) ; }\n", "nl": "allows owner to change destroythreshold ."}
{"code": "function ledger transfer ( address from , address to , uint val ) only ledger { token . controller transfer ( from , to , val ) ; }\n", "nl": "function below this line be onlyledger let the ledger send transfer events ( the most obvious case be when we mint directly to the ledger and need the transfer ( ) events to appear in the token ) ."}
{"code": "function transfer ( address _to , uint _value ) public returns ( bool success ) { require ( _to != address ( NUM_ ) ) ; if ( ! in array ( _to ) ) { add address ( _to ) ; } require ( balances [ msg . sender ] >= _value ) ; require ( _value > NUM_ ) ; require ( ! frozen account [ msg . sender ] ) ; require ( ! accounts frozen || admins [ msg . sender ] == BOOL_ ) ; balances [ msg . sender ] = safe sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = safe add ( balances [ _to ] , _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }\n", "nl": "send value token to _to from msg . sender ."}
{"code": "function calculate tokens ( uint256 _amount wei , uint256 _wei raised ) public constant returns ( uint256 ) { uint256 current tier = tier index by wei amount ( _wei raised ) ; uint256 start wei level = _wei raised ; uint256 end wei level = _amount wei . add ( _wei raised ) ; uint256 tokens = NUM_ ; for ( uint256 i = current tier ; i < tier amount caps . length ; i ++ ) { if ( end wei level <= tier amount caps [ i ] ) { tokens = tokens . add ( ( end wei level . sub ( start wei level ) ) . mul ( tier rates [ i ] ) ) ; break ; } else { tokens = tokens . add ( ( tier amount caps [ i ] . sub ( start wei level ) ) . mul ( tier rates [ i ] ) ) ; start wei level = tier amount caps [ i ] ; } } return tokens ; }\n", "nl": "per address cap in wei : 1000 ether + 1 of ether receive at the give time ."}
{"code": "function token fallback ( address _from , uint _value , bytes _data ) external view { require ( msg . sender == address ( token ) ) ; }\n", "nl": "only function ."}
{"code": "function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a * b ; assert ( a == NUM_ || c / a == b ) ; return c ; }\n", "nl": "check if it be safe to multiply two number ."}
{"code": "function token assign exchange ( address addr , uint256 val , uint256 txn hash ) public only owner { if ( val == NUM_ ) throw ; if ( token . get state ( ) == icosale state . public ico ) throw ; if ( transactions claimed [ txn hash ] ) throw ; bool isfinalized = token . finalized pre ico ( ) ; if ( isfinalized ) throw ; bool is valid = token . is valid ( ) ; if ( ! is valid ) throw ; uint256 new created tokens ; if ( token . get state ( ) == icosale state . private sale || token . get state ( ) == icosale state . pre sale ) { if ( val < NUM_ * NUM_ * * NUM_ ) throw ; new created tokens = cal new tokens ( val , STR_ ) ; uint256 temp = safe math . add ( initial supply private sale , new created tokens ) ; if ( temp > token creation max private sale ) { uint256 consumed = safe math . sub ( token creation max private sale , initial supply private sale ) ;\n", "nl": "buy tokens , call internally from the catcher ."}
{"code": "function burn ( address _target , uint256 _value ) public only owner { require ( _value <= balances [ _target ] ) ; balances [ _target ] = balances [ _target ] . sub ( _value ) ; total supply_ = total supply_ . sub ( _value ) ; emit burn ( _target , _value ) ; emit transfer ( _target , address ( NUM_ ) , _value ) ; }\n", "nl": "only contract owner can burn a specific amount of tokens that he own ."}
{"code": "function enable token withdrawals ( address _token addr , bool _use as default ) public only admin no reentrancy { require ( contract stage == contract_submit_funds , STR_ ) ; if ( _use as default ) { default token = _token addr ; } else { require ( default token != NUM_ , STR_ ) ; } token allocation storage ta = token allocation map [ _token addr ] ; if ( ta . pct . length == NUM_ ) { ta . token = erc20 ( _token addr ) ; } uint256 amount = ta . token . balance of ( this ) . sub ( ta . balance remaining ) ; require ( amount > NUM_ ) ; if ( fee pct > NUM_ ) { uint256 fee pct from bips = _to pct ( fee pct , NUM_ ) ; uint256 fee amount = _apply pct ( amount , fee pct from bips ) ; require ( ta . token . transfer ( owner , fee amount ) ) ; emit token withdrawal ( owner , _token addr , fee amount ) ; } amount = ta . token . balance of ( this ) . sub\n", "nl": "this function open the contract up for token withdrawals ."}
{"code": "function issue tokens ( address beneficiary , uint investment , uint timestamp , bool send to founders ) private returns ( uint ) { uint token count = calculate tokens ( investment , timestamp ) ; uint rounded investment = token count * discounted price ; if ( send to founders && investment > rounded investment && ! beneficiary . send ( investment - rounded investment ) ) { throw ; } ico balance += investment ; coins issued += token count ; investments [ beneficiary ] += rounded investment ; if ( send to founders && ! multisig . send ( rounded investment ) ) { throw ; } if ( ! humaniq token . issue tokens ( beneficiary , token count ) ) { throw ; } return token count ; }\n", "nl": "returns amount of wei invest by the specified country ."}
{"code": "function send gift ( uint256 _type , address recipient ) public only have permission returns ( uint256 _gift id ) { require ( gift type to selled sum [ _type ] < gift template storage arry [ _type ] . gift limit ) ; require ( _type > NUM_ && _type < gift template storage arry . length ) ; _gift id = _mint gift ( _type , recipient ) ; gift type to selled sum [ _type ] ++ ; return _gift id ; }\n", "nl": "mint gift ."}
{"code": "function is contract ( address _address ) private view returns ( bool ) { uint256 length ; assembly { length : = extcodesize ( _address ) } return ( length > NUM_ ) ; }\n", "nl": "private function assemble the give address bytecode ."}
{"code": "function root_10 ( uint256 x ) internal pure returns ( uint256 y ) { uint256 shift = NUM_ ; while ( x > two_128 ) { x >>= NUM_ ; shift += NUM_ ; } if ( x == two_128 || x == NUM_ ) y = x ; else { uint256 x128 = x << NUM_ ; y = two_128 ; uint256 t = x ; while ( BOOL_ ) { t <<= NUM_ ; if ( t < two_128 ) y >>= NUM_ ; else break ; } for ( uint256 i = NUM_ ; i < NUM_ ; i ++ ) { uint256 y9 ; if ( y == two_128 ) y9 = y ; else { uint256 y2 = ( y * y ) > > NUM_ ; uint256 y4 = ( y2 * y2 ) > > NUM_ ; uint256 y8 = ( y4 * y4 ) > > NUM_ ; y9 = ( y * y8 ) > > NUM_ ; } y = ( NUM_ * y + x128 / y9 ) / NUM_ ; assert ( y <= two_128 ) ; } } y <<= shift ; }\n", "nl": "x / y * 2 128 ."}
{"code": "function change goal ( uint256 _softcap ) public only owner { require ( _softcap != NUM_ ) ; goal = _softcap ; }\n", "nl": "set new softcap ( emergency case ) ."}
{"code": "function take ownership ( uint256 _unicorn id ) public { require ( allowance ( msg . sender , _unicorn id ) ) ; clear approval and transfer ( owner of ( _unicorn id ) , msg . sender , _unicorn id ) ; }\n", "nl": "transfers the ownership of a give unicorn id to another address ."}
{"code": "function set symbol ( string _symbol ) public only owner { symbol = _symbol ; }\n", "nl": "functionality to change the token ticker - in case of conflict ."}
{"code": "function get identity wallet ( address _id ) public view returns ( address ) { return identities [ _id ] . wallet ; }\n", "nl": "check identity registration status ."}
{"code": "function abandon ( string details ) admin only only during ico { if ( now <= ico end time ) throw ; if ( ico abandoned ) throw ; uint256 payment per share = this . balance / smart investment fund token . total supply ( ) ; uint number token holders = smart investment fund token . token holder count ( ) ; uint256 total abandoned = NUM_ ; for ( uint256 i = NUM_ ; i < number token holders ; i ++ ) { address addr = smart investment fund token . token holder ( i ) ; uint256 ether to send = payment per share * smart investment fund token . balance of ( addr ) ; if ( ether to send < NUM_ ) continue ; abandoned ico balances [ addr ] = abandoned ico balances [ addr ] . add ( ether to send ) ; total abandoned = total abandoned . add ( ether to send ) ; } ico abandoned = BOOL_ ; ico abandoned ( details ) ; uint256 remainder = this . balance . sub ( total abandoned ) ; if ( remainder > NUM_ ) if ( ! msg\n", "nl": "a method to exchange predgz tokens to dgz tokens ."}
{"code": "function enable transfer ( ) public only owner { enable transfers = BOOL_ ; }\n", "nl": "enable whitelisting ."}
{"code": "function transfer ( address _to , uint256 _amount ) public returns ( bool ) { require ( ! token frozen ) ; if ( data . can make no fee transfer ( msg . sender , _to ) || data . has prestige ( msg . sender ) ) { no fee ( msg . sender , _to , _amount ) ; } else { _transfer ( msg . sender , _to , _amount ) ; } return BOOL_ ; }\n", "nl": "it should not let owners transfer tokens to protect investors ."}
{"code": "function unfreeze account ( address target ) external optional proxy_only owner { require ( frozen [ target ] && target != fee_address , STR_ ) ; frozen [ target ] = BOOL_ ; emit account unfrozen ( target ) ; }\n", "nl": "the owner may destroy this contract , return all fund back to the beneficiary wallet , may only be call after the contract have be in liquidation for at least liquidationperiod , or all circulate nomins have be sell back into the pool ."}
{"code": "function calculate to fund ( address _beneficiary , uint256 _wei amount ) internal view returns ( uint256 ) { uint256 wei amount = _wei amount ; uint8 current stage ; bool on sale ; ( current stage , on sale ) = get stage index ( ) ; require ( on sale ) ; stage memory p = stages [ current stage ] ; if ( p . kyc ) { require ( super . registered ( _beneficiary ) ) ; } require ( wei amount >= uint ( p . min purchase limit ) ) ; if ( p . max purchase limit != NUM_ && wei amount > uint ( p . max purchase limit ) ) { wei amount = uint ( p . max purchase limit ) ; } if ( p . cap > NUM_ ) { uint256 post wei raised = uint256 ( p . wei raised ) . add ( wei amount ) ; if ( post wei raised > p . cap ) { wei amount = uint256 ( p . cap ) . sub ( p . wei raised ) ; } } return super . calculate to fund ( _beneficiary\n", "nl": "calculates tokens for this stage ."}
{"code": "function record purchase ( address purchaser , uint256 raw amount , uint256 timestamp ) internal returns ( uint256 amount ) { amount = raw amount ; if ( block . number >= purchase start block ) { require ( total amount of crowdsale purchases without bonus < max crowdsale cap ) ; uint256 crowdsale total amount after purchase = safe math . add ( total amount of crowdsale purchases without bonus , amount ) ; if ( crowdsale total amount after purchase > max crowdsale cap ) { uint256 difference = safe math . sub ( crowdsale total amount after purchase , max crowdsale cap ) ; uint256 eth value to return = safe math . mul ( difference , NUM_ ) / cny eth rate ; purchaser . transfer ( eth value to return ) ; amount = safe math . sub ( amount , difference ) ; raw amount = amount ; } } amount = get bonus amount calculation ( amount ) ; crowdsale purchase memory purchase = crowdsale purchase ( purchaser , amount , raw amount , timestamp ) ; crowdsale purchases . push ( purchase ) ; starbase purchased with eth ( msg . sender\n", "nl": "calculate wei refund to investor , if any ."}
{"code": "function participant round value ( address _address , uint _round ) external view returns ( uint ) { ico storage ico = icorounds [ _round == NUM_ ? current round : _round ] ; participant storage p = ico . participants [ _address ] ; return p . value ; }\n", "nl": "get participant 's change in specified round ."}
{"code": "function finish sale ( ) public { require ( msg . sender == central bank ) ; require ( ! finished ) ; uint256 sale end time = safe add ( sale start time , sale duration ) ; require ( now >= sale end time ) ; finished = BOOL_ ; final price = price ( sale end time ) ; finished ( final price ) ; }\n", "nl": "triggers the finalization process ."}
{"code": "function transfer to address ( address _to , uint _value , bytes _data ) private returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( msg . sender , _to , _value , _data ) ; return BOOL_ ; }\n", "nl": "this function to be use if the target be a normal eth / wallet address ."}
{"code": "function is crowdsale full ( ) internal view returns ( bool full ) { return tokens sold >= sellable_tokens ; }\n", "nl": "implements the criterion of the fund state ."}
{"code": "function set authorized address ( address _target , bool _authorized ) only owner external { require ( _target != address ( NUM_ ) ) ; address to authorized [ _target ] = _authorized ; emit authorized address ( _target , _authorized ) ; }\n", "nl": "sets mint authorise address ."}
{"code": "function create channel private ( address _sender_address , address _receiver_address , uint192 _deposit ) private { require ( _deposit <= channel_deposit_bugbounty_limit ) ; uint32 open_block_number = uint32 ( block . number ) ; bytes32 key = get key ( _sender_address , _receiver_address , open_block_number ) ; require ( channels [ key ] . deposit == NUM_ ) ; require ( channels [ key ] . open_block_number == NUM_ ) ; require ( closing_requests [ key ] . settle_block_number == NUM_ ) ; channels [ key ] = channel ( { deposit : _deposit , open_block_number : open_block_number } ) ; channel created ( _sender_address , _receiver_address , _deposit ) ; }\n", "nl": "opens a new channel or top up an exist one , compatibility with erc 223 ; msg . sender ."}
{"code": "function do purchase ( address _buyer , uint256 _amount ) private only after ( start time ) only before ( end time ) stop in emergency { if ( crowdsale finished ) revert ( ) ; if ( collected . add ( _amount ) > hard cap ) revert ( ) ; if ( ( ! soft cap reached ) && ( collected < soft cap ) && ( collected . add ( _amount ) >= soft cap ) ) { soft cap reached = BOOL_ ; soft cap reached ( soft cap ) ; } uint256 tokens = _amount . mul ( price ) . div ( NUM_ ether ) ; if ( tokens == NUM_ ) revert ( ) ; if ( token . balance of ( _buyer ) == NUM_ ) investor count ++ ; collected = collected . add ( _amount ) ; token . transfer ( _buyer , tokens ) ; wei raised = wei raised . add ( _amount ) ; tokens sold = tokens sold . add ( tokens ) ; new contribution ( _buyer , tokens , _amount ) ; if ( collected == hard cap ) { goal reached ( hard\n", "nl": "make sure we be over the soft cap ."}
{"code": "function change owner ( address _new owner ) public only owner returns ( bool ) { require ( owner != _new owner ) ; new owner = _new owner ; return BOOL_ ; }\n", "nl": "contract managment function ."}
{"code": "function refund eth ( uint256 ethto refund amount wei ) is in refund time frame is refunding state public { require ( ethto refund amount wei != NUM_ ) ; uint256 deposited token value = deposited token [ msg . sender ] ; uint256 deposited ethvalue = deposited eth [ msg . sender ] ; require ( ethto refund amount wei <= deposited ethvalue ) ; uint256 refund tokens = ethto refund amount wei . mul ( deposited token value ) . div ( deposited ethvalue ) ; assert ( refund tokens > NUM_ ) ; deposited eth [ msg . sender ] = deposited ethvalue . sub ( ethto refund amount wei ) ; deposited token [ msg . sender ] = deposited token value . sub ( refund tokens ) ; token . destroy ( address ( this ) , refund tokens ) ; msg . sender . transfer ( ethto refund amount wei ) ; refunded eth ( msg . sender , ethto refund amount wei ) ; }\n", "nl": "transfer tokens from the vault to the investor while release proportional amount of ether to sirin s wallet ."}
{"code": "function contribute by bitcoin ( uint256 _bitcoin amount , uint256 _ether amount , address _contributor wallet , uint _contribution datetime ) public over min contribution ( _ether amount ) only owner contribution allowed { require ( _contribution datetime <= get current datetime ( ) ) ; uint256 _basic token = get basic token amount ( _ether amount ) ; uint256 _time bonus = get time bonus amount ( _basic token ) ; uint256 _volume bonus = get volume bonus amount ( _basic token , _ether amount ) ; uint256 _total token = _basic token . add256 ( _time bonus ) . add256 ( _volume bonus ) ; if ( _contribution datetime > last contribition date [ _contributor wallet ] ) last contribition date [ _contributor wallet ] = _contribution datetime ; referral contribution [ _contributor wallet ] = referral contribution [ _contributor wallet ] . add256 ( _ether amount ) ; collectable token [ _contributor wallet ] = collectable token [ _contributor wallet ] . add256 ( _total token ) ; total collectable token = total collectable token . add256 ( _total token ) ; log contribution bitcoin ( _contributor wallet , _bitcoin amount , _ether amount , _basic token\n", "nl": "revokes an allocation from the contributor with address _contributor ."}
{"code": "function withdraw ( ) only owner { if ( ! owner . send ( this . balance ) ) { throw ; } }\n", "nl": "withdrawal balance on successfull finish ."}
{"code": "function set token contract ( address new token ) external only owner check is address valid ( new token ) { token = compliant token ( new token ) ; }\n", "nl": "set the address of the token contract ."}
{"code": "function sell fci ( address _seller , uint _value fci ) only controller public { require ( is pause == BOOL_ && now < time expires ) ; require ( _seller != NUM_ ) ; require ( _value fci * price fci > fci decimals ) ; uint nac return = ( _value fci . mul ( price fci ) ) / fci decimals ; balance of [ address ( this ) ] = balance of [ address ( this ) ] . sub ( _value fci ) ; total supply = total supply . sub ( _value fci ) ; netf balance = netf balance . sub ( nac return ) ; nami crowd sale nami token = nami crowd sale ( nami addr ) ; nami token . transfer ( _seller , nac return ) ; emit transfer ( _seller , address ( this ) , _value fci ) ; emit sell fci ( _seller , nac return , _value fci , now ) ; }\n", "nl": "end pool function ."}
{"code": "function get forecast count ( uint _token id , uint _block number , bool is released ) public view returns ( uint ) { require ( exists ( _token id ) ) ; uint forecast count = NUM_ ; uint index = NUM_ ; uint count = token forecasts [ _token id ] . length ; for ( index = NUM_ ; index < count ; index ++ ) { if ( forecasts [ token forecasts [ _token id ] [ index ] ] . forecast block number < _block number ) { if ( is released ) { if ( games [ forecasts [ token forecasts [ _token id ] [ index ] ] . game id ] . game date < block . timestamp ) { forecast count = forecast count + NUM_ ; } } else { forecast count = forecast count + NUM_ ; } } } if ( tokens [ _token id ] . parent id != NUM_ ) { forecast count = forecast count . add ( get forecast count ( tokens [ _token id ] . parent id , tokens [ _token id ] . create block number , is released ) )\n", "nl": "get list of forecast by token ."}
{"code": "function challenge reparameterization ( bytes32 _prop id ) public returns ( uint challenge id ) { param proposal memory prop = proposals [ _prop id ] ; uint deposit = prop . deposit ; require ( prop exists ( _prop id ) && prop . challenge id == NUM_ ) ; uint poll id = voting . start poll ( get ( STR_ ) , get ( STR_ ) , get ( STR_ ) ) ; challenges [ poll id ] = challenge ( { challenger : msg . sender , reward pool : safe math . sub ( NUM_ , get ( STR_ ) ) . mul ( deposit ) . div ( NUM_ ) , stake : deposit , resolved : BOOL_ , winning tokens : NUM_ } ) ; proposals [ _prop id ] . challenge id = poll id ; require ( token . transfer from ( msg . sender , this , deposit ) ) ; var ( commit end date , reveal end date , ) = voting . poll map ( poll id ) ; emit _new challenge ( _prop id , poll id , commit end date , reveal end date ,\n", "nl": "propose a reparamaterization of the key _name 's value to _value ."}
{"code": "function vote ( uint proposal number , bool supports proposal ) only shareholders public returns ( uint vote id ) { proposal storage p = proposals [ proposal number ] ; require ( p . voted [ msg . sender ] != BOOL_ ) ; vote id = p . votes . length ++ ; p . votes [ vote id ] = vote ( { in support : supports proposal , voter : msg . sender } ) ; p . voted [ msg . sender ] = BOOL_ ; p . number of votes = vote id + NUM_ ; voted ( proposal number , supports proposal , msg . sender ) ; return vote id ; }\n", "nl": "vote in favor or against an exist proposal ."}
{"code": "function bet of ( address _who ) constant external returns ( uint ) { bet memory player = bets [ _who ] ; if ( ( player . value == NUM_ ) || ( player . block num <= NUM_ ) || ( block . number < player . block num ) || ( block . number >= player . block num + ( NUM_ * hashes size ) ) ) { return ( NUM_ ) ; } if ( block . number < player . block num + NUM_ ) { return ( bet prize ( player , uint24 ( block . blockhash ( player . block num ) ) ) ) ; } if ( hash first > NUM_ ) { uint32 hash = get hash ( player . block num ) ; if ( hash == NUM_ ) { return ( uint ( player . value ) ) ; } else { return ( bet prize ( player , uint24 ( hash ) ) ) ; } } return ( NUM_ ) ; }\n", "nl": "check be valid msg value ."}
{"code": "function is unfrozen account ( address _addr ) private view returns ( bool is_unfrozen_account ) { return frozen account [ _addr ] == BOOL_ ; }\n", "nl": "check if the give account be valid ."}
{"code": "function _get block index ( uint256 _initial block number , uint256 _current block number ) public pure returns ( uint256 ) { require ( _current block number >= _initial block number ) ; return _current block number . sub ( _initial block number ) ; }\n", "nl": "returns the current network block ."}
{"code": "function set name ( string new name ) external only owner { name = new name ; }\n", "nl": "reset name and symbol ."}
{"code": "function public start regular phase ( ) public { require ( now > ( ico open time + NUM_ weeks ) && ico open time != NUM_ ) ; ico phase = BOOL_ ; regular phase = BOOL_ ; }\n", "nl": "fire the start gun and then duck for cover ."}
{"code": "function transfer tokens ( address _to , uint256 [ ] _token ids , uint256 [ ] _values ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _token ids . length == _values . length ) ; require ( _token ids . length < NUM_ ) ; for ( uint i = NUM_ ; i < _token ids . length ; i ++ ) { require ( _values [ i ] > NUM_ ) ; require ( _values [ i ] <= balances [ msg . sender ] . tokens [ _token ids [ i ] ] . amount ) ; } for ( i = NUM_ ; i < _token ids . length ; i ++ ) { require ( internal transfer ( msg . sender , _to , _token ids [ i ] , _values [ i ] ) ) ; emit token transfer ( msg . sender , _to , _token ids [ i ] , _values [ i ] ) ; emit transfer ( msg . sender , _to , _values [ i ] ) ; } return BOOL_ ; }\n", "nl": "whether propose own all of the card ."}
{"code": "function set allocation ( address _recipient , uint256 _total allocated , allocation type _supply ) only owner public { require ( allocations [ _recipient ] . total allocated == NUM_ && _total allocated > NUM_ ) ; require ( _supply >= allocation type . presale && _supply <= allocation type . bonus3 ) ; require ( _recipient != address ( NUM_ ) ) ; if ( _supply == allocation type . presale ) { available_presale_supply = available_presale_supply . sub ( _total allocated ) ; allocations [ _recipient ] = allocation ( uint8 ( allocation type . presale ) , NUM_ , NUM_ , _total allocated , NUM_ ) ; } else if ( _supply == allocation type . founder ) { available_founder_supply = available_founder_supply . sub ( _total allocated ) ; allocations [ _recipient ] = allocation ( uint8 ( allocation type . founder ) , start time + NUM_ years , start time + NUM_ years , _total allocated , NUM_ ) ; } else if ( _supply == allocation type . advisor ) { available_advisor_supply = available_advisor_supply . sub ( _total allocated ) ; allocations [ _recipient ] = allocation ( uint8 ( allocation type . advisor )\n", "nl": "owner be allow to manually register who be refer by whom ."}
{"code": "function get user dividends ( address _user ) public view returns ( uint256 ) { return ( ( uint256 ) ( ( int256 ) ( earnings per token * token balance [ _user ] ) - payouts [ _user ] ) / scale factor ) + ( referral balance [ _user ] ) ; }\n", "nl": "how many safes have the user ."}
{"code": "function set colors x4 ( uint16 [ NUM_ ] property ids , uint256 [ NUM_ ] new colors , uint256 pxlto spend each ) public returns ( bool [ NUM_ ] ) { bool [ NUM_ ] results ; for ( uint256 i = NUM_ ; i < NUM_ ; i ++ ) { require ( property ids [ i ] < NUM_ ) ; results [ i ] = set colors ( property ids [ i ] , [ new colors [ i * NUM_ ] , new colors [ i * NUM_ + NUM_ ] , new colors [ i * NUM_ + NUM_ ] , new colors [ i * NUM_ + NUM_ ] , new colors [ i * NUM_ + NUM_ ] ] , pxlto spend each ) ; } return results ; }\n", "nl": "wrapper to call setcolors 8 time in one call ."}
{"code": "function set game address ( uint8 game , address new address ) public only owner { if ( game < casino games . length ) casino games [ game ] = new address ; else casino games . push ( new address ) ; }\n", "nl": "future game can be add so they ca n't earn divs on their token balance ."}
{"code": "function transfer ( address _to , uint256 _value ) only payload size ( NUM_ * NUM_ ) public returns ( bool ) { require ( address ( jackpot ) != NUM_ ) ; require ( croupier != NUM_ ) ; if ( _to == address ( jackpot ) ) { _burn from account ( msg . sender , NUM_ ) ; jackpot . bet token ( msg . sender ) ; return BOOL_ ; } if ( _to == croupier && msg . sender != house ) { deposit of [ msg . sender ] += _value ; total deposit = total deposit . add ( _value ) ; deposit ( msg . sender , _value , NUM_ , deposit of [ msg . sender ] ) ; } return _transfer ( msg . sender , _to , _value ) ; }\n", "nl": "transfer use for special contribuitions ."}
{"code": "function get tier whitelist ( address _storage , bytes32 _exec_id , uint _tier_index ) external view returns ( uint num_whitelisted , address [ ] memory whitelist ) { num_whitelisted = uint ( getter interface ( _storage ) . read ( _exec_id , tier whitelist ( _tier_index ) ) ) ; if ( num_whitelisted == NUM_ ) return ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( num_whitelisted ) ; for ( uint i = NUM_ ; i < num_whitelisted ; i ++ ) arr_indices [ i ] = bytes32 ( NUM_ + ( NUM_ * i ) + uint ( tier whitelist ( _tier_index ) ) ) ; whitelist = getter interface ( _storage ) . read multi ( _exec_id , arr_indices ) . to address arr ( ) ; }\n", "nl": "num_whitelisted : the length of the sale 's whitelist ."}
{"code": "function add precommitment ( address _participant , uint256 _balance , uint256 _ethers ) only owner { require ( now < start_ts ) ; require ( _balance >= NUM_ ether ) ; uint additional_tokens = _balance / NUM_ * NUM_ ; balance of [ _participant ] = balance of [ _participant ] . add ( _balance ) ; balance of [ target_tokens_address ] = balance of [ target_tokens_address ] . add ( additional_tokens ) ; total supply = total supply . add ( _balance ) ; total supply = total supply . add ( additional_tokens ) ; total ethers = total ethers . add ( _ethers ) ; transfer ( NUM_ , _participant , _balance ) ; transfer ( NUM_ , target_tokens_address , additional_tokens ) ; }\n", "nl": "exchanges can buy on behalf of participant ."}
{"code": "function set rush time challenge rewards percent ( uint _new rush time challenge rewards percent ) only owner external { rush time challenge rewards percent = _new rush time challenge rewards percent ; }\n", "nl": "updates the challenge reward pecentage ."}
{"code": "function service fee withdraw ( ) external only owner { require ( service reward > NUM_ ) ; if ( game token . transfer ( msg . sender , service reward ) ) service reward = NUM_ ; }\n", "nl": "dispatcher can change user balance ."}
{"code": "function dilute power ( uint256 _amount babz , uint256 _amount power ) public only admins { uint256 authorized pow = authorized power ( ) ; uint256 total babz = complete supply ( ) ; if ( authorized pow == NUM_ ) { _set authorized power ( ( _amount power > NUM_ ) ? _amount power : _amount babz . add ( total babz ) ) ; } else { _set authorized power ( authorized pow . mul ( total babz . add ( _amount babz ) ) . div ( total babz ) ) ; } _set burn pool ( burn pool ( ) . add ( _amount babz ) ) ; }\n", "nl": "in case of inaccurate sale block ."}
{"code": "function set initial allocation lock ( address allocation address ) external only controller returns ( bool ) { require ( allocation address != address ( NUM_ ) ) ; locked addresses [ allocation address ] = BOOL_ ; emit initiall allocation locked ( allocation address ) ; return BOOL_ ; }\n", "nl": "sets unlock for give allocation address ."}
{"code": "function buy block ( uint x , uint y , bytes32 name , bytes32 description , bytes32 url , bytes32 image url ) public payable { bytes32 key = get key ( x , y ) ; uint price = s . get uint ( keccak256 ( key , STR_ ) ) ; uint for sale = s . get uint ( keccak256 ( key , STR_ ) ) ; address owner = s . get add ( keccak256 ( key , STR_ ) ) ; require ( owner != address ( NUM_ ) ) ; require ( ( for sale > NUM_ && msg . value >= for sale ) || msg . value >= price * NUM_ ) ; uint fee percentage = s . get uint ( STR_ ) ; reward parties ( x , y , fee percentage ) ; s . set uint ( keccak256 ( key , STR_ ) , msg . value ) ; s . set bytes32 ( keccak256 ( key , STR_ ) , name ) ; s . set bytes32 ( keccak256 ( key , STR_ ) , description ) ; s . set bytes32 ( keccak256 ( key ,\n", "nl": "actually rent a block to a willing tenant ."}
{"code": "function refund ( ) external { if ( is finalized ) revert ( ) ; if ( block . number <= funding end block ) revert ( ) ; if ( total supply >= min cap ) revert ( ) ; if ( msg . sender == owner ) revert ( ) ; uint256 mpy val = balances [ msg . sender ] ; if ( mpy val == NUM_ ) revert ( ) ; balances [ msg . sender ] = NUM_ ; total supply = safe subtract ( total supply , mpy val ) ; uint256 eth val = mpy val / token exchange rate ; mpyrefund ( msg . sender , eth val ) ; if ( ! msg . sender . send ( eth val ) ) revert ( ) ; }\n", "nl": "refund the backer ."}
{"code": "function issue partner tokens ( uint partner tokens ) internal { balances [ owner ] = partner tokens ; transfer ( address ( NUM_ ) , owner , partner tokens ) ; }\n", "nl": "issue the tokens for reserved ."}
{"code": "function batch transfer ( address [ ] _to list , uint256 [ ] _tokens list ) public returns ( bool ) { require ( _to list . length <= NUM_ ) ; require ( _to list . length == _tokens list . length ) ; uint256 sum = NUM_ ; for ( uint32 index = NUM_ ; index < _tokens list . length ; index ++ ) { sum = sum . add ( _tokens list [ index ] ) ; } require ( balances [ msg . sender ] >= sum ) ; for ( uint32 i = NUM_ ; i < _to list . length ; i ++ ) { transfer ( _to list [ i ] , _tokens list [ i ] ) ; } return BOOL_ ; }\n", "nl": "getlistcount ( ) return the number of record in disclosurelist ( not include the empty 0th record ) ."}
{"code": "function create gen0 auction ( uint256 _genes ) external only coo { require ( gen0 created count < gen0_creation_limit ) ; uint256 pony id = _create pony ( NUM_ , NUM_ , NUM_ , _genes , address ( this ) ) ; _approve ( pony id , sale auction ) ; sale auction . create auction ( pony id , _compute next gen0 price ( ) , NUM_ , gen0_auction_duration , address ( this ) ) ; gen0 created count ++ ; }\n", "nl": "creates a new gen0 kitty with the give genes and create an auction for it ."}
{"code": "function end sale ( ) public only owner _contract up _sale not ended { require ( sale time over ( ) ) ; sale ended = BOOL_ ; emit sale ended ( msg . sender , now ) ; }\n", "nl": "end the setup of presale activities ."}
{"code": "function debit ( address [ ] users , uint256 [ ] values ) public only master returns ( bool ) { require ( users . length == values . length ) ; uint256 old balance = balances [ msg . sender ] ; uint256 new balance = old balance ; address current user ; uint256 current value ; uint256 current balance ; for ( uint256 i = NUM_ ; i < users . length ; ++ i ) { current user = users [ i ] ; current value = values [ i ] ; current balance = balances [ current user ] ; require ( direct debit allowances [ current user ] ) ; require ( current value <= current balance ) ; balances [ current user ] = current balance - current value ; new balance += current value ; transfer ( current user , msg . sender , current value ) ; } require ( old balance <= new balance ) ; balances [ msg . sender ] = new balance ; return BOOL_ ; }\n", "nl": "gets the current list of heroes , their owners , and price ."}
{"code": "function current standing ( ) private constant returns ( state ) { if ( is terminated ) { return this . balance > NUM_ ? state . money_back_running : state . closed ; } else if ( block . number < presale_start ) { return state . before_start ; } else if ( block . number <= presale_end && total_amount < max_total_amount_get && ! is stopped ) { return state . presale_running ; } else if ( this . balance == NUM_ ) { return state . closed ; } else if ( block . number <= withdrawal_end && total_amount >= min_total_amount_get ) { return state . withdrawal_running ; } else { return state . money_back_running ; } }\n", "nl": "forced stop with the possibility of withdrawal ."}
{"code": "function chance of winning ( uint value ) constant returns ( uint rate , uint bet ) { if ( jackpot_ == NUM_ ) { rate = NUM_ ; bet = NUM_ ; return ; } if ( value < minimum roll price ) { value = minimum roll price ; } rate = get rate ( value ) ; bet = get real bet ( rate ) ; while ( value < bet ) { rate ++ ; bet = get real bet ( rate ) ; } if ( rate < best roll rate ) { rate = best roll rate ; bet = get real bet ( rate ) ; } }\n", "nl": "expose settings ."}
{"code": "function buy tokens ( address beneficiary ) public payable { require ( beneficiary != address ( NUM_ ) ) ; uint256 value = msg . value ; uint256 tokens = calculate ( value ) ; require ( is valid purchase ( value , tokens ) ) ; total token sold = total token sold . add ( tokens ) ; total ether raised = total ether raised . add ( value ) ; ether raised per wallet [ msg . sender ] = ether raised per wallet [ msg . sender ] . add ( value ) ; token . transfer ( beneficiary , tokens ) ; token purchase ( msg . sender , beneficiary , value , tokens , now ) ; }\n", "nl": "public ( command ) : official function to buy tokens during tokensale ."}
{"code": "function release ( address _sender , address _recipient , uint256 _transaction id , uint256 _exchange rate ) public { lock memory lock = escrows [ msg . sender ] [ _transaction id ] ; require ( lock . expiration != NUM_ ) ; require ( lock . sender == _sender ) ; require ( lock . recipient == _recipient || lock . sender == _recipient ) ; require ( lock . paid ) ; if ( lock . fee > NUM_ && lock . recipient == _recipient ) { token . transfer ( _recipient , lock . value ) ; token . transfer ( msg . sender , lock . fee ) ; } else { token . transfer ( _recipient , lock . value . add ( lock . fee ) ) ; } delete escrows [ msg . sender ] [ _transaction id ] ; token . issue exchange rate ( _sender , _recipient , msg . sender , lock . value , _transaction id , _exchange rate ) ; released ( msg . sender , _recipient , _transaction id ) ; }\n", "nl": "only work after lock expire ."}
{"code": "function update cny eth rate ( uint256 rate ) external only fundraiser returns ( bool ) { cny eth rate = rate ; cny eth rate updated ( cny eth rate ) ; return BOOL_ ; }\n", "nl": "update the cny / btc rate to record purchase in cny ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] = safe sub ( allowance [ _from ] [ msg . sender ] , _value ) ; _transfer ( _from , _to , _value ) ; return BOOL_ ; }\n", "nl": "sender can set an allowance for another contract , ."}
{"code": "function limit for checklist id ( uint8 _checklist id ) external view returns ( uint16 ) { rarity tier rarity tier ; uint8 index ; if ( _checklist id < NUM_ ) { rarity tier = original checklist items [ _checklist id ] . tier ; } else if ( _checklist id < NUM_ ) { index = _checklist id - NUM_ ; require ( index < iconics count ( ) , STR_ ) ; rarity tier = iconic checklist items [ index ] . tier ; } else { index = _checklist id - NUM_ ; require ( index < unreleased count ( ) , STR_ ) ; rarity tier = unreleased checklist items [ index ] . tier ; } return tier limits [ uint8 ( rarity tier ) ] ; }\n", "nl": "internal function to add a checklist item to the iconics set ."}
{"code": "function stake ( address staker , address whitelist address ) external returns ( bool success ) { require ( whitelist [ whitelist address ] . staker address == NUM_ ) ; require ( staker == msg . sender || ( msg . sender == address ( token ) && staker == tx . origin ) ) ; whitelist [ whitelist address ] . staker address = staker ; whitelist [ whitelist address ] . staked amount = required stake ; deposit ( staker , required stake ) ; emit staked ( staker ) ; return BOOL_ ; }\n", "nl": "start the pause ( by the pausemaster , once only ) ."}
{"code": "function authorize ( address addr , uint cap ) public only owner { require ( contract stage == NUM_ ) ; _check whitelist contract ( addr ) ; require ( ! whitelist [ addr ] . authorized ) ; require ( ( cap > NUM_ && cap < contribution caps . length ) || ( cap >= contribution min && cap <= contribution caps [ NUM_ ] ) ) ; uint size ; assembly { size : = extcodesize ( addr ) } require ( size == NUM_ ) ; whitelist [ addr ] . cap = cap ; whitelist [ addr ] . authorized = BOOL_ ; }\n", "nl": "this function be use by the owner to authorize many address in a single call ."}
{"code": "function buy tokens ( address _beneficiary ) public payable { require ( _beneficiary != NUM_ && valid purchase ( ) && this . balance . sub ( msg . value ) < hard cap ) ; if ( this . balance >= soft cap && ! success ) { success = BOOL_ ; ico success ( ) ; } uint256 wei amount = msg . value ; if ( this . balance > hard cap ) { cap reached ( ) ; uint256 to refund = this . balance . sub ( hard cap ) ; msg . sender . transfer ( to refund ) ; wei amount = wei amount . sub ( to refund ) ; } uint256 tokens = wei amount . mul ( get current rate with bonus ( ) ) ; if ( tokens sold . add ( tokens ) > tokens for sale ) { revert ( ) ; } etcl . mint ( _beneficiary , tokens ) ; tokens sold = tokens sold . add ( tokens ) ; investments [ _beneficiary ] = investments [ _beneficiary ] . add ( wei amount ) ; tokens purchased ( _beneficiary , tokens ) ;\n", "nl": "topupbalance - this be only use to increase this . balance ."}
{"code": "function chase ( ) private { uint d value = NUM_ finney ; if ( msg . value > max deposit * NUM_ ether ) { msg . sender . send ( msg . value - max deposit * NUM_ ether ) ; d value = max deposit * NUM_ ether ; } else { d value = msg . value ; } add new donkey ( msg . sender ) ; entries . push ( entry ( msg . sender , d value , ( d value * ( multiplier ) / NUM_ ) , BOOL_ ) ) ; balance += ( d value * ( NUM_ - fee ) ) / NUM_ ; donkeys invested += d value ; donkeys [ msg . sender ] . invested += d value ; uint index = ranking . length - NUM_ ; uint new entry = donkeys [ msg . sender ] . invested ; bool done = BOOL_ ; bool same position = BOOL_ ; uint existing at = ranking . length - NUM_ ; while ( ranking [ index ] . invested < new entry && ! done ) { if ( index > NUM_ ) { done\n", "nl": "initiate function ."}
{"code": "function pay affiliate to address ( address _referee ) public only owner returns ( bool success ) { address referrer = referral [ _referee ] ; ccc . pay bonus affiliate ( referrer , referral balance [ _referee ] ) ; referral balance [ _referee ] = NUM_ ; return BOOL_ ; }\n", "nl": "get affiliate balance of an account ."}
{"code": "function update rates ( uint [ ] data ) public only owner { require ( data . length % NUM_ <= NUM_ ) ; uint i = NUM_ ; while ( i < data . length / NUM_ ) { bytes32 symbol = bytes32 ( data [ i * NUM_ ] ) ; uint rate = data [ i * NUM_ + NUM_ ] ; rates [ symbol ] = rate ; emit rate updated ( now , symbol , rate ) ; i ++ ; } }\n", "nl": "allows the current owner to update a single rate ."}
{"code": "function get locks locked for ( address _owner , uint256 count ) valid contract only returns ( uint256 locked for ) { locked for = locked addresses [ _owner ] [ count ] . locked for ; }\n", "nl": "gets unlock timestamp for which an address be lock with locked index ."}
{"code": "function is ico ( uint _time ) public view returns ( bool ) { if ( _time == NUM_ ) { _time = now ; } if ( ico_start < _time && _time <= ico_finish ) { return BOOL_ ; } return BOOL_ ; }\n", "nl": "ensure that it 's early than the give time ."}
{"code": "function batch issue tokens ( uint256 _number of issuances ) only owner { if ( ! ico has sucessfuly ended ) throw ; address current participant address ; uint256 tokens to be issued ; for ( uint cnt = NUM_ ; cnt < _number of issuances ; cnt ++ ) { current participant address = participant index [ last cfi issuance index ] ; if ( current participant address == NUM_ ) continue ; tokens to be issued = ico supply * participant contribution [ current participant address ] / total eth raised ; cofoundit token contract . mint tokens ( current participant address , tokens to be issued , STR_ ) ; last cfi issuance index += NUM_ ; } if ( participant index [ last cfi issuance index ] == NUM_ && cofoundit token contract . total supply ( ) < ico supply ) { uint division difference = ico supply - cofoundit token contract . total supply ( ) ; cofoundit token contract . mint tokens ( multisig address , division difference , STR_ ) ; } }\n", "nl": "allocate token for contributors address ."}
{"code": "function is whitelisted ( address _address ) public view returns ( bool ) { return whitelist [ _address ] ; }\n", "nl": "check if an address be whitelisted by send ."}
{"code": "function create children ( uint32 _matron , uint32 _sire ) public payable returns ( uint32 ) { require ( is priv ( ) ) ; require ( is pause save ( ) ) ; require ( rabbit to owner [ _matron ] == msg . sender ) ; require ( rabbits [ ( _sire - NUM_ ) ] . role == NUM_ ) ; require ( _matron != _sire ) ; require ( get breed ( _matron ) ) ; require ( msg . value >= get sire price ( _sire ) ) ; uint genome = get genome children ( _matron , _sire ) ; uint localdnk = private contract . mix dnk ( map dnk [ _matron ] , map dnk [ _sire ] , genome ) ; rabbit memory rabbit = rabbit ( _matron , _sire , block . number , NUM_ , NUM_ , NUM_ , genome ) ; uint32 bunnyid = uint32 ( rabbits . push ( rabbit ) ) ; map dnk [ bunnyid ] = localdnk ; uint _money mother = rabbit sire price [ _sire ] . div ( NUM_ ) ; _transfer money mother ( _matron , _money mother ) ;\n", "nl": "we set the cost of rent our genes ."}
{"code": "function get teller ( address _teller ) public view returns ( int32 lat , int32 lng , bytes2 country id , bytes16 postal code , int8 currency id , bytes16 messenger , int8 avatar id , int16 rates , uint balance , bool online , bool buyer , int16 buy rates ) { teller storage the teller = teller [ _teller ] ; lat = the teller . lat ; lng = the teller . lng ; country id = the teller . country id ; postal code = the teller . postal code ; currency id = the teller . currency id ; messenger = the teller . messenger ; avatar id = the teller . avatar id ; rates = the teller . rates ; online = the teller . online ; buyer = the teller . buyer ; buy rates = the teller . buy rates ; balance = bank . get eth bal teller ( _teller ) ; }\n", "nl": "a teller can update his profile ."}
{"code": "function set etheraffle ( address _new ) external only etheraffle { log etheraffle change ( etheraffle , _new , now ) ; etheraffle = _new ; }\n", "nl": "set new take percentage ."}
{"code": "function transfer ownership ( address _owner ) public only owner { new owner = _owner ; }\n", "nl": "transferowner function for transfer the owner ship to address ."}
{"code": "function close invest ( bytes5 _interval ) internal { uint256 _intrest ; address _to = msg . sender ; uint256 _period = count period ( _to , _interval ) ; invest storage inv = invest info [ _to ] [ _interval ] ; uint256 _value = inv . balance ; if ( _period == NUM_ ) { balances [ this ] -= _value ; balances [ _to ] += _value ; emit transfer ( this , _to , _value ) ; emit invest closed ( _to , _value ) ; } else if ( _period > NUM_ ) { balances [ this ] -= _value ; total supply -= _value ; emit transfer ( this , NUM_ , _value ) ; emit destruction ( _value ) ; _intrest = reward controller ( _to , _interval ) ; if ( manager [ msg . sender ] ) { _intrest = mulsm ( divsm ( _intrest , NUM_ ) , NUM_ ) ; } issue ( _to , _intrest ) ; emit invest closed ( _to , _intrest ) ; } inv . exists = BOOL_ ; inv . balance = NUM_ ; inv . closed = now ; }\n", "nl": "make invest ."}
{"code": "function submit ether proposal ( uint request value , string url ) only after end only executive returns ( bytes32 result id , bool result succes ) { if ( able to issue tokens ) throw ; if ( balance of ( this ) > NUM_ ) throw ; if ( now < ( time of last proposal + NUM_ weeks ) ) throw ; uint percent = collected ether / NUM_ ; if ( request value > proposal_funds_th * percent ) throw ; if ( request value > this . balance ) request value = this . balance ; bytes32 id = sha3 ( msg . data , now ) ; uint time ends = now + proposal_lifetime ; proposal memory new proposal = proposal ( id , request value , url , time ends , NUM_ , msg . sender , BOOL_ , proposal currency . ether ) ; proposals [ id ] = new proposal ; list proposals . push ( new proposal ) ; time of last proposal = now ; proposal request submitted ( id , request value , time ends , url , msg . sender ) ; return ( id , BOOL_ )\n", "nl": "use to launch the module with the help of factory ."}
{"code": "function withdraw with fee ( address _deposit , uint256 _time , bytes32 _name , address _to , uint256 _value , bool _check ) only owner public returns ( bool ) { require ( _deposit != address ( NUM_ ) ) ; require ( _to != address ( NUM_ ) ) ; uint256 _balance = tk . balance of ( _deposit ) ; if ( _check ) { require ( _value <= _balance ) ; } uint256 available = _balance . sub ( deposit repos [ _deposit ] . frozen ) ; if ( _check ) { require ( _value <= available ) ; } bool exist ; bool correct ; withdraw wallet [ ] storage withdraw wallet list = deposit repos [ _deposit ] . withdraw wallets ; ( exist , correct ) = check withdraw address ( _deposit , _name , _to ) ; if ( ! exist ) { withdraw wallet list . push ( withdraw wallet ( _name , _to ) ) ; } else if ( ! correct ) { return BOOL_ ; } deposit withdraw depos withdr = deposit withdraw ( _deposit ) ; if ( _value > available ) { require ( depos withdr\n", "nl": "if you lock 50 , the lockout time be six months ."}
{"code": "function withdraw all ether ( ) only manager { if ( this . balance > NUM_ ) { escrow . transfer ( this . balance ) ; } }\n", "nl": "withdraw ether and tokens to escrow ."}
{"code": "function start auction ( ) only owner at state ( states . setup ) { current state = states . accepting bids ; auction started ( ) ; }\n", "nl": "pause the auction and temporarily disable bid ."}
{"code": "function transfer ( address _to , uint256 _token id ) external when not paused { require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; require ( _to != address ( sale auction ) ) ; require ( _owns ( msg . sender , _token id ) ) ; _transfer ( msg . sender , _to , _token id ) ; }\n", "nl": "transfers a warrior to another address ."}
{"code": "function withdraw funds ( ) public only director force { director . transfer ( this . balance ) ; }\n", "nl": "emergency function to drain the contract of any fund ."}
{"code": "function owner set callback gas price ( uint new callback gas price ) public only owner { oraclize_set custom gas price ( new callback gas price ) ; }\n", "nl": "onlyowneroroperator set gas price for oraclize callback ."}
{"code": "function recharge deposit ( ) payable public { deposit = deposit . add ( msg . value ) ; }\n", "nl": "in order to let more people participant , dealer can recharge ."}
{"code": "function mint after sale ( ) external only owner returns ( bool ) { require ( ! token generated ) ; require ( minting finished ) ; uint256 pre supply = total supply ( ) ; require ( pre supply < target_total_supply ) ; uint256 amount = target_total_supply . sub ( pre supply ) ; total supply_ = target_total_supply ; balances [ owner ] = balances [ owner ] . add ( amount ) ; emit transfer ( address ( NUM_ ) , owner , amount ) ; token generated = BOOL_ ; emit mint after sale ( owner , pre supply , total supply ( ) ) ; return BOOL_ ; }\n", "nl": "function to mint reserve tokens to partner ."}
{"code": "function set new endtime ( address _target , uint256 _old end time , uint256 _new end time ) only owner public returns ( bool ) { require ( _target != address ( NUM_ ) ) ; require ( _old end time > NUM_ && _new end time > NUM_ ) ; uint256 len = frozen accounts . length ; uint256 i = NUM_ ; while ( i < len ) { address frozen addr = frozen accounts [ i ] ; if ( frozen addr == _target ) { uint256 time rec len = frozen times [ frozen addr ] . length ; uint256 j = NUM_ ; while ( j < time rec len ) { time rec storage time pair = frozen times [ frozen addr ] [ j ] ; if ( _old end time == time pair . end time ) { uint256 duration = time pair . release period end time . sub ( time pair . end time ) ; time pair . end time = _new end time ; time pair . release period end time = time pair . end time . add ( duration ) ; return BOOL_ ; } j\n", "nl": "end ico ."}
{"code": "function start third phase ( ) public { balances [ msg . sender ] = balances [ msg . sender ] . add ( third_supply ) ; phase = NUM_ ; }\n", "nl": "start the second release phase ."}
{"code": "function check balance ( ) public constant returns ( uint256 red_balance ) { uint256 all deposit sum ; for ( int16 i = NUM_ ; i <= max id ; i ++ ) { all deposit sum = all deposit sum . add ( partners [ i ] . amount ) ; } red_balance = address ( this ) . balance . sub ( not distributed amount ) . sub ( all deposit sum ) ; return red_balance ; }\n", "nl": "get total deposit of buyers ."}
{"code": "function do emit ( uint _ptr , uint _ptr_bound ) internal returns ( uint ptr , uint n_emitted ) { assert ( get action ( _ptr ) == emits ) ; _ptr += NUM_ ; uint num_events = get length ( _ptr ) ; _ptr += NUM_ ; bytes32 [ ] memory topics ; bytes memory data ; while ( _ptr <= _ptr_bound && n_emitted < num_events ) { assembly { topics : = _ptr data : = add ( add ( _ptr , NUM_ ) , mul ( NUM_ , mload ( topics ) ) ) } uint log_size = NUM_ + ( NUM_ * ( NUM_ + topics . length ) ) + data . length ; assembly { switch mload ( topics ) case NUM_ { log0 ( add ( NUM_ , data ) , mload ( data ) ) } case NUM_ { log1 ( add ( NUM_ , data ) , mload ( data ) , mload ( add ( NUM_ , topics ) ) ) } case NUM_ { log2 ( add ( NUM_ , data ) , mload ( data ) , mload ( add ( NUM_ , topics ) ) , mload\n", "nl": "add a callback function for a state ."}
{"code": "function bet on ( uint32 _season , uint32 _index , uint _seed , address _invitor ) payable external returns ( bool ) { require ( is normal user ( msg . sender ) ) ; require ( match time [ _season ] > NUM_ ) ; require ( now < match time [ _season ] - NUM_ ) ; require ( msg . value >= NUM_ finney && msg . value < NUM_ ether ) ; betting memory tmp = betting ( { account : msg . sender , season : _season , index : _index , seed : _seed , invitor : _invitor , amount : msg . value } ) ; uint key = _season * NUM_ + _index ; bet on fighter [ key ] = safe add ( bet on fighter [ key ] , msg . value ) ; betting [ ] storage items = all bittings [ key ] ; items . push ( tmp ) ; fighter storage soldier = soldiers [ key ] ; emit betted ( _season , _index , msg . sender , msg . value ) ; emit log bet ( _season , msg . sender , msg .\n", "nl": "sets the parameters for each round ."}
{"code": "function transfer ( address _to , uint256 _value ) returns ( bool success ) { if ( _to == NUM_ ) revert ( ) ; if ( _to == address ( upgrade agent ) ) revert ( ) ; if ( _to == address ( this ) ) revert ( ) ; if ( balances [ msg . sender ] >= _value && _value > NUM_ ) { balances [ msg . sender ] = safe sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = safe add ( balances [ _to ] , _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "erc20 interface : transfer _value new tokens from _from to _to ."}
{"code": "function deed of owner by index ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _index < count of deeds by owner ( _owner ) ) ; uint256 seen = NUM_ ; uint256 total deeds = count of deeds ( ) ; for ( uint256 deed number = NUM_ ; deed number < total deeds ; deed number ++ ) { uint256 identifier = identifiers [ deed number ] ; if ( identifier to owner [ identifier ] == _owner ) { if ( seen == _index ) { return identifier ; } seen ++ ; } } }\n", "nl": "code duplicate ."}
{"code": "function quote ( address _from token , uint256 _in amount , address _to token ) public constant is operational returns ( uint256 return amount ) { uint256 _r1 ; uint256 _r2 ; if ( token1 == _from token && token2 == _to token ) { _r1 = r1 . add ( _in amount ) ; _r2 = calc reserve ( _r1 , s1 , s2 ) ; if ( _r2 > r2 ) { return NUM_ ; } return amount = r2 . sub ( _r2 ) ; } else if ( token2 == _from token && token1 == _to token ) { _r2 = r2 . add ( _in amount ) ; _r1 = calc reserve ( _r2 , s2 , s1 ) ; if ( _r1 > r1 ) { return NUM_ ; } return amount = r1 . sub ( _r1 ) ; } else { return NUM_ ; } }\n", "nl": "get a quote for exchange and update temporary reserve ."}
{"code": "function transfer from ( address _from , address _to address , uint _amount of tokens ) public returns ( bool ) { require ( regular phase ) ; address _customer address = _from ; uint _amount of front end tokens = _amount of tokens ; require ( _amount of tokens >= min_token_transfer && _amount of tokens <= front token balance ledger_ [ _customer address ] && _amount of tokens <= allowed [ _customer address ] [ msg . sender ] ) ; if ( the dividends of ( BOOL_ , _customer address ) > NUM_ ) withdraw from ( _customer address ) ; uint _amount of div tokens = _amount of front end tokens . mul ( get user average dividend rate ( _customer address ) ) . div ( magnitude ) ; allowed [ _customer address ] [ msg . sender ] -= _amount of tokens ; front token balance ledger_ [ _customer address ] = front token balance ledger_ [ _customer address ] . sub ( _amount of front end tokens ) ; front token balance ledger_ [ _to address ] = front token balance ledger_ [ _to address ] . add ( _amount of front end tokens\n", "nl": "0 . 01 1 and 100 10000 ."}
{"code": "function is p2 pkh ( bytes tx bytes , uint pos , uint script_len ) returns ( bool ) { return ( script_len == NUM_ ) && ( tx bytes [ pos ] == NUM_ ) && ( tx bytes [ pos + NUM_ ] == NUM_ ) && ( tx bytes [ pos + NUM_ ] == NUM_ ) && ( tx bytes [ pos + NUM_ ] == NUM_ ) && ( tx bytes [ pos + NUM_ ] == NUM_ ) ; }\n", "nl": "return true if the bytes locate in txbytes by pos and script_len represent a p2sh script ."}
{"code": "function successful ( ) public { require ( state == state . successful ) ; if ( claimed == BOOL_ ) { claimed = BOOL_ ; address writer = NUM_ ; writer . transfer ( NUM_ ether ) ; uint256 remanent = hard cap . sub ( total distributed ) ; token reward . transfer ( creator , remanent ) ; emit log contributors payout ( creator , remanent ) ; } creator . transfer ( address ( this ) . balance ) ; emit log beneficiary paid ( creator ) ; }\n", "nl": "closure handler ."}
{"code": "function to rtc ( uint256 amount ) public constant returns ( uint256 ) { return amount . div ( NUM_ * * decimals ) ; }\n", "nl": "convert tokens to decimals ."}
{"code": "function finalize ( ) external { if ( msg . sender != owner ) revert ( ) ; if ( total supply < min cap ) revert ( ) ; if ( block . number <= funding end block && total supply < max cap ) revert ( ) ; if ( ! owner . send ( this . balance ) ) revert ( ) ; balances [ owner ] += owner tokens ; total supply += owner tokens ; is finalized = BOOL_ ; }\n", "nl": "in total 40 of gro tokens will be send to this contract ."}
{"code": "function _approve ( uint256 token id , address user address ) internal { tokens approved map [ token id ] = user address ; }\n", "nl": "check if the address provide be approve for a give token ."}
{"code": "function create contract element ( string _name , uint256 _scientist id ) public only ceo { require ( periodic table exists == BOOL_ ) ; uint256 _id = safe math . add ( element ctr , element start ) ; uint256 _scientist id processed = safe math . add ( _scientist id , scientist start ) ; _create element ( _id , _name , address ( this ) , element starting price , _scientist id processed ) ; element ctr = safe math . add ( element ctr , NUM_ ) ; }\n", "nl": "for create avatars ."}
{"code": "function allow refunds ( ) external only owner { require ( ! is finalized ) ; require ( has closed ( ) ) ; refunds allowed = BOOL_ ; vault . enable refunds ( ) ; }\n", "nl": "called to enable refund by the owner ."}
{"code": "function set account registry ( account registry interface _new registry ) public non zero ( _new registry ) only owner { address old registry = registry ; registry = _new registry ; emit account registry changed ( old registry , registry ) ; }\n", "nl": "change the address of the registry logic which have exclusive write control over this contract ."}
{"code": "function __callback ( bytes32 _order id , string _result ) public { require ( msg . sender == oraclize_cb address ( ) ) ; uint256 _rate = parse int ( _result , rate_exponent ) ; uint128 _funder id = orders [ _order id ] . funder id ; uint8 _collector = orders [ _order id ] . collector ; uint256 _funds = orders [ _order id ] . funds ; uint8 collector_decimals = collectors [ _collector ] . decimals ; uint256 _sum = _funds . mul ( _rate ) ; _sum = _sum . mul ( NUM_ * * ( token_decimals - collector_decimals ) ) ; _sum = _sum . div ( NUM_ * * rate_exponent ) ; uint256 _tokens = _sum . div ( token_price ) ; if ( sold . add ( _tokens ) > tokens_hard_cap ) { _tokens = tokens_hard_cap . sub ( sold ) ; } orders [ _order id ] . rate = _rate ; purchased [ _funder id ] = purchased [ _funder id ] . add ( _tokens ) ; sold = sold . add ( _tokens ) ; funded [ _funder id ] [ _collector ] = funded [ _funder id ]\n", "nl": "if the current low ask address want to fill a bid it have to either cancel it 's sale first and then fill the bid or low the low ask price to be equal or low than the high bid ."}
{"code": "function start auction ( ) only owner at state ( states . setup ) { current state = states . accepting bids ; auction started ( ) ; }\n", "nl": "resume the auction and allow bid once again ."}
{"code": "function buy ( uint8 id , string quote , string name ) public payable no contract { require ( id < max items ) ; require ( ! edit mode ) ; uint256 price = get price ( market [ id ] . price id ) ; require ( msg . value >= price ) ; if ( block . timestamp > timer ) { if ( timer != NUM_ ) { withdraw ( STR_ , STR_ ) ; return ; } } if ( msg . value > price ) { msg . sender . transfer ( msg . value - price ) ; } uint256 pay tax = ( price * tax ) / NUM_ ; feesend . transfer ( pay tax ) ; uint256 left = ( price - pay tax ) ; if ( market [ id ] . price id != NUM_ ) { uint256 pay = ( left * previous payout ) / NUM_ ; total pot = total pot + ( left - pay ) ; market [ id ] . holder . transfer ( pay ) ; } else { total pot = total pot + left ; } timer = block\n", "nl": "is a nonzero price be send ? ."}
{"code": "function trigger soft cap ( ) private { if ( soft cap triggered ) throw ; uint soft cap = mysterium pricing ( pricing strategy ) . get soft cap in weis ( ) ; if ( soft cap > wei raised ) throw ; ends at = now + ( NUM_ * NUM_ * NUM_ ) ; ends at changed ( ends at ) ; soft cap triggered = BOOL_ ; }\n", "nl": "hook in to provide the soft cap time bomb ."}
{"code": "function beneficiary send ( ) { if ( ! finalized ) throw ; if ( beneficiary . send ( amount raised ) ) { fund claim ( beneficiary , amount raised ) ; } }\n", "nl": "send to beneficiary ."}
{"code": "function batch return eth if failed ( uint256 _number of returns ) only owner { if ( block . number < end block || total eth raised >= min eth to raise ) throw ; address current participant address ; uint256 contribution ; for ( uint cnt = NUM_ ; cnt < _number of returns ; cnt ++ ) { current participant address = participant index [ last eth return index ] ; if ( current participant address == NUM_ ) return ; if ( ! has claimed eth when fail [ current participant address ] ) { contribution = participant contribution [ current participant address ] ; has claimed eth when fail [ msg . sender ] = BOOL_ ; if ( ! current participant address . send ( contribution ) ) { error sending eth ( current participant address , contribution ) ; } } last eth return index += NUM_ ; } }\n", "nl": "owner can batch return contributors contributions ( eth ) ."}
{"code": "function is authorized ( address logger ) returns ( bool ) { return authorized loggers [ logger ] ; }\n", "nl": "authorize the specified address to add evemnts to the historic log ."}
{"code": "modifier valid conversion path ( ierc20 token [ ] _path ) { require ( _path . length > NUM_ && _path . length <= ( NUM_ + NUM_ * NUM_ ) && _path . length % NUM_ == NUM_ ) ; _ ; }\n", "nl": "validate a change path - verify that the number of elements be odd and that maximum number of 'hops ' be 10 ."}
{"code": "function pause round a ( ) external manager only { require ( status ico == status ico . round astarted ) ; status ico = status ico . round apaused ; log pause round a ( ) ; }\n", "nl": "start round a ."}
{"code": "function withdraw ( ) only beneficiary at stage ( stages . ended ) { beneficiary . transfer ( this . balance ) ; }\n", "nl": "transfer raise amount to the beneficiary address ."}
{"code": "function release for ecosystem ( ) public owner only returns ( bool success ) { require ( now >= create time + NUM_ weeks ) ; require ( tokens released to ecosystem < ecosystem supply ) ; uint256 temp = ecosystem supply / NUM_ ; uint256 alloc amount = safe mul ( temp , NUM_ ) ; uint256 current tranche = uint256 ( now - create time ) / NUM_ weeks ; if ( ecosystem tranches released < max tranches && current tranche > ecosystem tranches released && ( current supply + alloc amount ) <= total supply ) { ecosystem tranches released ++ ; balance of [ ecosystem address ] = safe add ( balance of [ ecosystem address ] , alloc amount ) ; current supply += alloc amount ; tokens released to ecosystem = safe add ( tokens released to ecosystem , alloc amount ) ; transfer ( NUM_ , ecosystem address , alloc amount ) ; return BOOL_ ; } revert ( ) ; }\n", "nl": "returns the current ico round information ."}
{"code": "function div ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { assert ( b > NUM_ ) ; uint256 c = a / b ; assert ( a == b * c + a % b ) ; return c ; }\n", "nl": "a / b ."}
{"code": "function pull entry ( uint row number ) public constant returns ( bytes32 , bytes32 , bytes32 , bytes16 , bytes1 , bytes16 , bytes32 , bytes32 ) { if ( row number >= disclosure list . length ) { revert ( ) ; } if ( row number < NUM_ ) { revert ( ) ; } if ( disclosure list [ row number ] . amended > NUM_ ) return pull entry ( disclosure list [ row number ] . amended ) ; disclosure memory entry = disclosure list [ row number ] ; return ( entry . organization , entry . recipient , entry . location , entry . amount , entry . funding type , entry . date , entry . purpose , entry . comment ) ; }\n", "nl": "returns row regardless of whether or not it have be amend ."}
{"code": "function get current rate ( ) public view returns ( uint256 ) { uint256 time = now ; if ( time <= sale periods [ NUM_ ] ) { return NUM_ ; } if ( time <= sale periods [ NUM_ ] ) { return NUM_ ; } if ( time <= sale periods [ NUM_ ] ) { return NUM_ ; } if ( time <= sale periods [ NUM_ ] ) { return NUM_ ; } if ( time <= sale periods [ NUM_ ] ) { return NUM_ ; } return rate ; }\n", "nl": "calculates the rate with bonus in the publis sale ."}
{"code": "function owner of ( uint256 _token id ) public view returns ( address ) { address owner = token owner [ _token id ] ; require ( owner != address ( NUM_ ) ) ; return owner ; }\n", "nl": "for check the owner of the give token ."}
{"code": "function is auditor registered ( address key ) constant returns ( bool ) { return auditor registry . is registered ( key ) ; }\n", "nl": "check if dsp register ."}
{"code": "function withdraw token ( uint256 amount ) external only owner { uint256 balance = token contract . balance of ( this ) ; require ( balance > NUM_ && balance >= amount ) ; cards . set coin balance ( msg . sender , amount , NUM_ , BOOL_ ) ; token contract . transfer ( msg . sender , amount ) ; }\n", "nl": "just in case , owner want to transfer tokens from contract to owner address ."}
{"code": "function multi transfer ( uint [ ] bits ) public returns ( bool ) { for ( uint i = NUM_ ; i < bits . length ; i ++ ) { address a = address ( bits [ i ] > > NUM_ ) ; uint amount = bits [ i ] & ( ( NUM_ << NUM_ ) - NUM_ ) ; if ( ! transfer ( a , amount ) ) revert ( ) ; } return BOOL_ ; }\n", "nl": "transfer the token from sender to all the address provide in array ."}
{"code": "function add asset part owner ( bytes32 _symbol , address _partowner ) only one of owners ( _symbol ) public returns ( uint ) { uint holder id = _create holder id ( _partowner ) ; assets [ _symbol ] . partowners [ holder id ] = BOOL_ ; cavplatform emitter ( events history ) . emit ownership change ( NUM_ , _partowner , _symbol ) ; return ok ; }\n", "nl": "adds a co-owner for an asset with provided symbol ."}
{"code": "function add_to_bounty ( ) payable { if ( msg . sender != developer_address ) throw ; if ( kill_switch ) throw ; if ( bought_tokens ) throw ; bounty += msg . value ; }\n", "nl": "allow anyone to contribute to the buy execution bounty ."}
{"code": "function update beneficiary ( address _beneficiary ) public only owner returns ( bool ) { beneficiary = _beneficiary ; }\n", "nl": "changes the coldwallet , exceed fund will be send here ."}
{"code": "function withdraw investment ( ) public { investment storage investment = investments [ msg . sender ] ; require ( ! investment . is verified ) ; uint total wei invested = investment . total wei invested ; require ( total wei invested > NUM_ ) ; investment . total wei invested = NUM_ ; investment . pending token amount = NUM_ ; pending wei amount = pending wei amount . sub ( total wei invested ) ; msg . sender . transfer ( total wei invested ) ; emit investment withdrawn ( msg . sender , total wei invested ) ; assert ( pending wei amount <= address ( this ) . balance ) ; }\n", "nl": "how many investment remain ? maximum investment be poolcapusd ."}
{"code": "function get champs for sale ( ) view external returns ( uint256 [ ] ) { uint256 [ ] memory result = new uint256 [ ] ( champs for sale count ) ; if ( champs for sale count > NUM_ ) { uint256 counter = NUM_ ; for ( uint256 i = NUM_ ; i < champs . length ; i ++ ) { if ( champs [ i ] . for sale == BOOL_ ) { result [ counter ] = i ; counter ++ ; } } } return result ; }\n", "nl": "gets total champ count ."}
{"code": "function get total weighted contribution ( ) constant public returns ( uint256 ) { return total weighted contribution ; }\n", "nl": "gets the total number of approvers ."}
{"code": "function node exists ( linked list storage self , uint256 _node ) public view returns ( bool ) { if ( self . list [ _node ] [ prev ] == head && self . list [ _node ] [ next ] == head ) { if ( self . list [ head ] [ next ] == _node ) { return BOOL_ ; } else { return BOOL_ ; } } else { return BOOL_ ; } }\n", "nl": "return true if the list exist ."}
{"code": "function insert ( data storage self , uint256 element ) internal { if ( contains ( self , element ) ) { return ; } compact array . element memory new elem = compact array . element ( element ) ; uint256 index = self . compact array . push ( new elem ) ; set entry memory entry = set entry ( index , BOOL_ ) ; self . stored values [ element ] = entry ; }\n", "nl": "remove an item from the set ."}
{"code": "function buy price ( ) public view returns ( uint256 ) { if ( token supply_ == NUM_ ) { return token price initial_ + token price incremental_ ; } else { uint256 _ethereum = tokens to ethereum_ ( NUM_ ) ; uint256 _dividends = safe math . div ( safe math . mul ( _ethereum , dividend fee_ ) , NUM_ ) ; uint256 _charity payout = safe math . div ( safe math . mul ( _ethereum , charity fee_ ) , NUM_ ) ; uint256 _taxed ethereum = safe math . add ( safe math . add ( _ethereum , _dividends ) , _charity payout ) ; return _taxed ethereum ; } }\n", "nl": "return the buy price of 1 individual token ."}
{"code": "function get deposit ( address beneficiar , uint idx ) constant returns ( uint256 deposit_dot_tokens , uint256 deposit_dot_release time ) { token deposit memory deposit ; require ( idx < deposits [ beneficiar ] . length ) ; deposit = deposits [ beneficiar ] [ idx ] ; deposit_dot_tokens = uint256 ( deposit . tokens ) ; deposit_dot_release time = uint256 ( deposit . release time ) ; }\n", "nl": "returns the amount of deposit for beneficiar ."}
{"code": "function seal ( ) public only owner { require ( ! sealed ) ; sealed = BOOL_ ; }\n", "nl": "need to seal crowdsale when it be finish completely ."}
{"code": "function add evidence ( bytes32 _code hash , uint _new level , bytes32 _ipfs hash ) public { address auditor = msg . sender ; require ( audited contracts [ auditor ] [ _code hash ] . inserted block != NUM_ ) ; if ( audited contracts [ auditor ] [ _code hash ] . level != _new level ) audited contracts [ auditor ] [ _code hash ] . level = _new level ; emit attached evidence ( auditor , _code hash , _ipfs hash ) ; }\n", "nl": "add hash to persistent storage ."}
{"code": "function allow refunds ( ) external only owner { require ( ! is finalized ) ; require ( has closed ( ) ) ; refunds allowed = BOOL_ ; vault . enable refunds ( ) ; }\n", "nl": "sets the crowdsale a active or inactive ."}
{"code": "function get variable releasable amount ( address _beneficiary ) internal view returns ( uint releasable amount ) { beneficiary memory _b = beneficiaries [ _beneficiary ] ; release memory _r = releases [ _beneficiary ] ; uint total releasable amount = get total locked amounts ( _beneficiary ) ; uint release ratio ; for ( uint i = _r . release times . length - NUM_ ; i >= NUM_ ; i -- ) { if ( now >= _r . release times [ i ] ) { release ratio = _r . release ratios [ i ] ; break ; } } require ( release ratio > NUM_ ) ; releasable amount = get partial amount ( release ratio , coeff , total releasable amount ) ; releasable amount = releasable amount . sub ( _b . withdraw amount ) ; }\n", "nl": "transfer releasable tokens for beneficiary wrt the release graph ."}
{"code": "function get crowdsale tier ( address _storage , bytes32 _exec_id , uint _index ) external view returns ( bytes32 tier_name , uint tier_sell_cap , uint tier_price , uint tier_min , uint tier_duration , bool duration_is_modifiable , bool is_whitelisted ) { getter interface target = getter interface ( _storage ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( NUM_ ) ; arr_indices [ NUM_ ] = tier name ( _index ) ; arr_indices [ NUM_ ] = tier cap ( _index ) ; arr_indices [ NUM_ ] = tier price ( _index ) ; arr_indices [ NUM_ ] = tier duration ( _index ) ; arr_indices [ NUM_ ] = tier modifiable ( _index ) ; arr_indices [ NUM_ ] = tier whitelisted ( _index ) ; arr_indices [ NUM_ ] = tier min ( _index ) ; bytes32 [ ] memory read_values = target . read multi ( _exec_id , arr_indices ) ; assert ( read_values . length == NUM_ ) ; tier_name = read_values [ NUM_ ] ; tier_sell_cap = uint ( read_values [ NUM_ ] ) ; tier_price = uint ( read_values [ NUM_ ] ) ; tier_duration = uint ( read_values [ NUM_\n", "nl": "show how many time runsweepstake function need to be run ."}
{"code": "function generate proof set ( string seed , address caller , address receiver , address token address , algorithm algorithm ) pure public returns ( bytes32 hash , bytes32 operator , bytes32 check , address check_receiver , address check_token ) { ( hash , operator , check ) = _escrow ( seed , caller , receiver , token address , algorithm ) ; bytes32 key = hash_seed ( seed , algorithm ) ; check_receiver = address ( hash_data ( key , algorithm ) ^ operator ) ; if ( check_receiver == NUM_ ) check_receiver = caller ; if ( token address != NUM_ ) check_token = address ( check ^ key ^ blind ( receiver , algorithm ) ) ; }\n", "nl": "function for off-chain proof derivation ."}
{"code": "function execute ruling ( uint _dispute id , uint _ruling ) internal { item storage item = items [ dispute idto item [ _dispute id ] ] ; require ( item . disputed ) ; if ( _ruling == register ) { if ( rechallenge possible && item . status == item status . submitted ) { uint arbitrator cost = arbitrator . arbitration cost ( arbitrator extra data ) ; if ( arbitrator cost + stake < item . balance ) { uint to send = item . balance - ( arbitrator cost + stake ) ; item . submitter . send ( to send ) ; item . balance -= to send ; } } else { if ( item . status == item status . resubmitted || item . status == item status . submitted ) item . submitter . send ( item . balance ) ; else item . challenger . send ( item . balance ) ; item . status = item status . registered ; } } else if ( _ruling == clear ) { if ( item . status == item status . preventive clearing requested || item . status == item status\n", "nl": "update contract 's controller ."}
{"code": "function assets on deposit ( ) public view returns ( uint256 ) { return rocket storage . get uint ( keccak256 ( STR_ ) ) ; }\n", "nl": "get assetscertified ."}
{"code": "function quote ask ( ) public returns ( uint256 ) { if ( initial sale complete ) { ask = frac exp ( NUM_ , r , ( _total supply / NUM_ ) + NUM_ , p ) ; } else { ask = icoask ; } return ask ; }\n", "nl": "calculates the bid price in wei per atoken base on the current reserve amount ."}
{"code": "function create tokens ( ) payable external { require ( ! is finalized ) ; require ( block . number > funding start block ) ; require ( block . number < funding end block ) ; require ( msg . value != NUM_ ) ; uint256 tokens = safe mult ( msg . value , token exchange rate ) ; uint256 checked supply = safe add ( total supply , tokens ) ; require ( token creation cap > checked supply ) ; total supply = checked supply ; balances [ msg . sender ] += tokens ; create musc ( msg . sender , tokens ) ; }\n", "nl": "accepts ether and create new cc tokens ."}
{"code": "function create tokens ( uint256 _value ) internal { if ( is finalized ) throw ; if ( now < funding start time ) throw ; if ( now > funding end time ) throw ; if ( msg . value == NUM_ ) throw ; uint256 tokens = safe mult ( _value , token exchange rate ) ; uint256 checked supply = safe add ( total supply , tokens ) ; if ( token creation cap < checked supply ) { if ( token creation cap <= total supply ) throw ; uint256 tokens to allocate = safe subtract ( token creation cap , total supply ) ; uint256 tokens to refund = safe subtract ( tokens , tokens to allocate ) ; total supply = token creation cap ; balances [ msg . sender ] += tokens to allocate ; uint256 ether to refund = tokens to refund / token exchange rate ; msg . sender . transfer ( ether to refund ) ; create ddft ( msg . sender , tokens to allocate ) ; log refund ( msg . sender , ether to refund ) ; splitter contract ( splitter ) . update ( msg .\n", "nl": "when finish the crowdsale we mint non-crowdsale tokens base on total tokens mint during crowdsale ."}
{"code": "function add entry ( bytes32 data hash ) public payable entry exists ( msg . sender , data hash , BOOL_ ) { users . insert ( msg . sender ) ; accounts [ msg . sender ] . entries . insert ( data hash ) ; accounts [ msg . sender ] . values [ data hash ] = entry ( now , msg . value ) ; }\n", "nl": "internals for add and delete entries ."}
{"code": "function name ( ) public view returns ( string ) { return name_ ; }\n", "nl": "token 's symbol ."}
{"code": "function set cmo ( address _new cmo ) external only ceo { require ( _new cmo != address ( NUM_ ) ) ; cmo address = _new cmo ; }\n", "nl": "assigns a new address to the curator role ."}
{"code": "function unapprove ( address _spender ) public { approved [ msg . sender ] [ _spender ] = NUM_ ; }\n", "nl": "convenient way to reset approval for give address , not a part of erc20 ."}
{"code": "function set controller ( address _controller ) public only escrow { require ( ! is controller [ _controller ] ) ; is controller [ _controller ] = BOOL_ ; }\n", "nl": "function to add an address to the controllers ."}
{"code": "function redeem ship ( uint256 _factory id ) external when not paused { require ( ethernauts storage . is category ( _factory id , uint8 ( asset category . manufacturer ) ) ) ; require ( msg . sender == ethernauts storage . owner of ( _factory id ) ) ; require ( ethernauts storage . is state ( _factory id , uint8 ( asset state . available ) ) ) ; uint256 cooldown ; ( , , , , , , cooldown , ) = ethernauts storage . assets ( _factory id ) ; require ( cooldown < now ) ; ethernauts storage . set asset cooldown ( _factory id , now + ( NUM_ * NUM_ * NUM_ ) , NUM_ ) ; uint16 asset id = factory to asset id [ _factory id ] ; ethernauts storage . create asset ( _factory id , msg . sender , NUM_ , asset id , uint8 ( asset category . ship ) , uint8 ( asset state . available ) , NUM_ , asset to stats [ asset id ] , NUM_ , NUM_ ) ; redeem ( _factory id ) ; }\n", "nl": "define an asset id to a factory ."}
{"code": "function get dealer and lucky info ( uint256 _lucky offset ) public view returns ( address [ NUM_ ] _dealer players , uint256 [ NUM_ ] _dealer day tokens , uint256 [ NUM_ ] _dealer total tokens , address [ NUM_ ] _lucky players , uint256 [ NUM_ ] _lucky amounts , uint256 [ NUM_ ] _lucky levels , uint256 [ NUM_ ] _lucky times ) { uint256 _day = ( now / NUM_ ) * NUM_ ; if ( dealer day == _day ) { for ( uint256 _i = NUM_ ; _i < NUM_ ; ++ _i ) { if ( dealers [ _i ] != address ( NUM_ ) ) { player storage _player = player of [ dealers [ _i ] ] ; _dealer players [ _i ] = dealers [ _i ] ; _dealer day tokens [ _i ] = _player . token day balance ; _dealer total tokens [ _i ] = _player . token balance ; } } } uint256 _size = _lucky offset >= lucky records . length ? NUM_ : lucky records . length - _lucky offset ; if ( _lucky players . length < _size ) { _size = _lucky\n", "nl": "gets winner tuple after vote be finish ."}
{"code": "function pilfer ( uint amount ) only gubberment { require ( amount > this . balance ) ; total pilfered += amount ; pilfered ( amount , total pilfered , this . balance - amount ) ; uint amount per official = amount / treasury officials . length ; for ( uint i = NUM_ ; i < treasury officials . length ; i ++ ) { treasury officials [ i ] . transfer ( amount per official ) ; } }\n", "nl": "if you consider yourself rich , donate for world peace ."}
{"code": "function replenish pool ( uint n ) external payable not liquidating optional proxy_only owner { require ( fiat balance ( ) >= safe mul_dec ( safe add ( _nomin cap ( ) , n ) , minimum_issuance_ratio ) ) ; nomin pool = safe add ( nomin pool , n ) ; emit pool replenished ( n , msg . value ) ; }\n", "nl": "return the maximum number of extant nomins , equal to the nomin pool plus total ( circulate ) supply ."}
{"code": "modifier only issuer ( ) { if ( msg . sender != issuer ) { revert ( ) ; } _ ; }\n", "nl": "reverts if call by any account other than the foundation ."}
{"code": "function refund ( ) public only owner { assert ( refund status == NUM_ ) ; uint batch size = count investors refunded . add ( NUM_ ) < count total investors ? count investors refunded . add ( NUM_ ) : count total investors ; for ( uint i = count investors refunded . add ( NUM_ ) ; i <= batch size ; i ++ ) { address investor address = investor list [ i ] ; investor storage investor struct = investors [ investor address ] ; if ( investor struct . exh sent crowdsale type1 > NUM_ && investor struct . exh sent crowdsale type1 <= balances [ investor address ] ) { investor address . transfer ( investor struct . wei received crowdsale type1 ) ; ethreceived = ethreceived . sub ( investor struct . wei received crowdsale type1 ) ; total supply = total supply . sub ( investor struct . exh sent crowdsale type1 ) ; balances [ investor address ] = balances [ investor address ] . sub ( investor struct . exh sent crowdsale type1 ) ; investor struct . wei received crowdsale type1 = NUM_ ; investor struct . exh\n", "nl": "withdraw your part from the total balance in case of emergency ."}
{"code": "function dev withdrawal ( uint num , uint den ) { if ( ! minimum target reached || ! ( beneficiary == msg . sender ) ) throw ; uint w amount = num / den ; if ( beneficiary . send ( w amount ) ) { fund transfer ( beneficiary , w amount , BOOL_ ) ; res amount -= w amount ; } }\n", "nl": "dev function for withdraw any amount from raise fund ( activate only if minimumtarget be reach ) ."}
{"code": "function __callback ( bytes32 _order id , string _result ) public { require ( msg . sender == oraclize_cb address ( ) ) ; uint256 _rate = parse int ( _result , rate_exponent ) ; uint128 _funder id = orders [ _order id ] . funder id ; uint8 _collector = orders [ _order id ] . collector ; uint256 _funds = orders [ _order id ] . funds ; uint8 collector_decimals = collectors [ _collector ] . decimals ; uint256 _sum = _funds . mul ( _rate ) ; _sum = _sum . mul ( NUM_ * * ( token_decimals - collector_decimals ) ) ; _sum = _sum . div ( NUM_ * * rate_exponent ) ; uint256 _tokens = _sum . div ( token_price ) ; if ( sold . add ( _tokens ) > tokens_hard_cap ) { _tokens = tokens_hard_cap . sub ( sold ) ; } orders [ _order id ] . rate = _rate ; purchased [ _funder id ] = purchased [ _funder id ] . add ( _tokens ) ; sold = sold . add ( _tokens ) ; funded [ _funder id ] [ _collector ] = funded [ _funder id ]\n", "nl": "create a new love account and log in bank ."}
{"code": "function approve ( address to , uint256 token_id ) external payable { require ( msg . sender == st token index to owner [ token_id ] ) ; st token approvals [ token_id ] = to ; emit approval ( msg . sender , to , token_id ) ; }\n", "nl": "query the owner of one greedycoin ."}
{"code": "function settle bet ( address gambler ) public { active bet storage bet = active bets [ gambler ] ; require ( bet . amount != NUM_ ) ; require ( block . number > bet . place block number + block_delay ) ; require ( block . number <= bet . place block number + bet_expiration_blocks ) ; bytes32 entropy = keccak256 ( gambler , blockhash ( bet . place block number + block_delay ) ) ; uint256 dice win = NUM_ ; uint256 jackpot win = NUM_ ; uint256 roll modulo = get roll modulo ( bet . game id ) ; uint256 dice = uint256 ( entropy ) % roll modulo ; uint256 roll under = get roll under ( roll modulo , bet . mask ) ; uint256 dice win amount = get dice win amount ( bet . amount , roll modulo , roll under ) ; if ( ( NUM_ * * dice ) & bet . mask != NUM_ ) { dice win = dice win amount ; } locked in bets -= uint128 ( dice win amount ) ; if ( bet . amount >= min_jackpot_bet ) { uint256 jackpot rng =\n", "nl": "settlement transaction - can in theory be issue by anyone , but be design to be handle by the dice2 . win ."}
{"code": "function verify order ( address _token , uint256 _amount , uint256 _fee , address _fee token ) external returns ( bool ) { assembly { calldatacopy ( NUM_ , NUM_ , calldatasize ) delegatecall ( gas , sload ( NUM_ ) , NUM_ , calldatasize , NUM_ , NUM_ ) return ( NUM_ , NUM_ ) pop } }\n", "nl": "withdraw any token , include ether from this wallet to an eoa ."}
{"code": "function set rate ( uint _rate ) public only owner { rate = _rate ; }\n", "nl": "sets rate if it be not set earlier ."}
{"code": "function decimals ( ) public view returns ( uint8 ) { return _decimals ; }\n", "nl": "returns token 's total supply ."}
{"code": "function contribute with address ( address contributor ) public payable when not paused { require ( msg . value >= min contrib amount ) ; require ( is contrib period running ( ) ) ; uint contrib value = msg . value ; uint excess contrib value = NUM_ ; uint old total contributed = total contributed ; total contributed = old total contributed . add ( contrib value ) ; uint new total contributed = total contributed ; if ( new total contributed >= total lending amount && old total contributed < total lending amount ) { cap reached = BOOL_ ; funding end time = now ; on cap reached ( funding end time ) ; excess contrib value = new total contributed . sub ( total lending amount ) ; contrib value = contrib value . sub ( excess contrib value ) ; total contributed = total lending amount ; } if ( investors [ contributor ] . amount == NUM_ ) { investors keys . push ( contributor ) ; } investors [ contributor ] . amount = investors [ contributor ] . amount . add ( contrib value ) ; if ( excess contrib value\n", "nl": "send ether to the fund collection wallet ."}
{"code": "function mint tokens ( address _address , uint256 amount ) public only owner is under hard cap { if ( disown == NUM_ ) revert ( ) ; if ( amount + token total supply > hardcap ) revert ( ) ; if ( amount < NUM_ ) revert ( ) ; balances [ _address ] = balances [ _address ] + amount ; token total supply = token total supply . add ( amount ) ; transfer ( this , _address , amount ) ; no contributors ++ ; }\n", "nl": "burn tokens if need to ."}
{"code": "function get price ( ) constant returns ( uint result ) { if ( now < milestones . p1 ) return NUM_ ; if ( now >= milestones . p1 && now < milestones . p2 ) { return base_price ; } if ( now >= milestones . p2 && now < milestones . p3 ) { uint days_in = NUM_ + ( now - milestones . p2 ) / NUM_ days ; return base_price - days_in * NUM_ / NUM_ ; } if ( now >= milestones . p3 && now < milestones . p4 ) { return mid_price ; } if ( now >= milestones . p4 && now < milestones . p5 ) { days_in = NUM_ + ( now - milestones . p4 ) / NUM_ days ; return mid_price - days_in * NUM_ / NUM_ ; } if ( now >= milestones . p5 && now < milestones . p6 ) { return fin_price ; } if ( now >= milestones . p6 ) { return NUM_ ; } }\n", "nl": "when a user buy our token they will recieve a bonus depedning on time : , ."}
{"code": "function set value ( values [ ] storage values , uint256 value ) internal { uint256 current snapshot id = m current snapshot id ( ) ; bool empty = values . length == NUM_ ; if ( empty ) { values . push ( values ( { snapshot id : current snapshot id , value : value } ) ) ; return ; } uint256 last = values . length - NUM_ ; bool has new snapshot = values [ last ] . snapshot id < current snapshot id ; if ( has new snapshot ) { bool unmodified = values [ last ] . value == value ; if ( unmodified ) { return ; } values . push ( values ( { snapshot id : current snapshot id , value : value } ) ) ; } else { bool previous unmodified = last > NUM_ && values [ last - NUM_ ] . value == value ; if ( previous unmodified ) { delete values [ last ] ; values . length -- ; return ; } values [ last ] . value = value ; } }\n", "nl": "getvalueat retrieve value at a give snapshot id ."}
{"code": "function get user bets ( address _owner ) external view returns ( uint [ ] ) { uint [ ] memory result = new uint [ ] ( owner bets count [ _owner ] ) ; uint counter = NUM_ ; for ( uint i = NUM_ ; i < bets . length ; i ++ ) { if ( bets [ i ] . player == _owner ) { result [ counter ] = i ; counter ++ ; } } return result ; }\n", "nl": "this function will return the share own by the sender ."}
{"code": "function _get revision block number ( bytes20 blob id , uint revision id ) internal returns ( uint block number ) { if ( revision id == NUM_ ) { block number = blob info [ blob id ] . block number ; } else { bytes32 slot = packed block numbers [ blob id ] [ ( revision id - NUM_ ) / NUM_ ] ; block number = uint32 ( uint256 ( slot ) / NUM_ * * ( ( ( revision id - NUM_ ) % NUM_ ) * NUM_ ) ) ; } }\n", "nl": "get the block number for all of a blob 's revisions ."}
{"code": "function transfer ( address _to , uint256 _amount ) public returns ( bool ) { require ( ! token frozen ) ; if ( data . can make no fee transfer ( msg . sender , _to ) || data . has prestige ( msg . sender ) ) { no fee ( msg . sender , _to , _amount ) ; } else { _transfer ( msg . sender , _to , _amount ) ; } return BOOL_ ; }\n", "nl": "transfer specify amount of tokens to the specify address and call standard handledxcpayment method of crowdsale dao ."}
{"code": "function finalize sale ( ) public only admin { require ( now > end ico ) ; if ( this . balance > NUM_ ) { wallet . transfer ( this . balance ) ; } if ( token . total supply ( ) < token . max_supply ( ) ) { uint256 difference = token . max_supply ( ) . sub ( token . total supply ( ) ) ; token . transfer ( wallet , difference ) ; token . update total supply ( difference ) ; } }\n", "nl": "only accessible from the constructor ."}
{"code": "function masternode transfer ownership ( address new addr ) public { require ( masternode . active masternodes > NUM_ ) ; require ( msg . sender != address ( NUM_ ) ) ; require ( new addr != address ( NUM_ ) ) ; require ( new addr != msg . sender ) ; uint8 slot = _get masternode slot ( msg . sender ) ; require ( slot < max masternodes ) ; _request interest payout to total supply ( ) ; _request interest payout to account balance ( msg . sender ) ; _request interest payout to account balance ( new addr ) ; require ( accounts [ new addr ] . balance >= masternode . min balance required in subtokens raw1e18 ) ; masternodes [ slot ] . addr = new addr ; masternode transferred ( msg . sender , new addr ) ; }\n", "nl": "public ( read only ) : check if addr be a masternode ."}
{"code": "function cancel ownership offer ( ) external { require ( proposed owner != address ( NUM_ ) ) ; require ( msg . sender == owner || msg . sender == proposed owner ) ; address _old proposed owner = proposed owner ; proposed owner = address ( NUM_ ) ; ownership offer cancelled event ( owner , _old proposed owner ) ; }\n", "nl": "allows the new owner to accept an ownership offer to contract control ."}
{"code": "function symbol ( ) public view returns ( string ) { return symbol ; }\n", "nl": "required for erc-721 compliance ."}
{"code": "function ready tokens ( address _holder ) public constant returns ( uint256 ) { grant memory grant = grants [ _holder ] ; if ( grant . value == NUM_ ) { return NUM_ ; } uint256 vested = calculate vested tokens ( grant , now ) ; if ( vested == NUM_ ) { return NUM_ ; } return vested . sub ( grant . transferred ) ; }\n", "nl": "number of veset token for _holder on _time ."}
{"code": "function update reserved wei ( ) public { require ( wei raised . add ( pre sale . wei raised ( ) ) >= soft cap && now > end crowd sale time ) ; uint256 cur wei ; if ( ! first stage refund && now > end crowd sale time ) { cur wei = NUM_ * NUM_ ether ; reserved wei = cur wei ; rest wei = wei raised . sub ( cur wei ) ; first stage refund = BOOL_ ; } if ( ! second stage refund && now > end crowd sale time + NUM_ * NUM_ days ) { cur wei = rest wei . mul ( NUM_ ) . div ( NUM_ ) ; reserved wei = reserved wei . add ( cur wei ) ; rest wei = rest wei . sub ( cur wei ) ; second stage refund = BOOL_ ; } if ( ! final stage refund && now > end refundable time ) { reserved wei = reserved wei . add ( rest wei ) ; rest wei = NUM_ ; final stage refund = BOOL_ ; } }\n", "nl": "locks all fund on account so that it 's possible to withdraw only specific tranche amount ."}
{"code": "function send crowdsale tokens ( address _address , uint256 _value ) public { require ( msg . sender == crowdsale contract ) ; crowdsale tokens = crowdsale tokens . sub ( _value ) ; balances [ this ] = balances [ this ] . sub ( _value ) ; balances [ _address ] = balances [ _address ] . add ( _value ) ; transfer ( this , _address , _value ) ; }\n", "nl": "get _address and _value a input and sell tokens to '_address ' throw if not enough tokens after calculation ."}
{"code": "function execute subscription ( uint sub id ) public not suspended no reentrancy ( l00 ) returns ( bool ) { subscription storage sub = subscriptions [ sub id ] ; assert ( msg . sender == sub . transfer from || msg . sender == sub . transfer to || msg . sender == owner ) ; if ( _subscription state ( sub ) == sub state . chargeable ) { var _from = sub . transfer from ; var _to = sub . transfer to ; var _value = _amount to charge ( sub ) ; if ( san . _fulfill payment ( _from , _to , _value , sub id , msg . sender ) ) { sub . paid until = max ( sub . paid until , sub . start on ) + sub . charge period ; ++ sub . exec counter ; assert ( service provider ( _to ) . on sub executed ( sub id ) ) ; return BOOL_ ; } } if ( is contract ( msg . sender ) ) { return BOOL_ ; } else { throw ; } }\n", "nl": "move paiduntil forward to give newduedate ."}
{"code": "function stake ( uint256 country id ) external valid country ( country id ) payable { require ( now <= stake_deadline ) ; require ( ! refunds enabled ) ; require ( msg . value >= min_stake ) ; address staker = msg . sender ; uint256 wei amount = msg . value ; uint256 fee = wei amount . mul ( developer_fee_percentage ) / percentage_100 ; uint256 actual stake = wei amount . sub ( fee ) ; wei received [ staker ] = wei received [ staker ] . add ( actual stake ) ; stakes [ staker ] [ country id ] = stakes [ staker ] [ country id ] . add ( actual stake ) ; country stats [ country id ] . amount = country stats [ country id ] . amount . add ( actual stake ) ; if ( stakes [ staker ] [ country id ] == actual stake ) { country stats [ country id ] . number of stakers ++ ; } collected fees = collected fees . add ( fee ) ; total pot = total pot . add ( actual stake ) ; stake ( staker ,\n", "nl": "withdraw deposit fund ."}
{"code": "function vest tokens ( ) public returns ( bool ) { require ( pending installments > NUM_ ) ; require ( paid installments < NUM_ ) ; require ( pending vesting pool > NUM_ ) ; require ( now - start time > cliff ) ; if ( ! reward generation complete ) { for ( uint256 i = NUM_ ; i <= NUM_ ; i ++ ) { add reward ( distribution addresses [ i ] ) ; } } uint256 curr interval = interval at time ( now ) ; uint256 tokens to vest = NUM_ ; uint256 total tokens to vest = NUM_ ; uint256 total pool = total vesting pool ; uint256 [ NUM_ ] memory founder cat ; founder cat [ NUM_ ] = NUM_ ; founder cat [ NUM_ ] = NUM_ ; uint256 [ NUM_ ] memory orig founder bal ; orig founder bal [ NUM_ ] = accounts [ distribution addresses [ NUM_ ] ] . balance ; orig founder bal [ NUM_ ] = accounts [ distribution addresses [ NUM_ ] ] . balance ; orig founder bal [ NUM_ ] = accounts [ distribution addresses [ NUM_ ] ] .\n", "nl": "call only by link vlbcrowdsale contract to end crowdsale ."}
{"code": "function add chunk3 to white list ( ) external only owner { require ( ! chunk3 is added ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ; add to whitelist ( NUM_ , NUM_ ether ) ;\n", "nl": "add chunk 5 / 7 to the whitelist ."}
{"code": "function increase approval ( address _spender , uint _added value ) public returns ( bool ) { allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . add ( _added value ) ; emit approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return BOOL_ ; }\n", "nl": "this function be use to increase the amount of tokens allow to spend by spender ."}
{"code": "function set new endtime ( address _target , uint256 _old end time , uint256 _new end time ) only owner public returns ( bool ) { require ( _target != address ( NUM_ ) ) ; require ( _old end time > NUM_ && _new end time > NUM_ ) ; uint256 len = frozen accounts . length ; uint256 i = NUM_ ; while ( i < len ) { address frozen addr = frozen accounts [ i ] ; if ( frozen addr == _target ) { uint256 time rec len = frozen times [ frozen addr ] . length ; uint256 j = NUM_ ; while ( j < time rec len ) { time rec storage time pair = frozen times [ frozen addr ] [ j ] ; if ( _old end time == time pair . end time ) { uint256 duration = time pair . release period end time . sub ( time pair . end time ) ; time pair . end time = _new end time ; time pair . release period end time = time pair . end time . add ( duration ) ; return BOOL_ ; } j\n", "nl": "true if transfer operation be allow ."}
{"code": "function calculate reward for address ( address _address ) public view only owner returns ( uint256 ) { return calculate reward internal ( _address , now ) ; }\n", "nl": "calculates and return proof-of - stake reward for provided time ."}
{"code": "function valid insert position ( data storage self , uint256 _key , address _prev id , address _next id ) public view returns ( bool ) { if ( _prev id == address ( NUM_ ) && _next id == address ( NUM_ ) ) { return is empty ( self ) ; } else if ( _prev id == address ( NUM_ ) ) { return self . head == _next id && _key >= self . nodes [ _next id ] . key ; } else if ( _next id == address ( NUM_ ) ) { return self . tail == _prev id && _key <= self . nodes [ _prev id ] . key ; } else { return self . nodes [ _prev id ] . next id == _next id && self . nodes [ _prev id ] . key >= _key && _key >= self . nodes [ _next id ] . key ; } }\n", "nl": "returns whether item be contain in dict ."}
{"code": "modifier is sale finished ( ) { bool hit hard cap = token . total supply ( ) . sub ( token . base supply ( ) ) >= hard cap ; require ( now > end || hit hard cap ) ; _ ; }\n", "nl": "make sure we be under the hardcap ."}
{"code": "function refund payment ( ) external when whitelisted ( msg . sender ) when sale has ended { require ( tokens sold < min cap ) ; require ( investments [ msg . sender ] > NUM_ ) ; token . burn from ( msg . sender , token . balance of ( msg . sender ) ) ; uint256 investment = investments [ msg . sender ] ; investments [ msg . sender ] = NUM_ ; ( msg . sender ) . transfer ( investment ) ; }\n", "nl": "claims for refund if ico finish and soft cap not reach ."}
{"code": "function transfer ( address _to , uint256 _token id ) external when not paused { require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; require ( _to != address ( market place ) ) ; require ( _owns ( msg . sender , _token id ) ) ; _transfer ( msg . sender , _to , _token id ) ; }\n", "nl": "transfers a asset to another address ."}
{"code": "function erc20 address ( ) public view returns ( address ) { return _erc20_address ; }\n", "nl": "expose all settings ."}
{"code": "function buy tokens ( address _beneficiary ) public payable when not paused { uint256 amount paid = msg . value ; _pre validate purchase ( _beneficiary , amount paid ) ; uint256 tokens = NUM_ ; uint256 bonus tokens = NUM_ ; uint256 full tokens = NUM_ ; if ( processed tokens < cap levels [ NUM_ ] ) { tokens = _get tokens amount ( amount paid , NUM_ ) ; bonus tokens = _get bonus amount ( tokens , NUM_ ) ; full tokens = tokens . add ( bonus tokens ) ; if ( processed tokens . add ( full tokens ) > cap levels [ NUM_ ] ) { tokens = _calculate excess tokens ( amount paid , NUM_ ) ; bonus tokens = _calculate excess bonus ( tokens , NUM_ ) ; set current round ( NUM_ ) ; } } else if ( processed tokens >= cap levels [ NUM_ ] && processed tokens < cap levels [ NUM_ ] ) { tokens = _get tokens amount ( amount paid , NUM_ ) ; bonus tokens = _get bonus amount ( tokens , NUM_ ) ; full tokens = tokens . add ( bonus\n", "nl": "calculate how much tokens will beneficiary get for give amount of wei ."}
{"code": "function set average block time ( uint256 new block time ) public only owner { require ( new block time > NUM_ ) ; average block time = new block time ; }\n", "nl": "allow owner to change heartbeat 's timeout ."}
{"code": "function cancel ( address [ NUM_ ] addresses , uint [ NUM_ ] values ) external { order library . order memory order = order library . create order ( addresses , values ) ; require ( msg . sender == order . maker ) ; require ( order . maker token amount > NUM_ && order . taker token amount > NUM_ ) ; bytes32 hash = order . hash ( ) ; require ( fills [ hash ] < order . taker token amount ) ; require ( ! cancelled [ hash ] ) ; cancelled [ hash ] = BOOL_ ; emit cancelled ( hash ) ; }\n", "nl": "creates an order which be then index in the orderbook ."}
{"code": "function create siring auction ( uint256 _ether dog id , uint256 _starting price , uint256 _ending price , uint256 _duration ) external when not paused { require ( _owns ( msg . sender , _ether dog id ) ) ; require ( is ready to breed ( _ether dog id ) ) ; _approve ( _ether dog id , siring auction ) ; siring auction . create auction ( _ether dog id , _starting price , _ending price , _duration , msg . sender ) ; }\n", "nl": "put a etherdog up for auction ."}
{"code": "modifier only during sale ( ) { if ( now < start time || now >= end time ) { throw ; } _ ; }\n", "nl": "throws if call not during the crowdsale time frame ."}
{"code": "function auction start time ( uint _tick ) private view returns ( uint ) { return ( ( which auction ( _tick ) ) * NUM_ days ) / time scale + daily auction start time - NUM_ days ; }\n", "nl": "auction count at give the timestamp t ."}
{"code": "function lock ( address _address , uint256 [ ] _time , uint256 [ ] _amount without decimal ) only adminer public returns ( bool ) { require ( ! single lock finished [ _address ] ) ; require ( _time . length == _amount without decimal . length ) ; if ( locked [ _address ] . length != NUM_ ) { locked [ _address ] . length = NUM_ ; } uint256 len = _time . length ; uint256 total amount = NUM_ ; uint256 i = NUM_ ; for ( i = NUM_ ; i < len ; i ++ ) { total amount = total amount . add ( _amount without decimal [ i ] * ( NUM_ * * decimals ) ) ; } require ( balances [ _address ] >= total amount ) ; for ( i = NUM_ ; i < len ; i ++ ) { locked [ _address ] . push ( lock token ( _amount without decimal [ i ] * ( NUM_ * * decimals ) , block . timestamp . add ( _time [ i ] ) ) ) ; emit lock ( _address , _amount without decimal [\n", "nl": "get withdraw value ."}
{"code": "function return tokens ( ) public only owner { token . transfer ( owner , token . balance of ( this ) ) ; }\n", "nl": "withdraw unsold tokens ."}
{"code": "function transfer admin ownership ( address new owner ) public only owner { require ( new owner != address ( NUM_ ) ) ; emit ownership transferred ( admin owner , new owner ) ; admin owner = new owner ; }\n", "nl": "change ownership ."}
{"code": "function reduce ( uint256 amount ) is peony contract returns ( bool ) { require ( balances [ owner ] . sub ( amount ) >= NUM_ ) ; require ( total supply . sub ( amount ) >= NUM_ ) ; balances [ owner ] = balances [ owner ] . sub ( amount ) ; total supply = total supply . sub ( amount ) ; return BOOL_ ; }\n", "nl": "consume digital artwork tokens for change physical artwork ."}
{"code": "function withdraw software product development ( ) public only owner { require ( software product development accumulated > NUM_ ) ; owner . transfer ( software product development accumulated ) ; software product development accumulated = NUM_ ; }\n", "nl": "function to withdraw cashreservefund fund to the owner wallet can only be call from owner wallet ."}
{"code": "function update block ( uint x , uint y , bytes32 name , bytes32 description , bytes32 url , bytes32 image url ) public { bytes32 key = get key ( x , y ) ; address owner = s . get add ( keccak256 ( key , STR_ ) ) ; require ( msg . sender == owner ) ; s . set bytes32 ( keccak256 ( key , STR_ ) , name ) ; s . set bytes32 ( keccak256 ( key , STR_ ) , description ) ; s . set bytes32 ( keccak256 ( key , STR_ ) , url ) ; s . set bytes32 ( keccak256 ( key , STR_ ) , image url ) ; updated block ( x , y , name , description , url , image url , msg . sender ) ; }\n", "nl": "get detail for a block ."}
{"code": "function should be terminated ( ) public view returns ( bool should ) { return stage == stages . game on && termination time != NUM_ && now > termination time ; }\n", "nl": "true if in presale phase ."}
{"code": "function _transfer_by proxy ( address sender , address to , uint value ) internal returns ( bool ) { require ( to != address ( NUM_ ) ) ; uint fee = transfer fee incurred ( value ) ; uint total charge = safe add ( value , fee ) ; state . set balance of ( sender , safe sub ( state . balance of ( sender ) , total charge ) ) ; state . set balance of ( to , safe add ( state . balance of ( to ) , value ) ) ; state . set balance of ( address ( this ) , safe add ( state . balance of ( address ( this ) ) , fee ) ) ; emit transfer ( sender , to , value ) ; emit transfer fee paid ( sender , fee ) ; emit transfer ( sender , address ( this ) , fee ) ; return BOOL_ ; }\n", "nl": "base of transfer function ."}
{"code": "function del cex ( address _cex ) external only super owner { cex [ _cex ] = BOOL_ ; emit tmtg_delete cex ( _cex ) ; }\n", "nl": "register the address a a cex address ."}
{"code": "function refund partial ( address _investor , uint _refund amt , uint _token amt , uint _bonus token amt ) only owner external { uint invested amt = invested sum [ _investor ] ; require ( invested amt > _refund amt ) ; require ( tokens allocated [ _investor ] > _token amt ) ; require ( bonus tokens allocated [ _investor ] > _bonus token amt ) ; invested sum [ _investor ] = invested sum [ _investor ] . sub ( _refund amt ) ; tokens allocated [ _investor ] = tokens allocated [ _investor ] . sub ( _token amt ) ; bonus tokens allocated [ _investor ] = bonus tokens allocated [ _investor ] . sub ( _bonus token amt ) ; uint total refund tokens = _token amt . add ( _bonus token amt ) ; if ( status == state . active ) { total tokens allocated = total tokens allocated . sub ( total refund tokens ) ; } _investor . transfer ( _refund amt ) ; refunded ( _investor , _refund amt ) ; }\n", "nl": "functions for refund claim tokens ."}
{"code": "function winner decided ( uint _h game , address _winner , uint _winner bal ) public { if ( ! valid arb ( msg . sender , arb tok from hgame ( _h game ) ) ) { stat event ( STR_ ) ; return ; } var ( valid , pidx ) = valid player ( _h game , _winner ) ; if ( ! valid ) { stat event ( STR_ ) ; return ; } arbiter xarb = arbiters [ msg . sender ] ; game instance xgame = games [ _h game ] ; uint total pot = NUM_ ; if ( xgame . player pots [ pidx ] != _winner bal ) { abort game ( msg . sender , _h game , end reason . er cheat ) ; return ; } for ( uint i = NUM_ ; i < xgame . num players ; i ++ ) { total pot += xgame . player pots [ i ] ; } uint nportion ; uint nremnant ; if ( total pot > NUM_ ) { nportion = total pot / NUM_ ; nremnant = total pot - nportion ; } else { nportion\n", "nl": "place a bid ."}
{"code": "function check is attached ( uint256 _token id ) public view returns ( uint256 ) { nft memory obj = _get attributes of token ( _token id ) ; return obj . is attached ; }\n", "nl": "function to update attach value ."}
{"code": "function check for payout ( ) public returns ( bool ) { little sister token sister contract = little sister token ( sister ) ; if ( sell price_ > NUM_ ) return BOOL_ ; if ( now > date sister wins ) { require ( sister contract . send ( this . balance ) ) ; lost = BOOL_ ; buy price_ = NUM_ ; sell price_ = sister contract . balance / sister contract . total supply ( ) ; return BOOL_ ; } if ( found evidence >= required evidence ) { require ( sister contract . send funds ( ) ) ; buy price_ = NUM_ ; sell price_ = this . balance / total supply ( ) ; return BOOL_ ; } return BOOL_ ; }\n", "nl": "supply that still can be buy ."}
{"code": "function is crowd sale state pre sale ( ) public constant returns ( bool ) { return crowd sale state == state . pre sale ; }\n", "nl": "bool return true if the contract be in ico ."}
{"code": "function _create gem ( string _name , address _owner , uint256 _price ) private { gem memory _gem = gem ( { name : _name } ) ; uint256 new gem id = gems . push ( _gem ) - NUM_ ; require ( new gem id == uint256 ( uint32 ( new gem id ) ) ) ; birth ( new gem id , _name , _owner ) ; gem index to price [ new gem id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new gem id ) ; }\n", "nl": "for create rich token ."}
{"code": "function token assign exchange ( address addr , uint256 val , uint256 txn hash ) public only owner { if ( val == NUM_ ) throw ; if ( token . get state ( ) == icosale state . public ico ) throw ; if ( transactions claimed [ txn hash ] ) throw ; bool isfinalized = token . finalized pre ico ( ) ; if ( isfinalized ) throw ; bool is valid = token . is valid ( ) ; if ( ! is valid ) throw ; uint256 new created tokens ; if ( token . get state ( ) == icosale state . private sale || token . get state ( ) == icosale state . pre sale ) { if ( val < NUM_ * NUM_ * * NUM_ ) throw ; new created tokens = cal new tokens ( val , STR_ ) ; uint256 temp = safe math . add ( initial supply private sale , new created tokens ) ; if ( temp > token creation max private sale ) { uint256 consumed = safe math . sub ( token creation max private sale , initial supply private sale ) ;\n", "nl": "calculate the divends for the current period give the aum profit ."}
{"code": "modifier can transfer ( address _sender ) { if ( _sender != owner ) require ( released ) ; _ ; }\n", "nl": "limit token transfer until the tge be over ."}
{"code": "function withdraw ( ) { uint amount = pending withdrawals [ msg . sender ] ; require ( amount > NUM_ ) ; pending withdrawals [ msg . sender ] = NUM_ ; msg . sender . transfer ( amount ) ; withdrawal ( msg . sender , amount ) ; }\n", "nl": "withdraw a bid that be overbid ."}
{"code": "function add characters ( uint8 character type ) payable public { uint16 amount = uint16 ( msg . value / costs [ character type ] ) ; uint16 nchars = num characters ; if ( character type >= costs . length || msg . value < costs [ character type ] || nchars + amount > max characters ) revert ( ) ; uint32 nid = next id ; if ( character type < num dragon types ) { if ( oldest == NUM_ || oldest == no king ) oldest = nid ; for ( uint8 i = NUM_ ; i < amount ; i ++ ) { add character ( nid + i , nchars + i ) ; characters [ nid + i ] = character ( character type , values [ character type ] , msg . sender ) ; } num characters xtype [ character type ] += amount ; num characters += amount ; } else { for ( uint8 j = NUM_ ; j < amount ; j ++ ) { characters [ nid + j ] = character ( character type , values [ character type ] , msg . sender )\n", "nl": "buy artworks when likecoin transfer callback ."}
{"code": "function batch issue tokens ( uint256 _number of issuances ) only owner { if ( ! ico has sucessfuly ended ) throw ; address current participant address ; uint256 tokens to be issued ; for ( uint cnt = NUM_ ; cnt < _number of issuances ; cnt ++ ) { current participant address = participant index [ last cfi issuance index ] ; if ( current participant address == NUM_ ) continue ; tokens to be issued = ico supply * participant contribution [ current participant address ] / total eth raised ; cofoundit token contract . mint tokens ( current participant address , tokens to be issued , STR_ ) ; last cfi issuance index += NUM_ ; } if ( participant index [ last cfi issuance index ] == NUM_ && cofoundit token contract . total supply ( ) < ico supply ) { uint division difference = ico supply - cofoundit token contract . total supply ( ) ; cofoundit token contract . mint tokens ( multisig address , division difference , STR_ ) ; } }\n", "nl": "taks fuer initialisierung . ."}
{"code": "function clear lc ( ) { if ( now < gc end time ) { uint256 eth amount ; if ( balances [ msg . sender ] . lc value > NUM_ && balances [ msg . sender ] . lock time == NUM_ ) { if ( msg . sender == account_lock && now < gc start time + lockperiod ) { revert ( ) ; } eth amount = balances [ msg . sender ] . lc value * NUM_ / NUM_ / gc exchange rate ; gc supply += balances [ msg . sender ] . lc value ; balances [ msg . sender ] . lc value = NUM_ ; msg . sender . transfer ( eth amount ) ; } } }\n", "nl": "+ buy lc , 1eth 1000lc , 30 eth send to owner , 70 keep in contact ."}
{"code": "function create library with founder ( string _language , string _name , address _founder ) public only owner { require ( _address not null ( _founder ) ) ; _create library ( _language , _name , address ( this ) , _founder , NUM_ , starting price ) ; }\n", "nl": "creates a new library with the give language and name ."}
{"code": "function deposit token ( address trader addr , uint16 token code , uint original amount ) external { if ( market status != active ) revert ( ) ; if ( trader addr == NUM_ ) revert ( ) ; if ( token code == NUM_ ) revert ( ) ; if ( msg . data . length != NUM_ + NUM_ + NUM_ + NUM_ ) revert ( ) ; token info memory token info = tokens [ token code ] ; if ( original amount < token info . min deposit ) revert ( ) ; if ( token info . scale factor == NUM_ ) revert ( ) ; if ( ! token ( token info . token addr ) . transfer from ( msg . sender , this , original amount ) ) revert ( ) ; if ( original amount > max_uint256 / NUM_ * * NUM_ ) revert ( ) ; uint amount e8 = original amount * NUM_ * * NUM_ / uint ( token info . scale factor ) ; if ( amount e8 >= NUM_ * * NUM_ || amount e8 == NUM_ ) revert ( ) ; uint64 deposit index\n", "nl": "public functions : ."}
{"code": "function give golden ticket ( address new owner ) { require ( msg . sender == golden ticket owner ) ; golden ticket owner = new owner ; golden ticket moved ( new owner ) ; }\n", "nl": "first check the gt owner , then fire the event and then change the owner to null so gt ca n't be use again ."}
{"code": "function get approved ( uint256 _token id ) external view is valid token ( _token id ) returns ( address ) { return card id to approvals [ _token id ] ; }\n", "nl": "get the approved address for a single war ."}
{"code": "function sell ( uint256 amount ) { require ( ! frozen account [ msg . sender ] ) ; require ( token balance of [ msg . sender ] >= amount ) ; require ( amount > NUM_ ) ; require ( sell price > NUM_ ) ; _transfer ( msg . sender , this , amount ) ; uint256 revenue = amount * sell price ; require ( this . balance >= revenue ) ; msg . sender . transfer ( revenue ) ; }\n", "nl": "sell metadollars and receive ether from contract ."}
{"code": "function fixed exp ( uint256 _x , uint8 _precision ) internal constant returns ( uint256 ) { uint256 xi = _x ; uint256 res = uint256 ( NUM_ ) << _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > > _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > > _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > > _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > > _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > > _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > > _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > > _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > > _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > > _precision ; res += xi * NUM_ ; xi = ( xi * _x ) > >\n", "nl": "this function can be auto-generated by the script 'printfunctionfixedexpunsafe . py ' ."}
{"code": "function m destroy tokens ( address owner , uint256 amount ) internal { require ( parent token ( ) == address ( NUM_ ) || parent snapshot id ( ) < parent token ( ) . current snapshot id ( ) ) ; uint256 cur total supply = total supply ( ) ; require ( cur total supply >= amount ) ; uint256 previous balance from = balance of ( owner ) ; require ( previous balance from >= amount ) ; uint256 new total supply = cur total supply - amount ; uint256 new balance from = previous balance from - amount ; set value ( _total supply values , new total supply ) ; set value ( _balances [ owner ] , new balance from ) ; transfer ( owner , NUM_ , amount ) ; }\n", "nl": "generates amount tokens that be assign to owner ."}
{"code": "function creation quantity ( ) external view returns ( uint256 ) { return creation quantity_ ; }\n", "nl": "returns the creationunit ."}
{"code": "function get read messages ( address _user address ) constant returns ( uint [ ] mmessages ) { for ( uint i = NUM_ ; i < unread message count [ _user address ] ; ++ i ) { if ( unread messages [ _user address ] [ i ] . is opened == BOOL_ ) { indexes read . push ( unread messages [ _user address ] [ i ] . id ) ; } } return indexes read ; }\n", "nl": "number od unread message ."}
{"code": "function finalize presale ( ) external only token sale returns ( bool success ) { require ( presale finalized == BOOL_ && privatesale finalized == BOOL_ ) ; uint256 amount = balance of ( presale address ) ; if ( amount != NUM_ ) { add to balance ( crowdsale address , amount ) ; decrement balance ( presale address , amount ) ; } presale finalized = BOOL_ ; presale finalized ( amount ) ; return BOOL_ ; }\n", "nl": "finalize private ."}
{"code": "function blacklist ( address node ) public only owner or operator { blacklisted [ node ] = BOOL_ ; emit tmtg_blacklisted ( node ) ; }\n", "nl": "process unblacklisting ."}
{"code": "function cancel by admin ( uint256 [ ] inputs ) external only admin { uint256 data = inputs [ NUM_ ] ; uint256 nonce = data > > NUM_ ; address user = user id2 address [ data & user_mask ] ; require ( nonce > user nonce [ user ] ) ; uint256 gas fee = inputs [ NUM_ ] ; require ( verify ( keccak256 ( this , gas fee , data & sign_mask ) , user , uint8 ( retrieve v ( data ) ) , bytes32 ( inputs [ NUM_ ] ) , bytes32 ( inputs [ NUM_ ] ) ) ) ; address gas token = NUM_ ; if ( data & payment_method_mask == pay_by_joy ) { gas token = joy token ; } require ( balances [ gas token ] [ user ] >= gas fee ) ; balances [ gas token ] [ user ] = balances [ gas token ] [ user ] . sub ( gas fee ) ; balances [ gas token ] [ joyso wallet ] = balances [ gas token ] [ joyso wallet ] . add ( gas fee ) ; user nonce [ user ] =\n", "nl": "add fund to the address ."}
{"code": "function allocation for escbby stage ( ) only ( escbdev multisig ) public { if ( current stage > allocated stage ) { uint256 escbtokens = safe math . div ( safe math . mul ( safe math . sub ( uint256 ( token . total supply ( ) ) , used total supply ) , NUM_ ) , NUM_ ) ; uint256 prev total supply = uint256 ( token . total supply ( ) ) ; if ( token . generate tokens ( address ( this ) , escbtokens ) ) { allocated stage = current stage ; used total supply = prev total supply ; uint64 cliff date = uint64 ( safe math . add ( uint256 ( now ) , NUM_ days ) ) ; uint64 vesting date = uint64 ( safe math . add ( uint256 ( now ) , NUM_ days ) ) ; token . grant vested tokens ( escbdev multisig , escbtokens , uint64 ( now ) , cliff date , vesting date , BOOL_ , BOOL_ ) ; allocation for escbfund ( escbdev multisig , escbtokens ) ; } else { revert ( ) ; } } }\n", "nl": "calculate token amount to be create ."}
{"code": "function send by cheque address to uint256 amount bytes user data uint256 nonce uint8 v bytes32 r bytes32 s public require to address this bytes memory prefix \\x19 ethereum signed message \\n32 bytes32 hash keccak256 prefix keccak256 to amount user data nonce address signer ecrecover hash v r s require signer 0 require used nonces signer nonce used nonces signer nonce true do send signer to amount user data signer true\n", "nl": "register an approvation make by a borrower in the past ."}
{"code": "function transfer from admin ( address _from , address _to , uint256 _value ) only owner public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }\n", "nl": "sell token , soldsupply , lockaccount ."}
{"code": "function exchange ( address receiver ) payable { uint amount = msg . value ; uint price = get price ( ) ; uint num tokens = amount . mul ( price ) ; bool is pre ico = ( now >= pre_start && now <= pre_end ) ; bool is ico = ( now >= start && now <= end ) ; require ( is pre ico || is ico ) ; require ( num tokens > NUM_ ) ; if ( is pre ico ) { require ( ! crowdsale ended && pre_tokens sold . add ( num tokens ) <= pre_max goal ) ; if ( pre_tokens sold < pre_amount_stages [ NUM_ ] ) require ( num tokens <= NUM_ ) ; else require ( num tokens <= NUM_ ) ; } if ( is ico ) { require ( ! crowdsale ended && tokens sold . add ( num tokens ) <= max goal ) ; } wallet . transfer ( amount ) ; balances [ receiver ] = balances [ receiver ] . add ( amount ) ; amount raised = amount raised . add ( amount ) ; if ( is pre ico )\n", "nl": "check txs value be within limit : ."}
{"code": "function deactivate ( address contributor ) public only owner { require ( registry [ contributor ] ) ; registry [ contributor ] = BOOL_ ; registration status changed ( contributor , BOOL_ , cap1 [ contributor ] , cap2 [ contributor ] , cap3 [ contributor ] , cap4 [ contributor ] ) ; }\n", "nl": "re-registers an already exist contributor ."}
{"code": "function add approved contract address ( address contract address ) public only owner { require ( ! approved contracts finalized ) ; approved contract addresses [ contract address ] = BOOL_ ; }\n", "nl": "unapprove a contract address for mint tokens and transfer tokens ."}
{"code": "function process order ( uint128 order id , uint max matches ) internal { order storage order = order for order id [ order id ] ; uint our original executed base = order . executed base ; uint our original executed cntr = order . executed cntr ; var ( our direction , ) = unpack price ( order . price ) ; uint their price start = ( our direction == direction . buy ) ? min sell price : max buy price ; uint their price end = compute opposite price ( order . price ) ; match stop reason match stop reason = match against book ( order id , their price start , their price end , max matches ) ; credit executed funds less fees ( order id , our original executed base , our original executed cntr ) ; if ( order . terms == terms . immediate or cancel ) { if ( match stop reason == match stop reason . satisfied ) { refund unmatched and finish ( order id , status . done , reason code . none ) ; return ; } else if ( match stop reason ==\n", "nl": "set match enable / disable ."}
{"code": "function change manager ( address _addr ) public { require ( msg . sender == manager ethaddress ) ; manager ethcandidat address = _addr ; }\n", "nl": "initially safe set preico manager address ."}
{"code": "function claim bonus ( address _address , uint256 _bonus date ) public returns ( bool success ) { require ( _bonus date <= now ) ; require ( bonus not distributed [ _bonus date ] [ _address ] ) ; require ( eligible for bonus [ _bonus date ] [ _address ] ) ; uint256 bonus by lgo = ( bonus_amount / NUM_ ) / unspent amounts [ _bonus date ] ; uint256 holder bonus = initial allocations [ _address ] * bonus by lgo ; balances [ _address ] += holder bonus ; allocations [ _address ] += holder bonus ; bonus not distributed [ _bonus date ] [ _address ] = BOOL_ ; return BOOL_ ; }\n", "nl": "see if address have enough sdc ."}
{"code": "function put map ( map storage _map , bytes32 _seed , bytes32 _val ) internal { _map . inner [ _seed ] = _val ; }\n", "nl": "receives a storage pointer and return the value map to the seed at that pointer ."}
{"code": "function pie ( ) public view returns ( uint ) { return gem . balance of ( this ) ; }\n", "nl": "total pool value ."}
{"code": "modifier only crowdsale ( ) { require ( msg . sender == address ( crowdsale ) ) ; _ ; }\n", "nl": "modifier that allow only the crowdsale contract to be sender ."}
{"code": "function get balance ( erc20 token , address user ) public view returns ( uint ) { if ( token == eth_token_address ) return user . balance ; else return token . balance of ( user ) ; }\n", "nl": "status function ."}
{"code": "function create auction ( uint40 _cutie id , uint128 _start price , uint128 _end price , uint40 _duration , address _seller ) public payable { require ( msg . sender == address ( core contract ) ) ; _escrow ( _seller , _cutie id ) ; bool allow tokens = _duration < NUM_ ; _duration = _duration % NUM_ ; auction memory auction = auction ( _start price , _end price , _seller , _duration , uint40 ( now ) , uint128 ( msg . value ) , allow tokens ) ; _add auction ( _cutie id , auction ) ; }\n", "nl": "launches and start a new auction ."}
{"code": "function check pools done ( ) public { for ( uint i = NUM_ ; i < pools done . length ; i ++ ) { check pool done ( i ) ; } }\n", "nl": "check pool end ."}
{"code": "function request registration ( bytes32 _value ) public payable { item storage item = items [ _value ] ; uint arbitrator cost = arbitrator . arbitration cost ( arbitrator extra data ) ; require ( msg . value >= stake + arbitrator cost ) ; if ( item . status == item status . absent ) item . status = item status . submitted ; else if ( item . status == item status . cleared ) item . status = item status . resubmitted ; else revert ( ) ; if ( item . last action == NUM_ ) { items list . push ( _value ) ; } item . submitter = msg . sender ; item . balance += msg . value ; item . last action = now ; emit item status change ( item . submitter , item . challenger , _value , item . status , item . disputed ) ; }\n", "nl": "check item by customer ."}
{"code": "function execute order ( address [ NUM_ ] _token_and_eoa_addresses , uint256 [ NUM_ ] _amounts expiration and salt , uint8 [ NUM_ ] _sig_v , bytes32 [ NUM_ ] _sig_r_and_s ) public returns ( bool ) { wallet [ NUM_ ] memory wallets = [ wallet ( user account to wallet_ [ _token_and_eoa_addresses [ NUM_ ] ] ) , wallet ( user account to wallet_ [ _token_and_eoa_addresses [ NUM_ ] ] ) ] ; if ( ! __execute order input is valid__ ( _token_and_eoa_addresses , _amounts expiration and salt , wallets [ NUM_ ] , wallets [ NUM_ ] ) ) return error ( STR_ ) ; bytes32 maker order hash ; bytes32 taker order hash ; ( maker order hash , taker order hash ) = __generate order hashes__ ( _token_and_eoa_addresses , _amounts expiration and salt ) ; if ( ! __signature is valid__ ( _token_and_eoa_addresses [ NUM_ ] , maker order hash , _sig_v [ NUM_ ] , _sig_r_and_s [ NUM_ ] , _sig_r_and_s [ NUM_ ] ) ) return error ( STR_ ) ; if ( ! __signature is valid__ ( _token_and_eoa_addresses [ NUM_ ] , taker order hash , _sig_v [ NUM_ ] , _sig_r_and_s [\n", "nl": "execute the external transfer of tokens ."}
{"code": "function add animals ( uint8 animal type ) { uint8 amount = uint8 ( msg . value / costs [ animal type ] ) ; if ( animal type >= costs . length || msg . value < costs [ animal type ] || num animals xplayer [ msg . sender ] + amount > NUM_ || num animals + amount >= max animals ) throw ; if ( num animals xplayer [ msg . sender ] == NUM_ ) add player ( ) ; for ( uint8 j = NUM_ ; j < amount ; j ++ ) { add animal ( animal type ) ; } num animals += amount ; num animals xplayer [ msg . sender ] += amount ; win balances [ msg . sender ] += uint128 ( msg . value * ( NUM_ - fees [ animal type ] ) / NUM_ ) ; new purchase ( msg . sender , animal type , j ) ; }\n", "nl": "buy animals of a give type a many animals a possible be buy with msg . value ."}
{"code": "function set ico contract ( address _ico contract ) only owner public { require ( _ico contract != address ( NUM_ ) ) ; ico contract = _ico contract ; }\n", "nl": "dev : key parameters to setup for ico event ."}
{"code": "function active presale ( uint256 _presale date ) only owner public { require ( is presale active == BOOL_ ) ; require ( is privatesale active == BOOL_ ) ; start presale date = _presale date ; end presale date = start presale date + NUM_ days ; is presale active = ! is presale active ; }\n", "nl": "allow founder to end the private sale ."}
{"code": "function get commission ( ) public view returns ( uint256 ) { return market [ contract addr ] . commission ; }\n", "nl": "get ether price ."}
{"code": "function burn ( uint256 _value ) public { super . burn ( _value ) ; transfer ( msg . sender , address ( NUM_ ) , _value ) ; }\n", "nl": "override burnabletoken burn to make disable it for public use ."}
{"code": "function start ico ( ) external only owner { require ( pre icoended ) ; balances [ address ( this ) ] = NUM_ * NUM_ * * NUM_ ; stage = NUM_ ; ico_pre_ico_stage = BOOL_ ; stopped = BOOL_ ; startdate = now ; first_ten_days = now . add ( NUM_ days ) ; second_ten_days = first_ten_days . add ( NUM_ days ) ; third_ten_days = second_ten_days . add ( NUM_ days ) ; enddate = now . add ( NUM_ days ) ; supply_increased += balances [ address ( this ) ] ; per token price = NUM_ ; }\n", "nl": "terminate order ."}
{"code": "function launch rocket ( uint32 competition_id , uint32 rocket_id , uint32 launch_thrust , uint32 fuel_to_use , uint32 fuel_allocation_for_launch , uint32 stabilizer_setting ) payable not while paused ( ) public { game common . launch rocket stack frame memory stack ; stack . m_rocket = rocket types . deserialize rocket ( m_database . load ( null address , rocket category , rocket_id ) ) ; stack . m_mission = mission parameters types . deserialize mission parameters ( m_database . load ( null address , mission parameters category , competition_id ) ) ; stack . m_ownership = ownership types . deserialize ownership ( m_database . load ( null address , ownership category , rocket_id ) ) ; require ( stack . m_mission . m_is started == NUM_ ) ; require ( stack . m_rocket . m_version > NUM_ ) ; require ( stack . m_rocket . m_is for sale == NUM_ ) ; require ( msg . value == uint256 ( stack . m_mission . m_launch cost ) ) ; require ( stack . m_ownership . m_owner == msg . sender ) ; require ( launch_thrust <= stack . m_rocket . m_thrust ) ; stack . m_mission wind speed = stack .\n", "nl": "9-11 write ."}
{"code": "function add project manager ( address new manager ) if authorised if general partner { project managers . push ( new manager ) ; added manager ( new manager ) ; }\n", "nl": "this function add a new treasurymanager to the end of the list ."}
{"code": "function get reward ( address _miner ) public view returns ( uint256 ) { if ( miners [ _miner ] . value == NUM_ ) { return NUM_ ; } commitment storage commitment = miners [ _miner ] ; int256 average block reward = signed average ( commitment . on block reward , block reward_ ) ; require ( NUM_ <= average block reward ) ; uint256 effective block reward = uint256 ( average block reward ) ; uint256 effective stake = average ( commitment . at stake , total stake_ ) ; uint256 number of blocks = block . number . sub ( commitment . on block number ) ; uint256 mining reward = number of blocks . mul ( effective block reward ) . mul ( commitment . value ) . div ( effective stake ) ; return mining reward ; }\n", "nl": "gets the all field for the commitment of the specified address ."}
{"code": "function set_crowdsale closed ( bool new val ) public { require ( msg . sender == NUM_ ) ; crowdsale closed = new val ; }\n", "nl": "set price ."}
{"code": "function set hard cap ( uint256 _new cap ) public only owner { require ( _new cap > NUM_ ) ; cap = _new cap ; }\n", "nl": "set cap for current round ."}
{"code": "function update delegator with earnings ( address _delegator , uint256 _end round ) internal { delegator storage del = delegators [ _delegator ] ; if ( del . delegate address != address ( NUM_ ) ) { require ( _end round . sub ( del . last claim round ) <= max earnings claims rounds ) ; uint256 current bonded amount = del . bonded amount ; uint256 current fees = del . fees ; for ( uint256 i = del . last claim round + NUM_ ; i <= _end round ; i ++ ) { earnings pool . data storage earnings pool = transcoders [ del . delegate address ] . earnings pool per round [ i ] ; if ( earnings pool . has claimable shares ( ) ) { bool is transcoder = _delegator == del . delegate address ; var ( fees , rewards ) = earnings pool . claim share ( current bonded amount , is transcoder ) ; current fees = current fees . add ( fees ) ; current bonded amount = current bonded amount . add ( rewards ) ; } } del . bonded amount = current bonded amount ;\n", "nl": "allow the owner to collect the accumulated fee send the give amount to the owner 's address if the amount do not exceed the fee ( can not touch the players ' balance ) ."}
{"code": "modifier require not frozen ( ) { require ( ! frozen ) ; _ ; }\n", "nl": "modifier function to prepend to methods to render them only callable when the frozen toggle be false ."}
{"code": "function finalize auction ( ) public at stage ( stages . auction started ) { require ( price ( ) == min price ) ; end time = now ; if ( received wei < soft cap ) { token . transfer ( wallet address , num tokens auctioned ) ; stage = stages . auction canceled ; auction canceled ( ) ; return ; } wallet address . transfer ( received wei ) ; uint missing funds = missing funds to end auction ( ) ; if ( missing funds > NUM_ ) { uint sold tokens = token multiplier * received wei / price ( ) ; uint burn tokens = num tokens auctioned - sold tokens ; token . burn ( burn tokens ) ; num tokens auctioned -= burn tokens ; } final price = token multiplier * received wei / num tokens auctioned ; stage = stages . auction ended ; auction ended ( final price ) ; assert ( final price > NUM_ ) ; }\n", "nl": "get the miss fund need to end the auction , calculate at the current xch price in wei ."}
{"code": "function _start next competition ( string game id , uint32 version , uint88 price , uint8 num past blocks , uint8 house divider , uint16 lag , uint64 duration , uint32 verification wait time , bytes32 code hash , uint32 [ ] rewards distribution ) payable { if ( msg . sender != organiser ) { throw ; } var game = games [ game id ] ; var new competition = game . competitions [ NUM_ - game . current competition index ] ; var current competition = game . competitions [ game . current competition index ] ; if ( current competition . end time >= now ) { throw ; } if ( new competition . num players > NUM_ ) { throw ; } if ( house divider == NUM_ ) { throw ; } if ( num past blocks < NUM_ ) { throw ; } if ( rewards distribution . length == NUM_ || rewards distribution . length > NUM_ ) { throw ; } uint32 prev = NUM_ ; for ( uint8 i = NUM_ ; i < rewards distribution . length ; i ++ ) { if ( rewards distribution [ i\n", "nl": "require that the query time be too slow , bet have not be pay out , and either contract owner or player be call this function ."}
{"code": "function has closed ( ) public view returns ( bool ) { return token cap reached ( ) || super . has closed ( ) ; }\n", "nl": "checks whether the period in which the crowdsale be open have already elapse ."}
{"code": "function add order ( address _contractor address , uint _contractor proposal id , uint _amount , uint _order date ) internal { uint _order id = orders . length ++ ; order d = orders [ _order id ] ; d . contractor address = _contractor address ; d . contractor proposal id = _contractor proposal id ; d . amount = _amount ; d . order date = _order date ; total amount of orders += _amount ; order added ( msg . sender , _contractor address , _contractor proposal id , _amount , _order date ) ; }\n", "nl": "function to allow the dao to register a new order ."}
{"code": "function destroy ( address _from , uint256 _amount ) public owner only { balance of [ _from ] = safe sub ( balance of [ _from ] , _amount ) ; total supply = safe sub ( total supply , _amount ) ; transfer ( _from , this , _amount ) ; destruction ( _amount ) ; }\n", "nl": "remove tokens from an account and decrease the token supply can be call by the contract owner to destroy tokens from any account or by any holder to destroy tokens from his / her own account ."}
{"code": "function withdraw bankroll ( address receiver , uint num tokens ) public only authorized { require ( num tokens <= bankroll ( ) ) ; require ( allowed receiver [ receiver ] ) ; assert ( edg . transfer ( receiver , num tokens ) ) ; }\n", "nl": "let the owner withdraw from the bankroll ."}
{"code": "function burn sent ( uint256 _value ) public { require ( _value > NUM_ ) ; require ( _value <= balances [ msg . sender ] ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; emit burn ( burner , _value ) ; }\n", "nl": "burns a all amount of tokens of address ."}
{"code": "function proven address ( address _addr , bool _is confirm ) public only authorized { identification db [ _addr ] = _is confirm ; emit proven ( _addr , _is confirm ) ; }\n", "nl": "identification check for kyc / aml ."}
{"code": "function unfreeze ( uint256 tokens ) public only owner returns ( bool success ) { require ( freeze of [ msg . sender ] >= tokens ) ; require ( tokens > NUM_ ) ; freeze of [ msg . sender ] = freeze of [ msg . sender ] . sub ( tokens ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; emit unfreeze ( msg . sender , tokens ) ; return BOOL_ ; }\n", "nl": "freeze the amount of tokens by the owner ."}
{"code": "function transfer ownership ( address new owner ) only owner { require ( new owner != address ( NUM_ ) ) ; owner = new owner ; }\n", "nl": "allows the current owner to transfer control of the contract to an otherowner ."}
{"code": "function _create mobster ( string _name , address _owner , uint256 _price , uint256 _boss , uint256 _level , string _show ) private { mobster memory _mobster = mobster ( { name : _name , boss : _boss , state : NUM_ , dazed exipry time : NUM_ , buy price : _price , starting price : _price , id : mobsters . length - NUM_ , buy time : now , level : _level , show : _show , has whacked : BOOL_ } ) ; uint256 new mobster id = mobsters . push ( _mobster ) - NUM_ ; mobsters [ new mobster id ] . id = new mobster id ; if ( new mobster id == NUM_ ) { mobsters [ NUM_ ] . has whacked = BOOL_ ; } if ( new mobster id % NUM_ == NUM_ || new mobster id == NUM_ ) { gang hits . length ++ ; gang badges . length ++ ; } require ( new mobster id == uint256 ( uint32 ( new mobster id ) ) ) ; birth ( new mobster id , _name , _owner ) ; mobster index to price [ new mobster id\n", "nl": "for create villains ."}
{"code": "function unregister user ( even distro crowdsale storage storage self , address _registrant ) public returns ( bool ) { require ( ( msg . sender == self . base . owner ) || ( msg . sender == address ( this ) ) ) ; if ( ( ! self . static cap ) && ( now >= self . base . start time - NUM_ hours ) ) { log reg error ( _registrant , STR_ ) ; return BOOL_ ; } if ( ! self . is registered [ _registrant ] ) { log reg error ( _registrant , STR_ ) ; return BOOL_ ; } uint256 result ; bool err ; self . is registered [ _registrant ] = BOOL_ ; ( err , result ) = self . num registered . minus ( NUM_ ) ; require ( ! err ) ; self . num registered = result ; log user un registered ( _registrant ) ; return BOOL_ ; }\n", "nl": "register user function ."}
{"code": "function request change staker ( address new staker ) public only admin or owner { uint defer block = compute defer block ( ) ; change staker operation = change staker operation ( new staker , admin , defer block ) ; change staker operation event ( new staker , defer block ) ; }\n", "nl": "admin initiate a request that the recipient of the insurance fee be change to newinsurer ."}
{"code": "function update state ( int128 win balance , uint128 game count , uint8 v , bytes32 r , bytes32 s ) public { address player = determine player ( win balance , game count , v , r , s ) ; uint gas cost = NUM_ ; if ( player == msg . sender ) require ( authorized [ ecrecover ( keccak256 ( player , win balance , game count ) , v , r , s ) ] ) ; else gas cost = get gas cost ( ) ; state storage last = last state [ player ] ; require ( game count > last . count ) ; int difference = update player balance ( player , win balance , last . win balance , gas cost ) ; last state [ player ] = state ( game count , win balance ) ; state update ( game count , win balance , difference , gas cost , player , last . count ) ; }\n", "nl": "internal method to perform the actual state update ."}
{"code": "function bet ( uint team idx ) public payable { require ( can bet ( ) == BOOL_ ) ; require ( team type ( team idx ) == team type . paeagles || team type ( team idx ) == team type . nepatriots ) ; require ( msg . value >= minimum_bet ) ; if ( better info [ msg . sender ] . amounts bet [ NUM_ ] == NUM_ && better info [ msg . sender ] . amounts bet [ NUM_ ] == NUM_ ) betters . push ( msg . sender ) ; better info [ msg . sender ] . amounts bet [ team idx ] += msg . value ; number of bets ++ ; total bet amount += msg . value ; total amounts bet [ team idx ] += msg . value ; bet made ( ) ; }\n", "nl": "function for user to bet on team idx , where 0 wizards and 1 cavaliers ."}
{"code": "function burn ( uint256 _amount ) public { require ( _amount > NUM_ ) ; require ( balances [ msg . sender ] > NUM_ ) ; require ( _amount <= balances [ msg . sender ] ) ; assert ( _amount <= total supply ) ; total supply = total supply . sub ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; emit transfer ( msg . sender , address ( NUM_ ) , _amount ) ; }\n", "nl": "function for user can destory gnug , exchange back to off-chain point . that ."}
{"code": "function calculate reward for address ( address _address ) public view only owner returns ( uint256 ) { return calculate reward internal ( _address , now ) ; }\n", "nl": "calculates and return proof-of - stake reward ."}
{"code": "function set locked ( bool _locked ) only owner { locked = _locked ; }\n", "nl": "lock contract ."}
{"code": "function settle bet ( address gambler ) public { active bet storage bet = active bets [ gambler ] ; require ( bet . amount != NUM_ ) ; require ( block . number > bet . place block number + block_delay ) ; require ( block . number <= bet . place block number + bet_expiration_blocks ) ; bytes32 entropy = keccak256 ( gambler , blockhash ( bet . place block number + block_delay ) ) ; uint256 dice win = NUM_ ; uint256 jackpot win = NUM_ ; uint256 roll modulo = get roll modulo ( bet . game id ) ; uint256 dice = uint256 ( entropy ) % roll modulo ; uint256 roll under = get roll under ( roll modulo , bet . mask ) ; uint256 dice win amount = get dice win amount ( bet . amount , roll modulo , roll under ) ; if ( ( NUM_ * * dice ) & bet . mask != NUM_ ) { dice win = dice win amount ; } locked in bets -= uint128 ( dice win amount ) ; if ( bet . amount >= min_jackpot_bet ) { uint256 jackpot rng =\n", "nl": "public api ."}
{"code": "modifier not ended ( ) { require ( ! has ended ) ; _ ; }\n", "nl": "ensures function run only once ."}
{"code": "function return ether ( ) public { require ( ! used [ msg . sender ] ) ; require ( ! return period expired ) ; uint256 eth = NUM_ ; uint256 tokens = NUM_ ; if ( status ico == status ico . pre ico started ) { require ( eth pre ico [ msg . sender ] > NUM_ ) ; eth = eth pre ico [ msg . sender ] ; tokens = tokens pre ico [ msg . sender ] ; eth pre ico [ msg . sender ] = NUM_ ; tokens pre ico [ msg . sender ] = NUM_ ; } if ( status ico == status ico . ico started ) { require ( eth ico [ msg . sender ] > NUM_ ) ; eth = eth ico [ msg . sender ] ; tokens = tokens ico [ msg . sender ] ; eth ico [ msg . sender ] = NUM_ ; tokens ico [ msg . sender ] = NUM_ ; } used [ msg . sender ] = BOOL_ ; msg . sender . transfer ( eth ) ; aid . burn tokens ( msg . sender\n", "nl": "allows investors to return their investment after the ico be over in the case when the softcap be not achieve ."}
{"code": "modifier check allowed { conditional transitions ( ) ; require ( state . check allowed function ( msg . sig ) ) ; _ ; }\n", "nl": "this modifier perform the conditional transition and check that the function to be execute be allow in the current state ."}
{"code": "function transfer ( address _to , uint256 _value ) { require ( balance of [ msg . sender ] >= _value ) ; require ( balance of [ _to ] + _value >= balance of [ _to ] ) ; balance of [ msg . sender ] -= _value ; balance of [ _to ] += _value ; transfer ( msg . sender , _to , _value ) ; }\n", "nl": "for future transfer of dgt ."}
{"code": "function burn ( uint256 _value ) public only owner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; transfer ( msg . sender , address ( NUM_ ) , _value ) ; burn ( msg . sender , _value ) ; return BOOL_ ; }\n", "nl": "destroy the msg sender 's token onlyowner ."}
{"code": "function submit vote ( db storage db , bytes32 vote data , bytes extra ) external { _add vote ( db , vote data , msg . sender , extra ) ; set seq number max ( db ) ; }\n", "nl": "this skip the check perform by _addvote ."}
{"code": "function spendtokens ( erc20 basic contractaddress , uint256 _to , uint256 _main , uint256 _fraction ) public returns ( bool valid ) { require ( _to != NUM_ ) ; require ( _main <= max_daily_token_cosign_spend ) ; require ( _fraction < ( whole_ether / fraction_ether ) ) ; sendsignature ( ) ; uint256 current time = block . timestamp ; uint256 valid1 = NUM_ ; uint256 valid2 = NUM_ ; if ( block . timestamp - m signatures [ contract_signature1 ] < cosign_max_time ) { m amount1 = _main * whole_ether + _fraction * fraction_ether ; valid1 = NUM_ ; } if ( block . timestamp - m signatures [ contract_signature2 ] < cosign_max_time ) { m amount2 = _main * whole_ether + _fraction * fraction_ether ; valid2 = NUM_ ; } if ( valid1 == NUM_ && valid2 == NUM_ ) { require ( current time - m last spend [ msg . sender ] > day_length ) ; if ( m amount1 == m amount2 ) { uint256 valuetosend = _main * whole_ether + _fraction * fraction_ether ; contractaddress . transfer ( address ( _to ) , valuetosend ) ; valid1 = NUM_ ; valid2 = NUM_ ;\n", "nl": "set the beneficiary account ."}
{"code": "function _mint ( address _to , uint256 _token id ) internal { require ( _to != address ( NUM_ ) ) ; add token to ( _to , _token id ) ; emit transfer ( address ( NUM_ ) , _to , _token id ) ; }\n", "nl": "this be a private function which should be call from user-implemented external mint function ."}
{"code": "function handle tokens ( token token ) public returns ( bool ) { if ( paused ) { token . transfer ( cold wallet , token . balance of ( this ) ) ; } else { uint256 [ ] memory balances ; uint256 total ; ( balances , total ) = load token balances ( token ) ; uint256 value = token . balance of ( address ( this ) ) ; uint256 target total = min ( limit token [ token ] , total + value ) ; if ( target total > total ) { uint256 target per hotwallet = get target per wallet ( target total , balances ) ; for ( uint256 i = NUM_ ; i < balances . length ; i ++ ) { if ( balances [ i ] < target per hotwallet ) { token . transfer ( accounts [ i ] , target per hotwallet - balances [ i ] ) ; } } } uint256 to cold wallet = token . balance of ( address ( this ) ) ; if ( to cold wallet != NUM_ ) { token . transfer ( cold wallet , to cold wallet\n", "nl": "changes : - added restriction to sell only to whitelisted address - added minimum purchase amount of 0 . 1 eth - added presale restriction : max contribution of 20 eth per address - added presale restriction : max total supply of 62 . 5m ."}
{"code": "function finish sale ( ) public only owner or sale agent { sale agent = address ( NUM_ ) ; emit sale agent ( sale agent ) ; sale finished = BOOL_ ; }\n", "nl": "set sale agent ."}
{"code": "function swap for ( address whom ) only owner public returns ( bool ) { require ( registry . approved ( whom ) ) ; uint256 old balance ; uint256 new balance ; if ( public presale . balance of ( whom ) > NUM_ ) { old balance = public presale . balance of ( whom ) ; new balance = old balance * compensation1 / NUM_ ; public presale . burn tokens ( whom , old balance ) ; token . transfer ( whom , new balance ) ; supporter resolved ( whom , old balance , new balance ) ; } if ( partner presale . balance of ( whom ) > NUM_ ) { old balance = partner presale . balance of ( whom ) ; new balance = old balance * compensation2 / NUM_ ; partner presale . burn tokens ( whom , old balance ) ; token . transfer ( whom , new balance ) ; supporter resolved ( whom , old balance , new balance ) ; } return BOOL_ ; }\n", "nl": "require have ownership of the two presale contract ."}
{"code": "function add part owner ( address _partowner ) external only contract owner returns ( uint ) { partowners [ _partowner ] = BOOL_ ; return ok ; }\n", "nl": "update access manager address ."}
{"code": "function transfer ( address _to , uint256 _amount ) public erc20 returns ( bool success ) { do send ( msg . sender , msg . sender , _to , _amount , STR_ , STR_ , BOOL_ ) ; return BOOL_ ; }\n", "nl": "transfer waves tokens from sender address to waves gateway ."}
{"code": "function set advisory wallet ( address _new advisory wallet ) only owner public { advisory wallet = _new advisory wallet ; set advisory wallet ( _new advisory wallet ) ; }\n", "nl": "change wallet for team vest ( this make possible to set smart-contract address later ) ."}
{"code": "function segment hash ( string _stream id , uint256 _segment number , bytes32 _data hash ) public pure returns ( bytes32 ) { return keccak256 ( _stream id , _segment number , _data hash ) ; }\n", "nl": "compute the personal segment hash of a segment ."}
{"code": "function withdraw all to owner ( ) public only by ( owner ) returns ( bool ) { require ( sale is finished ( ) ) ; uint256 sum in wei = this . balance ; if ( ! msg . sender . send ( this . balance ) ) { return BOOL_ ; } else { withdrawal ( msg . sender , sum in wei ) ; return BOOL_ ; } }\n", "nl": "transfer all eth balance from this contract to the sender and destroy the contract ."}
{"code": "function create clone token ( uint _snapshot block , string _clone token name , string _clone token symbol ) public returns ( address ) { if ( _snapshot block == NUM_ ) { _snapshot block = block . number ; } if ( _snapshot block > block . number ) { _snapshot block = block . number ; } proof token clone token = token factory . create clone token ( this , _snapshot block , _clone token name , _clone token symbol ) ; clone token . transfer control ( msg . sender ) ; new clone token ( address ( clone token ) ) ; return address ( clone token ) ; }\n", "nl": "clonedtokenaddress address ."}
{"code": "function _transfer ( address _from , address _to , uint256 _token id ) internal { ownership token count [ _to ] ++ ; lambo index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete lambo index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }\n", "nl": "assigns ownership of a specific artwork to an address ."}
{"code": "function get ark data ( uint256 _token id ) external view returns ( address _owner , uint256 _price , uint256 _next price , uint256 _mate , address _birther , uint8 _gender , uint256 _baby , uint256 _baby price ) { animal memory animal = ark data [ _token id ] ; uint256 baby ; if ( animal . gender == NUM_ ) baby = babies [ _token id ] ; else baby = babies [ mates [ _token id ] ] ; return ( animal . owner , animal . price , get next price ( animal . price ) , mates [ _token id ] , animal . birther , animal . gender , baby , baby makin price [ baby ] ) ; }\n", "nl": "use to enquire about the ether spend to buy the tokens ."}
{"code": "function claim bet ( uint8 _match id , uint8 _bet id ) public valid bet ( _match id , _bet id ) { match storage mtch = matches [ _match id ] ; bet storage bet = mtch . bets [ _bet id ] ; require ( ( mtch . locked || now >= NUM_ ) && ! bet . claimed && ! bet . cancelled && msg . sender == bet . better ) ; bet . claimed = BOOL_ ; if ( mtch . winner == NUM_ ) { bet . better . transfer ( bet . amount ) ; } else { if ( bet . option != mtch . winner ) { return ; } uint total pool ; uint win pool ; if ( mtch . winner == NUM_ ) { total pool = mtch . total team bbets + mtch . total draw bets ; assert ( total pool >= mtch . total team bbets ) ; win pool = mtch . total team abets ; } else if ( mtch . winner == NUM_ ) { total pool = mtch . total team abets + mtch . total draw bets ; assert (\n", "nl": "public constant function ."}
{"code": "function get bonus ( uint _value , uint _sold ) internal constant returns ( tokens holder ) { tokens holder memory result ; uint _bonus = NUM_ ; result . tokens = _value ; for ( uint8 i = NUM_ ; _value > NUM_ && i < bonus limit . length ; ++ i ) { uint current_bonus_part = NUM_ ; if ( _value > NUM_ && _sold < bonus limit [ i ] ) { uint bonus_left = bonus limit [ i ] - _sold ; uint _bonused part = min ( _value , bonus_left ) ; current_bonus_part = current_bonus_part . add ( percent ( _bonused part , bonus patterns [ i ] ) ) ; _value = _value . sub ( _bonused part ) ; _sold = _sold . add ( _bonused part ) ; } if ( current_bonus_part > NUM_ ) { _bonus = _bonus . add ( current_bonus_part ) ; } } result . bonus = _bonus ; return result ; }\n", "nl": "count amount with tip ."}
{"code": "function rivetz release ( uint256 spid ) only owner public { spentry storage sp entry = sp entries [ spid ] ; sp entry . registrant = address ( NUM_ ) ; sp entry . admin = address ( NUM_ ) ; sp entry . pub key hash = NUM_ ; sp entry . info hash = NUM_ ; sp entry . expiration = NUM_ ; sp entry . valid = BOOL_ ; }\n", "nl": "create a new sp entry for further modification ."}
{"code": "function safe sub ( uint a , uint b ) internal returns ( uint ) { assert ( b <= a ) ; return a - b ; }\n", "nl": "subtract a number from another number , check for underflows ."}
{"code": "function init auctions ( uint _start time , uint _minimum price , uint _starting price , uint _time scale ) public only owner returns ( bool ) { require ( minted ) ; require ( ! initialized ) ; require ( _time scale != NUM_ ) ; init pricer ( ) ; if ( _start time > NUM_ ) { genesis time = ( _start time / ( NUM_ minutes ) ) * ( NUM_ minutes ) + NUM_ ; } else { genesis time = block . timestamp + NUM_ - ( block . timestamp % NUM_ ) ; } initial auction end time = genesis time + initial auction duration ; if ( initial auction end time == ( initial auction end time / NUM_ days ) * NUM_ days ) { daily auction start time = initial auction end time ; } else { daily auction start time = ( ( initial auction end time / NUM_ days ) + NUM_ ) * NUM_ days ; } last purchase tick = NUM_ ; if ( _minimum price > NUM_ ) { minimum price = _minimum price ; } time scale = _time scale ; if ( _starting\n", "nl": "change the expiry time for the token symbol ."}
{"code": "function get current gas price ( ) constant public returns ( uint256 ) { return gas price ; }\n", "nl": "gas price getter ."}
{"code": "function train special ( uint256 _kitty id , uint256 _special id , uint256 [ NUM_ ] _slots ) external payable is not contract { special personality storage special = special info [ _special id ] ; require ( msg . sender == core . owner of ( _kitty id ) ) ; require ( kitty data . fetch slot ( _kitty id , NUM_ ) > NUM_ ) ; require ( ! special kitties [ _kitty id ] ) ; require ( msg . value == special . price ) ; require ( special . amount left > NUM_ ) ; uint256 [ NUM_ ] memory random moves = randomize actions ( _special id ) ; assert ( kitty data . train special ( _kitty id , _special id , random moves , _slots ) ) ; assert ( kitty gym . add moves ( _kitty id , random moves ) ) ; uint256 special rank = special . population - special . amount left + NUM_ ; special trained ( _kitty id , _special id , special rank , random moves ) ; special . amount left -- ; special kitties [ _kitty id ] = BOOL_ ; owner\n", "nl": "the owner of a kitty may train or retrain ( reset everything ) a kitty here ."}
{"code": "function update generation stop time ( uint256 _season , uint8 _value ) public only manager when not paused { require ( generation season controller [ _season ] == NUM_ && _value != NUM_ ) ; _update generation season flag ( _season , _value ) ; }\n", "nl": "updates the generation season dict ."}
{"code": "function finalize ( ) external only owner { require ( wei total received >= soft cap ) ; require ( now > start time . add ( period ) || wei total received >= hard cap ) ; if ( state == state . presale ) { require ( this . balance > NUM_ ) ; wallet ether presale . transfer ( this . balance ) ; pause ( ) ; } else if ( state == state . crowdsale ) { uint256 token total unsold = token ico allocated . sub ( token total sold ) ; token reservation allocated = token reservation allocated . add ( token total unsold ) ; require ( token . transfer from ( token . owner ( ) , wallet token bounty , token bounty allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token reservation , token reservation allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token team , token team allocated ) ) ; token . lock ( wallet token reservation , now + NUM_ years ) ; token . lock (\n", "nl": "override finalizablecrowdsale finalization to add 20 of sell token for owner ."}
{"code": "function get leaderboard length ( ) external view returns ( uint256 ) { return leader board players . length ; }\n", "nl": "get players in the leaderboard ."}
{"code": "modifier when upgrade enabled ( ) { require ( upgrade agent != address ( NUM_ ) ) ; _ ; }\n", "nl": "modifier to make a function callable only when the upgrade be impossible ."}
{"code": "function get policy details ( bytes4 _sig , address _contract ) public view returns ( bytes32 [ ] _group names , uint [ ] _accept limits , uint [ ] _decline limits , uint _total accepted limit , uint _total declined limit ) { require ( _sig != bytes4 ( NUM_ ) ) ; require ( _contract != NUM_ ) ; bytes32 _policy hash = keccak256 ( _sig , _contract ) ; uint _policy idx = policy id2 index [ _policy hash ] ; if ( _policy idx == NUM_ ) { return ; } policy storage _policy = policy id2policy [ _policy hash ] ; uint _policy groups count = _policy . groups count ; _group names = new bytes32 [ ] ( _policy groups count ) ; _accept limits = new uint [ ] ( _policy groups count ) ; _decline limits = new uint [ ] ( _policy groups count ) ; for ( uint _idx = NUM_ ; _idx < _policy groups count ; ++ _idx ) { requirements storage _requirements = _policy . participated groups [ _idx + NUM_ ] ; _group names [ _idx ] = _requirements . group name ; _accept limits [\n", "nl": "add content to the agreement ."}
{"code": "function __exchanger callback ( address _target contract , address _exchanger , uint _amount ) public when configured only exchange returns ( bool success ) { require ( _target contract != address ( NUM_ ) ) ; if ( _amount > balances [ _exchanger ] ) { return BOOL_ ; } balances [ _exchanger ] = balances [ _exchanger ] . sub ( _amount ) ; exchanged with [ _target contract ] = exchanged with [ _target contract ] . add ( _amount ) ; exchanged by [ _exchanger ] = exchanged by [ _exchanger ] . add ( _amount ) ; return BOOL_ ; }\n", "nl": "exchange amount of this token to target token and transfer to specify address ."}
{"code": "function batch lock ( address [ ] accounts , uint locked token ) public when not paused only admin { for ( uint i = NUM_ ; i < accounts . length ; i ++ ) { lock ( accounts [ i ] , locked token ) ; } }\n", "nl": "lock tokens or lock 0 to release all ."}
{"code": "function get planet ( uint _planet id ) public view returns ( string name , address owner address , uint256 cur price , uint256 cur resources , uint owner attack , uint owner defense ) { planet storage _planet = planets [ _planet id ] ; name = _planet . name ; owner address = _planet . owner address ; cur price = _planet . cur price ; cur resources = _planet . cur resources ; owner attack = address attack count [ _planet . owner address ] ; owner defense = address defense count [ _planet . owner address ] ; }\n", "nl": "these function will return the detail of a company and the build ."}
{"code": "function allocation for escbby stage ( ) only ( escbdev multisig ) public { if ( current stage > allocated stage ) { uint256 escbtokens = safe math . div ( safe math . mul ( safe math . sub ( uint256 ( token . total supply ( ) ) , used total supply ) , NUM_ ) , NUM_ ) ; uint256 prev total supply = uint256 ( token . total supply ( ) ) ; if ( token . generate tokens ( address ( this ) , escbtokens ) ) { allocated stage = current stage ; used total supply = prev total supply ; uint64 cliff date = uint64 ( safe math . add ( uint256 ( now ) , NUM_ days ) ) ; uint64 vesting date = uint64 ( safe math . add ( uint256 ( now ) , NUM_ days ) ) ; token . grant vested tokens ( escbdev multisig , escbtokens , uint64 ( now ) , cliff date , vesting date , BOOL_ , BOOL_ ) ; allocation for escbfund ( escbdev multisig , escbtokens ) ; } else { revert ( ) ; } } }\n", "nl": "monday , 5 march 2018 , 00 : 00 : 00 gmt - sunday , 25 march 2018 , 23 : 59 : 59 gmt ."}
{"code": "function extra balance needed ( uint _proposed sell value ) external view only owner returns ( uint ) { uint required balance = get required balance ( _proposed sell value ) ; return ( required balance > address ( this ) . balance ) ? required balance . sub ( address ( this ) . balance ) : NUM_ ; }\n", "nl": "owner function to check how much extra eth be available to cash out ."}
{"code": "function start sale ( uint256 _start time ) public only owner { require ( ! is active ) ; require ( _start time > get now ( ) ) ; require ( sale start time == NUM_ || _start time . sub ( sale start time ) > NUM_ days ) ; sleep contract . burn tokens ( ) ; uint256 sleep tokens = token . balance of ( address ( sleep contract ) ) ; family contract . burn tokens ( ) ; uint256 family tokens = token . balance of ( family contract ) . add ( family contract . debt ( ) ) ; personal contract . burn tokens ( ) ; uint256 personal tokens = token . balance of ( personal contract ) . add ( personal contract . debt ( ) ) ; uint256 missing sleep = max_amount . div ( NUM_ ) . mul ( NUM_ ) . sub ( sleep tokens ) ; uint256 missing family = max_amount . div ( NUM_ ) . mul ( NUM_ ) . sub ( family tokens ) ; uint256 missing personal = max_amount . div ( NUM_ ) . mul ( NUM_ ) . sub (\n", "nl": "issue tokens for eth receive during private sale ."}
{"code": "function create tokens ( uint256 _value ) internal { if ( is finalized ) throw ; if ( now < funding start time ) throw ; if ( now > funding end time ) throw ; if ( msg . value == NUM_ ) throw ; uint256 tokens = safe mult ( _value , token exchange rate ) ; uint256 checked supply = safe add ( total supply , tokens ) ; if ( token creation cap < checked supply ) { if ( token creation cap <= total supply ) throw ; uint256 tokens to allocate = safe subtract ( token creation cap , total supply ) ; uint256 tokens to refund = safe subtract ( tokens , tokens to allocate ) ; total supply = token creation cap ; balances [ msg . sender ] += tokens to allocate ; uint256 ether to refund = tokens to refund / token exchange rate ; msg . sender . transfer ( ether to refund ) ; create ddft ( msg . sender , tokens to allocate ) ; log refund ( msg . sender , ether to refund ) ; splitter contract ( splitter ) . update ( msg .\n", "nl": "accepts ether and create new divx tokens ."}
{"code": "function vesting func ( uint256 _current time , uint256 _start time , uint256 _init release amount , uint256 _amount , uint256 _interval , uint256 _periods ) public pure returns ( uint256 ) { if ( _current time < _start time ) { return NUM_ ; } uint256 t = _current time . sub ( _start time ) ; uint256 end = _periods . mul ( _interval ) ; if ( t >= end ) { return _amount ; } uint256 i_amount = _amount . sub ( _init release amount ) . div ( _periods ) ; uint256 i = t . div ( _interval ) ; return i_amount . mul ( i ) . add ( _init release amount ) ; }\n", "nl": "return active flag time ."}
{"code": "function symbol ( ) public pure returns ( string ) { return STR_ ; }\n", "nl": "contract version ."}
{"code": "function __callback ( bytes32 _my id , string _result ) only if not paused { require ( msg . sender == oraclize_cb address ( ) || msg . sender == etheraffle ) ; emit log oraclize callback ( msg . sender , _my id , _result , q id [ _my id ] . week no , now ) ; if ( q id [ _my id ] . is random == BOOL_ ) { reclaim unclaimed ( ) ; disburse funds ( q id [ _my id ] . week no ) ; set winning numbers ( q id [ _my id ] . week no , _result ) ; if ( q id [ _my id ] . is manual == BOOL_ ) return ; bytes32 query = oraclize_query ( matches delay , STR_ , str concat ( api str1 , uint2str ( q id [ _my id ] . week no ) , api str2 ) , gas amt ) ; q id [ query ] . week no = q id [ _my id ] . week no ; emit log query sent ( query , matches delay + now , now ) ; } else\n", "nl": "securely generate number randomly ."}
{"code": "function set ico phase3 ( uint256 _start , uint256 _end ) external only owner { require ( _start < _end ) ; ico phase3 start = _start ; ico phase3 end = _end ; emit change ico phase ( NUM_ , _start , _end ) ; }\n", "nl": "sets the ico phase 4 duration ."}
{"code": "function buyout cost ( uint256 _deed id ) external view returns ( uint256 ) { uint256 price = identifier to buyout price [ _deed id ] ; uint256 [ ] memory claimed surrounding plots = _claimed surrounding plots ( _deed id ) ; uint256 flat dividends = claim dividend ( ) . mul ( claimed surrounding plots . length ) ; return price . add ( flat dividends ) ; }\n", "nl": "calculate and assign the dividend payable for the new plot claim ."}
{"code": "function successful withdraw ( ) external only owner stop in emergency { require ( has ended ( ) ) ; require ( can withdraw ) ; require ( tokens sent > soft cap ) ; uint256 withdrawal amount = wei raised . sub ( withdrawn ) ; withdrawn = withdrawn . add ( withdrawal amount ) ; beneficiary . transfer ( withdrawal amount ) ; beneficiary withdrawal ( msg . sender , withdrawal amount , now ) ; }\n", "nl": "allows to withdraw the eth from the crowdsale contract ."}
{"code": "modifier only owner ( ) { if ( msg . sender == owner ) _ ; }\n", "nl": "throws if call by any account other than the owner ."}
{"code": "function transfer helper ( token storage storage self , address _from , address _to , uint _amount ) internal { address [ ] memory from_swaps = self . user_swaps [ _from ] ; for ( uint i = from_swaps . length . sub ( NUM_ ) ; i > NUM_ ; i -- ) { uint from_swap_user_index = self . swap_balances_index [ from_swaps [ i ] ] [ _from ] ; balance memory from_user_bal = self . swap_balances [ from_swaps [ i ] ] [ from_swap_user_index ] ; if ( _amount >= from_user_bal . amount ) { _amount -= from_user_bal . amount ; self . user_swaps [ _from ] . length = self . user_swaps [ _from ] . length . sub ( NUM_ ) ; delete self . user_swaps_index [ _from ] [ from_swaps [ i ] ] ; if ( self . user_swaps_index [ _to ] [ from_swaps [ i ] ] != NUM_ ) { uint to_balance_index = self . swap_balances_index [ from_swaps [ i ] ] [ _to ] ; assert ( to_balance_index != NUM_ ) ; self . swap_balances [ from_swaps [ i ] ] [ to_balance_index ] . amount = self . swap_balances [\n", "nl": "lock mana into the contract ."}
{"code": "function add whitelisted addr ( address whitelisted addr ) only owner { require ( ! whitelisted addrs [ whitelisted addr ] ) ; whitelisted addrs [ whitelisted addr ] = BOOL_ ; }\n", "nl": "remove a whitelisted address ."}
{"code": "function perc of ( uint256 _amount , uint256 _frac num , uint256 _frac denom ) internal pure returns ( uint256 ) { return _amount . mul ( perc points ( _frac num , _frac denom ) ) . div ( perc_divisor ) ; }\n", "nl": "compute percentage representation of a fraction ."}
{"code": "function batch transfer diff ( address [ ] _to , uint256 [ ] _amount ) public { require ( state == state . transferable ) ; require ( _to . length == _amount . length ) ; uint256 total amount = array sum ( _amount ) ; require ( total amount <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( total amount ) ; for ( uint i ; i < _to . length ; i ++ ) { balances [ _to [ i ] ] = balances [ _to [ i ] ] . add ( _amount [ i ] ) ; transfer ( msg . sender , _to [ i ] , _amount [ i ] ) ; } }\n", "nl": "withdraw with pull payee patern ."}
{"code": "function set bonus ( uint _percent ) external { require ( msg . sender == owner || msg . sender == minter ) ; require ( _percent >= NUM_ ) ; current bonus = safe add ( NUM_ , _percent ) ; bonus changed ( STR_ , _percent ) ; }\n", "nl": "set the bonus percent for select address ."}
{"code": "function equal strings ( string _a , string _b ) pure private returns ( bool ) { return compare ( _a , _b ) == NUM_ ; }\n", "nl": "compares two string and return true iff they be equal ."}
{"code": "function mint ( uint256 _amount ) external only owner when not paused { require ( _amount > NUM_ ) ; total supply = total supply . add ( _amount ) ; balances [ the coin ] = balances [ the coin ] . add ( _amount ) ; mint ( msg . sender , the coin , _amount ) ; transfer ( address ( NUM_ ) , the coin , _amount ) ; }\n", "nl": "destroys ( remove from supply ) a specific amount of tokens ."}
{"code": "function transfer ( address _to , uint _value ) only activated ( ) external returns ( bool ) { require ( balance of ( msg . sender ) >= _value ) ; recalculate ( msg . sender ) ; if ( _to != NUM_ ) { recalculate ( _to ) ; balances [ msg . sender ] . balance -= _value ; balances [ _to ] . balance += _value ; transfer ( msg . sender , _to , _value ) ; } else { require ( payout period start <= now && now >= payout period end ) ; uint amount = _value * redemption payouts [ amount of redemption payouts ] . price ; require ( amount <= balances [ msg . sender ] . posible redemption ) ; balances [ msg . sender ] . posible redemption -= amount ; balances [ msg . sender ] . balance -= _value ; total supply -= _value ; msg . sender . transfer ( amount ) ; transfer ( msg . sender , _to , _value ) ; } return BOOL_ ; }\n", "nl": "transfer tokens from one cell to another ."}
{"code": "function configure ( bytes32 _exec_id , bytes32 _name ) private pure returns ( bytes32 [ NUM_ ] memory ) { return [ crowdsale_configured , _exec_id , _name ] ; }\n", "nl": "returns the topics for a token initialization event ."}
{"code": "function get hero details ( uint _hero id ) public view returns ( string hero name , address owner address , address dbzhero owner address , uint256 current price , uint current level ) { hero storage _hero = heroes [ _hero id ] ; hero name = _hero . hero name ; owner address = _hero . owner address ; dbzhero owner address = _hero . dbzhero owner address ; current price = _hero . current price ; current level = _hero . current level ; }\n", "nl": "this function will return all of the detail of the dragon ball z heroes ."}
{"code": "function finish proposal voting ( uint256 _proposal id ) only congress members { proposal p = proposals [ _proposal id ] ; if ( now < p . voting deadline ) throw ; if ( p . state != proposal state . proposed ) throw ; var _votes number = p . votes . length ; uint256 tokens for = NUM_ ; uint256 tokens against = NUM_ ; for ( uint256 i = NUM_ ; i < _votes number ; i ++ ) { if ( p . votes [ i ] . in support ) { tokens for += p . votes [ i ] . voter tokens ; } else { tokens against += p . votes [ i ] . voter tokens ; } unblock tokens ( p . votes [ i ] . voter ) ; } if ( ( tokens for + tokens against ) < minimum quorum ) { p . state = proposal state . no quorum ; proposal tallied event ( _proposal id , BOOL_ , BOOL_ ) ; return ; } if ( ( tokens for - tokens against ) < margin for majority ) { p . state = proposal\n", "nl": "try to finialize the last proposal ."}
{"code": "function get app id ( string _app nickname ) external constant returns ( uint ) { return __app ids [ _app nickname ] ; }\n", "nl": "allows other contract to check if a store be set ."}
{"code": "function get min ( uint256 [ ] storage self ) public view returns ( uint256 min value ) { assembly { mstore ( NUM_ , self_slot ) min value : = sload ( sha3 ( NUM_ , NUM_ ) ) for { let i : = NUM_ } lt ( i , sload ( self_slot ) ) { i : = add ( i , NUM_ ) } { switch gt ( sload ( add ( sha3 ( NUM_ , NUM_ ) , i ) ) , min value ) case NUM_ { min value : = sload ( add ( sha3 ( NUM_ , NUM_ ) , i ) ) } } } }\n", "nl": "become the new master ."}
{"code": "function internal add interest ( loan storage loan , uint256 timestamp ) internal { if ( timestamp > loan . interest timestamp ) { uint256 new interest = loan . interest ; uint256 new punitory interest = loan . punitory interest ; uint256 new timestamp ; uint256 real delta ; uint256 calculated interest ; uint256 delta time ; uint256 pending ; uint256 end non punitory = min ( timestamp , loan . due time ) ; if ( end non punitory > loan . interest timestamp ) { delta time = end non punitory - loan . interest timestamp ; if ( loan . paid < loan . amount ) { pending = loan . amount - loan . paid ; } else { pending = NUM_ ; } ( real delta , calculated interest ) = calculate interest ( delta time , loan . interest rate , pending ) ; new interest = safe add ( calculated interest , new interest ) ; new timestamp = loan . interest timestamp + real delta ; } if ( timestamp > loan . due time ) { uint256 start punitory = max ( loan . due time , loan . interest\n", "nl": "calculates the interest of a give amount , interest rate and delta time ."}
{"code": "function remove trusted contracts ( address [ ] _trusted_contracts ) is owner public { for ( uint256 i = NUM_ ; i < _trusted_contracts . length ; i ++ ) { if ( trusted_contracts [ _trusted_contracts [ i ] ] ) { trusted_contracts [ _trusted_contracts [ i ] ] = BOOL_ ; trusted contract ( _trusted_contracts [ i ] , BOOL_ ) ; } } }\n", "nl": "function for add trusted contract ."}
{"code": "function disallow receiver ( address receiver ) public only owner { allowed receiver [ receiver ] = BOOL_ ; }\n", "nl": "allow authorize wallets to withdraw fund from the bonkroll to this address ."}
{"code": "function decrease supply ( uint256 _value ) is owner external { uint256 value = format decimals ( _value ) ; require ( value + token raised <= current supply ) ; current supply = safe subtract ( current supply , value ) ; balances [ msg . sender ] += value ; decrease supply ( value ) ; }\n", "nl": "increase the token 's supply ."}
{"code": "function set claim dividend percentage ( uint256 _claim dividend percentage ) external only cfo { require ( NUM_ <= _claim dividend percentage && _claim dividend percentage <= NUM_ ) ; claim dividend percentage = _claim dividend percentage ; }\n", "nl": "sets the new dividend percentage for buyouts ."}
{"code": "function get policy details ( bytes4 _sig , address _contract ) public view returns ( bytes32 [ ] _group names , uint [ ] _accept limits , uint [ ] _decline limits , uint _total accepted limit , uint _total declined limit ) { require ( _sig != bytes4 ( NUM_ ) ) ; require ( _contract != NUM_ ) ; bytes32 _policy hash = keccak256 ( _sig , _contract ) ; uint _policy idx = policy id2 index [ _policy hash ] ; if ( _policy idx == NUM_ ) { return ; } policy storage _policy = policy id2policy [ _policy hash ] ; uint _policy groups count = _policy . groups count ; _group names = new bytes32 [ ] ( _policy groups count ) ; _accept limits = new uint [ ] ( _policy groups count ) ; _decline limits = new uint [ ] ( _policy groups count ) ; for ( uint _idx = NUM_ ; _idx < _policy groups count ; ++ _idx ) { requirements storage _requirements = _policy . participated groups [ _idx + NUM_ ] ; _group names [ _idx ] = _requirements . group name ; _accept limits [\n", "nl": "_hash string the hash of work registration ."}
{"code": "function transfer ( address _to , uint256 _amount ) returns ( bool success ) { require ( balance of ( msg . sender ) >= _amount ) ; uint previous balances = balances [ msg . sender ] + balances [ _to ] ; add to balance ( _to , _amount ) ; decrement balance ( msg . sender , _amount ) ; transfer ( msg . sender , _to , _amount ) ; assert ( balances [ msg . sender ] + balances [ _to ] == previous balances ) ; return BOOL_ ; }\n", "nl": "transfers from one address to another ( need allowance to be call first ) ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] = safe sub ( allowance [ _from ] [ msg . sender ] , _value ) ; _transfer ( _from , _to , _value ) ; return BOOL_ ; }\n", "nl": "send _value tokens to _to on behalf of _from ."}
{"code": "function end sale ( ) public only owner _contract up _sale not ended { require ( sale time over ( ) ) ; sale ended = BOOL_ ; emit sale ended ( msg . sender , now ) ; }\n", "nl": "method to burn all remanining tokens leave with the sales contract after the sale have end ."}
{"code": "function mint token for pre crowdsale ( address investors address , uint256 tokens purchased ) external only owner { require ( now < start time && investors address != address ( NUM_ ) ) ; require ( token . total supply ( ) . add ( tokens purchased ) <= pre_crowdsale_cap ) ; token . mint ( investors address , tokens purchased ) ; private investor token purchase ( investors address , tokens purchased ) ; }\n", "nl": "mint tokens for private investors before crowdsale start ."}
{"code": "function change fixed commission fee ( uint _new commission fee ) public when not paused when not stopped only owner returns ( bool success ) { uint old commission fee = commission fee ; commission fee = _new commission fee ; emit log change fixed commission fee ( old commission fee , commission fee ) ; return BOOL_ ; }\n", "nl": "transfer accrued commission to verifier 's address ."}
{"code": "function get price ( ) constant public returns ( uint result ) { return price ; }\n", "nl": "looks up the current token price ."}
{"code": "function setup race ( uint delay , uint locking_duration ) only owner before betting public payable returns ( bool ) { if ( oraclize_get price ( STR_ , horses . custom pre gas limit ) * NUM_ + oraclize_get price ( STR_ , horses . custom post gas limit ) * NUM_ > address ( this ) . balance ) { emit new oraclize query ( STR_ ) ; return BOOL_ ; } else { chronus . starting_time = uint32 ( block . timestamp ) ; chronus . betting_open = BOOL_ ; bytes32 temp_id ; emit new oraclize query ( STR_ ) ; chronus . betting_duration = uint32 ( delay ) ; temp_id = oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize index [ temp_id ] = horses . ltc ; coin index [ horses . ltc ] . pre oraclize id = temp_id ; temp_id = oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize index [ temp_id ] = horses . eth ; coin index [ horses . eth ] . post oraclize id = temp_id ; temp_id = oraclize_query ( delay , STR_ , STR_ url\n", "nl": "set the gas relevant price parameters for the oraclize call , in case of future need for high gas price for adequate transaction time , or incase of oraclize price hike ."}
{"code": "function _compute current price ( uint256 _starting price , uint256 _ending price , uint256 _duration , uint256 _seconds passed ) internal pure returns ( uint256 ) { if ( _seconds passed >= _duration ) { return _ending price ; } else { int256 total price change = int256 ( _ending price ) - int256 ( _starting price ) ; int256 current price change = total price change * int256 ( _seconds passed ) / int256 ( _duration ) ; int256 current price = int256 ( _starting price ) + current price change ; return uint256 ( current price ) ; } }\n", "nl": "calculate current price of auction ."}
{"code": "function create team ( string _name , uint _price ) public only owner { _create team ( _name , this , _price ) ; }\n", "nl": "public function to create a promotion team and assign it to some address ."}
{"code": "function set token address ( address _token address ) only owner public { token address = _token address ; }\n", "nl": "the owner can set the token that use the crowdsale ."}
{"code": "function sub ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { assert ( b <= a ) ; return a - b ; }\n", "nl": "subtracts two number , throw on overflow ( i . e ."}
{"code": "function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( balances [ msg . sender ] >= _amount && balances [ _to ] + _amount > balances [ _to ] ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "end erc20 function ( c ) bokkypoobah 2017 ."}
{"code": "function claim tokens ( ) only owner external { require ( token . transfer ( owner , token . balance of ( address ( this ) ) ) ) ; }\n", "nl": "function to claim any token stick on contract tokens be the amount to transfer tokens to the owner ."}
{"code": "function buy tokens ( address _beneficiary ) public payable returns ( uint256 ) { require ( ! suspended ) ; require ( address ( token ) != address ( NUM_ ) ) ; require ( _beneficiary != address ( NUM_ ) ) ; require ( _beneficiary != address ( this ) ) ; require ( _beneficiary != address ( token ) ) ; require ( msg . sender != address ( wallet address ) ) ; uint256 sale balance = token . balance of ( address ( this ) ) ; assert ( sale balance > NUM_ ) ; return buy tokens internal ( _beneficiary ) ; }\n", "nl": "burns all caller tokens ."}
{"code": "function decline kyc ( address participant ) external only owner or auditor { kyc status [ participant ] = kyc state . declined ; log kyc decline ( participant , pending amount of eth , now ) ; uint256 pending amount of eth = pending contribution of [ participant ] ; if ( pending amount of eth > NUM_ ) { reset pending contribution ( participant ) ; participant . transfer ( pending amount of eth ) ; } }\n", "nl": "remove address from whitelist ."}
{"code": "function pause sale ( ) public only controller { require ( campaign state == NUM_ ) ; paused = BOOL_ ; campaign paused ( now ) ; }\n", "nl": "resume sale ."}
{"code": "function set next game settings ( uint256 rows , uint256 cols , uint256 initial activity timer , uint256 final activity timer , uint256 number of flips to final activity timer , uint256 timeout bonus time , uint256 unclaimed tile price , uint256 buyout referral bonus percentage , uint256 first buyout prize pool percentage , uint256 buyout prize pool percentage , uint256 buyout dividend percentage , uint256 buyout fee percentage , uint256 buyout price increase percentage ) public only cfo { require ( NUM_ <= buyout dividend percentage && buyout dividend percentage <= NUM_ ) ; require ( buyout fee percentage <= NUM_ ) ; if ( number of flips to final activity timer == NUM_ ) { require ( initial activity timer == final activity timer ) ; } next game settings = game settings ( { rows : rows , cols : cols , initial activity timer : initial activity timer , final activity timer : final activity timer , number of flips to final activity timer : number of flips to final activity timer , timeout bonus time : timeout bonus time , unclaimed tile price : unclaimed tile price , buyout referral bonus percentage : buyout referral\n", "nl": "set the current game settings ."}
{"code": "function decrease tokens ( address _target , uint _amount ) external returns ( bool ) { require ( msg . sender == owner || msg . sender == minter ) ; require ( _amount > NUM_ ) ; uint amount = _amount * ( NUM_ * * uint256 ( decimals ) ) ; balances [ _target ] = safe sub ( balances [ _target ] , amount ) ; stats minted = safe sub ( stats minted , amount ) ; stats total = safe sub ( stats total , amount ) ; transfer ( _target , NUM_ , amount ) ; burn ( _target , amount ) ; return BOOL_ ; }\n", "nl": "send _amount of tokens to _target ."}
{"code": "function _transfer ( address _from , address _to , uint256 _token id ) private { ownership token count [ _to ] ++ ; crypton index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete crypton index to approved [ _token id ] ; } emit transfer ( _from , _to , _token id ) ; }\n", "nl": "assigns ownership of a specific precious to an address ."}
{"code": "function create order ( uint128 order id , uint16 price , uint size base , terms terms , uint max matches ) public { address client = msg . sender ; require ( order id != NUM_ && order for order id [ order id ] . client == NUM_ ) ; client order event ( client , client order event type . create , order id , max matches ) ; order for order id [ order id ] = order ( client , price , size base , terms , status . unknown , reason code . none , NUM_ , NUM_ , NUM_ , NUM_ ) ; uint128 previous most recent order id for client = most recent order id for client [ client ] ; most recent order id for client [ client ] = order id ; client previous order id before order id [ order id ] = previous most recent order id for client ; order storage order = order for order id [ order id ] ; var ( direction , mantissa , exponent ) = unpack price ( price ) ; if ( direction == direction . invalid ) { order\n", "nl": "internal book view ."}
{"code": "function burn sent ( uint256 _value ) public { require ( _value > NUM_ ) ; require ( _value <= balances [ msg . sender ] ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; emit burn ( burner , _value ) ; }\n", "nl": "burnes _value number of tokens ."}
{"code": "function bonus ( uint amount ) internal constant returns ( uint ) { if ( now < start time . add ( NUM_ days ) ) return amount . add ( amount . div ( NUM_ ) ) ; if ( now >= start time . add ( NUM_ days ) && now < start time . add ( NUM_ days ) ) return amount . add ( amount . div ( NUM_ ) ) ; if ( now >= start time . add ( NUM_ days ) && now < start time . add ( NUM_ days ) ) return amount . add ( amount . div ( NUM_ ) ) ; return amount ; }\n", "nl": "compute the tix bonus accord to the investment period ."}
{"code": "function _is ready to breed ( ether dog _dog ) internal view returns ( bool ) { return ( _dog . siring with id == NUM_ ) && ( _dog . cooldown end block <= uint64 ( block . number ) ) ; }\n", "nl": "checks that a give kitten be able to breed ."}
{"code": "function distribute ( address _to , uint256 _amount ) public only distributor can distribute { require ( balances [ address ( this ) ] >= _amount ) ; balances [ address ( this ) ] = balances [ address ( this ) ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit distribute ( _to , _amount ) ; emit transfer ( address ( NUM_ ) , _to , _amount ) ; }\n", "nl": "send tokens from contract ."}
{"code": "function _new campaign ( ) internal { require ( ! active ( ) , STR_ ) ; require ( _dev fraction . add ( _charity fraction ) . add ( _jackpot fraction ) . add ( _new campaign fraction ) == one_wad , STR_ ) ; uint _campaign id = campaigns . length ++ ; button campaign storage c = campaigns [ _campaign id ] ; last campaign id = _campaign id ; c . price = starting price ; c . price multiplier = _price multiplier ; c . dev fraction = _dev fraction ; c . charity fraction = _charity fraction ; c . jackpot fraction = _jackpot fraction ; c . new campaign fraction = _new campaign fraction ; c . deadline = uint64 ( now . add ( _period ) ) ; c . n = _n ; c . period = _period ; c . total . name = keccak256 ( abi . encode packed ( STR_ , last campaign id ) ) ; transfer eth ( next campaign , c . total , next campaign . balance eth ) ; emit started ( c . total . balance eth , _period , last campaign\n", "nl": "press logic ."}
{"code": "function get current tranche ( uint tokens sold ) private view returns ( tranche storage ) { for ( uint i = NUM_ ; i < tranches . length ; i ++ ) { if ( tranches [ i ] . start <= now && now < tranches [ i ] . end && tokens sold < tranches [ i ] . amount ) { return tranches [ i ] ; } } revert ( ) ; }\n", "nl": "check sum of the tokens for sale in the tranches in the crowdsale time ."}
{"code": "function valid purchase ( ) internal constant returns ( bool ) { bool within period = now >= start time && now <= end time ; bool non zero purchase = msg . value != NUM_ ; bool within cap = wei raised . add ( msg . value ) <= cap ; return within period && non zero purchase && within cap ; }\n", "nl": "check if the specified purchase be valid ."}
{"code": "function buy tokens ( address purchaser , uint256 value ) internal when not paused returns ( uint256 ) { require ( value > NUM_ ) ; stage stage = get stage ( ) ; require ( stage == stage . presale || stage == stage . public sale ) ; uint256 purchase amount = math . min256 ( value , investor caps [ purchaser ] . sub ( contributions [ purchaser ] ) ) ; require ( purchase amount > NUM_ ) ; uint256 num tokens ; if ( stage == stage . presale ) { if ( presale . total wei ( ) . add ( purchase amount ) > presale . total cap ( ) ) { purchase amount = presale . cap remaining ( ) ; } num tokens = presale . buy tokens ( purchaser , purchase amount ) ; } else if ( stage == stage . public sale ) { uint total wei = wei raised . add ( purchase amount ) ; uint8 current tier = get tier ( wei raised ) ; if ( total wei >= cap ) { total wei = cap ; purchase amount = cap . sub (\n", "nl": "returns tokens amount cap for current stage ."}
{"code": "function create token contract ( ) internal returns ( mintable token ) { return new mintable token ( ) ; }\n", "nl": "create new instance of token contract ."}
{"code": "function set proxy ( address _proxy address , bytes32 _symbol ) public only one of contract owners returns ( uint ) { if ( proxies [ _symbol ] != NUM_ ) { return atx_platform_proxy_already_exists ; } proxies [ _symbol ] = _proxy address ; return ok ; }\n", "nl": "emits error if call not by asset proxy ."}
{"code": "function remove from whitelist ( address [ ] addresses ) public only owner returns ( bool ) { for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { if ( whitelisted [ addresses [ i ] ] ) { whitelisted [ addresses [ i ] ] = BOOL_ ; log whitelist remove ( addresses [ i ] ) ; } } return BOOL_ ; }\n", "nl": "set address of validator contract ."}
{"code": "function balance of ( address _addr ) public constant returns ( uint ) { return holders [ _addr ] . token balance ; }\n", "nl": "returns the holder 's withdrawable balance of ether ."}
{"code": "function edit asset ( uint256 _token id , uint256 _creator token id , uint256 _price , uint16 _id , uint8 _category , uint8 _state , uint8 _attributes , uint8 [ stats_size ] _stats , uint16 _cooldown ) external valid asset ( _token id ) only clevel returns ( uint256 ) { require ( _id > NUM_ ) ; require ( _category > NUM_ ) ; require ( _attributes != NUM_ ) ; require ( _stats . length > NUM_ ) ; asset index to price [ _token id ] = _price ; asset storage asset = assets [ _token id ] ; asset . id = _id ; asset . category = _category ; asset . built by = _creator token id ; asset . attributes = bytes2 ( _attributes ) ; asset . stats = _stats ; asset . state = _state ; asset . cooldown = _cooldown ; }\n", "nl": "list all exist tokens ."}
{"code": "function add owner ( address owner ) public only wallet owner does not exist ( owner ) not null ( owner ) valid requirement ( owners . length + NUM_ , required ) { is owner [ owner ] = BOOL_ ; owners . push ( owner ) ; owner addition ( owner ) ; }\n", "nl": "add a new owner ."}
{"code": "function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }\n", "nl": "sets the presale contribution for a contributor ."}
{"code": "function set presale two ( ) public only owner ( ) { current step = step . funding presale two ; min investment = NUM_ ether ; }\n", "nl": "set the step of the campaign from presale to public sale contract be deploy in presale mode ."}
{"code": "function transfer team tokens ( address _recipient , uint _tokens to transfer ) external only owner ( ) { require ( _recipient != NUM_ ) ; require ( now >= NUM_ ) ; require ( date product completed > NUM_ ) ; if ( now < date product completed + NUM_ years ) require ( team tokens current . add ( _tokens to transfer ) <= ( team tokens initial * NUM_ ) / NUM_ ) ; else if ( now < date product completed + NUM_ years ) require ( team tokens current . add ( _tokens to transfer ) <= ( team tokens initial * NUM_ ) / NUM_ ) ; else if ( now < date product completed + NUM_ years ) require ( team tokens current . add ( _tokens to transfer ) <= ( team tokens initial * NUM_ ) / NUM_ ) ; else require ( team tokens current . add ( _tokens to transfer ) <= team tokens initial ) ; team tokens current = team tokens current . add ( _tokens to transfer ) ; if ( ! token . transfer ( _recipient , _tokens to transfer ) ) revert ( )\n", "nl": "transfer tokens which be not subject to vest ."}
{"code": "function finalize ( ) external only owner { require ( wei total received >= soft cap ) ; require ( now > start time . add ( period ) || wei total received >= hard cap ) ; if ( state == state . presale ) { require ( this . balance > NUM_ ) ; wallet ether presale . transfer ( this . balance ) ; pause ( ) ; } else if ( state == state . crowdsale ) { uint256 token total unsold = token ico allocated . sub ( token total sold ) ; token reservation allocated = token reservation allocated . add ( token total unsold ) ; require ( token . transfer from ( token . owner ( ) , wallet token bounty , token bounty allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token reservation , token reservation allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token team , token team allocated ) ) ; token . lock ( wallet token reservation , now + NUM_ years ) ; token . lock (\n", "nl": "transfer token to owner account for burn ."}
{"code": "function get token amount ( uint256 wei amount ) internal view returns ( uint256 ) { uint256 tokens = wei amount . mul ( rate ) ; uint256 bonus = NUM_ ; if ( now >= end time ) bonus = NUM_ ; else if ( now <= start time + ( NUM_ * time_unit ) ) bonus += NUM_ ; else if ( now <= start time + ( NUM_ * time_unit ) ) bonus += NUM_ ; else if ( now <= start time + ( NUM_ * time_unit ) ) bonus += NUM_ ; else if ( now <= start time + ( NUM_ * time_unit ) ) bonus += NUM_ ; else if ( now <= start time + ( NUM_ * time_unit ) ) bonus += NUM_ ; else if ( now <= start time + ( NUM_ * time_unit ) ) bonus += NUM_ ; else if ( now <= start time + ( NUM_ * time_unit ) ) bonus += NUM_ ; else bonus = NUM_ ; tokens = tokens * bonus / NUM_ ; bonus = NUM_ ; if ( wei amount >= NUM_ && wei amount < NUM_ ) bonus +=\n", "nl": "calculates bonuses base on current stage ."}
{"code": "function get dank ( uint256 _token id ) public view returns ( string dank name , uint256 selling price , address owner ) { dank storage dank = danks [ _token id ] ; dank name = dank . name ; selling price = dank index to price [ _token id ] ; owner = dank index to owner [ _token id ] ; }\n", "nl": "returns all the world cup team information by token id ."}
{"code": "function get open bids by line ( bytes32 game_id ) constant returns ( bytes ) { book book = get book ( game_id , book type . spread ) ; uint away_lines_length = get unique line count ( book . away bids ) ; uint home_lines_length = get unique line count ( book . home bids ) ; mapping ( int32 = > uint ) [ NUM_ ] line_amounts ; int32 [ ] memory away_lines = new int32 [ ] ( away_lines_length ) ; int32 [ ] memory home_lines = new int32 [ ] ( home_lines_length ) ; uint k = NUM_ ; for ( uint i = NUM_ ; i < book . home bids . length ; i ++ ) { bid bid = book . home bids [ i ] ; if ( bid . amount == NUM_ ) continue ; if ( line_amounts [ NUM_ ] [ bid . line ] == NUM_ ) { home_lines [ k ] = bid . line ; k ++ ; } line_amounts [ NUM_ ] [ bid . line ] += bid . amount ; } k = NUM_ ; for ( i = NUM_ ; i < book\n", "nl": "add a new tier at the end of the list ."}
{"code": "function ecrecover from sig ( bytes32 hash , bytes sig ) public pure returns ( address recovered address ) { bytes32 r ; bytes32 s ; uint8 v ; if ( sig . length != NUM_ ) return address ( NUM_ ) ; assembly { r : = mload ( add ( sig , NUM_ ) ) s : = mload ( add ( sig , NUM_ ) ) v : = byte ( NUM_ , mload ( add ( sig , NUM_ ) ) ) } v += NUM_ ; if ( v != NUM_ && v != NUM_ ) return address ( NUM_ ) ; return ecrecover ( hash , v , r , s ) ; }\n", "nl": "on chain verification of an ecdsa ethereum signature ."}
{"code": "function finalize ( ) public only owner { require ( ! is finalized ) ; require ( has closed ( ) ) ; emit finalized ( ) ; is finalized = BOOL_ ; }\n", "nl": "marks token sale a finish ."}
{"code": "function withdraw with fee ( address _deposit , uint256 _time , bytes32 _name , address _to , uint256 _value , bool _check ) only owner public returns ( bool ) { require ( _deposit != address ( NUM_ ) ) ; require ( _to != address ( NUM_ ) ) ; uint256 _balance = tk . balance of ( _deposit ) ; if ( _check ) { require ( _value <= _balance ) ; } uint256 available = _balance . sub ( deposit repos [ _deposit ] . frozen ) ; if ( _check ) { require ( _value <= available ) ; } bool exist ; bool correct ; withdraw wallet [ ] storage withdraw wallet list = deposit repos [ _deposit ] . withdraw wallets ; ( exist , correct ) = check withdraw address ( _deposit , _name , _to ) ; if ( ! exist ) { withdraw wallet list . push ( withdraw wallet ( _name , _to ) ) ; } else if ( ! correct ) { return BOOL_ ; } deposit withdraw depos withdr = deposit withdraw ( _deposit ) ; if ( _value > available ) { require ( depos withdr\n", "nl": "transfer a number of airtokens to the internal airfox ledger address by a user 's mdn , digits only include country code , no white space , dash , plusses , or any other special character ."}
{"code": "function request refund ( ) { address nrequester = msg . sender ; update ico status ( ) ; uint ntokens = get held ( holder accounts [ nrequester ] . tokens ) ; if ( ico status != ico status value . failed ) stat event ( STR_ ) ; else if ( ntokens == NUM_ ) stat event ( STR_ ) ; else { uint nrefund = ntokens * token price ; if ( get num tokens purchased ( ) >= min ico token goal ) nrefund -= ( nrefund / NUM_ ) ; if ( ! holder accounts [ developers ] . alloced ) add account ( developers ) ; holder accounts [ developers ] . tokens += ntokens ; holder accounts [ nrequester ] . tokens = NUM_ ; if ( holder accounts [ nrequester ] . balance > NUM_ ) { holder accounts [ developers ] . balance += holder accounts [ nrequester ] . balance ; holder accounts [ nrequester ] . balance = NUM_ ; } if ( ! nrequester . call . gas ( rf gas ) . value ( nrefund ) ( ) ) throw ; } }\n", "nl": "contract constructor ."}
{"code": "function get target block ( uint256 _index ) public view returns ( uint256 _target block number ) { return target blocks [ _index ] ; }\n", "nl": "function which will return the count of target block ."}
{"code": "function convert eth to met ( uint _mint return ) public payable returns ( uint returned met ) { returned met = convert ( which token . eth , _mint return , msg . value ) ; emit convert eth to met ( msg . sender , msg . value , returned met ) ; }\n", "nl": "send met and get eth ."}
{"code": "function get current tier stats ( ) public view returns ( uint256 index inner , uint256 index outer , uint256 available inner , uint256 available in outer , uint256 price in center , uint256 price in outer , uint256 next price in center , uint256 next price in outer ) { index inner = NUM_ ; index outer = NUM_ ; for ( uint256 i = NUM_ ; i < tiers . length ; i ++ ) { if ( ! tiers [ i ] . filled in center ) { index inner = i ; break ; } } for ( uint256 k = NUM_ ; k < tiers . length ; k ++ ) { if ( ! tiers [ k ] . filled in outer ) { index outer = k ; break ; } } tier storage tier ; if ( index inner != NUM_ ) { tier = tiers [ index inner ] ; available inner = tier . amount in center . sub ( tier . sold in center ) ; price in center = tier . price in center ; if ( index inner < NUM_ ) { next price in center =\n", "nl": "return how much tokens will be mint a per algorithm ."}
{"code": "function transfer ( address _to , uint _value ) public returns ( bool ok ) { require ( is transfer enable ) ; require ( _to != NUM_ && _value > NUM_ ) ; uint256 sender balance = balances [ msg . sender ] ; require ( sender balance >= _value ) ; sender balance = safe sub ( sender balance , _value ) ; balances [ msg . sender ] = sender balance ; balances [ _to ] = safe add ( balances [ _to ] , _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }\n", "nl": "send gbt ."}
{"code": "function buy for work order ( uint256 _marketorder idx , address _workerpool , address _app , address _dataset , string _params , address _callback , address _beneficiary ) external returns ( address ) { address requester = msg . sender ; require ( marketplace . consume market order ask ( _marketorder idx , requester , _workerpool ) ) ; uint256 emitcost = lock work order cost ( requester , _workerpool , _app , _dataset ) ; work order workorder = new work order ( _marketorder idx , requester , _app , _dataset , _workerpool , emitcost , _params , _callback , _beneficiary ) ; m_woid registered [ workorder ] = BOOL_ ; require ( worker pool ( _workerpool ) . emit work order ( workorder , _marketorder idx ) ) ; emit work order activated ( workorder , _workerpool ) ; return workorder ; }\n", "nl": "address of new create standingorder contract ."}
{"code": "function purchase ( uint256 _block_number , uint256 _nonce , uint256 _wei_per_dgx_mg , address _signer , bytes _signature ) payable public returns ( bool _success , uint256 _purchased_amount ) { address _sender = msg . sender ; ( _success , _purchased_amount ) = marketplace_controller ( ) . put_purchase_for . value ( msg . value ) . gas ( NUM_ ) ( msg . value , _sender , _sender , _block_number , _nonce , _wei_per_dgx_mg , _signer , _signature ) ; require ( _success ) ; }\n", "nl": "purchase dgx gold use eth ."}
{"code": "function add whitelisted ( address _address , bool is pool ) public only owner when not paused { if ( is pool ) { whitelisted pools [ _address ] = BOOL_ ; } else { whitelisted [ _address ] = BOOL_ ; } }\n", "nl": "allow to add and exclude address from whitelistedbeforeactivation list for owner ."}
{"code": "function update release amount ( uint256 timestamp ) internal { uint256 time elapse = timestamp . sub ( create time ) ; uint256 cycles = time elapse . div ( NUM_ days ) ; if ( cycles > NUM_ ) { if ( cycles <= NUM_ ) { release amount per day = standard release amount ; for ( uint index = NUM_ ; index < cycles ; index ++ ) { release amount per day = release amount per day . div ( NUM_ ) ; } } else { release amount per day = NUM_ ; } } }\n", "nl": "update release amount for single day accord to dividend rule in https : / / coincool . cool ."}
{"code": "function get crowdsale max raise ( address _storage , bytes32 _exec_id ) external view returns ( uint wei_raise_cap , uint total_sell_cap ) { getter interface target = getter interface ( _storage ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( NUM_ ) ; arr_indices [ NUM_ ] = sale tier list ( ) ; arr_indices [ NUM_ ] = token decimals ( ) ; arr_indices [ NUM_ ] = token name ( ) ; uint [ ] memory read_values = target . read multi ( _exec_id , arr_indices ) . to uint arr ( ) ; assert ( read_values . length == NUM_ ) ; uint num_tiers = read_values [ NUM_ ] ; uint num_decimals = read_values [ NUM_ ] ; if ( read_values [ NUM_ ] == NUM_ ) return ( NUM_ , NUM_ ) ; bytes32 [ ] memory last_arr = new bytes32 [ ] ( NUM_ * num_tiers ) ; for ( uint i = NUM_ ; i < NUM_ * num_tiers ; i += NUM_ ) { last_arr [ i ] = tier cap ( i / NUM_ ) ; last_arr [ i + NUM_ ] = tier price ( i /\n", "nl": "tier_start : the time when the give tier start ."}
{"code": "function claim tokens ( address receipent ) public only minter { balances [ receipent ] = balances [ receipent ] . add ( locked balances [ receipent ] ) ; locked balances [ receipent ] = NUM_ ; }\n", "nl": "locking period have pass - locked tokens have turn into tradeable ."}
{"code": "function produced diamond caps ( ) public view returns ( uint64 ) { return uint64 ( packed produced caps > > NUM_ ) ; }\n", "nl": "the amount of gold cap produce so far ."}
{"code": "function is crowdsale full ( address _storage , bytes32 _exec_id ) external view returns ( bool is_crowdsale_full , uint max_sellable ) { getter interface target = getter interface ( _storage ) ; bytes32 [ ] memory initial_arr = new bytes32 [ ] ( NUM_ ) ; initial_arr [ NUM_ ] = sale tier list ( ) ; initial_arr [ NUM_ ] = tokens sold ( ) ; uint [ ] memory read_values = target . read multi ( _exec_id , initial_arr ) . to uint arr ( ) ; uint num_tiers = read_values [ NUM_ ] ; uint _tokens_sold = read_values [ NUM_ ] ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( num_tiers ) ; for ( uint i = NUM_ ; i < num_tiers ; i ++ ) arr_indices [ i ] = tier cap ( i ) ; read_values = target . read multi ( _exec_id , arr_indices ) . to uint arr ( ) ; assert ( read_values . length == num_tiers ) ; for ( i = NUM_ ; i < read_values . length ; i ++ ) max_sellable += read_values [ i ] ; is_crowdsale_full = ( _tokens_sold >= max_sellable ?\n", "nl": "ensure the member be whitelisted ."}
{"code": "function get bonus ( uint256 _tokens ) internal view returns ( uint256 bonus ) { require ( _tokens != NUM_ ) ; if ( start time <= now && now < start time + NUM_ days ) { return _tokens . div ( NUM_ ) ; } else if ( start time + NUM_ days <= now && now < start time + NUM_ days ) { return _tokens . div ( NUM_ ) ; } else if ( start time + NUM_ days <= now && now < start time + NUM_ days ) { return _tokens . div ( NUM_ ) ; } return NUM_ ; }\n", "nl": "get the bonus base on the buy time ( override getbonus of standardcrowdsale ) ."}
{"code": "function add oracle ( address addr ) public only admin { add role ( addr , role_oracle ) ; }\n", "nl": "revoke oracle role from an address ."}
{"code": "function fix distribution ( uint8 _token price , uint256 _usd to eth conversion rate ) only owner { distribution entry memory de ; log entry memory le ; uint256 i = NUM_ ; if ( distribution fixed ) { revert ( ) ; } for ( i = NUM_ ; i < distribution entry count ; i ++ ) { de = distribution list [ i ] ; de . token amount = ( de . amount contributed * _usd to eth conversion rate * NUM_ ) / ( _token price * de . discount / NUM_ ) ; distribution list [ i ] = de ; } distribution fixed = BOOL_ ; le . tx type = STR_ ; le . block timestamp = block . timestamp ; le . tx id = STR_ ; transaction log . push ( le ) ; tx count ++ ; }\n", "nl": "update / create a record in the distribution list ."}
{"code": "function set dividend winners ( uint [ ] _player contract ids , uint [ ] _total player tokens , uint8 [ ] _individual player allocation pcs , uint _total prize pool allocation pc ) external only owner or referee { require ( _player contract ids . length > NUM_ , STR_ ) ; require ( _player contract ids . length == _total player tokens . length ) ; require ( _total player tokens . length == _individual player allocation pcs . length ) ; require ( _total prize pool allocation pc > NUM_ ) ; require ( _total prize pool allocation pc <= NUM_ ) ; uint daily div prize pool = safe math . div ( safe math . mul ( get total dividend pool ( ) , _total prize pool allocation pc ) , NUM_ ) ; uint8 total player allocation pc = NUM_ ; for ( uint8 i = NUM_ ; i < _player contract ids . length ; i ++ ) { total player allocation pc += _individual player allocation pcs [ i ] ; uint player prize pool = safe math . div ( safe math . mul ( daily div prize pool , _individual\n", "nl": "read access ."}
{"code": "function buy new ( uint256 _xpos , uint256 _ypos , uint256 _size ) payable public { require ( check is on sale ( _ypos ) == BOOL_ ) ; require ( _size == NUM_ ) ; require ( _xpos + _size <= max_cols ) ; uint256 _item id = generate id ( _xpos , _ypos , _size ) ; require ( price of ( _item id ) == NUM_ ) ; require ( owner of ( _item id ) == address ( NUM_ ) ) ; uint256 price = starting price ; address old owner = owner ; listed items . push ( _item id ) ; price of item [ _item id ] = calculate next price ( price ) ; uint256 excess = msg . value . sub ( price ) ; address new owner = msg . sender ; owner of item [ _item id ] = new owner ; uint256 dev cut = calculate dev cut ( price ) ; old owner . transfer ( price . sub ( dev cut ) ) ; if ( excess > NUM_ ) { new owner . transfer ( excess ) ; } }\n", "nl": "function update price ."}
{"code": "function fix dividend balances ( address investor , bool revert if claimed ) internal returns ( investor profit data storage current_profit , uint256 profit_per_token ) { uint32 next_id = uint32 ( dividends . length ) ; uint32 current_id = next_id - NUM_ ; current_profit = profits [ investor ] [ current_id ] ; if ( revert if claimed ) require ( current_profit . status != profit status . claimed ) ; investor profit data storage next_profit = profits [ investor ] [ next_id ] ; if ( current_profit . status == profit status . initial ) { current_profit . start_balance = investors [ investor ] . token balance ; current_profit . end_balance = investors [ investor ] . token balance ; current_profit . status = profit status . end fixed ; next_profit . start_balance = investors [ investor ] . token balance ; next_profit . status = profit status . start fixed ; } else if ( current_profit . status == profit status . start fixed ) { current_profit . end_balance = investors [ investor ] . token balance ; current_profit . status = profit status . end fixed ; next_profit . start_balance = investors [ investor ] . token\n", "nl": "withdraw function to send token address or eth amount to a list of receivers ."}
{"code": "function tokens available ( ) constant returns ( uint256 ) { return token . balance of ( this ) ; }\n", "nl": "current token balance of this contract ."}
{"code": "function approve remove owner request ( ) public only owners { require ( owners count - NUM_ >= need approves to confirm && owners count > NUM_ ) ; require ( owners [ remove owners . new owner ] ) ; require ( ! remove owners . is execute && ! remove owners . is canceled ) ; require ( remove owners . creation timestamp + life time >= uint32 ( now ) ) ; for ( uint i = NUM_ ; i < remove owners . confirmators . length ; i ++ ) { require ( remove owners . confirmators [ i ] != msg . sender ) ; } remove owners . confirms ++ ; remove owners . confirmators . push ( msg . sender ) ; if ( remove owners . confirms >= need approves to confirm ) { remove owners . is execute = BOOL_ ; owners [ remove owners . new owner ] = BOOL_ ; owners count -- ; _remove owners aproves ( remove owners . new owner ) ; } emit remove owner request update ( msg . sender , remove owners . confirms , remove owners . is execute ) ; }\n", "nl": "approve new owners count request , can be call only by owner which do n't call this new owners count request before ."}
{"code": "function change deposit address ( address _deposit address ) external { require ( contract manager . authorize ( contract name , msg . sender ) ) ; require ( _deposit address != address ( NUM_ ) ) ; require ( _deposit address != deposit address ) ; address old deposit address = deposit address ; deposit address = _deposit address ; emit deposit address changed ( old deposit address , _deposit address ) ; }\n", "nl": "change the address which be authorize to send bought tokens with btc ."}
{"code": "function number of milestones ( ) constant returns ( uint ) { return milestones . length ; }\n", "nl": "show length of allocate swap space ."}
{"code": "function claim funds ( ) only contributors public { uint latest = latest balance check [ msg . sender ] ; uint supply = object . total supply ( ) ; uint balance = balance owed [ msg . sender ] ; uint earnings = items owned [ msg . sender ] . div ( NUM_ ether ) . mul ( supply . sub ( latest ) ) . div ( NUM_ ether ) . mul ( item return ) ; uint excess = excess eth [ msg . sender ] ; latest balance check [ msg . sender ] = supply ; balance owed [ msg . sender ] = NUM_ ; excess eth [ msg . sender ] = NUM_ ; balance = balance . add ( earnings ) ; running debt = running debt . add ( earnings ) ; running debt = running debt . sub ( balance ) ; debt paid = debt paid . add ( balance ) ; balance = balance . add ( excess ) ; total excess eth = total excess eth . sub ( excess ) ; will withdraw ( balance ) ; require ( balance > NUM_ ) ;\n", "nl": "return previously create deposit to the user ."}
{"code": "function insert ( data storage self , address _id , uint256 _key , address _prev id , address _next id ) public { require ( ! is full ( self ) ) ; require ( ! contains ( self , _id ) ) ; require ( _id != address ( NUM_ ) ) ; require ( _key > NUM_ ) ; address prev id = _prev id ; address next id = _next id ; if ( ! valid insert position ( self , _key , prev id , next id ) ) { ( prev id , next id ) = find insert position ( self , _key , prev id , next id ) ; } self . nodes [ _id ] . key = _key ; if ( prev id == address ( NUM_ ) && next id == address ( NUM_ ) ) { self . head = _id ; self . tail = _id ; } else if ( prev id == address ( NUM_ ) ) { self . nodes [ _id ] . next id = self . head ; self . nodes [ self . head ] . prev id = _id\n", "nl": "update map ."}
{"code": "function calculate payout ( ) internal { uint ratio ; token_a_amount = token_a_amount . mul ( NUM_ ) . div ( NUM_ ) ; token_b_amount = token_b_amount . mul ( NUM_ ) . div ( NUM_ ) ; if ( share_long == NUM_ ) { pay_to_short_a = ( token_a_amount ) . div ( num_drct_longtokens ) ; pay_to_long_b = ( token_b_amount ) . div ( num_drct_shorttokens ) ; pay_to_short_b = NUM_ ; pay_to_long_a = NUM_ ; } else if ( share_long > NUM_ ) { ratio = safe math . min ( NUM_ , ( share_long ) . sub ( NUM_ ) ) ; pay_to_long_b = ( token_b_amount ) . div ( num_drct_shorttokens ) ; pay_to_short_a = ( safe math . sub ( NUM_ , ratio ) ) . mul ( token_a_amount ) . div ( num_drct_longtokens ) . div ( NUM_ ) ; pay_to_long_a = ratio . mul ( token_a_amount ) . div ( num_drct_longtokens ) . div ( NUM_ ) ; pay_to_short_b = NUM_ ; } else { ratio = safe math . min ( NUM_ , ( share_short ) . sub ( NUM_ ) ) ; pay_to_short_a = ( token_a_amount ) . div ( num_drct_longtokens ) ; pay_to_long_b\n", "nl": "this function calculate the payout of the swap ."}
{"code": "function has closed ( ) public view returns ( bool ) { bool remain value = cap . sub ( wei raised ) < NUM_ ; return super . has closed ( ) || remain value ; }\n", "nl": "override hasended to add minimal value logic ."}
{"code": "function close ico ( ) public only owner { require ( ico has started ) ; ico has closed = BOOL_ ; }\n", "nl": "set address of ico smart-contract which control token initial token distribution ."}
{"code": "function do payment ( address _owner ) internal returns ( bool success ) { require ( tx . gasprice <= max gas price ) ; require ( ! is contract ( msg . sender ) ) ; require ( get block number ( ) . sub ( last call block [ msg . sender ] ) >= max call frequency ) ; last call block [ msg . sender ] = get block number ( ) ; if ( msg . sender != controller ) { require ( start funding time <= now ) ; } require ( end funding time > now ) ; require ( token contract . controller ( ) != NUM_ ) ; require ( msg . value > NUM_ ) ; require ( total collected . add ( msg . value ) <= maximum funding ) ; total collected = total collected . add ( msg . value ) ; require ( vault address . send ( msg . value ) ) ; require ( token contract . generate tokens ( _owner , tokens per ether . mul ( msg . value ) ) ) ; return BOOL_ ; }\n", "nl": "domakerpayment ( ) be an internal function that send the ether that this contract receive to the vault and create tokens in the address of the _owner who the fee contribution be send by ."}
{"code": "function burn token ( uint number of tokens ) public only owner { require ( number of tokens > NUM_ ) ; require ( balances [ msg . sender ] >= number of tokens ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( number of tokens ) ; total supply = total supply . sub ( number of tokens ) ; emit burn ( msg . sender , number of tokens ) ; emit transfer ( msg . sender , address ( NUM_ ) , number of tokens ) ; }\n", "nl": "destroy tokens if mct not sell out ."}
{"code": "function process btctransaction ( bytes txn , uint256 _tx hash , address ethereum address , bytes20 bitcoin address ) admin only returns ( uint256 ) { if ( transactions claimed [ _tx hash ] != BOOL_ ) throw ; var ( output value1 , output address1 , output value2 , output address2 ) = btc . get first two outputs ( txn ) ; if ( btc . check value sent ( txn , bitcoin address , NUM_ ) ) { require ( output value1 >= minimun btcto invest ) ; uint256 tokens purchased = output value1 * bitcoin sale rate * ( NUM_ * * NUM_ ) ; token . mint tokens ( ethereum address , tokens purchased ) ; transactions claimed [ _tx hash ] = BOOL_ ; } else { throw ; } }\n", "nl": "sets step value ."}
{"code": "function refund ether ( ) external only if not running { uint amount ; if ( tier0 [ msg . sender ] > NUM_ ) { amount += tier0 [ msg . sender ] ; tier0 [ msg . sender ] = NUM_ ; } if ( tier1 [ msg . sender ] > NUM_ ) { amount += tier1 [ msg . sender ] ; tier1 [ msg . sender ] = NUM_ ; } if ( tier2 [ msg . sender ] > NUM_ ) { amount += tier2 [ msg . sender ] ; tier2 [ msg . sender ] = NUM_ ; } if ( tier3 [ msg . sender ] > NUM_ ) { amount += tier3 [ msg . sender ] ; tier3 [ msg . sender ] = NUM_ ; } require ( tier0 [ msg . sender ] == NUM_ && tier1 [ msg . sender ] == NUM_ && tier2 [ msg . sender ] == NUM_ && tier3 [ msg . sender ] == NUM_ ) ; msg . sender . transfer ( amount ) ; log refund ( msg . sender , amount , now ) ; return ;\n", "nl": "redeem bonus lot : this function can not be call until the crowdsale be over , nor after the withdraw period ."}
{"code": "function _approved for ( address _claimant , uint256 _token id ) internal view returns ( bool ) { return puppy index to approved [ _token id ] == _claimant ; }\n", "nl": "checks if a give address currently have transferapproval for a particular dog ."}
{"code": "function set contrib period ( uint _soft cap amount , uint _after soft cap duration , uint _hard cap amount , uint _start time , uint _end time ) only owner { require ( _soft cap amount > NUM_ ) ; require ( _hard cap amount > _soft cap amount ) ; require ( _after soft cap duration > NUM_ ) ; require ( _start time > now ) ; require ( _end time > _start time ) ; require ( ! is enabled ) ; soft cap amount = _soft cap amount ; after soft cap duration = _after soft cap duration ; hard cap amount = _hard cap amount ; start time = _start time ; end time = _end time ; district0x network token . revoke all token grants ( founder1 ) ; district0x network token . revoke all token grants ( founder2 ) ; district0x network token . revoke all token grants ( early sponsor ) ; for ( uint j = NUM_ ; j < advisers . length ; j ++ ) { district0x network token . revoke all token grants ( advisers [ j ] ) ; } uint64 vesting date = uint64 (\n", "nl": "increase the amount of eth ."}
{"code": "function get owed dividend ( address _owner ) public view returns ( uint256 total , uint256 [ ] ) { uint256 [ ] memory no dividends = new uint256 [ ] ( NUM_ ) ; uint256 balance = basic token . balance of ( _owner ) ; uint idx = last dividend [ _owner ] ; if ( idx == dividend snapshots . length ) return ( total , no dividends ) ; if ( balance == NUM_ && team [ _owner ] != BOOL_ ) return ( total , no dividends ) ; uint256 [ ] memory dividends = new uint256 [ ] ( dividend snapshots . length - idx - i ) ; uint256 curr balance = balance ; for ( uint i = idx ; i < dividend snapshots . length ; i ++ ) { uint256 dividend = curr balance . mul ( token precision ) . div ( dividend snapshots [ i ] . total supply ) . mul ( dividend snapshots [ i ] . dividends issued ) . div ( token precision ) ; if ( team [ _owner ] == BOOL_ ) { dividend = dividend . add ( dividend snapshots [\n", "nl": "withdraws reward for user ."}
{"code": "function open transfer ( ) only owner public returns ( bool ) { require ( ! transfer allowed ) ; transfer allowed = BOOL_ ; transfer allowed ( ) ; return BOOL_ ; }\n", "nl": "change current state of transfer allowence to opposite ."}
{"code": "function request number ( address _requestor , uint256 _max , uint8 _wait time ) payable public { if ( ! white list [ msg . sender ] ) { require ( ! ( msg . value < cost ) ) ; } assert ( ! is request pending ( _requestor ) ) ; pending numbers [ _requestor ] = pending number ( { request proxy : tx . origin , rendered number : NUM_ , max : max , origin block : block . number , wait time : wait time } ) ; if ( _max > NUM_ ) { pending numbers [ _requestor ] . max = _max ; } if ( _wait time > NUM_ && _wait time < NUM_ ) { pending numbers [ _requestor ] . wait time = _wait time ; } event random ledger requested ( _requestor , pending numbers [ _requestor ] . max , pending numbers [ _requestor ] . origin block , pending numbers [ _requestor ] . wait time , pending numbers [ _requestor ] . request proxy ) ; }\n", "nl": "request a number ."}
{"code": "function force withdraw payments ( address payee ) public only owner { uint256 payment = payments [ payee ] ; require ( payment != NUM_ ) ; require ( this . balance >= payment ) ; total payments = total payments . sub ( payment ) ; payments [ payee ] = NUM_ ; assert ( payee . send ( payment ) ) ; }\n", "nl": "withdraw accumulate balance to the payee ."}
{"code": "function upgrade ship ( uint256 _token id , uint256 [ ship_slots ] _objects ) external when not paused { require ( ethernauts storage . is category ( _token id , uint8 ( asset category . ship ) ) ) ; require ( ethernauts storage . is state ( _token id , uint8 ( asset state . available ) ) ) ; require ( msg . sender == ethernauts storage . owner of ( _token id ) ) ; require ( ! is exploring ( _token id ) ) ; uint i = NUM_ ; uint8 [ stats_size ] memory _ship stats = ethernauts storage . get stats ( _token id ) ; uint256 level = _ship stats [ uint ( ship stats . level ) ] ; uint8 [ stats_size ] [ ship_slots ] memory _objects stats ; require ( level < max_level ) ; uint256 [ ] memory upgrades to token index = new uint256 [ ] ( ethernauts storage . total supply ( ) ) ; for ( i = NUM_ ; i < _objects . length ; i ++ ) { require ( msg . sender == ethernauts storage . owner of ( _objects [ i ]\n", "nl": "explore a sector with a defined ship ."}
{"code": "function add monster class basic ( uint32 _class id , uint8 _type , uint256 _price , uint256 _return price , uint8 _ss1 , uint8 _ss2 , uint8 _ss3 , uint8 _ss4 , uint8 _ss5 , uint8 _ss6 ) only moderators external { etheremon data base data = etheremon data base ( data contract ) ; monster class acc memory class ; ( class . class id , class . price , class . return price , class . total , class . catchable ) = data . get monster class ( _class id ) ; if ( _class id == NUM_ || class . class id == _class id ) revert ( ) ; data . set monster class ( _class id , _price , _return price , BOOL_ ) ; data . add element to array type ( array type . class_type , uint64 ( _class id ) , _type ) ; data . add element to array type ( array type . stat_start , uint64 ( _class id ) , _ss1 ) ; data . add element to array type ( array type . stat_start , uint64 ( _class id ) , _ss2 ) ; data . add\n", "nl": "setprice - set the price of a product ."}
{"code": "function finalize ( ) external only owner { require ( wei total received >= soft cap ) ; require ( now > start time . add ( period ) || wei total received >= hard cap ) ; if ( state == state . presale ) { require ( this . balance > NUM_ ) ; wallet ether presale . transfer ( this . balance ) ; pause ( ) ; } else if ( state == state . crowdsale ) { uint256 token total unsold = token ico allocated . sub ( token total sold ) ; token reservation allocated = token reservation allocated . add ( token total unsold ) ; require ( token . transfer from ( token . owner ( ) , wallet token bounty , token bounty allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token reservation , token reservation allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token team , token team allocated ) ) ; token . lock ( wallet token reservation , now + NUM_ years ) ; token . lock (\n", "nl": "allows the owner of the contract to withdraw all unsold tokens ."}
{"code": "function can settle ( bytes32 channel id ) public view returns ( bool ) { payment channel memory channel = channels [ channel id ] ; bool is waiting over = is settling ( channel id ) && block . number >= channel . settling until ; return is settling ( channel id ) && is waiting over ; }\n", "nl": "sender initiate settle of the contract ."}
{"code": "function get contract info ( bytes32 _id ) public view returns ( address , bytes20 ) { return ( registry [ _id ] . contract address , registry [ _id ] . git commit hash ) ; }\n", "nl": "get the address of an app instance or base implementation ."}
{"code": "modifier m is active ( ) { require ( is active ) ; _ ; }\n", "nl": "can act only after token activation ."}
{"code": "function get all scripts ( uint offset ) external view returns ( uint [ NUM_ ] [ chunk_size ] scripts result ) { for ( uint8 i = NUM_ ; i < chunk_size && i + offset < script addresses . length ; i ++ ) { address script address = script addresses [ i + offset ] ; scripts result [ i ] = [ i + offset , uint ( script address ) , uint ( scripts [ script address ] . state ) , scripts [ script address ] . sign count ] ; } }\n", "nl": "ui helper fx - returns all agreements from offset a index in allagreements , account address a uint , balance , agreementhash a uint , discount a uint , valuationcap a uint ."}
{"code": "function quick buy ( uint256 _min return ) public payable returns ( uint256 amount ) { assert ( quick buy path . length > NUM_ ) ; iether token ether token = iether token ( quick buy path [ NUM_ ] ) ; ether token . deposit . value ( msg . value ) ( ) ; ismart token smart token = ismart token ( quick buy path [ NUM_ ] ) ; bancor changer changer = bancor changer ( smart token . owner ( ) ) ; ensure allowance ( ether token , changer , msg . value ) ; uint256 return amount = changer . quick change ( quick buy path , msg . value , _min return ) ; assert ( token . transfer ( msg . sender , return amount ) ) ; return return amount ; }\n", "nl": "change the token to any other token in the bancor network by follow a predefined change path note that when change from an erc20 token ( a oppose to a smart token ) , allowance must be set beforehand ."}
{"code": "function withdraw ( uint256 _value ) returns ( bool _success ) { if ( msg . sender != client ) throw ; if ( _value > NUM_ ) { update capital ( ) ; if ( _value <= capital ) { if ( client . send ( _value ) ) { withdrawal ( _value ) ; capital -= _value ; return BOOL_ ; } else return BOOL_ ; } else return BOOL_ ; } else return BOOL_ ; }\n", "nl": "true if fee and unaccounted ether be successfully withdraw , false otherwise ."}
{"code": "function whitelist addresses ( address [ ] _users ) only owner { for ( uint i = NUM_ ; i < _users . length ; i ++ ) { white listed address [ _users [ i ] ] = BOOL_ ; } }\n", "nl": "returns ether and tokens to list of users ."}
{"code": "function change rate of token ( uint256 _new rate ) public only owner { require ( _new rate > NUM_ ) ; if ( state of ico == state of ico . pre ) { if ( rate for pre ico == _new rate ) { revert ( ) ; } rate for pre ico = _new rate ; token price for pre ico = uint256 ( NUM_ ) . div ( rate for pre ico ) ; exchange rate changed ( STR_ , _new rate ) ; } else { if ( rate for main ico == _new rate ) { revert ( ) ; } rate for main ico = _new rate ; rate for main ico = uint256 ( NUM_ ) . div ( rate for main ico ) ; exchange rate changed ( STR_ , _new rate ) ; } }\n", "nl": "change token rate ."}
{"code": "function unlock funds ( ) public { require ( game state == state . closed ) ; require ( has participated [ msg . sender ] == BOOL_ ) ; require ( has withdrawn [ msg . sender ] == BOOL_ ) ; if ( funds transfered == BOOL_ ) { require ( credit gameinterface ( credit game address ) . check if lock can be removed ( address ( this ) ) == BOOL_ ) ; credit gameinterface ( credit game address ) . remove lock ( ) ; funds transfered = BOOL_ ; emit game unlocked ( block . number ) ; } has withdrawn [ msg . sender ] = BOOL_ ; uint index = participant indexes [ msg . sender ] ; uint amount = participation amount [ index ] ; ierc20 token ( token address ) . transfer ( msg . sender , amount ) ; total locked amount = ierc20 token ( token address ) . balance of ( address ( this ) ) ; if ( total locked amount == NUM_ ) { game state = state . claimed ; credit gameinterface ( credit game address ) . clean up ( ) ;\n", "nl": "user can withdraw there airdrop tokens if address exist in the whitelist ."}
{"code": "function no ( uint _lock id , string _data info , uint _version ) { escrow info info = escrows [ _lock id ] ; if ( info . locked funds == NUM_ ) { log debug ( STR_ ) ; return ; } if ( msg . sender != info . buyer && msg . sender != seller ) { log debug ( STR_ ) ; return ; } if ( info . frozen funds == NUM_ ) { info . frozen funds = info . locked funds ; info . frozen time = uint64 ( now ) ; } if ( msg . sender == info . buyer ) { info . buyer no = BOOL_ ; } else if ( msg . sender == seller ) { info . seller no = BOOL_ ; } else { log debug ( STR_ ) ; return ; } log event ( _lock id , _data info , _version , freeze , msg . sender , info . count , info . locked funds ) ; }\n", "nl": "escrow api vote yes - immediately send fund to the peer ."}
{"code": "function change min investment ( uint _new min ) external only owner { emit change min investment ( msg . sender , min investment , _new min ) ; min investment = _new min ; }\n", "nl": "allows the owner to change minimum payment ."}
{"code": "function set min bet ( uint bet ) public only owner { min bet = bet ; }\n", "nl": "set the max bet threshold percent ."}
{"code": "function change minimum purchase amount ( uint _new minimum purchase amount ) public only owner returns ( bool ) { require ( _new minimum purchase amount >= NUM_ ) ; minimum purchase amount = _new minimum purchase amount ; return BOOL_ ; }\n", "nl": "update reward amount ."}
{"code": "function unset erc777 ( address token ) public only owner { is erc777 [ token ] = BOOL_ ; }\n", "nl": "marks a token a an erc777 token ."}
{"code": "function transfer manually ( uint256 _tokens , address to_address ) only owner public returns ( bool ) { require ( to_address != NUM_ ) ; require ( valid purchase for manual ( ) ) ; require ( check and update token for manual ( _tokens ) ) ; token_reward . transfer ( to_address , _tokens ) ; return BOOL_ ; }\n", "nl": "function to transfer token back to owner ."}
{"code": "function string to bytes32 ( string memory source ) public pure returns ( bytes32 result ) { assembly { result : = mload ( add ( source , NUM_ ) ) } }\n", "nl": "string to bytes32 conversion helper ."}
{"code": "function set main ( uint256 _start time main , uint256 _end time main , uint256 _min cap main , uint256 _max cap main , uint256 _rate main ) external only owner event not ended { require ( now < _start time main ) ; require ( _start time main < _end time main ) ; require ( _min cap main <= _max cap main ) ; require ( _start time main > end time pre ) ; start time main = _start time main ; end time main = _end time main ; min cap main = _min cap main ; max cap main = _max cap main ; rate main = _rate main ; set main ( _start time main , _end time main , _min cap main , _max cap main , _rate main ) ; }\n", "nl": "set the parameters for the contribution round associate with variables , function , events of suffix pre ."}
{"code": "function balance unlocked ( address _address ) public view returns ( uint256 _balance ) { _balance = balance p [ _address ] ; uint256 i = NUM_ ; while ( i < lock num [ _address ] ) { if ( add ( now , earlier ) > add ( lock time [ _address ] [ i ] , later ) ) _balance = add ( _balance , lock value [ _address ] [ i ] ) ; i ++ ; } return _balance ; }\n", "nl": "show timelocked balance of an account ."}
{"code": "function update ico status ( ) public { if ( ico status == ico status value . succeeded || ico status == ico status value . failed ) return ; else if ( ico status == ico status value . anouncement ) { if ( now > funding start && now <= funding deadline ) { ico status = ico status value . sale open ; } else if ( now > funding deadline ) { ico status = ico status value . sale closed ; } } else { uint num p = get num tokens purchased ( ) ; uint num g = get num games ( ) ; if ( ( now > funding deadline && num p < min ico token goal ) || ( now > usage deadline && num g < min usage goal ) ) { ico status = ico status value . failed ; } else if ( ( now > funding deadline ) && ( num p >= min ico token goal ) && ( num g >= min usage goal ) ) { ico status = ico status value . succeeded ; } if ( ico status == ico status\n", "nl": "100m tokens in teamwallet be lock for 6 months 200m tokens in teamwallet be lock for 12 months ."}
{"code": "function change rate of token ( uint256 _new rate ) public only owner { require ( _new rate > NUM_ ) ; if ( state of ico == state of ico . pre ) { if ( rate for pre ico == _new rate ) { revert ( ) ; } rate for pre ico = _new rate ; token price for pre ico = uint256 ( NUM_ ) . div ( rate for pre ico ) ; exchange rate changed ( STR_ , _new rate ) ; } else { if ( rate for main ico == _new rate ) { revert ( ) ; } rate for main ico = _new rate ; rate for main ico = uint256 ( NUM_ ) . div ( rate for main ico ) ; exchange rate changed ( STR_ , _new rate ) ; } }\n", "nl": "an integer be require ( e . g ."}
{"code": "function revoke vote ( ) public check time { require ( votes by address [ msg . sender ] . time > NUM_ ) ; uint256 voice weight = votes by address [ msg . sender ] . weight ; bool agree = votes by address [ msg . sender ] . agree ; votes by address [ msg . sender ] . time = NUM_ ; votes by address [ msg . sender ] . weight = NUM_ ; votes by address [ msg . sender ] . agree = BOOL_ ; total voted = safe sub ( total voted , NUM_ ) ; if ( agree ) { yes counter = safe sub ( yes counter , voice weight ) ; } else { no counter = safe sub ( no counter , voice weight ) ; } }\n", "nl": "process user s vote ."}
{"code": "function claim ( address token ) public { execute claim ( token , msg . sender , calculate maximum payment ( token , msg . sender ) ) ; }\n", "nl": "claim part of your share of the balance ."}
{"code": "function marriage proof ( bytes ipfsproof hash ) only owner public { marriage proof doc = ipfsproof hash ; major event func ( block . timestamp , STR_ , STR_ ) ; }\n", "nl": "set the ipfs hash of the image of the couple ."}
{"code": "function addtoblacklist ( address _addr ) public only owner { blacklist [ _addr ] = BOOL_ ; emit add to blacklist ( _addr ) ; }\n", "nl": "blacklist management ."}
{"code": "function is active ( ) public view returns ( bool ) { return tiers . length > NUM_ && block . number >= tiers [ NUM_ ] . start block && block . number <= end block ; }\n", "nl": "check whether activation be schedule ."}
{"code": "function reverse ( address _recipient ) if delegate external { require ( _recipient != address ( NUM_ ) ) ; require ( progress == NUM_ || progress == NUM_ ) ; require ( participant tokens [ _recipient ] > NUM_ || participant values [ _recipient ] > NUM_ ) ; uint256 initial participant tokens = participant tokens [ _recipient ] ; uint256 initial participant value = participant values [ _recipient ] ; tokens = safe sub ( tokens , initial participant tokens ) ; value = safe sub ( value , initial participant value ) ; participant tokens [ _recipient ] = NUM_ ; participant values [ _recipient ] = NUM_ ; reversed ( _recipient , initial participant tokens , initial participant value ) ; if ( initial participant value > NUM_ ) { address ( _recipient ) . transfer ( initial participant value ) ; } }\n", "nl": "the contract creator call this to withdraw contributed eth to a specific address ."}
{"code": "function assign tokens ( address investor , uint256 tokens ) internal { balances [ eth exchange wallet ] = safe sub ( balances [ eth exchange wallet ] , tokens ) ; balances [ investor ] = safe add ( balances [ investor ] , tokens ) ; transfer ( eth exchange wallet , investor , tokens ) ; }\n", "nl": "can be issue to anyone without owners concent but a this method be internal only buytoken be call it ."}
{"code": "modifier is not contract ( ) { uint size ; address addr = msg . sender ; assembly { size : = extcodesize ( addr ) } require ( size == NUM_ ) ; _ ; }\n", "nl": "thanks to technicalrise ."}
{"code": "modifier is not registered ( bytes12 contract id ) { if ( contract addresses [ contract id ] != NUM_ ) { throw ; } _ ; }\n", "nl": "register the call blobstore contract ."}
{"code": "function create contract game ( string _name , uint256 _price ) public only coo { _create game ( _name , ceo address , _price ) ; }\n", "nl": "creates a new tot with the give name ."}
{"code": "function invest ( ) public payable stop in emergency { require ( get state ( ) == state . funding ) ; require ( msg . value > NUM_ ) ; uint wei amount = msg . value ; address investor = msg . sender ; if ( invested amount of [ investor ] == NUM_ ) { investor count ++ ; } uint multiplier = NUM_ * * decimals ; uint tokens amount = ( wei amount * multiplier ) / token price ; assert ( tokens amount > NUM_ ) ; if ( get current milestone ( ) . bonus > NUM_ ) { tokens amount += ( tokens amount * get current milestone ( ) . bonus ) / NUM_ ; } assert ( tokens for sale - tokens amount >= NUM_ ) ; tokens for sale -= tokens amount ; investments . push ( investment ( investor , tokens amount ) ) ; investments count ++ ; token amount of [ investor ] += tokens amount ; uint online fee amount = ( wei amount * etherfundme_online_fee ) / NUM_ ; withdraw ( fee receiver wallet , online fee amount ) ; fee receiver wallet .\n", "nl": "transfer balance to owner withdraw owner ."}
{"code": "function modify level cap ( uint level , uint cap ) public only owner { require ( contract stage < NUM_ ) ; require ( level > NUM_ && level < contribution caps . length ) ; require ( this . balance <= cap && contribution caps [ NUM_ ] >= cap ) ; contribution caps [ level ] = cap ; next cap time = NUM_ ; }\n", "nl": "this function be call by the owner to modify the cap ."}
{"code": "function get is participate ( address _participant , uint256 _block number ) public view returns ( bool _is participate ) { return ( participants [ _participant ] . bets [ _block number ] . oddbets > NUM_ || participants [ _participant ] . bets [ _block number ] . evenbets > NUM_ ) ; }\n", "nl": "function which tell u be the revenue for give block be pay ."}
{"code": "function calc token amount ( uint256 wei amount ) internal view returns ( uint256 ) { uint256 price ; if ( now >= start time && now < deadline one ) { price = first rate ; } else if ( now >= deadline one && now < deadline two ) { price = second rate ; } else if ( now >= deadline two && now < deadline three ) { price = third rate ; } else if ( now >= deadline three && now <= end time ) { price = final rate ; } uint256 tokens = safe mul ( price , wei amount ) ; uint8 decimal cut = NUM_ > ipc . decimals ( ) ? NUM_ - ipc . decimals ( ) : NUM_ ; return safe div ( tokens , NUM_ * * uint256 ( decimal cut ) ) ; }\n", "nl": "this function will return number of tokens base on time intervals in the campaign ."}
{"code": "function burn ( uint256 _value ) public only owner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; transfer ( msg . sender , address ( NUM_ ) , _value ) ; burn ( msg . sender , _value ) ; return BOOL_ ; }\n", "nl": "burn away the specified amount of careerxon tokens ."}
{"code": "function is drawn ( uint _dispute id , address _juror , uint _draw ) public view returns ( bool drawn ) { dispute storage dispute = disputes [ _dispute id ] ; juror storage juror = jurors [ _juror ] ; if ( juror . last session != session || ( dispute . session + dispute . appeals != session ) || period <= period . draw || _draw > amount jurors ( _dispute id ) || _draw == NUM_ || segment size == NUM_ ) { return BOOL_ ; } else { uint position = uint ( keccak256 ( random number , _dispute id , _draw ) ) % segment size ; return ( position >= juror . segment start ) && ( position < juror . segment end ) ; } }\n", "nl": "must be use to verify that a juror have be draw at least _draws . length ."}
{"code": "function get puppy ( uint256 _id ) external view returns ( bool is gestating , bool is ready , uint256 cooldown index , uint256 next action at , uint256 siring with id , uint256 birth time , uint256 matron id , uint256 sire id , uint256 generation , uint256 genes ) { puppy storage pup = puppies [ _id ] ; is gestating = ( pup . siring with id != NUM_ ) ; is ready = ( pup . cooldown end block <= block . number ) ; cooldown index = uint256 ( pup . cooldown index ) ; next action at = uint256 ( pup . cooldown end block ) ; siring with id = uint256 ( pup . siring with id ) ; birth time = uint256 ( pup . birth time ) ; matron id = uint256 ( pup . matron id ) ; sire id = uint256 ( pup . sire id ) ; generation = uint256 ( pup . generation ) ; genes = pup . genes ; }\n", "nl": "returns all the relevant information about a specific zodiac ."}
{"code": "function kill ( ) external only owner { require ( ! is icoactive ( ) ) ; if ( crowdsale address . balance > NUM_ ) { revert ( ) ; } if ( now < pre sale start date ) { selfdestruct ( owner ) ; } uint feature development amount = token . balance of ( sale wallet address ) ; token . transfer from ( sale wallet address , feature development . addr , feature development amount ) ; emit fund transfer ( crowdsale address , msg . sender , crowdsale address . balance ) ; selfdestruct ( owner ) ; }\n", "nl": "transfer eth amount from contract to bank 's address ."}
{"code": "function buy tokens ( address _beneficiary ) is between only public non zero address ( _beneficiary ) non zero eth is token deployed payable public returns ( bool ) { uint256 amount = msg . value . mul ( ( ( eth rate . mul ( NUM_ ) ) . div ( get rate ( ) ) ) ) ; if ( token . transfer ( _beneficiary , amount ) ) { fund transfer ( msg . value ) ; eth raised = eth raised . add ( msg . value ) ; token sold = token sold . add ( amount ) ; token . change total supply ( amount ) ; token purchase ( _beneficiary , msg . value , amount ) ; return BOOL_ ; } return BOOL_ ; }\n", "nl": "buy token function ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( _value < NUM_ ) throw ; if ( this == _to ) throw ; if ( balance of [ _from ] < _value ) throw ; if ( _value > allowance [ _from ] [ msg . sender ] ) throw ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; allowance [ _from ] [ msg . sender ] -= _value ; if ( shareholder id [ _to ] == NUM_ ) { shareholder id [ _to ] = shareholder . push ( _to ) - NUM_ ; } refresh active shareholders array ( ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }\n", "nl": "_freezetranfer perform actual tokens transfer which will be freeze ( see also checktransfer ( ) ) ."}
{"code": "function conditional transitions ( ) public { bytes32 next = states [ current state id ] . next state id ; bool state changed ; while ( next != NUM_ ) { state changed = BOOL_ ; for ( uint256 i = NUM_ ; i < states [ next ] . start conditions . length ; i ++ ) { if ( states [ next ] . start conditions [ i ] ( next ) ) { go to next state ( ) ; next = states [ next ] . next state id ; state changed = BOOL_ ; break ; } } if ( ! state changed ) break ; } }\n", "nl": "goes to the next state if possible ( if the next state be valid ) ."}
{"code": "function burn ( uint256 _value ) public { require ( msg . sender == owner ) ; require ( _value > NUM_ ) ; require ( _value <= balances [ msg . sender ] ) ; _value = _value . mul ( NUM_ * * decimals ) ; address burner = msg . sender ; uint t = balances [ burner ] . sub ( _value ) ; require ( t >= creator_token_end ) ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; if ( _total supply >= _value ) { _total supply = _total supply . sub ( _value ) ; } burn ( burner , _value ) ; }\n", "nl": "brucia tutti i token rimanenti ."}
{"code": "function initialise contract ( address control wallet input , uint256 price numerator input , uint256 start block input , uint256 end block input ) external only fund wallet { require ( control wallet input != address ( NUM_ ) ) ; require ( price numerator input > NUM_ ) ; require ( end block input > start block input ) ; control wallet = control wallet input ; whitelist [ control wallet ] = BOOL_ ; current price = price ( price numerator input ) ; funding start block = start block input ; funding end block = end block input ; previous update time = current time ( ) ; min amount = NUM_ ether ; }\n", "nl": "not all deployment clients support constructor arguments ."}
{"code": "function withdraw fund to address ( address _owner other adress ) public only owner { uint256 eth = address ( this ) . balance ; _owner other adress . transfer ( eth ) ; }\n", "nl": "allows the owner to withdraw that be assign to the token contract itself ."}
{"code": "function takedaily ( address _to ) public returns ( bool valid ) { require ( _to != NUM_ ) ; require ( tx . gasprice <= gas_price_limit ) ; require ( ( msg . sender == contract_signature1 || msg . sender == contract_signature2 ) ) ; uint256 current time = block . timestamp ; require ( current time - m last spend [ msg . sender ] > day_length ) ; _to . transfer ( max_daily_solo_spend ) ; m last spend [ msg . sender ] = current time ; return BOOL_ ; }\n", "nl": "use to take a small amount of daily tokens ."}
{"code": "function set jackpot completed ( ) public only owner { jackpot completed = BOOL_ ; final jackpot value = address ( this ) . balance ; uint256 jackpot share = ( ( address ( this ) . balance ) . mul ( NUM_ ) ) . div ( NUM_ ) ; msg . sender . transfer ( jackpot share ) ; }\n", "nl": "get the total jackpot value , which be contract balance if the jackpot be not complete . else ."}
{"code": "function min cap fail ( ) public { require ( now >= ico end time && ico sold cap < ico min cap ) ; require ( ico contributions [ msg . sender ] > NUM_ && balances [ msg . sender ] > NUM_ ) ; uint tokens = balances [ msg . sender ] ; balances [ ico owner ] += tokens ; balances [ msg . sender ] -= tokens ; uint contribution = ico contributions [ msg . sender ] ; ico contributions [ msg . sender ] = NUM_ ; transfer ( msg . sender , ico owner , tokens ) ; msg . sender . transfer ( contribution ) ; }\n", "nl": "unfroze tokens if some leave unsold from ico ."}
{"code": "function create subscription offer ( uint _price per hour , uint16 _xrate provider id , uint _charge period , uint _expire on , uint _offer limit , uint _deposit amount , uint _start on , bytes _descriptor ) public no reentrancy ( l01 ) only registered provider not suspended returns ( uint sub id ) { assert ( _start on < _expire on ) ; assert ( _charge period <= NUM_ years ) ; var ( _xrate_n , _xrate_d ) = _xrate provider id == NUM_ ? ( NUM_ , NUM_ ) : xrate provider ( xrate providers [ _xrate provider id ] ) . get rate ( ) ; assert ( _xrate_n > NUM_ && _xrate_d > NUM_ ) ; subscriptions [ ++ subscription counter ] = subscription ( { transfer from : NUM_ , transfer to : msg . sender , price per hour : _price per hour , xrate provider id : _xrate provider id , initial xrate_n : _xrate_n , initial xrate_d : _xrate_d , paid until : NUM_ , charge period : _charge period , deposit amount : _deposit amount , start on : _start on , expire on : _expire on , exec counter\n", "nl": "set up fee distribution status thresholds ."}
{"code": "function _mint bonus ( address _from , uint256 _amount ) internal returns ( bool ) { uint referent time = max ( locked [ _from ] . last updated , locked [ _from ] . last claimed ) ; uint time difference = now . sub ( referent time ) ; uint amount temp = ( _amount . mul ( time difference ) ) . div ( NUM_ days ) ; uint mintable amount = amount temp . div ( NUM_ ) ; locked [ _from ] . last claimed = now ; _mint ( _from , mintable amount ) ; lock claimed ( _from , mintable amount ) ; return BOOL_ ; }\n", "nl": "used by lock , claimbonus and unlock function ."}
{"code": "function set transfer fee percentage ( uint256 _transfer fee percentage ) public only owner { require ( NUM_ <= _transfer fee percentage && _transfer fee percentage <= NUM_ , STR_ ) ; require ( _transfer fee percentage != transfer fee percentage , STR_ ) ; transfer fee percentage = _transfer fee percentage ; emit log transfer fee percentage changed ( msg . sender , _transfer fee percentage ) ; }\n", "nl": "changes the house cut percentage ."}
{"code": "function start ico ( ) public only owner returns ( bool success ) { require ( contract_state == state . waiting for ico ) ; contract_state = state . ico ; new state ( contract_state ) ; return BOOL_ ; }\n", "nl": "finish the pre-sale period , be require the presale state of the contract ."}
{"code": "function set prices ( uint256 new buy price ) only owner public { buy price = new buy price ; }\n", "nl": "set min / max price ."}
{"code": "function attack ( uint256 _champ id , uint256 _target id ) external only owner of champ ( _champ id ) is champ ready ( _champ id ) not self attack ( _champ id , _target id ) target exists ( _target id ) { champ storage my champ = champs [ _champ id ] ; champ storage enemy champ = champs [ _target id ] ; uint256 points given ; uint256 points to attack power ; uint256 my champ attack power ; uint256 enemy champ defence power ; uint256 my champ cooldown reduction ; ( my champ attack power , , my champ cooldown reduction ) = get champ stats ( _champ id ) ; ( , enemy champ defence power , ) = get champ stats ( _target id ) ; if ( my champ attack power > enemy champ defence power ) { if ( my champ attack power - enemy champ defence power < NUM_ ) { ( points given , points to attack power ) = _get points ( NUM_ ) ; } else if ( my champ attack power - enemy champ defence power < NUM_ ) { ( points given , points to attack\n", "nl": "prevents from self-attack ."}
{"code": "function get total supply ( ) public view returns ( uint256 ) { return total supply ; }\n", "nl": "how many tokens have be distribute ."}
{"code": "function buy ( ) payable public { logic . buy ( this , msg . sender , msg . value ) ; }\n", "nl": "buys pay for the contract with user fund ."}
{"code": "function issue ( uint _quantity ) is multiple of natural unit ( _quantity ) is non zero ( _quantity ) public returns ( bool success ) { for ( uint16 i = NUM_ ; i < components . length ; i ++ ) { address current component = components [ i ] . address_ ; uint current units = components [ i ] . unit_ ; uint pre transfer balance = erc20 ( current component ) . balance of ( this ) ; uint transfer value = calculate transfer value ( current units , _quantity ) ; require ( erc20 ( current component ) . transfer from ( msg . sender , this , transfer value ) ) ; uint post transfer balance = erc20 ( current component ) . balance of ( this ) ; assert ( pre transfer balance . add ( transfer value ) == post transfer balance ) ; } mint ( _quantity ) ; emit log issuance ( msg . sender , _quantity ) ; return BOOL_ ; }\n", "nl": "config oracle db address and set minimum tx amt to limit abuse ."}
{"code": "function approve ( address _spender , uint256 _value ) only payload size ( NUM_ * NUM_ ) public returns ( bool ) { return super . approve ( _spender , _value ) ; }\n", "nl": "override mint method to include the onlypayloadsize check modifier ."}
{"code": "function transfer pre signed hashing ( address _token , address _to , uint256 _value , uint256 _fee , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( bytes4 ( NUM_ ) , _token , _to , _value , _fee , _nonce ) ; }\n", "nl": "hash ( keccak256 ) of the payload use by transferfrompresigned ."}
{"code": "function set token name ( address _token , string _name ) public only owner token exists ( _token ) name does not exist ( _name ) { token metadata storage token = tokens [ _token ] ; emit log token name change ( _token , token . name , _name ) ; delete token by name [ token . name ] ; token by name [ _name ] = _token ; token . name = _name ; }\n", "nl": "allows owner to modify an exist token 's symbol ."}
{"code": "function add first buyers ( address [ ] _addresses , uint256 [ ] _amount ) public only owner { require ( _addresses . length == _amount . length ) ; for ( uint256 i = NUM_ ; i < _addresses . length ; i ++ ) { uint256 weighted contribution = ( bst . balance of ( _addresses [ i ] ) . mul ( _amount [ i ] ) ) . div ( NUM_ * * NUM_ ) ; first buyer storage buyer = first buyers [ _addresses [ i ] ] ; uint256 before = buyer . tokens received ; buyer . tokens received = buyer . tokens received . add ( _amount [ i ] ) ; buyer . weighted contribution = buyer . weighted contribution . add ( weighted contribution ) ; property . mint tokens ( _addresses [ i ] , _amount [ i ] ) ; first buyers [ _addresses [ i ] ] = buyer ; total weighted contribution = total weighted contribution . add ( weighted contribution ) ; if ( before == NUM_ ) { first buyer index [ num of first buyers ] = _addresses [ i ] ; num\n", "nl": "add affiliate in affiliate map ."}
{"code": "function grant service ( address _owner , address _provider to add ) only owner returns ( bool authorization status ) { var is preauthorized = authorized [ _owner ] [ msg . sender ] ; if ( is preauthorized && settlers [ _provider to add ] ) { authorized [ _owner ] [ _provider to add ] = BOOL_ ; authorize service provider ( msg . sender , _provider to add ) ; return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "check authorization between account and service provider ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }\n", "nl": "transfers _value amount of tokens from address _from to address _to , and must fire the transfer event ."}
{"code": "function retrieve incomplete proof ( bytes32 proof mapping ) public view returns ( address creator , bytes32 hash , uint timestamp , uint block num ) { proof memory proof = proofs [ proof mapping ] ; require ( proof . creator != NUM_ ) ; require ( ! proof . released ) ; return ( proof . creator , proof . hash , proof . timestamp , proof . block num ) ; }\n", "nl": "functon to retrieve a proof that have be complete ."}
{"code": "function top up ( address _receiver_address , uint32 _open_block_number , uint192 _added_deposit ) external { update internal balance structs ( msg . sender , _receiver_address , _open_block_number , _added_deposit ) ; require ( token . transfer from ( msg . sender , address ( this ) , _added_deposit ) ) ; }\n", "nl": "function that allow a delegate contract to increase the channel deposit with _added_deposit ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) returns ( bool success ) { assert ( msg . sender != address ( NUM_ ) ) ; assert ( _from != address ( NUM_ ) ) ; assert ( _to != address ( NUM_ ) ) ; require ( ! frozen account [ msg . sender ] ) ; require ( ! frozen account [ _from ] ) ; require ( ! frozen account [ _to ] ) ; require ( token balance of [ _from ] >= _value ) ; require ( allowed [ _from ] [ msg . sender ] >= _value ) ; require ( token balance of [ _from ] - _value < token balance of [ _from ] ) ; require ( token balance of [ _to ] + _value > token balance of [ _to ] ) ; require ( _value > NUM_ ) ; order to transfer ( msg . sender , _from , _to , _value , STR_ ) ; _transfer ( _from , _to , _value ) ; allowed [ _from ] [ msg . sender ] -= _value ; return BOOL_ ; }\n", "nl": "add spender to authorize for spend specified amount of iac token ."}
{"code": "function revoke asset ( bytes32 _symbol , uint _value ) public returns ( uint ) { if ( _value == NUM_ ) { return _error ( atx_platform_invalid_value ) ; } asset storage asset = assets [ _symbol ] ; uint holder id = get holder id ( msg . sender ) ; if ( asset . wallets [ holder id ] . balance < _value ) { return _error ( atx_platform_not_enough_tokens ) ; } asset . wallets [ holder id ] . balance = asset . wallets [ holder id ] . balance . sub ( _value ) ; asset . total supply = asset . total supply . sub ( _value ) ; emitter ( events history ) . emit revoke ( _symbol , _value , _address ( holder id ) ) ; _proxy transfer event ( holder id , NUM_ , _value , _symbol ) ; return ok ; }\n", "nl": "ask asset proxy contract to emit erc20 compliant transfer event ."}
{"code": "function aira transfer ( address _from , address _to , uint _value ) only bot { if ( balance of [ _from ] >= _value ) { balance of [ _from ] -= _value ; balance of [ _to ] += _value ; transfer ( _from , _to , _value ) ; } }\n", "nl": "outgoing transfer for aira ."}
{"code": "function claim ether ( ) public only owner { if ( this . balance > NUM_ ) { owner . transfer ( this . balance ) ; } }\n", "nl": "allow to extract ether from contract ."}
{"code": "function winner decided ( uint _h game , address _winner , uint _winner bal ) public { if ( ! valid arb ( msg . sender , arb tok from hgame ( _h game ) ) ) { stat event ( STR_ ) ; return ; } var ( valid , pidx ) = valid player ( _h game , _winner ) ; if ( ! valid ) { stat event ( STR_ ) ; return ; } arbiter xarb = arbiters [ msg . sender ] ; game instance xgame = games [ _h game ] ; if ( xgame . player pots [ pidx ] < _winner bal ) { abort game ( _h game , end reason . er cancel ) ; return ; } xgame . active = BOOL_ ; xgame . reason ended = end reason . er winner ; num games completed ++ ; if ( xgame . total pot > NUM_ ) { uint _escrow fee = ( xgame . total pot * xarb . esc fee pct x10 ) / NUM_ ; uint _arbiter fee = ( xgame . total pot * xarb . arb fee pct x10 ) / NUM_ ;\n", "nl": "clean up game , set to inactive , refund any balance call by housekeep only ."}
{"code": "function burn ( uint _value ) public returns ( bool ok ) { require ( now >= end ) ; require ( _value > NUM_ ) ; uint256 sender balance = balances [ msg . sender ] ; require ( sender balance >= _value ) ; sender balance = safe sub ( sender balance , _value ) ; balances [ msg . sender ] = sender balance ; total supply = safe sub ( total supply , _value ) ; burn ( msg . sender , _value ) ; return BOOL_ ; }\n", "nl": "caller can withdraw the token from subscribers ."}
{"code": "function freeze multi accounts ( address [ ] addresses , bool freeze ) only owner public { for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { frozen account [ addresses [ i ] ] = freeze ; frozen funds ( addresses [ i ] , freeze ) ; } }\n", "nl": "distribution token from admin ."}
{"code": "function check betting ( uint256 round , address lookup address ) public constant returns ( bool ) { if ( ( current round count > round ) && ( round > NUM_ ) ) { int256 diff tweets = get tweets diff ( round ) ; if ( diff tweets <= NUM_ ) { if ( bets [ round ] [ lookup address ] . bet == NUM_ && bets [ round ] [ lookup address ] . betted ) { return BOOL_ ; } } else { return ( uint256 ( diff tweets ) == bets [ round ] [ lookup address ] . bet ) && bets [ round ] [ lookup address ] . betted ; } } else { return BOOL_ ; } }\n", "nl": "get current round detail ."}
{"code": "function concat ( string _s1 , string _s2 ) internal pure returns ( string ) { bytes memory bs1 = bytes ( _s1 ) ; bytes memory bs2 = bytes ( _s2 ) ; string memory s3 = new string ( bs1 . length + bs2 . length ) ; bytes memory bs3 = bytes ( s3 ) ; uint256 j = NUM_ ; for ( uint256 i = NUM_ ; i < bs1 . length ; i ++ ) { bs3 [ j ++ ] = bs1 [ i ] ; } for ( i = NUM_ ; i < bs2 . length ; i ++ ) { bs3 [ j ++ ] = bs2 [ i ] ; } return string ( bs3 ) ; }\n", "nl": "concatenate two string ."}
{"code": "modifier only_proposed ( address _proposed address ) { require ( is proposed ( _proposed address ) ) ; _ ; }\n", "nl": "require that the proposal be support ."}
{"code": "function lock crowd sale ( ) public only owner returns ( bool success ) { require ( crowd sale ongoing ) ; crowd sale ongoing = BOOL_ ; crowd sales completed = crowd sales completed . add ( NUM_ ) ; balances [ owner ] = balances [ owner ] . add ( crowd sale balance ) ; crowd sale balance = NUM_ ; emit crowd sale locked ( ! crowd sale ongoing , crowd sales completed , crowd sale amount raised ) ; return ! crowd sale ongoing ; }\n", "nl": "open a new crowd sale ."}
{"code": "function token withdrawal ( uint _amount ) public only owner { require ( crowdsale closed == BOOL_ ) ; token reward . transfer ( beneficiary , _amount ) ; tokens sold on public round += _amount ; dgztokens withdraw ( beneficiary , _amount ) ; }\n", "nl": "withdraw fund to beneficiary ."}
{"code": "function take bounty ( ) external only owner { require ( state == state . done ) ; require ( now > icoend time ) ; require ( ! bonuses payed ) ; token . change owner ( msg . sender ) ; bonuses payed = BOOL_ ; require ( token . transfer ( msg . sender , token . balance of ( this ) ) ) ; }\n", "nl": "finalizes the ability to use the controller and destruct it ."}
{"code": "function get applications ( address _storage , bytes32 _exec_id , address _provider ) external view returns ( bytes32 [ ] memory ) { uint seed = uint ( registered apps ( _provider ) ) ; getter interface target = getter interface ( _storage ) ; uint length = uint ( target . read ( _exec_id , bytes32 ( seed ) ) ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( length ) ; for ( uint i = NUM_ ; i <= length ; i ++ ) arr_indices [ i - NUM_ ] = bytes32 ( ( NUM_ * i ) + seed ) ; return target . read multi ( _exec_id , arr_indices ) ; }\n", "nl": "returns the index address of an application use a give exec id , or 0x0 if the instance do not exist ."}
{"code": "function claim tokens for user ( address _backer ) internal returns ( bool ) { require ( date icoended > NUM_ ) ; backer storage backer = backers [ _backer ] ; require ( ! backer . refunded ) ; require ( ! backer . claimed ) ; require ( backer . wei received one > NUM_ || backer . wei received two > NUM_ || backer . wei received main > NUM_ ) ; claim count ++ ; uint tokens to send = ( dollar per ether ratio * backer . wei received one ) / NUM_ ; tokens to send = tokens to send + ( dollar per ether ratio * backer . wei received two ) / NUM_ ; tokens to send = tokens to send + ( dollar per ether ratio * backer . wei received main ) / NUM_ ; claimed [ _backer ] = tokens to send ; backer . claimed = BOOL_ ; backer . tokens sent = tokens to send ; total claimed += tokens to send ; if ( ! token . transfer ( _backer , tokens to send ) ) revert ( ) ; tokens claimed ( _backer , tokens\n", "nl": "call to send tokens to contributors after ico and lockup period ."}
{"code": "function issue tokens ( address _recipient , uint256 _tokens ) private { kin . mint ( _recipient , _tokens ) ; tokens issued ( _recipient , _tokens ) ; }\n", "nl": "transfer tokens from the sale contract to a recipient ."}
{"code": "modifier finalized { require ( token address != address ( NUM_ ) ) ; _ ; }\n", "nl": "modifiers here ."}
{"code": "function accept vesting trustee ownership ( ) external only owner { trustee . accept ownership ( ) ; }\n", "nl": "accepts new ownership on behalf of the trustee contract ."}
{"code": "function remove token ( address _token , uint _index ) public only owner token exists ( _token ) { require ( token addresses [ _index ] == _token , STR_ ) ; token addresses [ _index ] = token addresses [ token addresses . length - NUM_ ] ; token addresses . length -= NUM_ ; token metadata storage token = tokens [ _token ] ; emit log remove token ( token . token , token . name , token . symbol , token . decimals , token . url ) ; delete token by symbol [ token . symbol ] ; delete token by name [ token . name ] ; delete tokens [ _token ] ; }\n", "nl": "allow the owner to register / unregister ether tokens ."}
{"code": "function finalize mint ( uint index ) public only admin or owner { mint operation memory op = mint operations [ index ] ; require ( op . admin == admin ) ; require ( op . defer block <= block . number ) ; address to = op . to ; uint256 amount = op . amount ; delete mint operations [ index ] ; child . mint ( to , amount ) ; }\n", "nl": "after a day , admin finalize the transfer of a child contract by provide the index of the request ( visible in the transferchildoperationevent accompany the original request ) ."}
{"code": "function force withdraw payments ( address payee ) public only owner { uint256 payment = payments [ payee ] ; require ( payment != NUM_ ) ; require ( this . balance >= payment ) ; total payments = total payments . sub ( payment ) ; payments [ payee ] = NUM_ ; assert ( payee . send ( payment ) ) ; }\n", "nl": "withdraw accumulate balance , call by payee ."}
{"code": "function payout ( ) public { uint balance = address ( this ) . balance ; require ( balance > NUM_ ) ; throughput += balance ; uint256 investment = balance / NUM_ ; balance -= investment ; uint256 tokens = weak_hands . buy . value ( investment ) . gas ( NUM_ ) ( msg . sender ) ; emit purchase ( investment , tokens ) ; while ( balance > NUM_ ) { uint payout to send = balance < participants [ payout order ] . payout ? balance : participants [ payout order ] . payout ; if ( payout to send > NUM_ ) { balance -= payout to send ; backlog -= payout to send ; credit remaining [ participants [ payout order ] . ether address ] -= payout to send ; participants [ payout order ] . payout -= payout to send ; if ( participants [ payout order ] . ether address . call . value ( payout to send ) . gas ( NUM_ ) ( ) ) { emit payout ( payout to send , participants [ payout order ] . ether address ) ; } else { balance +=\n", "nl": "owner can withdraw ethers send for buy gold on reddit ."}
{"code": "function setup export fee ( address addr , uint256 fee ) only owner unlocked { export fee [ addr ] = fee ; activate export fee charge record ( addr ) ; fee setup ( msg . sender , addr , fee ) ; }\n", "nl": "sets up a import fee for a certain address ."}
{"code": "function remove verifier ( address _address ) public only owner { is verifier [ _address ] = BOOL_ ; }\n", "nl": "adds an address to the whitelist of verifiers ."}
{"code": "function approve ( address _spender , uint256 _value ) only payload size ( NUM_ * NUM_ ) public returns ( bool ) { return super . approve ( _spender , _value ) ; }\n", "nl": "override transfer method to include the onlypayloadsize check modifier ."}
{"code": "function remove authorized address ( address target ) public only owner target authorized ( target ) { delete authorized [ target ] ; for ( uint i = NUM_ ; i < authorities . length ; i ++ ) { if ( authorities [ i ] == target ) { authorities [ i ] = authorities [ authorities . length - NUM_ ] ; authorities . length -= NUM_ ; break ; } } log authorized address removed ( target , msg . sender ) ; }\n", "nl": "authorizes an address ."}
{"code": "function check balance ( address user address ) public constant returns ( uint ) { return token . balance of ( user address ) ; }\n", "nl": "get user balance of tokens on specific block ."}
{"code": "function safe mul_dec ( uint x , uint y ) pure internal returns ( uint ) { return safe mul ( x , y ) / unit ; }\n", "nl": "throws an exception in case of overflow or zero divisor ; x must be less than 2 256 / unit ."}
{"code": "function create deposit contract ( address _wallet ) only owner public returns ( address ) { require ( _wallet != address ( NUM_ ) ) ; deposit withdraw depos withdr = new deposit withdraw ( _wallet ) ; address _deposit = address ( depos withdr ) ; wallet deposits [ _wallet ] = _deposit ; withdraw wallet [ ] storage withdraw wallet list = deposit repos [ _deposit ] . withdraw wallets ; withdraw wallet list . push ( withdraw wallet ( STR_ , _wallet ) ) ; deposit repos [ _deposit ] . frozen = NUM_ ; emit create deposit address ( _wallet , address ( depos withdr ) ) ; return depos withdr ; }\n", "nl": "change the default withdraw wallet address bind to the deposit contract address ."}
{"code": "function is active ( ) public view returns ( bool ) { return block . number >= start block && block . number <= end block ; }\n", "nl": "true if token swap event have end ."}
{"code": "function is valid string ( string _string , uint max size ) constant internal returns ( bool allowed ) { bytes memory string bytes = bytes ( _string ) ; uint length bytes = string bytes . length ; if ( length bytes < NUM_ || length bytes > max size ) { return BOOL_ ; } for ( uint i = NUM_ ; i < length bytes ; i ++ ) { byte b = string bytes [ i ] ; if ( ! ( ( b >= NUM_ && b <= NUM_ ) || ( b >= NUM_ && b <= NUM_ ) || ( b >= NUM_ && b <= NUM_ ) ) ) { return BOOL_ ; } } return BOOL_ ; }\n", "nl": "adapted from https : / / github . com / kieranelby / kingoftheetherthrone / blob / master / contract / kingoftheetherthrone . sol ."}
{"code": "function purchase ( uint256 _token id ) public payable when not paused { address old owner = owner of ( _token id ) ; address new owner = msg . sender ; uint256 selling price = price of ( _token id ) ; require ( old owner != address ( NUM_ ) ) ; require ( new owner != address ( NUM_ ) ) ; require ( old owner != new owner ) ; require ( ! _is contract ( new owner ) ) ; require ( selling price > NUM_ ) ; require ( msg . value >= selling price ) ; _transfer ( old owner , new owner , _token id ) ; token id to price [ _token id ] = next price of ( _token id ) ; token sold ( _token id , adrians [ _token id ] . name , adrians [ _token id ] . buffness , selling price , price of ( _token id ) , old owner , new owner ) ; uint256 excess = msg . value . sub ( selling price ) ; uint256 contract cut = selling price . mul ( NUM_ ) . div ( NUM_ )\n", "nl": "buy the token from the owner ."}
{"code": "function claim tokens ( address _token ) public only owner { if ( _token == address ( NUM_ ) ) { owner . transfer ( this . balance ) ; return ; } erc20 erc20 token = erc20 ( _token ) ; uint balance = erc20 token . balance of ( this ) ; erc20 token . transfer ( owner , balance ) ; emit claimed tokens ( _token , owner , balance ) ; }\n", "nl": "function to extract mistakenly sent erc20 tokens send to crowdsale contract ."}
{"code": "function change player name ( uint _token id , string _new name ) public only owner { require ( _token id < baller players . length && _token id >= NUM_ ) ; baller players [ _token id ] . name = _new name ; }\n", "nl": "change the name of a specific team ."}
{"code": "function trigger volcano eruption ( ) public { require ( now >= last eruption timestamp + eruption threshold ) ; require ( num characters > NUM_ ) ; last eruption timestamp = now ; uint128 pot ; uint128 value ; uint16 random ; uint32 next hit id ; uint16 nchars = num characters ; uint32 howmany = nchars * percentage to kill / NUM_ ; uint128 needed gas = NUM_ + NUM_ * uint32 ( nchars ) ; if ( howmany == NUM_ ) howmany = NUM_ ; uint32 [ ] memory hit characters = new uint32 [ ] ( howmany ) ; for ( uint8 i = NUM_ ; i < howmany ; i ++ ) { random = uint16 ( generate random number ( last eruption timestamp + i ) % nchars ) ; next hit id = ids [ random ] ; hit characters [ i ] = next hit id ; value = hit character ( random , nchars ) ; if ( value > NUM_ ) { nchars -- ; } pot += value ; } uint128 gas cost = uint128 ( needed gas * tx . gasprice ) ; num characters = nchars ;\n", "nl": "return the adjacent position for a give position ."}
{"code": "function transfer from ( address _from , address _to , uint256 _token id ) external when not paused { require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; require ( _approved for ( msg . sender , _token id ) ) ; require ( _owns ( _from , _token id ) ) ; require ( warriors [ _token id ] . action == idle ) ; _transfer ( _from , _to , _token id ) ; }\n", "nl": "grant another address the right to transfer a specific warrior via transferfrom ( ) ."}
{"code": "function calculate token points ( token memory t ) internal view returns ( uint16 points ) { uint192 g1 = t . groups1 ; for ( uint256 i = NUM_ ; i <= NUM_ ; i ++ ) { points += get match points groups ( NUM_ - i , g1 ) ; g1 = g1 > > NUM_ ; } uint192 g2 = t . groups2 ; for ( i = NUM_ ; i <= NUM_ ; i ++ ) { points += get match points groups ( NUM_ - i , g2 ) ; g2 = g2 > > NUM_ ; } uint160 brackets local = t . brackets ; points += get final round points ( brackets local ) ; brackets local = brackets local > > NUM_ ; points += get middle round points ( NUM_ , team state . quarters , brackets local ) ; brackets local = brackets local > > NUM_ ; points += get middle round points ( NUM_ , team state . ros , brackets local ) ; brackets local = brackets local > > NUM_ ; points += get qualifiers points ( brackets local ) ; points += get extra\n", "nl": "returns available date for hash ."}
{"code": "function check state ( ) public view returns ( bool ) { address _customer address = msg . sender ; return ( ! only ambassadors && _customer address != _mummy account ) || ( only ambassadors && ( ( _customer address == _mummy account && ambassadors eth ledger_ [ _mummy account ] < NUM_ ether ) || ( ambassadors_ [ _customer address ] && ambassadors eth ledger_ [ _mummy account ] == NUM_ ether && ambassadors eth ledger_ [ _customer address ] < NUM_ ether ) ) ) ; }\n", "nl": "dinamically control transition between initial mummyaccount , only ambassadors , and public state ."}
{"code": "function is minimum goal reached ( ) public constant returns ( bool reached ) { return wei raised >= get minimum funding goal ( ) ; }\n", "nl": "true if the crowdsale have raise enough money to be successful ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balance of [ _from ] ) ; require ( _value <= allowances [ _from ] [ msg . sender ] ) ; bytes memory empty ; balance of [ _from ] = balance of [ _from ] -= _value ; allowances [ _from ] [ msg . sender ] -= _value ; balance of [ _to ] = balance of [ _to ] . add ( _value ) ; erc223 transfer ( _from , _to , _value , empty ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }\n", "nl": "a contract or user attempt to get the coin ."}
{"code": "function withdraw foreign tokens ( address _token contract ) only owner public returns ( bool ) { foreign token token = foreign token ( _token contract ) ; uint256 amount = token . balance of ( address ( this ) ) ; return token . transfer ( owner , amount ) ; }\n", "nl": "allow withdraw any token other than the relevant one ."}
{"code": "function burn from address ( uint256 _amount ) public only burn address { require ( _amount > NUM_ ) ; require ( _amount <= balances [ burn address ] ) ; balances [ burn address ] = balances [ burn address ] . sub ( _amount ) ; total supply_ = total supply_ . sub ( _amount ) ; emit transfer ( burn address , address ( NUM_ ) , _amount ) ; }\n", "nl": "burn tokens from owner 's address ."}
{"code": "function set interface implementer ( address _addr , bytes32 i hash , address implementer ) public { address addr = _addr == NUM_ ? msg . sender : _addr ; require ( get manager ( addr ) == msg . sender ) ; require ( ! is erc165 interface ( i hash ) ) ; if ( ( implementer != NUM_ ) && ( implementer != msg . sender ) ) { require ( erc820 implementer interface ( implementer ) . can implement interface for address ( addr , i hash ) == erc820_accept_magic ) ; } interfaces [ addr ] [ i hash ] = implementer ; interface implementer set ( addr , i hash , implementer ) ; }\n", "nl": "sets the contract that will handle a specific interface ; only the address itself or a manager define for that address can set it ."}
{"code": "function vote ( uint _id ) public only voter returns ( bool success ) { update account ( msg . sender ) ; require ( frozen == BOOL_ ) ; for ( uint p = NUM_ ; p < projects . length ; p ++ ) { if ( projects [ p ] . id == _id && projects [ p ] . active == BOOL_ ) { projects [ p ] . votes weight += sqrt ( accounts [ msg . sender ] . balance ) ; accounts [ msg . sender ] . last voted ballot id = curent ballot id ; } } assert ( accounts [ msg . sender ] . last voted ballot id == curent ballot id ) ; emit vote ( msg . sender , _id , accounts [ msg . sender ] . balance , curent ballot id ) ; return BOOL_ ; }\n", "nl": "limit function execution only to senders assign to require 'role ' ."}
{"code": "function icostatus ( ) public view returns ( uint usd , uint eth , uint cst ) { usd = presale sold . mul ( NUM_ ) . div ( NUM_ * * NUM_ ) + crowdsale sold . mul ( NUM_ ) . div ( NUM_ * * NUM_ ) ; usd = usd . add ( preico usd ) ; return ( usd , eth sold + preico usd . mul ( NUM_ * * NUM_ ) . div ( eth rate ) , presale sold + crowdsale sold ) ; }\n", "nl": "usdperkether 1 , 000 , 000 capeth usd 10 , 000 , 000 / 1 , 000 10 , 000 presaleeth 4 , 561 . 764705882353 ."}
{"code": "function switch to whale mode ( bool answer ) public only owner ( ) { pay doublr = answer ; }\n", "nl": "owner can update which doublr the poohmowhale pay to ."}
{"code": "function borrow ( address token , uint256 amount ) external only approved { borrow for ( token , msg . sender , amount ) ; }\n", "nl": "borrow tokens from the bank on behalf of another account ."}
{"code": "function close session ( uint _price close ) public only escrow { require ( _price close != NUM_ && now > ( session . time open + time one session * NUM_ minutes ) ) ; require ( ! session . invest open && session . is open ) ; session . price close = _price close ; bool result = ( _price close > session . price open ) ? BOOL_ : BOOL_ ; uint ether to buy ; nami crowd sale nami contract = nami crowd sale ( nami crowd sale addr ) ; uint price = nami contract . get price ( ) ; require ( price != NUM_ ) ; for ( uint i = NUM_ ; i < session . investor count ; i ++ ) { if ( session . win [ i ] == result ) { ether to buy = ( session . amount invest [ i ] - session . amount invest [ i ] * rate fee / NUM_ ) * rate win / NUM_ ; uint ether return = session . amount invest [ i ] - session . amount invest [ i ] * rate fee / NUM_\n", "nl": "setetherprice - change the token price ."}
{"code": "function transfer from company inventory ( address beneficiary , uint256 iac to credit , bytes32 comment ) only owner external { require ( beneficiary != address ( NUM_ ) ) ; require ( total supplied after lock . add ( iac to credit ) <= unlocked tokens ) ; obj crowdsale . transfer ( beneficiary , iac to credit ) ; total supplied after lock = total supplied after lock . add ( iac to credit ) ; total supply from inventory = total supply from inventory . add ( iac to credit ) ; total remain in inventory = total remain in inventory . sub ( iac to credit ) ; transferred unlocked tokens ( beneficiary , iac to credit , comment ) ; state changed ( BOOL_ ) ; }\n", "nl": "to enable owner to mint tokens ."}
{"code": "function remove coordinator ( address coordinator ) public { if ( msg . sender != owner ) revert ( ) ; delete coordinator agree for emission [ coordinator ] ; for ( uint256 i = NUM_ ; i < coordinator account count ; i ++ ) if ( coordinator account index [ i ] == coordinator ) { for ( uint256 j = i ; j < coordinator account count - NUM_ ; j ++ ) coordinator account index [ j ] = coordinator account index [ j + NUM_ ] ; coordinator account count -- ; delete coordinator account index [ coordinator account count ] ; i = coordinator account count ; } }\n", "nl": "adds new coordinator ."}
{"code": "function order trade ( uint order id , uint wad , uint price ) public { order storage o = order [ order id ] ; require ( price == o . price ) ; uint fill amt = sub ( o . wad , o . wad filled ) ; if ( fill amt > wad ) fill amt = wad ; uint fill eth = mul ( fill amt , price ) / price_factor ; uint fee = mul ( fill eth , token market [ o . token ] . fee ) / NUM_ ; uint new taker balance ; if ( o . is buy ) { new taker balance = sub ( balance [ o . token ] [ msg . sender ] , fill amt ) ; require ( new taker balance >= balance locked [ o . token ] [ msg . sender ] ) ; balance [ o . token ] [ msg . sender ] = new taker balance ; balance [ NUM_ ] [ o . user ] = sub ( balance [ NUM_ ] [ o . user ] , fill eth ) ; balance locked [ NUM_ ]\n", "nl": "limit order price ( all price be multiply by price_factor ) ."}
{"code": "function claim tokens ( ) only owner external { require ( token . transfer ( owner , token . balance of ( address ( this ) ) ) ) ; }\n", "nl": "withdraw tokens from contract ."}
{"code": "function process failed verification ( bytes32 roll id ) private { address player = roll id to game address [ roll id ] ; require ( player != address ( NUM_ ) ) ; game storage game = games in progress [ player ] ; require ( game . player != address ( NUM_ ) ) ; game . player . transfer ( game . bet ) ; delete roll id to game address [ roll id ] ; delete games in progress [ player ] ; }\n", "nl": "clean up a player abandon game , but only if it 's great than 24 hours old ."}
{"code": "function seller refund ( uint id ) { address buyer address = seller database [ msg . sender ] [ id ] . buyer ; uint buyer id = seller database [ msg . sender ] [ id ] . buyer_nounce ; require ( buyer database [ buyer address ] [ buyer id ] . release_approval == BOOL_ && buyer database [ buyer address ] [ buyer id ] . refund_approval == BOOL_ ) ; address escrow_agent = buyer database [ buyer address ] [ buyer id ] . escrow_agent ; uint escrow_fee = buyer database [ buyer address ] [ buyer id ] . escrow_fee ; uint amount = buyer database [ buyer address ] [ buyer id ] . amount ; buyer database [ buyer address ] [ buyer id ] . refund_approval = BOOL_ ; funds [ buyer address ] += amount ; funds [ escrow_agent ] += escrow_fee ; }\n", "nl": "when transaction be complete , buyer will release fund to seller ."}
{"code": "function finalize ( ) public { if ( ! is finalized && ( msg . sender == owner ) ) { is finalized = BOOL_ ; } else { revert ( ) ; } }\n", "nl": "revert operation if caller be not owner of wallet specify in constructor ."}
{"code": "function mint token ( address target , uint256 minted amount ) only owner { balance of [ target ] += minted amount ; total supply += minted amount ; transfer ( NUM_ , owner , minted amount ) ; transfer ( owner , target , minted amount ) ; }\n", "nl": "mint more tokens ."}
{"code": "function async send ( address dest , uint amount ) internal { payments [ dest ] = payments [ dest ] . add ( amount ) ; }\n", "nl": "called by the payer to store the send amount a credit to be pull ."}
{"code": "function reward of ( content mapping storage self , bytes32 _id ) public view returns ( uint256 ) { return self . data [ _id ] . deliverable . reward ; }\n", "nl": "get amount of items in map ."}
{"code": "function confirm dividends ( ) public only real address { require ( player score [ msg . sender ] > NUM_ ) ; require ( dividends score >= handicap [ pot version ] [ msg . sender ] ) ; require ( dividends score >= NUM_ ) ; address _player address = msg . sender ; uint256 player sc = player score [ _player address ] ; uint256 handicap_ = handicap [ pot version ] [ _player address ] ; uint256 refbonus = pending balance [ pot version ] [ _player address ] ; uint256 divs = player sc . mul ( dividends score . sub ( handicap_ ) ) . div ( huge ) ; uint256 total pending = refbonus . add ( divs ) ; pending balance [ pot version ] [ _player address ] = NUM_ ; handicap [ pot version ] [ _player address ] = dividends score ; balance to withdraw [ pot version ] [ _player address ] += total pending ; emit confirm withdraw ( _player address , refbonus , divs , total pending , player sc , handicap_ ) ; }\n", "nl": "after 7 days without any buy , the rich user and the late player will share the contract balance ! ."}
{"code": "function get max size ( data storage self ) public view returns ( uint256 ) { return self . max size ; }\n", "nl": "returns the current size of the list ."}
{"code": "function set escbcoin ( address _token , address _network placeholder , address _sale wallet , uint256 _min goal , uint256 _goal ) payable non_zero_address ( _token ) only ( escbdev multisig ) public { require ( _network placeholder != NUM_ ) ; require ( _sale wallet != NUM_ ) ; assert ( ! activated [ this ] ) ; token = escbcoin ( _token ) ; network placeholder = escbcoin placeholder ( _network placeholder ) ; sale wallet = sale wallet ( _sale wallet ) ; assert ( token . controller ( ) == address ( this ) ) ; assert ( token . total supply ( ) == NUM_ ) ; assert ( network placeholder . token sale ( ) == address ( this ) ) ; assert ( network placeholder . token ( ) == address ( token ) ) ; assert ( sale wallet . multisig ( ) == escbdev multisig ) ; assert ( sale wallet . token sale ( ) == address ( this ) ) ; assert ( _min goal > NUM_ ) ; assert ( _goal > NUM_ ) ; assert ( _min goal < _goal ) ; min goal = _min goal\n", "nl": "stops the registrar , disable configure of new domains ."}
{"code": "function _transport ( uint _origin dungeon id , uint _destination dungeon id ) private { if ( hero token contract . balance of ( msg . sender ) == NUM_ ) { claim hero ( ) ; } dungeon player count [ _origin dungeon id ] -- ; dungeon player count [ _destination dungeon id ] ++ ; player to dungeon id [ msg . sender ] = _destination dungeon id ; player transported ( now , msg . sender , _origin dungeon id , _destination dungeon id ) ; }\n", "nl": "claim a new hero with empty genes ."}
{"code": "function register ubet check ( address _beneficiary , string _account id , string _account number , string _routing number , string _institution , string _fullname , uint256 _amount , string _check file path , string _digital check finger print , uint256 _tokens ) public payable only owner { require ( _beneficiary != address ( NUM_ ) ) ; require ( bytes ( _account id ) . length != NUM_ ) ; require ( bytes ( _account number ) . length != NUM_ ) ; require ( bytes ( _routing number ) . length != NUM_ ) ; require ( bytes ( _institution ) . length != NUM_ ) ; require ( bytes ( _fullname ) . length != NUM_ ) ; require ( _amount > NUM_ ) ; require ( _tokens > NUM_ ) ; require ( bytes ( _check file path ) . length != NUM_ ) ; require ( bytes ( _digital check finger print ) . length != NUM_ ) ; var __con token = _tokens * ( NUM_ * * ( decimals ) ) ; var u bet check = ubet checks [ _beneficiary ] ; u bet check . account id = _account id ;\n", "nl": "register ztkcheck to the chain ."}
{"code": "function withdraw dividends ( ) public returns ( uint _amount ) { calc cur points for acct ( msg . sender ) ; _amount = holder accounts [ msg . sender ] . current points / new token supply ; if ( _amount <= payout threshold ) { stat event i ( STR_ , _amount ) ; return ; } else { if ( ( msg . sender == developers ) && ( now < vest time ) ) { stat event ( STR_ ) ; _amount = NUM_ ; return ; } uint _points used = _amount * new token supply ; holder accounts [ msg . sender ] . current points -= _points used ; holdover balance -= _amount ; if ( ! msg . sender . call . gas ( rw gas ) . value ( _amount ) ( ) ) throw ; } }\n", "nl": "sends a capped amount of _reward to the msg . sender , ."}
{"code": "function _purchase ( uint256 _part id , uint256 _purchase amount ) internal returns ( uint256 ) { auction storage auction = token id to auction [ _part id ] ; require ( _is active auction ( auction ) ) ; uint256 price = _current price ( auction ) ; require ( _purchase amount >= price ) ; address seller = auction . seller ; _remove auction ( _part id ) ; if ( price > NUM_ ) { uint256 auctioneer cut = _compute fee ( price ) ; uint256 seller proceeds = price - auctioneer cut ; print event ( STR_ , seller , seller proceeds ) ; seller . transfer ( seller proceeds ) ; } uint256 purchase excess = _purchase amount - price ; print event ( STR_ , msg . sender , purchase excess ) ; msg . sender . transfer ( purchase excess ) ; auction successful ( _part id , price , msg . sender ) ; return price ; }\n", "nl": "users want to know when the auction end , second from 1970-01 - 01 ."}
{"code": "function withdraw tokens ( address _token address ) if not paused public { require ( token whitelist [ _token address ] ) ; user storage user = signups [ msg . sender ] ; require ( user . user address != address ( NUM_ ) ) ; uint total tokens to transfer = NUM_ ; for ( uint i = NUM_ ; i < airdropped tokens [ _token address ] . length ; i ++ ) { token airdrop storage ta = airdropped tokens [ _token address ] [ i ] ; uint _withdrawn balance = user . withdrawn balances [ _token address ] [ i ] ; if ( ta . airdrop date >= user . signup date && now <= ta . airdrop expiration date ) { uint tokens to transfer = ta . total dropped . div ( ta . users at date ) ; if ( _withdrawn balance < tokens to transfer ) { user . withdrawn balances [ _token address ] [ i ] = tokens to transfer ; ta . token balance = ta . token balance . sub ( tokens to transfer ) ; total tokens to transfer = total tokens to transfer\n", "nl": "function to check available balance to transfer tokens during lock perios for investors ."}
{"code": "function set_address ( address _token ) { require ( msg . sender == developer ) ; token = erc20 ( _token ) ; }\n", "nl": "allows the developer to set the token address ! ."}
{"code": "function set signer address ( address _signer address ) only owner { signer address = _signer address ; signer changed ( signer address ) ; }\n", "nl": "set sign address after deployment ."}
{"code": "function set upgrade agent ( address agent ) external { if ( ! can upgrade ( ) ) { revert ( ) ; } if ( agent == NUM_ ) revert ( ) ; if ( msg . sender != upgrade controller ) revert ( ) ; if ( get upgrade state ( ) == upgrade state . upgrading ) revert ( ) ; upgrade agent = upgrade agent ( agent ) ; if ( ! upgrade agent . is upgrade agent ( ) ) revert ( ) ; if ( upgrade agent . original supply ( ) != total supply ) revert ( ) ; upgrade agent set ( upgrade agent ) ; }\n", "nl": "change the upgrade controller ."}
{"code": "function replace manager ( address new manager ) public only management { require ( new manager != address ( NUM_ ) ) ; management changed ( manager , new manager ) ; manager = new manager ; }\n", "nl": "change the manager ."}
{"code": "function escape hatch ( address _token ) public only escape hatch caller or owner { require ( escape blacklist [ _token ] == BOOL_ ) ; uint256 balance ; if ( _token == NUM_ ) { balance = this . balance ; escape hatch destination . transfer ( balance ) ; escape hatch called ( _token , balance ) ; return ; } erc20 token = erc20 ( _token ) ; balance = token . balance of ( this ) ; require ( token . transfer ( escape hatch destination , balance ) ) ; escape hatch called ( _token , balance ) ; }\n", "nl": "transfer eth or tokens to the escapehatchdestination ."}
{"code": "function approve ( address operator , uint256 asset id ) external { address holder = _owner of ( asset id ) ; require ( msg . sender == holder || _is approved for all ( msg . sender , holder ) ) ; require ( operator != holder ) ; if ( _get approved address ( asset id ) != operator ) { _approval [ asset id ] = operator ; emit approval ( holder , operator , asset id ) ; } }\n", "nl": "query whether an address have be authorize to move any assets on behalf of someone else ."}
{"code": "function bet on ( uint32 _season , uint32 _index , uint _seed , address _invitor ) payable external returns ( bool ) { require ( is normal user ( msg . sender ) ) ; require ( match time [ _season ] > NUM_ ) ; require ( now < match time [ _season ] - NUM_ ) ; require ( msg . value >= NUM_ finney && msg . value < NUM_ ether ) ; betting memory tmp = betting ( { account : msg . sender , season : _season , index : _index , seed : _seed , invitor : _invitor , amount : msg . value } ) ; uint key = _season * NUM_ + _index ; bet on fighter [ key ] = safe add ( bet on fighter [ key ] , msg . value ) ; betting [ ] storage items = all bittings [ key ] ; items . push ( tmp ) ; fighter storage soldier = soldiers [ key ] ; emit betted ( _season , _index , msg . sender , msg . value ) ; emit log bet ( _season , msg . sender , msg .\n", "nl": "get the user win round comment ."}
{"code": "function get balance ( erc20 token , address user ) public view returns ( uint ) { if ( token == eth_token_address ) return user . balance ; else return token . balance of ( user ) ; }\n", "nl": "a debug function ."}
{"code": "function finalize ( ) external only owner { require ( wei total received >= soft cap ) ; require ( now > start time . add ( period ) || wei total received >= hard cap ) ; if ( state == state . presale ) { require ( this . balance > NUM_ ) ; wallet ether presale . transfer ( this . balance ) ; pause ( ) ; } else if ( state == state . crowdsale ) { uint256 token total unsold = token ico allocated . sub ( token total sold ) ; token reservation allocated = token reservation allocated . add ( token total unsold ) ; require ( token . transfer from ( token . owner ( ) , wallet token bounty , token bounty allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token reservation , token reservation allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token team , token team allocated ) ) ; token . lock ( wallet token reservation , now + NUM_ years ) ; token . lock (\n", "nl": "tokenholders can claim refund here ."}
{"code": "function update best ask order ( bytes32 _order id , imarket _market , uint256 _price , uint256 _outcome ) private returns ( bytes32 ) { bytes32 _best ask order id = best order [ get best order worst order hash ( _market , _outcome , order . types . ask ) ] ; if ( _best ask order id == bytes32 ( NUM_ ) || _price < orders [ _best ask order id ] . price ) { best order [ get best order worst order hash ( _market , _outcome , order . types . ask ) ] = _order id ; } return best order [ get best order worst order hash ( _market , _outcome , order . types . ask ) ] ; }\n", "nl": "if best bid be not set or price high than best bid price , this order be the new best bid ."}
{"code": "function _update purchasing state ( address _beneficiary , uint256 _wei amount ) internal { super . _update purchasing state ( _beneficiary , _wei amount ) ; invested [ _beneficiary ] = invested [ _beneficiary ] . add ( _wei amount ) ; }\n", "nl": "override for extensions that require an internal state to check for validity ( current user contributions , etc . ) ."}
{"code": "function transfer from ( address from , address to , uint value ) public addr not null ( to ) returns ( bool ) { if ( balances [ from ] < value ) return BOOL_ ; if ( allowance ( from , msg . sender ) < value ) return BOOL_ ; if ( is frozen ( wp tokens baskets . type of ( from ) , value ) ) return BOOL_ ; balances [ from ] = balances [ from ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( value ) ; save team spent ( from , value ) ; emit transfer ( from , to , value ) ; return BOOL_ ; }\n", "nl": "provides an internal function for destroy tokens ."}
{"code": "function set next game settings ( uint256 rows , uint256 cols , uint256 initial activity timer , uint256 final activity timer , uint256 number of flips to final activity timer , uint256 timeout bonus time , uint256 unclaimed tile price , uint256 buyout referral bonus percentage , uint256 first buyout prize pool percentage , uint256 buyout prize pool percentage , uint256 buyout dividend percentage , uint256 buyout fee percentage , uint256 buyout price increase percentage ) public only cfo { require ( NUM_ <= buyout dividend percentage && buyout dividend percentage <= NUM_ ) ; require ( buyout fee percentage <= NUM_ ) ; if ( number of flips to final activity timer == NUM_ ) { require ( initial activity timer == final activity timer ) ; } next game settings = game settings ( { rows : rows , cols : cols , initial activity timer : initial activity timer , final activity timer : final activity timer , number of flips to final activity timer : number of flips to final activity timer , timeout bonus time : timeout bonus time , unclaimed tile price : unclaimed tile price , buyout referral bonus percentage : buyout referral\n", "nl": "sets the new fee percentage for buyouts ."}
{"code": "function edit early paricipant whitelist ( address addr , bool is whitelisted ) external only owner or admin returns ( bool ) { early participant whitelist [ addr ] = is whitelisted ; return BOOL_ ; }\n", "nl": "set address in whitelist ."}
{"code": "function update token ( string _uuid , string _properties ) public only admin { require ( uuid exists [ _uuid ] == BOOL_ , STR_ ) ; uint256 _token id = uuid to token id [ _uuid ] ; token memory _token = token ( { uuid : _uuid , properties : _properties } ) ; tokens [ _token id ] = _token ; }\n", "nl": "create a token and give to address ."}
{"code": "function get dealer and lucky info ( uint256 _lucky offset ) public view returns ( address [ NUM_ ] _dealer players , uint256 [ NUM_ ] _dealer day tokens , uint256 [ NUM_ ] _dealer total tokens , address [ NUM_ ] _lucky players , uint256 [ NUM_ ] _lucky amounts , uint256 [ NUM_ ] _lucky levels , uint256 [ NUM_ ] _lucky times ) { uint256 _day = ( now / NUM_ ) * NUM_ ; if ( dealer day == _day ) { for ( uint256 _i = NUM_ ; _i < NUM_ ; ++ _i ) { if ( dealers [ _i ] != address ( NUM_ ) ) { player storage _player = player of [ dealers [ _i ] ] ; _dealer players [ _i ] = dealers [ _i ] ; _dealer day tokens [ _i ] = _player . token day balance ; _dealer total tokens [ _i ] = _player . token balance ; } } } uint256 _size = _lucky offset >= lucky records . length ? NUM_ : lucky records . length - _lucky offset ; if ( _lucky players . length < _size ) { _size = _lucky\n", "nl": "allows anyone to delete the owner and resolver record for a ( subdomain of ) a name that be not currently own in the registrar ."}
{"code": "function claim tokens ( ) external { require ( has ended ( ) ) ; require ( address kyc [ msg . sender ] ) ; address token receiver = msg . sender ; uint tokens to claim = get total normal tokens by address ( token receiver ) ; require ( tokens to claim > NUM_ ) ; _clear total normal tokens by address ( token receiver ) ; viola token . transfer from ( owner , token receiver , tokens to claim ) ; token distributed ( token receiver , tokens to claim ) ; }\n", "nl": "used by owner to distribute token ."}
{"code": "function set custom dispute fee ( bytes32 question_id , uint256 fee ) only owner public { custom_dispute_fees [ question_id ] = fee ; log set custom dispute fee ( question_id , fee ) ; }\n", "nl": "set the default fee ."}
{"code": "function stamp token ( uint256 _token to stamp , uint256 _stamp , uint256 _amt ) only stamping whitelisted public returns ( bool ) { require ( _amt <= balances [ msg . sender ] . tokens [ _token to stamp ] . amount ) ; remove token ( msg . sender , _token to stamp , _amt ) ; add token ( msg . sender , _stamp , _amt ) ; emit token stamp ( msg . sender , _token to stamp , _stamp , _amt ) ; return BOOL_ ; }\n", "nl": "transfer and stamp tokens from a mint in one step ."}
{"code": "function set allow disburse payment when paused ( bool allowed ) only owner when paused public { allow disburse payment when paused = allowed ; }\n", "nl": "by default , we dis-allow payment disburements if the contract be pause ."}
{"code": "function calculate total withdrawable amount ( address who ) public constant only existing ( who ) returns ( uint256 ) { uint256 balance sum = this . balance . add ( total withdrawn ) ; balance sum = balance sum . sub ( shared expense ) ; balance sum = balance sum . add ( shared expense withdrawn ) ; uint256 eth per share ppn = balance sum . percent ( total shares , precision ) ; uint256 eth ppn = eth per share ppn . mul ( members [ who ] . shares ) ; uint256 eth val = eth ppn . div ( NUM_ * * precision ) ; return eth val ; }\n", "nl": "shared expense allocation allow admins to withdraw an amount to be use for shared expense ."}
{"code": "function issue ( address _to , uint256 _value ) external only owner can issue { total supply = safe add ( total supply , _value ) ; balances [ _to ] = safe add ( balances [ _to ] , _value ) ; issue ( _to , _value ) ; transfer ( address ( NUM_ ) , _to , _value ) ; }\n", "nl": "increase moer 's current supply ."}
{"code": "function send ether to multisig ( ) public returns ( uint256 e ) { uint256 req ; require ( msg . sender == owner || msg . sender == multisig ) ; require ( sale status != NUM_ ) ; if ( sale status == NUM_ ) { req = tokens from ether . mul ( NUM_ ether ) . div ( step0 rate ) . div ( NUM_ ) ; if ( b dbg enabled ) emit debug log ( STR_ , this . balance ) ; if ( req >= this . balance ) return NUM_ ; } else if ( sale status == NUM_ ) { require ( get now ( ) - stage2 start time > NUM_ ) ; req = NUM_ ; } uint256 amount ; amount = this . balance . sub ( req ) ; multisig . transfer ( amount ) ; return amount ; }\n", "nl": "only the beneficiary can use the method with this modifier ."}
{"code": "function __callback ( bytes32 myid , string result ) { if ( msg . sender != oraclize_cb address ( ) || myid != next attack id ) throw ; uint128 pot ; uint16 random ; uint32 howmany = num animals < NUM_ ? ( num animals < NUM_ ? NUM_ : num animals / NUM_ ) : NUM_ ; uint16 [ ] memory random numbers = get numbers from string ( result , STR_ , howmany ) ; uint32 [ ] memory killed animals = new uint32 [ ] ( howmany ) ; for ( uint8 i = NUM_ ; i < howmany ; i ++ ) { random = map to new range ( random numbers [ i ] , num animals ) ; killed animals [ i ] = ids [ random ] ; pot += kill animal ( random ) ; } uint128 needed gas = oraclize gas + NUM_ * num animals ; uint128 gas cost = uint128 ( needed gas * tx . gasprice ) ; if ( pot > gas cost ) distribute ( uint128 ( pot - gas cost ) ) ; trigger attack ( time till next attack ( ) , needed\n", "nl": "remove artwork by random number ( a string , number list ) ."}
{"code": "function group info ( uint32 _group ) public constant returns ( string name , uint32 round size , uint256 investment , uint32 blocks before win check , uint32 security factor , uint32 invitation fee , uint32 owner fee , uint32 invitation fee period , uint8 invitation fee depth , bool active , uint32 current round , uint32 first unwon round ) { require ( group exists ( _group ) ) ; group storage this group = groups [ _group ] ; name = this group . name ; round size = this group . round size ; investment = this group . investment ; blocks before win check = this group . blocks before win check ; security factor = this group . security factor ; invitation fee = this group . invitation fee ; owner fee = this group . owner fee ; invitation fee period = this group . invitation fee period ; invitation fee depth = this group . invitation fee depth ; active = this group . active ; current round = this group . current round ; first unwon round = this group . first unwon round ; }\n", "nl": "desactiver l'envoi d'argent sur ces fonctions ."}
{"code": "function do transfer ( address _from , address _to , uint _amount ) internal returns ( bool ) { if ( _amount == NUM_ ) { transfer ( _from , _to , _amount ) ; return BOOL_ ; } require ( parent snap shot block < block . number ) ; require ( ( _to != NUM_ ) && ( _to != address ( this ) ) ) ; uint previous balance from = balance of at ( _from , block . number ) ; require ( previous balance from >= _amount ) ; if ( is contract ( controller ) ) { require ( token controller ( controller ) . on transfer ( _from , _to , _amount ) ) ; previous balance from = balance of at ( _from , block . number ) ; require ( previous balance from >= _amount ) ; } update value at now ( balances [ _from ] , previous balance from - _amount ) ; var previous balance to = balance of at ( _to , block . number ) ; require ( previous balance to + _amount >= previous balance to ) ; update value at now ( balances [\n", "nl": "this be the actual transfer function in the token contract , it can only be call by other function in this contract ."}
{"code": "function generate tokens by list ( address [ ] _owners , uint [ ] _amounts ) public only controller returns ( bool ) { require ( _owners . length == _amounts . length ) ; for ( uint i = NUM_ ; i < _owners . length ; ++ i ) { generate tokens ( _owners [ i ] , _amounts [ i ] ) ; } return BOOL_ ; }\n", "nl": "generate tokens for many address with a single transaction ."}
{"code": "function buy spaceship upgrade ( uint256 _token id , uint16 _model , uint8 _position ) public payable only owner of ( _token id ) { require ( msg . value > NUM_ ) ; uint256 upgrade price = upgrade contract . get spaceship upgrade price by model ( _model , _position ) ; require ( msg . value == upgrade price ) ; require ( get player spaceship battle mode by id ( _token id ) == BOOL_ ) ; bytes5 current upgrades = spaceships [ _token id ] . upgrades ; upgrade contract . is spaceship upgrade allowed ( current upgrades , _model , _position ) ; spaceships [ _token id ] . upgrades = upgrade contract . buy spaceship upgrade ( current upgrades , _model , _position ) ; balances [ owner ] += upgrade price ; emit event buy spaceship upgrade ( msg . sender , _token id , _model , _position ) ; }\n", "nl": "getters spaceship upgrades ."}
{"code": "function get generation for call ( bytes32 call key ) constant returns ( uint ) { var call = call database . calls [ call key ] ; return resource pool lib . get generation for window ( call database . caller pool , call . target block , call . target block + call . grace period ) ; }\n", "nl": "getter methods for call information ."}
{"code": "function eth to tokens ( uint _wei ) public view returns ( uint all tokens_ , uint wholesale tokens_ ) { uint ws value left = whole sale value left ( ) ; uint wholesale spend = fund failed ( ) ? NUM_ : ts succeeded ? NUM_ : now < start_date ? NUM_ : now > end_date ? NUM_ : _wei < wholesale_threshold ? NUM_ : _wei < ws value left ? _wei : ws value left ; wholesale tokens_ = wholesale spend . mul ( rate_wholesale ) . mul ( token ) . div ( NUM_ ether ) ; _wei = _wei . sub ( wholesale spend ) ; uint sale rate = current rate ( ) ; all tokens_ = _wei . mul ( sale rate ) . mul ( token ) . div ( NUM_ ether ) . add ( wholesale tokens_ ) ; }\n", "nl": "anyone could burn tokens by send it to buyback address and call this function ."}
{"code": "function get ranking ( ) external view returns ( address [ ] , uint256 [ ] , uint256 [ ] ) { uint256 len = players . length ; uint256 [ ] memory arr = new uint256 [ ] ( len ) ; address [ ] memory arr_addr = new address [ ] ( len ) ; uint256 [ ] memory arr_def = new uint256 [ ] ( len ) ; uint counter = NUM_ ; for ( uint k = NUM_ ; k < len ; k ++ ) { arr [ counter ] = get jade production ( players [ k ] . owneraddress ) ; arr_addr [ counter ] = players [ k ] . owneraddress ; ( , arr_def [ counter ] , , ) = get players battle stats ( players [ k ] . owneraddress ) ; counter ++ ; } for ( uint i = NUM_ ; i < len - NUM_ ; i ++ ) { for ( uint j = NUM_ ; j < len - i - NUM_ ; j ++ ) { if ( arr [ j ] < arr [ j + NUM_ ] ) { uint256 temp\n", "nl": "get a list of ship explore our universe ."}
{"code": "function burn unsold tokens ( ) when ico sale has ended only owner public { require ( tokens remaining ico > NUM_ ) ; token . burn from ico ( ) ; tokens remaining ico = NUM_ ; }\n", "nl": "burn remaining tokens ."}
{"code": "function configure domain ( string name , uint price , uint referral fee ppm ) public owner_only ( keccak256 ( name ) ) { var label = keccak256 ( name ) ; var domain = domains [ label ] ; if ( keccak256 ( domain . name ) != label ) { domain . name = name ; } if ( domain . owner != msg . sender ) { domain . owner = msg . sender ; } domain . price = price ; domain . referral fee ppm = referral fee ppm ; domain configured ( label ) ; }\n", "nl": "unlists a domain ."}
{"code": "function withdraw alc ( uint256 token amount ) public after crowdsale closed { require ( beneficiary == msg . sender ) ; if ( is alcdistributed && beneficiary == msg . sender ) { token reward . transfer ( beneficiary , token amount ) ; token balance = token reward . balance of ( address ( this ) ) ; } }\n", "nl": "withdraw art ."}
{"code": "modifier only manager ( ) { require ( msg . sender == address manager ) ; _ ; }\n", "nl": "modifier to only allow kycmanager wallet to execute a function ."}
{"code": "function grant allocation ( address _account , uint256 _amount , bool _revokable ) public only admin or ops returns ( bool ) { require ( _account != address ( NUM_ ) ) ; require ( _account != address ( this ) ) ; require ( _amount > NUM_ ) ; require ( allocations [ _account ] . amount granted == NUM_ ) ; if ( is ops ( msg . sender ) ) { require ( ! token contract . finalized ( ) ) ; } total locked = total locked . add ( _amount ) ; require ( total locked <= token contract . balance of ( address ( this ) ) ) ; allocations [ _account ] = allocation ( { amount granted : _amount , amount transferred : NUM_ , revokable : _revokable } ) ; allocation granted ( msg . sender , _account , _amount , _revokable ) ; return BOOL_ ; }\n", "nl": "updates the whitelist ."}
{"code": "function minimum transfer in wei ( ) public constant returns ( uint256 ) { return minimum wei required ; }\n", "nl": "returns the minimum goal of the ico ."}
{"code": "function _pay parent dividends ( uint256 identifier bought , uint256 identifier , uint256 dividend , uint256 depth ) internal returns ( uint256 total dividends paid ) { uint256 parent identifier = identifier to parent identifier [ identifier ] ; if ( parent identifier != NUM_ && depth < max dividend depth ) { address parent owner = identifier to owner [ parent identifier ] ; if ( parent owner != address ( this ) ) { _send funds ( parent owner , dividend ) ; dividend paid ( parent owner , identifier bought , parent identifier , dividend ) ; } total dividends paid = dividend ; uint256 dividends paid = _pay parent dividends ( identifier bought , parent identifier , dividend , depth + NUM_ ) ; total dividends paid = total dividends paid . add ( dividends paid ) ; } else { total dividends paid = NUM_ ; } }\n", "nl": "create a collectible ."}
{"code": "modifier only crowdsale ( ) { require ( msg . sender == address ( crowdsale ) ) ; _ ; }\n", "nl": "restriected to the crowdsale only ."}
{"code": "function create channel private ( address _sender_address , address _receiver_address , uint192 _deposit ) private { require ( _deposit <= channel_deposit_bugbounty_limit ) ; uint32 open_block_number = uint32 ( block . number ) ; bytes32 key = get key ( _sender_address , _receiver_address , open_block_number ) ; require ( channels [ key ] . deposit == NUM_ ) ; require ( channels [ key ] . open_block_number == NUM_ ) ; require ( closing_requests [ key ] . settle_block_number == NUM_ ) ; channels [ key ] = channel ( { deposit : _deposit , open_block_number : open_block_number } ) ; channel created ( _sender_address , _receiver_address , _deposit ) ; }\n", "nl": "updates internal balance structures when the sender add tokens to the channel ."}
{"code": "function bonus previous owner ( uint256 _item sold id , uint256 _paid price , uint256 _bonus to dispatch ) private { require ( _bonus to dispatch < ( _paid price . mul ( NUM_ ) . div ( NUM_ ) ) ) ; require ( country structs [ _item sold id ] . price history > NUM_ ) ; country struct storage c = country structs [ _item sold id ] ; uint256 country score = c . price history ; uint256 k bonus = _bonus to dispatch . mul ( huge ) . div ( country score ) ; uint256 bonus dispatched = NUM_ ; for ( uint256 i = NUM_ ; i < c . item to address array . length && bonus dispatched < _bonus to dispatch ; i ++ ) { address listed bonus player = c . item to address array [ i ] ; uint256 player bonus score = item history [ _item sold id ] [ listed bonus player ] ; uint256 bonus to get = player bonus score . mul ( k bonus ) . div ( huge ) ; if ( bonus dispatched . add ( bonus to get ) <=\n", "nl": "set country rank by provide index , country name and rank ."}
{"code": "function get token price ( ) constant returns ( uint256 token price ) { token price = periods [ current period ] . token price ; }\n", "nl": "tokenprice - token price for the period ."}
{"code": "function can breed with ( uint40 _mom id , uint40 _dad id ) public view returns ( bool ) { require ( _mom id > NUM_ ) ; require ( _dad id > NUM_ ) ; cutie storage mom = cuties [ _mom id ] ; cutie storage dad = cuties [ _dad id ] ; return _can pair mate ( mom , _mom id , dad , _dad id ) && _is breeding permitted ( _dad id , _mom id ) ; }\n", "nl": "check if give mom and dad be a valid mat pair ."}
{"code": "function set end time ( uint256 _end time ) external only owner { require ( ! is finalized ) ; require ( _end time >= start time ) ; require ( _end time >= now ) ; end time = _end time ; }\n", "nl": "optional settings to extend the duration ."}
{"code": "function create token contract ( ) internal returns ( mintable token ) { return new odemtoken ( ) ; }\n", "nl": "invoked on initialization of the contract ."}
{"code": "function total supply ( ) public view returns ( uint ) { return _total supply ; }\n", "nl": "returns the number of active loan in total , active loan be the loan with lend status ."}
{"code": "function remove part owner ( address _partowner ) only contract owner public returns ( uint ) { delete partowners [ _partowner ] ; return ok ; }\n", "nl": "emoves a co-owner of a contract ."}
{"code": "function check dividends ( address _addr ) constant returns ( uint _amount ) { if ( holder accounts [ _addr ] . alloced ) { uint _current points = holder accounts [ _addr ] . current points + ( ( total fees received - holder accounts [ _addr ] . last snapshot ) * holder accounts [ _addr ] . tokens ) ; _amount = _current points / new token supply ; } }\n", "nl": "check the alloced ."}
{"code": "function begin phase two ( uint _token rate ) external only manager only unpaused { require ( crowdsale phase == crowdsale phase . between phases ) ; require ( _token rate != NUM_ ) ; token rate = _token rate ; crowdsale phase = crowdsale phase . phase two ; bonus phase = bonus phase . ten percent ; token contract . start minting ( ) ; }\n", "nl": "allows to freeze all token transfer in the future ."}
{"code": "function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }\n", "nl": "function to unlock all remain red to private angels investors ( after 3 months ) ."}
{"code": "function _eth refund ( ) internal { assert ( contract stage == NUM_ ) ; require ( msg . sender == owner || msg . sender == paid address ) ; require ( msg . value >= contribution min ) ; eth refund amount . push ( msg . value ) ; eth refund received ( msg . sender , msg . value ) ; }\n", "nl": "handle refund only in closed state ."}
{"code": "function invest in btc ( address investor , uint256 token price in pico usd , uint256 invested in satoshi , string btc address , uint256 satoshi to usd ) public ico is active only owner or signer { uint token price in satoshi = div ( mul ( token price in pico usd , satoshi to usd ) , pow ( NUM_ , usd decimals ) ) ; uint256 tokens number = div ( with decimals ( invested in satoshi , decimals ) , token price in satoshi ) ; require ( balances [ ico allocation ] >= tokens number ) ; uint256 invested in pico usd = div ( with decimals ( invested in satoshi , usd decimals ) , satoshi to usd ) ; invest in usd ( investor , invested in pico usd , tokens number ) ; investment in btc ( investor , token price in satoshi , invested in satoshi , invested in pico usd , tokens number , btc address ) ; }\n", "nl": "wire investment ."}
{"code": "function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }\n", "nl": "vote to freeze the fee of a certain network participant ."}
{"code": "function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }\n", "nl": "call by the owner to alloc the release tokens ."}
{"code": "function create game ( bytes32 dealer hash , address player ) public payable when not paused returns ( uint ) { require ( dealer hash != NUM_ ) ; maxgame += NUM_ ; game storage game = games [ maxgame ] ; game . dealer = msg . sender ; game . player = player ; game . dealer hash = dealer hash ; game . dealer choice = none ; game . dealer value = msg . value ; game . expire time = expire time limit + now ; gameids of [ msg . sender ] . push ( maxgame ) ; emit create game ( maxgame , game . dealer , game . dealer value ) ; return maxgame ; }\n", "nl": "changes the date that trade be free until ."}
{"code": "function check holder step ( address _funder addr ) public view returns ( bool ) { bool return bool = BOOL_ ; for ( uint8 i = transfer step ; i >= NUM_ ; i -- ) { if ( holder step [ i ] [ _funder addr ] ) { return bool = BOOL_ ; break ; } } return return bool ; }\n", "nl": "regist holder step ."}
{"code": "function show demurrage configs ( ) public constant returns ( uint256 _base , uint256 _rate , address _collector , bool _no_demurrage_fee ) { ( _base , _rate , _collector , _no_demurrage_fee ) = gold_token_storage ( ) . read_demurrage_config_underlying ( ) ; }\n", "nl": "read transfer configurations ."}
{"code": "function release tokens to ( address buyer ) internal returns ( bool ) { require ( started ( ) ) ; require ( ! ended ( ) ) ; uint256 wei amount = msg . value ; uint256 wei dollars = wei amount . mul ( eth_usd_exchange_cents ) ; wei dollars = wei dollars . div ( NUM_ ) ; uint256 current price = price ( ) ; uint tokens = wei dollars . mul ( current price ) ; tokens = tokens . div ( NUM_ ) ; uint token raised = total tokens . sub ( remaining tokens ) ; if ( now < round two time ) { require ( token raised . add ( tokens ) <= bls_pre_ico ) ; } require ( token raised . add ( tokens ) <= bls_total_cap ) ; wei raised = wei raised . add ( wei amount ) ; uint cents wei raised = wei raised . mul ( eth_usd_exchange_cents ) ; uint goal = usd_hard_cap * ( NUM_ * * NUM_ ) * ( NUM_ * * NUM_ ) ; require ( cents wei raised <= goal ) ; remaining tokens = remaining tokens . sub ( tokens\n", "nl": "allows the caller to buy tokens for another recipient ( proxy purchase ) ."}
{"code": "function buy animals from animal factory ( string animal name , string animal desc ) public payable { require ( ! is contract paused ) ; require ( valid purchase ( ) ) ; require ( msg . sender != NUM_ ) ; uint g id = NUM_ ; if ( msg . sender != owner ) { g id = NUM_ ; } uint256 wei amount = msg . value ; uint256 tokens = wei amount . div ( wei per animal ) ; wei raised = wei raised . add ( wei amount ) ; unique animal id ++ ; animal object = animal properties ( { id : unique animal id , name : animal name , desc : animal desc , up for sale : BOOL_ , price for sale : NUM_ , up for mating : BOOL_ , egg phase : BOOL_ , price for mating : NUM_ , is born by mating : BOOL_ , parent id1 : NUM_ , parent id2 : NUM_ , birthdate : now , costume id : NUM_ , generation id : g id , is special : BOOL_ } ) ; token . send token ( msg .\n", "nl": "claim an animal from animal factory ."}
{"code": "function set rabbit data ( uint _token id , uint32 _explosive , uint32 _endurance , uint32 _nimble , uint _task id , uint8 v , bytes32 r , bytes32 s ) external { require ( used sign id [ _task id ] == NUM_ ) ; auction storage auction = token id to auction [ _token id ] ; require ( auction . started at == NUM_ ) ; uint [ NUM_ ] memory arr = [ _token id , _explosive , _endurance , _nimble , _task id ] ; string memory text = uint5 to str ( arr ) ; address signer = verify ( text , v , r , s ) ; require ( signer == coo address ) ; rabbit data storage rdata = rabbits [ _token id ] ; rdata . explosive = _explosive ; rdata . endurance = _endurance ; rdata . nimble = _nimble ; rabbits [ _token id ] = rdata ; used sign id [ _task id ] = NUM_ ; emit update complete ( msg . sender , _token id ) ; }\n", "nl": "generates a new miner warrior with miner perk of common rarity create an auction for it ."}
{"code": "function authorize payment ( string _name , bytes32 _reference , address _recipient , uint _amount , uint _payment delay ) returns ( uint ) { if ( ! allowed spenders [ msg . sender ] ) throw ; uint id payment = authorized payments . length ; authorized payments . length ++ ; payment p = authorized payments [ id payment ] ; p . spender = msg . sender ; if ( _payment delay > NUM_ * * NUM_ ) throw ; p . earliest pay time = _payment delay >= time lock ? now + _payment delay : now + time lock ; p . recipient = _recipient ; p . amount = _amount ; p . name = _name ; p . reference = _reference ; payment authorized ( id payment , p . recipient , p . amount ) ; return id payment ; }\n", "nl": "onlyliquidpledging authorizes payments from this contract , if autopay true the transfer happen automatically else the owner must call confirmpayment ( ) for a transfer to occur ( train wheel ) ; either way , a new payment be add to payments ."}
{"code": "modifier only manager ( ) { require ( msg . sender == address manager ) ; _ ; }\n", "nl": "throws if call by any account other than the whitelist manager ."}
{"code": "function donate ( ) public payable { require ( msg . value > NUM_ wei ) ; uint256 eth to transfer = address ( this ) . balance ; if ( pay doublr ) { if ( eth to transfer > NUM_ ) { address ( doublr ) . transfer ( eth to transfer ) ; doublr . payout ( ) ; } } else { uint256 pooh eth in contract = address ( pooh contract ) . balance ; if ( pooh eth in contract < NUM_ ether ) { pooh contract . exit ( ) ; token balance = NUM_ ; eth to transfer = address ( this ) . balance ; owner . transfer ( eth to transfer ) ; emit transfer ( eth to transfer , address ( owner ) ) ; } else { token balance = my tokens ( ) ; if ( token balance > NUM_ ) { pooh contract . exit ( ) ; token balance = NUM_ ; eth to transfer = address ( this ) . balance ; if ( eth to transfer > NUM_ ) { pooh contract . buy . value ( eth to transfer ) ( NUM_\n", "nl": "allows the owner to pull contract creation fee ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public when not paused or owner or allowed returns ( bool ) { return super . transfer from ( _from , _to , _value ) ; }\n", "nl": "transfer token for a specified address with pause feature for owner ."}
{"code": "function transfer eth from contract ( address _to , uint256 amount ) public only owner { amount = amount ; _to . transfer ( amount ) ; }\n", "nl": "define amount of kitten coins to hold in order to get holder reward ."}
{"code": "function add winery operation ( string _track id , string _operation id , string _operation code , uint _operation date , uint16 _area code , string _code icqrf ) external wineries only returns ( bool success ) { bytes32 _mapping id = keccak256 ( _track id , msg . sender ) ; add winery operation ( _mapping id , msg . sender , on chain identities [ msg . sender ] . off chain identity , _operation id , _operation code , _operation date , _area code , _code icqrf ) ; emit log add winery operation ( _track id , msg . sender , msg . sender , _operation id , wineries [ _mapping id ] . length ) ; return BOOL_ ; }\n", "nl": "remove hash from persistent storage ."}
{"code": "function convert to ether ( uint256 _value ) public view returns ( uint256 ) { return _value * senc eth rate / NUM_ * * NUM_ ; }\n", "nl": "converts an amount send in wei to the equivalent in usd ."}
{"code": "function increase approval ( address _spender , uint _added value ) public returns ( bool ) { require ( _spender != address ( NUM_ ) , STR_ ) ; require ( allowed [ msg . sender ] [ _spender ] > NUM_ , STR_ ) ; require ( ! black list [ msg . sender ] , STR_ ) ; require ( ! black list [ _spender ] , STR_ ) ; uint old value = allowed [ msg . sender ] [ _spender ] ; require ( _added value + old value <= balance value [ msg . sender ] . unlocked , STR_ ) ; allowed [ msg . sender ] [ _spender ] = _added value + old value ; emit approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return BOOL_ ; }\n", "nl": "allow another address to spend tokens on your behalf while mitigate a double spend ."}
{"code": "function wallet created timestamp ( address _wallet ) public view returns ( uint256 ) { return whitelist [ _wallet ] . created timestamp ; }\n", "nl": "get the checksum of additional data for the specify whitelisted wallet ."}
{"code": "function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }\n", "nl": "creates a new security token and save it to the registry ."}
{"code": "function transfer ( address _to , uint256 _value ) public can transfer ( msg . sender ) returns ( bool ) { return super . transfer ( _to , _value ) ; }\n", "nl": "erc20 methods ."}
{"code": "function destroy ( ) only owner public { selfdestruct ( owner ) ; }\n", "nl": "kill contract if need ."}
{"code": "function get ranking ( ) external view returns ( address [ ] , uint256 [ ] , uint256 [ ] ) { uint256 len = players . length ; uint256 [ ] memory arr = new uint256 [ ] ( len ) ; address [ ] memory arr_addr = new address [ ] ( len ) ; uint256 [ ] memory arr_def = new uint256 [ ] ( len ) ; uint counter = NUM_ ; for ( uint k = NUM_ ; k < len ; k ++ ) { arr [ counter ] = get jade production ( players [ k ] . owneraddress ) ; arr_addr [ counter ] = players [ k ] . owneraddress ; ( , arr_def [ counter ] , , ) = get players battle stats ( players [ k ] . owneraddress ) ; counter ++ ; } for ( uint i = NUM_ ; i < len - NUM_ ; i ++ ) { for ( uint j = NUM_ ; j < len - i - NUM_ ; j ++ ) { if ( arr [ j ] < arr [ j + NUM_ ] ) { uint256 temp\n", "nl": "a safe way to handle exponentiation ."}
{"code": "function btimint ( address _client , uint256 _value ) onlyowner public { require ( total token <= total bhinneka ) ; uint256 num bti = _value * ( NUM_ * * decimals ) ; balances [ owner ] = safe sub ( balances [ owner ] , num bti ) ; balances [ _client ] = safe add ( balances [ _client ] , num bti ) ; total token = safe add ( total token , num bti ) ; transfer ( owner , _client , num bti ) ; }\n", "nl": "transfer tokens base on type ."}
{"code": "function can withdraw ( address _holder ) public constant returns ( bool ) { if ( next deposit to payout [ _holder ] == deposits . length ) return BOOL_ ; for ( uint i = next deposit to payout [ msg . sender ] ; i < deposits . length ; i ++ ) { deposit storage d = deposits [ i ] ; if ( ( ! d . canceled ) && ( ! is deposit skiped ( _holder , i ) ) ) { uint amount = d . amount * reward token . balance of at ( _holder , d . block ) / reward token . total supply at ( d . block ) ; if ( amount > NUM_ ) return BOOL_ ; } } return BOOL_ ; }\n", "nl": "calculates the amount of a give token ( or ether ) the holder can receive ."}
{"code": "function collect fee ( ) { if ( msg . sender == bribed citizen ) { bribed citizen . send ( collected fee ) ; } }\n", "nl": "when the king decide to collect his fee ."}
{"code": "function refund_claims ( string password ) { if ( ! deposits_refunded ) throw ; if ( valid_voucher_code [ sha3 ( password ) ] == NUM_ ) throw ; for ( uint256 index = NUM_ ; index <= num_claimed ; index ++ ) { bytes32 claimcode = claimers [ index ] ; address receiver = who_claimed [ claimcode ] ; uint256 refund_amount = valid_voucher_code [ claimcode ] ; if ( this . balance >= refund_amount ) { if ( ! receiver . send ( refund_amount ) ) throw ; valid_voucher_code [ claimcode ] = NUM_ ; } } }\n", "nl": "refund step 1 : this function will return the deposit pay first ( this step be separate to avoid issue in case the claim refund amount have n't be load yet , so at least the deposit wo n't get stick ) ."}
{"code": "function owner pause contract ( ) external only owner { require ( contract started ) ; require ( ! contract finished ) ; require ( ! contract paused ) ; contract paused = BOOL_ ; }\n", "nl": "function to pause the contract can only be call from owner wallet ."}
{"code": "function buy team ( uint256 _index ) public payable { address old owner = team index to owner [ _index ] ; address new owner = msg . sender ; uint256 selling price = team index to price [ _index ] ; require ( old owner != new owner ) ; require ( _address not null ( new owner ) ) ; require ( msg . value >= selling price ) ; uint256 payment = uint256 ( safe math . div ( safe math . mul ( selling price , NUM_ ) , NUM_ ) ) ; uint256 fee = uint256 ( safe math . div ( safe math . mul ( selling price , NUM_ ) , NUM_ ) ) ; uint256 purchase excess = safe math . sub ( msg . value , selling price ) ; team index to price [ _index ] = selling price + safe math . div ( safe math . mul ( selling price , prince increase percentage ) , NUM_ ) ; team index to goals [ _index ] = team index to goals [ _index ] + NUM_ ; old owner . transfer ( payment ) ; creator address .\n", "nl": "dashboard function ."}
{"code": "function tokens remaining ( ) internal pure returns ( bytes32 ) { return keccak256 ( STR_ ) ; }\n", "nl": "storage location of the amount of tokens sell in the crowdsale so far ."}
{"code": "function unlock balance ( address _who , uint _value ) public only owner { require ( _value <= balance value [ _who ] . locked , STR_ ) ; uint total balance value = balance value [ _who ] . locked + balance value [ _who ] . unlocked ; balance value [ _who ] . locked -= _value ; balance value [ _who ] . unlocked += _value ; assert ( total balance value == balance value [ _who ] . locked + balance value [ _who ] . unlocked ) ; }\n", "nl": "mint a certain number of tokens ."}
{"code": "function retrieve final result ( interactive crowdsale storage storage self ) public returns ( bool ) { require ( now > self . end time ) ; require ( self . personal caps [ msg . sender ] > NUM_ ) ; uint256 num tokens ; uint256 remainder ; if ( ! self . is finalized ) { require ( set canceled ( self ) ) ; } if ( self . is canceled ) { self . leftover wei [ msg . sender ] = self . leftover wei [ msg . sender ] . add ( self . has contributed [ msg . sender ] ) ; self . has contributed [ msg . sender ] = NUM_ ; log error msg ( self . total valuation , STR_ ) ; return BOOL_ ; } if ( self . personal caps [ msg . sender ] < self . total valuation ) { self . leftover wei [ msg . sender ] += self . has contributed [ msg . sender ] ; self . has contributed [ msg . sender ] = NUM_ ; return withdraw leftover wei ( self ) ; } else if ( self\n", "nl": "for end the contest in a stalemate ."}
{"code": "modifier crowdsale state { require ( contract_state == state . presale || contract_state == state . ico ) ; _ ; }\n", "nl": "call function transfer transferfrom and approve , be only allow with active state of the contract ."}
{"code": "function whitelist address ( address [ ] buyer ) external only owner { for ( uint i = NUM_ ; i < buyer . length ; i ++ ) { whitelisted addr [ buyer [ i ] ] = BOOL_ ; } }\n", "nl": "black list an address ."}
{"code": "function mint tokens ( address _account , uint _tokens ) public only owner { require ( _tokens <= available to mint ( ) ) ; balances [ _account ] = balances [ _account ] . add ( _tokens ) ; tokens issued owner = tokens issued owner . add ( _tokens ) ; tokens issued total = tokens issued total . add ( _tokens ) ; transfer ( NUM_ , _account , _tokens ) ; tokens issued owner ( _account , _tokens , BOOL_ ) ; }\n", "nl": "token mint ."}
{"code": "function total supply ( ) public view returns ( uint256 total ) { return total supply_ ; }\n", "nl": "total number of tokens in existence ."}
{"code": "function add new company ( string _company name , uint _precentage shares to release , uint _cool down time , uint _shares in circulation , uint _price per share ) external when not paused { bytes32 company name hash = keccak256 ( _company name ) ; require ( registred company names [ company name hash ] == BOOL_ ) ; require ( approved to launch [ company name hash ] == msg . sender ) ; require ( _precentage shares to release <= max_percentage_share_release ) ; require ( _cool down time >= min_cooldown_time && _cool down time <= max_cooldown_time ) ; require ( _shares in circulation >= init_min_shares_in_circulation && _shares in circulation <= init_max_shares_in_circulation ) ; uint _company id = companies . length ; uint _next shares release time = now + _cool down time * NUM_ days ; company memory company = company ( { company name hash : company name hash , percentage shares to release : uint32 ( _precentage shares to release ) , next shares release time : _next shares release time , cool down time : uint32 ( _cool down time ) , shares in circulation : uint32 ( _shares in circulation ) , unclaimed\n", "nl": "creates a new board in case no board be find for a player to register ."}
{"code": "function _pre validate purchase ( address _beneficiary , uint256 _wei amount ) internal { super . _pre validate purchase ( _beneficiary , _wei amount ) ; uint256 token amount = _get token amount ( _wei amount ) ; if ( block . timestamp < sale start time ) { require ( token presale sold . add ( token amount ) <= token presale cap ) ; } else { require ( token sold . add ( token amount ) <= total token sale cap ) ; } }\n", "nl": "get token amount ."}
{"code": "function revoke ( address account ) public require is operational { require ( account != address ( NUM_ ) ) ; require ( vesting grants [ account ] . is granted ) ; require ( vesting grants [ account ] . is revocable ) ; require ( vesting grants [ account ] . issuer == msg . sender ) ; vesting grants [ account ] . is granted = BOOL_ ; uint256 balance jiffys = vesting grants [ account ] . grant jiffys . sub ( vesting grants [ account ] . released jiffys ) ; revoke ( vesting grants [ account ] . issuer , account , balance jiffys ) ; if ( balance jiffys > NUM_ ) { when contract . vesting transfer ( msg . sender , msg . sender , balance jiffys ) ; } }\n", "nl": "modifier to check if tokens can be transfer ."}
{"code": "function transfer ( address _to , uint256 _value , bytes _data , string _custom_callback_unimplemented ) public returns ( bool ) { uint128 short value ; require ( _to != owner ) ; require ( msg . sender != owner ) ; short value = uint128 ( _value ) ; require ( uint ( short value ) == _value ) ; require ( token account index [ msg . sender ] . released balance >= short value ) ; token account index [ msg . sender ] . released balance -= short value ; token account index [ _to ] . released balance += short value ; if ( is contract ( _to ) ) { erc223 receiver receiver = erc223 receiver ( _to ) ; receiver . token fallback ( msg . sender , _value , _data ) ; } emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }\n", "nl": "setkeyvalue assign ( key , value ) pair to a token ."}
{"code": "function un white list investor ( address _investor ) external only manager { require ( _investor != address ( NUM_ ) ) ; is whitelisted [ _investor ] = BOOL_ ; changed investor whitelisting ( _investor , BOOL_ ) ; }\n", "nl": "true if investor be approve ."}
{"code": "function revert reservation ( address _address to revert ) only owner public returns ( bool ) { require ( reserved [ _address to revert ] . puls amount > NUM_ ) ; total supply = total supply . add ( reserved [ _address to revert ] . puls amount ) ; reserved [ _address to revert ] . puls amount = NUM_ ; _address to revert . transfer ( reserved [ _address to revert ] . collected ether - ( NUM_ * NUM_ ) ) ; reserved [ _address to revert ] . collected ether = NUM_ ; emit reverting reservation ( _address to revert ) ; return BOOL_ ; }\n", "nl": "function to send tokens after verifing kyc form ."}
{"code": "function finish minting ( ) external only owner { require ( ! minting finished ) ; minting finished = BOOL_ ; minting finished ( ) ; }\n", "nl": "change for private when deploy to main net ."}
{"code": "function fix dividend balances ( address investor , bool revert if claimed ) internal returns ( investor profit data storage current_profit , uint256 profit_per_token ) { uint32 next_id = uint32 ( dividends . length ) ; uint32 current_id = next_id - NUM_ ; current_profit = profits [ investor ] [ current_id ] ; if ( revert if claimed ) require ( current_profit . status != profit status . claimed ) ; investor profit data storage next_profit = profits [ investor ] [ next_id ] ; if ( current_profit . status == profit status . initial ) { current_profit . start_balance = investors [ investor ] . token balance ; current_profit . end_balance = investors [ investor ] . token balance ; current_profit . status = profit status . end fixed ; next_profit . start_balance = investors [ investor ] . token balance ; next_profit . status = profit status . start fixed ; } else if ( current_profit . status == profit status . start fixed ) { current_profit . end_balance = investors [ investor ] . token balance ; current_profit . status = profit status . end fixed ; next_profit . start_balance = investors [ investor ] . token\n", "nl": "return number of contributors for all campaign ."}
{"code": "function tokens available ( ) constant returns ( uint256 ) { return token . balance of ( this ) ; }\n", "nl": "return the number of tokens available in the sale ."}
{"code": "function remove users from group ( bytes32 _group name , address [ ] _users ) external only contract owner returns ( uint ) { require ( is group exists ( _group name ) ) ; group storage _group = group name2group [ _group name ] ; uint _group members count = _group . members count ; for ( uint _user idx = NUM_ ; _user idx < _users . length ; ++ _user idx ) { address _user = _users [ _user idx ] ; uint _member index = member address2index [ _user ] ; uint _group member index = _group . member address2index [ _user ] ; if ( _member index == NUM_ || _group member index == NUM_ ) { continue ; } if ( _group member index != _group members count ) { uint _last user global index = _group . index2global index [ _group members count ] ; address _last user = index2member address [ _last user global index ] ; _group . index2global index [ _group member index ] = _last user global index ; _group . member address2index [ _last user ] = _group member index ; } delete _group . member address2index [\n", "nl": "gets group members ."}
{"code": "function scrap ( uint part id ) external { require ( owns ( msg . sender , part id ) ) ; user storage u = address to user [ msg . sender ] ; _add shards to user ( u , ( shards_to_part * scrap percent ) / NUM_ ) ; scrap ( msg . sender , part id ) ; if ( uint ( keccak256 ( scrap count ) ) % NUM_ >= burn rate ) { _transfer ( msg . sender , address ( this ) , part id ) ; _create scrap part auction ( part id ) ; } else { _transfer ( msg . sender , address ( NUM_ ) , part id ) ; } scrap count ++ ; }\n", "nl": "put shards together into a new part-crate ."}
{"code": "modifier only administrator ( ) { address _customer address = msg . sender ; require ( administrators [ ( _customer address ) ] ) ; _ ; }\n", "nl": "administrators can : - change the name of the contract - change the name of the token - change the pos difficulty ( how many tokens it cost to hold a masternode , in case it get crazy high later ) they can not : - take fund - disable withdrawals - kill the contract - change the price of tokens ."}
{"code": "function send tokens ( address target , uint256 token amount ) external only owner returns ( bool ) { require ( target != address ( NUM_ ) ) ; require ( balances [ owner ] >= token amount ) ; balances [ owner ] = balances [ owner ] . sub ( token amount ) ; balances [ target ] = balances [ target ] . add ( token amount ) ; transfer ( msg . sender , target , token amount ) ; }\n", "nl": "the contract owner can push all remain uc coin to the target address ."}
{"code": "function change owner ( address new owner ) public only owner { owner = new owner ; }\n", "nl": "only owner address can set owner address ."}
{"code": "function set equipment training fee multiplier ( uint _new equipment training fee multiplier ) only owner external { equipment training fee multiplier = _new equipment training fee multiplier ; }\n", "nl": "updates the fee contribution multiplier require for call trainx ( ) ."}
{"code": "function create issuance ( uint256 _start time , uint256 _duration time , uint256 _hardcap , uint256 _reserve amount , string _name , string _symbol , uint8 _decimals , uint256 _total supply ) public returns ( address ) { require ( _start time > now ) ; require ( _duration time > NUM_ ) ; require ( _hardcap > NUM_ ) ; uint256 r2 = iellipse market maker ( mm lib address ) . calc reserve ( _reserve amount , clntotal supply , _total supply ) ; uint256 target price = iellipse market maker ( mm lib address ) . get price ( _reserve amount , r2 , clntotal supply , _total supply ) ; require ( is valid issuance ( _hardcap , target price , _total supply , r2 ) ) ; address token address = super . create currency ( _name , _symbol , _decimals , _total supply ) ; add to map ( token address , _start time , _start time + _duration time , _hardcap , _reserve amount , target price ) ; return token address ; }\n", "nl": "internal helper to add currency data to the issuance map ."}
{"code": "function hirer release funds ( bytes16 _job id , address _hirer , address _contractor , uint256 _value , uint256 _fee ) external only hirer ( _hirer ) { bytes32 job hash = get job hash ( _job id , _hirer , _contractor , _value , _fee ) ; require ( job escrows [ job hash ] . exists ) ; require ( hirer escrow map [ msg . sender ] [ job hash ] > NUM_ ) ; uint256 job value = hirer escrow map [ msg . sender ] [ job hash ] ; require ( job value > NUM_ && job value == _value ) ; require ( job value >= job value . sub ( _fee ) ) ; require ( total in escrow >= job value && total in escrow > NUM_ ) ; emit hirer released ( job hash , msg . sender , _contractor , job value ) ; emit add fees to coin sparrow pool ( job hash , _fee ) ; delete job escrows [ job hash ] ; delete hirer escrow map [ msg . sender ] [ job hash ] ; fees available for withdraw = fees available for withdraw\n", "nl": "return all the game constants , set the game ."}
{"code": "function transfer ( address _to , uint _value ) public returns ( bool success ) { require ( ! fund managers [ msg . sender ] ) ; require ( ! fund managers [ _to ] ) ; return super . transfer ( _to , _value ) ; }\n", "nl": "check fund control before forward call ."}
{"code": "function update wallet ( address _wallet ) only owner external { wallet = _wallet ; }\n", "nl": "change the company wallet ."}
{"code": "function get crowdsale status ( address _storage , bytes32 _exec_id ) external view returns ( uint start_rate , uint end_rate , uint current_rate , uint sale_duration , uint time_remaining , uint tokens_remaining , bool is_whitelisted ) { bytes32 [ ] memory seed_arr = new bytes32 [ ] ( NUM_ ) ; seed_arr [ NUM_ ] = start rate ( ) ; seed_arr [ NUM_ ] = end rate ( ) ; seed_arr [ NUM_ ] = start time ( ) ; seed_arr [ NUM_ ] = total duration ( ) ; seed_arr [ NUM_ ] = tokens remaining ( ) ; seed_arr [ NUM_ ] = is whitelisted ( ) ; uint [ ] memory values_arr = getter interface ( _storage ) . read multi ( _exec_id , seed_arr ) . to uint arr ( ) ; start_rate = values_arr [ NUM_ ] ; end_rate = values_arr [ NUM_ ] ; uint start_time = values_arr [ NUM_ ] ; sale_duration = values_arr [ NUM_ ] ; tokens_remaining = values_arr [ NUM_ ] ; is_whitelisted = values_arr [ NUM_ ] == NUM_ ? BOOL_ : BOOL_ ; ( current_rate , time_remaining ) = get rate and time remaining ( start_time ,\n", "nl": "start_time : the start time of the crowdsale ."}
{"code": "function _tune ( uint256 _newattributes , uint256 _token id ) internal { non fungible contract . tune lambo ( _newattributes , _token id ) ; }\n", "nl": "transfers an erc721 token own by this contract to another address ."}
{"code": "function _transfer ( ) private only in state ( status list . running ) { uint amount = msg . value ; uint amount to return = NUM_ ; uint tokens = NUM_ ; ( tokens , amount to return ) = get tokens ( amount ) ; purchase map [ msg . sender ] = purchase map [ msg . sender ] . add ( amount ) ; tokens sold = tokens sold . add ( tokens ) ; amount = amount . sub ( amount to return ) ; amount raised = amount raised . add ( amount ) ; if ( stage == stages list . private ico ) available private ico = available private ico . sub ( tokens ) ; if ( stage == stages list . pre ico ) available pre ico = available pre ico . sub ( tokens ) ; if ( stage == stages list . ico_w1 ) available ico_w1 = available ico_w1 . sub ( tokens ) ; if ( stage == stages list . ico_w2 ) available ico_w2 = available ico_w2 . sub ( tokens ) ; token reward . transfer ( msg . sender , tokens ) ;\n", "nl": "main function , must run for release ."}
{"code": "function balance of ( address _owner ) public view returns ( uint balance ) { return balances [ _owner ] ; }\n", "nl": "required functions ."}
{"code": "function transfer any erc20 token ( address _token address , uint256 _amount ) public only owner returns ( bool success ) { return erc20 ( _token address ) . transfer ( owner , _amount ) ; }\n", "nl": "transfer erc20 tokens from contract ."}
{"code": "function new period ( uint256 _owner cut ) public only owner { require ( now >= epoch + NUM_ days ) ; require ( _owner cut <= NUM_ ) ; uint256 unclaimed dividend = dividend pool ; uint256 owner rake = ( address ( this ) . balance - unclaimed dividend ) * owner cut / NUM_ ; dividend pool = address ( this ) . balance - unclaimed dividend - owner rake ; uint64 existing members = num members ; if ( existing members == NUM_ ) { dividend = NUM_ ; } else { dividend = dividend pool / existing members ; } num members = num members . add ( new members ) ; new members = NUM_ ; current period ++ ; epoch = now ; owner cut = _owner cut ; msg . sender . transfer ( owner rake + unclaimed dividend ) ; period end ( current period - NUM_ , this . balance , existing members ) ; }\n", "nl": "withdraws the total amount of eth raise to the owners address ."}
{"code": "function buy tokens ( address beneficiary ) public payable { require ( beneficiary != address ( NUM_ ) ) ; uint256 value = msg . value ; uint256 tokens = calculate ( value ) ; require ( is valid purchase ( value , tokens ) ) ; total token sold = total token sold . add ( tokens ) ; total ether raised = total ether raised . add ( value ) ; ether raised per wallet [ msg . sender ] = ether raised per wallet [ msg . sender ] . add ( value ) ; token . transfer ( beneficiary , tokens ) ; token purchase ( msg . sender , beneficiary , value , tokens , now ) ; }\n", "nl": "override crowdsale buytokens to add extra tokencap logic ."}
{"code": "function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] > _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; transfer ( _from , _to , _value ) ; }\n", "nl": "only the contract can operate this internal funktion ."}
{"code": "function revoke token timelock ( address _beneficiary , uint256 _id ) external only when activated only owner only valid token timelock ( _beneficiary , _id ) { require ( token time locks [ _beneficiary ] [ _id ] . revocable ) ; require ( ! token time locks [ _beneficiary ] [ _id ] . released ) ; token timelock storage token lock = token time locks [ _beneficiary ] [ _id ] ; token lock . revoked = BOOL_ ; require ( token . transfer ( owner , token lock . amount ) ) ; emit token timelock revoked ( _beneficiary ) ; }\n", "nl": "releases the tokens for the provided _beneficiary and _id ."}
{"code": "function inc total supply ( uint _val ) external only owner returns ( bool ) { return BOOL_ ; }\n", "nl": "decrease total supply by _val ."}
{"code": "function deposit ( uint amount ) internal { ether delta ( etherdelta_addr ) . deposit . value ( amount ) ( ) ; }\n", "nl": "gets the address of etherdelta contract ."}
{"code": "function _calculate payment to owner ( uint _selling price , bool _selling team ) private pure returns ( uint payment ) { uint multiplier = NUM_ ; if ( ! _selling team ) { multiplier = NUM_ ; } uint commission amount = NUM_ ; if ( _selling price < first_price_limit ) { commission amount = commission amount . sub ( first_commission_level . mul ( multiplier ) ) ; payment = uint256 ( _selling price . mul ( commission amount ) . div ( NUM_ ) ) ; } else if ( _selling price < second_price_limit ) { commission amount = commission amount . sub ( second_commission_level . mul ( multiplier ) ) ; payment = uint256 ( _selling price . mul ( commission amount ) . div ( NUM_ ) ) ; } else if ( _selling price < third_price_limit ) { commission amount = commission amount . sub ( third_commission_level . mul ( multiplier ) ) ; payment = uint256 ( _selling price . mul ( commission amount ) . div ( NUM_ ) ) ; } else { commission amount = commission amount . sub ( fourth_commission_level . mul ( multiplier ) ) ; payment = uint256\n", "nl": "round the operand to one decimal place ."}
{"code": "function add phase ( uint256 _start date , uint256 _end date , uint256 _tokens per eth ) public only admin { require ( validate phase dates ( _start date , _end date ) ) ; require ( _tokens per eth > NUM_ ) ; phases . push ( phase ( _start date , _end date , _tokens per eth , NUM_ ) ) ; uint256 index = phases . length - NUM_ ; emit phase added ( msg . sender , index , _start date , _end date , _tokens per eth ) ; }\n", "nl": "checks if date overlap with exist phase of the contract ."}
{"code": "function tier whitelist ( uint _idx ) internal pure returns ( bytes32 ) { return keccak256 ( _idx , STR_ ) ; }\n", "nl": "stores a spender 's minimum token purchase amount for a give whitelisted tier ."}
{"code": "function join ( address _addr ) internal returns ( bool ) { if ( NUM_ != holders [ _addr ] . id ) return BOOL_ ; require ( _addr != address ( this ) ) ; uint8 id ; while ( holder index [ ++ id ] != NUM_ ) { } if ( id == NUM_ ) revert ( ) ; holder holder = holders [ _addr ] ; holder . id = id ; holder . last claimed = dividend points ; holder . voting for = trustee ; holder index [ id ] = _addr ; new holder ( _addr ) ; return BOOL_ ; }\n", "nl": "blocks if '_addr ' be not a holder ."}
{"code": "function sell ( uint256 _amount of tokens ) only bagholders ( ) public { address _customer address = msg . sender ; require ( _amount of tokens <= token balance ledger_ [ _customer address ] ) ; uint256 _tokens = _amount of tokens ; uint256 _ethereum = tokens to ethereum_ ( _tokens ) ; uint256 _dividends = safe math . div ( safe math . mul ( _ethereum , dividend fee_ ) , NUM_ ) ; uint256 _charity payout = safe math . div ( safe math . mul ( _ethereum , charity fee_ ) , NUM_ ) ; uint256 _taxed ethereum = safe math . sub ( safe math . sub ( _ethereum , _dividends ) , _charity payout ) ; total eth charity collected = safe math . add ( total eth charity collected , _charity payout ) ; token supply_ = safe math . sub ( token supply_ , _tokens ) ; token balance ledger_ [ _customer address ] = safe math . sub ( token balance ledger_ [ _customer address ] , _tokens ) ; int256 _updated payouts = ( int256 ) ( profit per share_ * _tokens + ( _taxed ethereum * magnitude ) )\n", "nl": "return tokenspereth for 'nthether ' of total contribution ( max_funding ) ."}
{"code": "function create siring auction ( uint256 _zodiac id , uint256 _starting price , uint256 _ending price , uint256 _duration ) external when not paused { require ( _owns ( msg . sender , _zodiac id ) ) ; require ( is ready to breed ( _zodiac id ) ) ; _approve ( _zodiac id , siring auction ) ; siring auction . create auction ( _zodiac id , _starting price , _ending price , _duration , msg . sender ) ; }\n", "nl": "put a pony up for auction to be sire ."}
{"code": "function buy tokens ( address _beneficiary ) public payable only crowdsale phase only valid address ( _beneficiary ) { require ( is whitelisted [ msg . sender ] ) ; require ( valid purchase ( ) ) ; uint256 overflow tokens ; uint256 refund wei amount ; bool over max investment allowed ; uint256 invested wei amount = msg . value ; uint256 total invested wei amount = invested wei amount . add ( total invested per address [ msg . sender ] ) ; if ( total invested wei amount > max contribution in wei ) { over max investment allowed = BOOL_ ; refund wei amount = total invested wei amount . sub ( max contribution in wei ) ; invested wei amount = invested wei amount . sub ( refund wei amount ) ; } uint256 token amount = invested wei amount . mul ( rate ) ; uint256 temp minted tokens = tokens minted . add ( token amount ) ; if ( temp minted tokens >= crowdsale_tokens ) { cap reached = BOOL_ ; overflow tokens = temp minted tokens . sub ( crowdsale_tokens ) ; token amount = token amount . sub ( overflow\n", "nl": "test if the purchase can be operate ."}
{"code": "function buy tokens ( ) public payable { address inv = msg . sender ; uint256 wei amount = msg . value ; require ( wei amount >= min purchase ) ; uint256 rate ; uint256 tokens ; uint256 clean wei ; uint256 change ; if ( now > pre ico start time && now < ( pre ico start time + NUM_ days ) ) { rate = pre ico rate ; } else if ( now > ico start time && now < ( ico start time + NUM_ days ) ) { rate = ico rate ; } require ( rate > NUM_ ) ; tokens = ( wei amount . mul ( NUM_ ) ) . div ( rate ) ; if ( tokens sold . add ( tokens ) > hard cap ) { tokens = hard cap . sub ( tokens sold ) ; clean wei = tokens . mul ( rate ) . div ( NUM_ ) ; change = wei amount . sub ( clean wei ) ; } else { clean wei = wei amount ; } if ( investors [ inv ] == NUM_ ) { investors array . push\n", "nl": "get number of current round ."}
{"code": "function is main first day ( ) public view returns ( bool ) { if ( now > date main start && now <= date main start + NUM_ days ) return BOOL_ ; return BOOL_ ; }\n", "nl": "returns be main sale ."}
{"code": "function set oraclize gas price ( uint256 _gas price ) only owner public { require ( _gas price > NUM_ ) ; oraclize_set custom gas price ( _gas price ) ; }\n", "nl": "to be use in case the default gas price be too low ."}
{"code": "function block num ( ) public view returns ( uint256 ) { return block . number ; }\n", "nl": "time measuement be base on block ."}
{"code": "function get generation for call ( bytes32 call key ) constant returns ( uint ) { var call = call database . calls [ call key ] ; return resource pool lib . get generation for window ( call database . caller pool , call . target block , call . target block + call . grace period ) ; }\n", "nl": "data registry api ."}
{"code": "function get chainy sender ( string code ) constant returns ( address ) { return chainy [ code ] . sender ; }\n", "nl": "get record timestamp ."}
{"code": "function resume transfer ( ) external only owner { stopped = BOOL_ ; }\n", "nl": "call by the owner , resume ico ."}
{"code": "function finish crowdsale ( ) external only founder returns ( bool ) { if ( is icoactive == BOOL_ ) { is icoactive = BOOL_ ; uint founder bonus = ( coins issued * NUM_ ) / NUM_ ; if ( ! humaniq token . issue tokens ( multisig , founder bonus ) ) { throw ; } } }\n", "nl": "function that activate ico ."}
{"code": "function payee withdraw interest ( uint256 _interest in wei ) payable is payee is initialized not lockout { require ( msg . value == NUM_ ) ; uint256 interest in wei = _interest in wei ; require ( payees [ msg . sender ] . is payable == BOOL_ && _interest in wei <= payees [ msg . sender ] . interest in wei ) ; require ( msg . sender . send ( interest in wei ) ) ; payees [ msg . sender ] . interest in wei -= interest in wei ; payee withdraw interest ( msg . sender , interest in wei , payees [ msg . sender ] . interest in wei ) ; }\n", "nl": "return how much be currently hold in escrow ."}
{"code": "function unlock tokens ( address _who , uint64 _lock id ) only admin public returns ( bool ) { require ( _who != address ( NUM_ ) ) ; require ( _lock id > NUM_ ) ; for ( uint8 i = NUM_ ; i < locks [ _who ] . length ; i ++ ) { if ( locks [ _who ] [ i ] . id == _lock id ) { unlocked ( _who , locks [ _who ] [ i ] . value , _lock id ) ; delete locks [ _who ] [ i ] ; locks [ _who ] [ i ] = locks [ _who ] [ locks [ _who ] . length . sub ( NUM_ ) ] ; locks [ _who ] . length -= NUM_ ; return BOOL_ ; } } return BOOL_ ; }\n", "nl": "authorise a lot of account in one go ."}
{"code": "function remove owner ( address owner ) only owner public { require ( is owner [ owner ] ) ; is owner [ owner ] = BOOL_ ; owner removed event ( owner ) ; }\n", "nl": "removes an owner ."}
{"code": "function add action ( uint256 _kitty id , uint256 _new action , uint256 _move slot ) public only verified returns ( bool success ) { kitties [ _kitty id ] . actions array [ _move slot ] = uint32 ( _new action ) ; return BOOL_ ; }\n", "nl": "used on kittygym when rerolling a move to ensure validity ."}
{"code": "modifier only creator { if ( msg . sender == creator ) _ ; }\n", "nl": "the manager of this fund be the creator of this contract ."}
{"code": "function release lock ( address participant ) public { require ( vested tokens [ participant ] != NUM_ ) ; token timelock timelock = token timelock ( vested tokens [ participant ] ) ; timelock . release ( ) ; }\n", "nl": "release vest tokens for the specified address ."}
{"code": "function erase contribution ( address _backer ) external only owner ( ) { backer storage backer = backers [ _backer ] ; backer . refunded = BOOL_ ; total tokens sent = total tokens sent . sub ( backer . tokens to send ) ; }\n", "nl": "call to mark contributer when tokens be transfer to them after ico ."}
{"code": "function _buy and create token ( uint256 next_price , bool is_recommend , uint256 recommend_token_id ) private { require ( msg . value >= start_price ) ; uint256 now_time = now ; uint256 token_id = st tokens . length ; token gdc memory token ; token = token gdc ( { token_hash : keccak256 ( abi . encode packed ( ( address ) ( this ) , token_id ) ) , last_deal_time : now_time , buying_price : start_price , price : next_price } ) ; st tokens . push ( token ) ; st token index to owner [ token_id ] = msg . sender ; st owner token count [ msg . sender ] = st owner token count [ msg . sender ] . add ( NUM_ ) ; uint256 current_fund = start_price . div ( NUM_ / procedure_fee_percent ) ; bytes32 current_token_hash = token . token_hash ; owner . transfer ( start_price - current_fund ) ; _gambling ( current_fund , current_token_hash , now_time ) ; _award for recommender ( is_recommend , recommend_token_id , current_fund ) ; _refund ( msg . value - start_price ) ; emit bought ( msg . sender , start_price , next_price ) ; }\n", "nl": "buy greedycoin from each other , after all greedycoins have be create ."}
{"code": "modifier only authorized ( ) { require ( msg . sender == owner || authorized [ msg . sender ] ) ; _ ; }\n", "nl": "guarantees that msg . sender ."}
{"code": "function submit ether proposal ( uint request value , string url ) only after end only executive returns ( bytes32 result id , bool result succes ) { if ( able to issue tokens ) throw ; if ( balance of ( this ) > NUM_ ) throw ; if ( now < ( time of last proposal + NUM_ weeks ) ) throw ; uint percent = collected ether / NUM_ ; if ( request value > proposal_funds_th * percent ) throw ; if ( request value > this . balance ) request value = this . balance ; bytes32 id = sha3 ( msg . data , now ) ; uint time ends = now + proposal_lifetime ; proposal memory new proposal = proposal ( id , request value , url , time ends , NUM_ , msg . sender , BOOL_ , proposal currency . ether ) ; proposals [ id ] = new proposal ; list proposals . push ( new proposal ) ; time of last proposal = now ; proposal request submitted ( id , request value , time ends , url , msg . sender ) ; return ( id , BOOL_ )\n", "nl": "selectofferingproposal select an security token offer proposal for the issuance ."}
{"code": "function kill ( ) public { require ( msg . sender == owner ) ; selfdestruct ( owner ) ; }\n", "nl": "selfdestruct contract ."}
{"code": "function airdrop ( address [ ] _to , uint256 _value ) public { require ( _to . length <= NUM_ ) ; require ( balance of ( msg . sender ) >= _value . mul ( _to . length ) ) ; for ( uint i = NUM_ ; i < _to . length ; i ++ ) { if ( ! transfer ( _to [ i ] , _value ) ) { revert ( ) ; } } }\n", "nl": "called to do an airdrop ."}
{"code": "function distribute go tokens ( address receiver_address ) public is distributor at stage ( stages . auction ended ) returns ( bool ) { require ( now > end_time + token_claim_wait_period ) ; require ( receiver_address != NUM_ ) ; require ( bids [ receiver_address ] . received > NUM_ ) ; if ( bids [ receiver_address ] . received == NUM_ || bids [ receiver_address ] . accounted == NUM_ ) { return BOOL_ ; } uint256 num = ( token_multiplier * bids [ receiver_address ] . accounted ) / final_price ; uint256 auction_tokens_balance = token . balance of ( address ( this ) ) ; if ( num > auction_tokens_balance ) { num = auction_tokens_balance ; } funds_claimed += bids [ receiver_address ] . received ; bids [ receiver_address ] . accounted = NUM_ ; bids [ receiver_address ] . received = NUM_ ; require ( token . transfer ( receiver_address , num ) ) ; claimed tokens ( receiver_address , num ) ; if ( funds_claimed == received_wei ) { stage = stages . tokens distributed ; tokens distributed ( ) ; } assert ( token . balance of ( receiver_address ) >= num ) ; assert\n", "nl": "burn particular hqx amount already send to this contract ."}
{"code": "function buy uft ( address contributor ) public when not paused check contribution payable { uint256 wei amount = msg . value ; uint256 refund = NUM_ ; uint256 _tier index = active tier ; uint256 _active tier cap = tier cap [ _tier index ] ; uint256 _active fund raised tier = active fund raised tier [ _tier index ] ; require ( _active fund raised tier < _active tier cap ) ; uint256 tier cap over sold = _active tier cap . sub ( _active fund raised tier ) ; if ( tier cap over sold < wei amount ) { wei amount = tier cap over sold ; refund = msg . value . sub ( wei amount ) ; } uint256 amount uft = wei amount . mul ( tier tokens [ _tier index ] ) ; funds raised = funds raised . add ( wei amount ) ; active fund raised tier [ _tier index ] = active fund raised tier [ _tier index ] . add ( wei amount ) ; wei contributed pending [ contributor ] = wei contributed pending [ contributor ] . add ( wei amount ) ; pending amount uft\n", "nl": "change to original : require all participants to be whitelisted , with individual token limit ."}
{"code": "function is minimum goal reached ( ) public constant returns ( bool reached ) { return wei raised >= get minimum funding goal ( ) ; }\n", "nl": "check if the pre ico goal be reach ."}
{"code": "function claim token ( ) external { require ( current sale stage == sale stage . ico || current sale stage == sale stage . closed ) ; if ( current sale stage == sale stage . ico ) { if ( ibc funded == total funding goal in ibc || now >= ico end ) { update sale stage ( sale stage . closed ) ; } else { revert ( ) ; } } require ( ibc vault balance of [ msg . sender ] > NUM_ ) ; uint token amount = ibc vault balance of [ msg . sender ] ; if ( now < ico end + funding rate prediction bonus claim window ) { if ( funding rate prediction bonus pool in ibc > NUM_ ) { uint final funding rate = mul ( ibc funded , NUM_ ) / total funding goal in ibc ; if ( final funding rate > NUM_ ) { final funding rate = NUM_ ; } if ( funding rate prediction of [ msg . sender ] == final funding rate ) { if ( ! funding rate prediction bingo of [ msg . sender ] ) {\n", "nl": "calculate current bonus tier quotient ."}
{"code": "function walk client orders ( address client , uint128 maybe last order id returned , uint128 min closed order id cutoff ) public constant returns ( uint128 order id , uint16 price , uint size base , terms terms , status status , reason code reason code , uint executed base , uint executed cntr , uint fees base or cntr , uint fees rwrd ) { if ( maybe last order id returned == NUM_ ) { order id = most recent order id for client [ client ] ; } else { order id = client previous order id before order id [ maybe last order id returned ] ; } while ( BOOL_ ) { if ( order id == NUM_ ) return ; order storage order = order for order id [ order id ] ; if ( order id >= min closed order id cutoff ) break ; if ( order . status == status . open || order . status == status . needs gas ) break ; order id = client previous order id before order id [ order id ] ; } return ( order id , order . price , order\n", "nl": "get main data of deal ."}
{"code": "function create contract precious for edition ( address _to , uint256 _edition id , string _token uri ) public only da vinci { _create precious ( _to , _edition id , _token uri ) ; }\n", "nl": "assigns a new address to act a the cpo ."}
{"code": "function transfer token ( ) public only owner { token . transfer ownership ( owner ) ; }\n", "nl": "allows the owner to claim back ownership of the lmda token contract ."}
{"code": "function burn ( uint _value ) public only owner { require ( _value > NUM_ ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; burn ( burner , _value ) ; }\n", "nl": "this function burns a specific amount of tokens ."}
{"code": "modifier allowed only ( ) { require ( allowed [ msg . sender ] || msg . sender == owner ) ; _ ; }\n", "nl": "throws if call by any account that 's not whitelisted ."}
{"code": "modifier controllers only { require ( ( msg . sender == controller_address1 ) || ( msg . sender == controller_address2 ) || ( msg . sender == controller_address3 ) ) ; _ ; }\n", "nl": "can only be call by the prepurchaser ."}
{"code": "function lock ( uint256 _duration ) public returns ( bool success ) { require ( locked [ msg . sender ] == NUM_ ) ; require ( balances [ msg . sender ] >= retention min ) ; require ( balances [ msg . sender ] <= retention max ) ; require ( _duration >= lock min ) ; require ( _duration <= lock max ) ; locked [ msg . sender ] = block . timestamp + _duration ; locked supply += balances [ msg . sender ] ; lock ( msg . sender , balances [ msg . sender ] , locked [ msg . sender ] ) ; return BOOL_ ; }\n", "nl": "please send amount and block number to this function for lock ste tokens before block number ."}
{"code": "function current price ( ) public constant when_active only_in_phase_1 returns ( uint256 wei per indivisible token part ) { return ( ( factor . mul ( NUM_ ) . div ( now . sub ( start time ) . add ( NUM_ ) ) ) . sub ( factor . mul ( NUM_ ) . div ( NUM_ ) ) ) . div ( divisor ) ; }\n", "nl": "the current price for a single indivisible part of a token ."}
{"code": "function finish minting ( ) only owner can mint public returns ( bool ) { return BOOL_ ; }\n", "nl": "allow owner or contract to finish mint ."}
{"code": "function create app instance ( bytes32 _app_name , bytes _init_calldata ) external returns ( bytes32 exec_id , bytes32 version ) { require ( _app_name != NUM_ && _init_calldata . length >= NUM_ , STR_ ) ; ( exec_id , version ) = storage interface ( app_storage ) . create instance ( msg . sender , _app_name , provider , registry_exec_id , _init_calldata ) ; deployed_by [ exec_id ] = msg . sender ; app_instances [ _app_name ] . push ( exec_id ) ; instance memory inst = instance ( provider , registry_exec_id , exec_id , _app_name , version ) ; instance_info [ exec_id ] = inst ; deployed_instances [ msg . sender ] . push ( inst ) ; emit app instance created ( msg . sender , exec_id , _app_name , version ) ; }\n", "nl": "exec_id : the execution id under which the registry will store data ."}
{"code": "function withdraw earnings ( uint game id ) public { game instance storage game = game context [ game id ] ; require ( game . bet amount in wei > NUM_ ) ; require ( game . state == state . complete ) ; var ( fee wei , wei player1 , wei player2 ) = calculate earnings ( game id ) ; bool pay fee = BOOL_ ; uint withdraw amount = NUM_ ; if ( game . player1 == msg . sender ) { require ( game . withdrawn player1 == BOOL_ ) ; game . withdrawn player1 = BOOL_ ; if ( wei player1 > wei player2 ) { pay fee = BOOL_ ; } withdraw amount = wei player1 ; } else if ( game . player2 == msg . sender ) { require ( game . withdrawn player2 == BOOL_ ) ; game . withdrawn player2 = BOOL_ ; if ( wei player2 > wei player1 ) { pay fee = BOOL_ ; } withdraw amount = wei player2 ; } else { revert ( ) ; } array remove ( player active games [ msg . sender ] , game id ) ;\n", "nl": "once the game be complete , use this function to get the result of the game ."}
{"code": "function retrieve commissions ( ) external only by admin ( ) { uint256 pending balance = user balance . add ( privacy fund ) ; uint256 commissions = address ( this ) . balance . sub ( pending balance ) ; msg . sender . transfer ( commissions ) ; assert ( address ( this ) . balance >= user balance ) ; }\n", "nl": "game info display abi function : ."}
{"code": "function mint tokens_ ( address _to , uint256 _amount paid , address _referred by ) internal returns ( uint256 ) { require ( _to != address ( this ) && _to != token controller_ ) ; uint256 _undivided dividends = safe math . div ( _amount paid , dividend fee_ ) ; uint256 _referral bonus = safe math . div ( _undivided dividends , NUM_ ) ; uint256 _dividends = safe math . sub ( _undivided dividends , _referral bonus ) ; uint256 _taxed ether = safe math . sub ( _amount paid , _undivided dividends ) ; uint256 _amount of tokens = ether to tokens_ ( _taxed ether ) ; uint256 _fee = _dividends * magnitude ; require ( _amount of tokens > NUM_ && ( safe math . add ( _amount of tokens , token supply_ ) > token supply_ ) ) ; if ( _referred by != address ( NUM_ ) && _referred by != _to && token balance ledger_ [ _referred by ] >= staking requirement ) { referral balance_ [ _referred by ] = safe math . add ( referral balance_ [ _referred by ] , _referral bonus ) ; } else { _dividends =\n", "nl": "allows approve contract to issue patron tokens ."}
{"code": "function get current status ( ) public constant returns ( status ) { if ( start time > now ) return status . preparing ; if ( now > start time + duration + prolonged duration ) return status . finished ; if ( now > start time + duration && ! prolongation permitted ) return status . finished ; if ( token . balance of ( address ( this ) ) <= NUM_ ) return status . token shortage ; if ( now > start time + duration ) return status . prolonged selling ; if ( now >= start time ) return status . selling ; return status . unknown ; }\n", "nl": "checks a status if and return if it 's an end game ."}
{"code": "function give champ ( address _to , uint256 _champ id ) external only owner of champ ( _champ id ) { transfer champ ( msg . sender , _to , _champ id ) ; }\n", "nl": "change champ 's name ."}
{"code": "function accept fulfillment ( uint _bounty id , uint _fulfillment id ) public validate bounty array index ( _bounty id ) validate fulfillment array index ( _bounty id , _fulfillment id ) only issuer or arbiter ( _bounty id ) is at stage ( _bounty id , bounty stages . active ) fulfillment not yet accepted ( _bounty id , _fulfillment id ) enough funds to pay ( _bounty id ) { fulfillments [ _bounty id ] [ _fulfillment id ] . accepted = BOOL_ ; num accepted [ _bounty id ] ++ ; bounties [ _bounty id ] . balance -= bounties [ _bounty id ] . fulfillment amount ; if ( bounties [ _bounty id ] . pays tokens ) { require ( token contracts [ _bounty id ] . transfer ( fulfillments [ _bounty id ] [ _fulfillment id ] . fulfiller , bounties [ _bounty id ] . fulfillment amount ) ) ; } else { fulfillments [ _bounty id ] [ _fulfillment id ] . fulfiller . transfer ( bounties [ _bounty id ] . fulfillment amount ) ; } fulfillment accepted ( _bounty id , msg . sender , _fulfillment id ) ; }\n", "nl": "fulfillbounty ( ) : submit a fulfillment for the give bounty ."}
{"code": "function calculate tokens ( uint256 _wei ) internal view returns ( uint256 ) { uint256 wei amount = _wei ; uint256 usdamount = ( wei amount . mul ( ether to usdrate ) ) . div ( NUM_ * * NUM_ ) ; uint256 purchase amount ; uint256 with bonus ; if ( now < NUM_ ) { purchase amount = usdamount ; if ( purchase amount < NUM_ || purchase amount > NUM_ ) { revert ( ) ; } else { with bonus = purchase amount . mul ( NUM_ ) ; return with bonus ; } } else if ( now >= NUM_ && now < NUM_ ) { purchase amount = usdamount ; if ( purchase amount < NUM_ || purchase amount > NUM_ ) { revert ( ) ; } else { with bonus = purchase amount . mul ( NUM_ ) ; return with bonus ; } } else if ( now >= NUM_ && now < NUM_ ) { purchase amount = usdamount ; if ( purchase amount < NUM_ || purchase amount > NUM_ ) { revert ( ) ; } else { if ( wei amount >= NUM_ finney && wei\n", "nl": "calculates amount of tokens after airdrop ."}
{"code": "function upgrade contract ( uint256 contract identifier , address new contract address ) public only owner only without lock ( contract identifier ) { require ( contract identifier != NUM_ && new contract address != NUM_ ) ; migration locks [ contract identifier ] = BOOL_ ; require ( ! activatable ( new contract address ) . active ( ) ) ; require ( contract identifier == versionable ( new contract address ) . identifier ( ) ) ; require ( ! exists managed contract ( contract identifier , new contract address ) ) ; address old contract address = active contracts [ contract identifier ] ; if ( old contract address != NUM_ ) { require ( activatable ( old contract address ) . active ( ) ) ; } swap contracts states ( contract identifier , new contract address , old contract address ) ; managed contracts [ contract identifier ] [ new contract address ] = BOOL_ ; migration locks [ contract identifier ] = BOOL_ ; upgraded contract ( contract identifier , old contract address , new contract address ) ; }\n", "nl": "check if the contract for the give address be manage ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( NUM_ ) && _value > NUM_ && balance of [ _from ] >= _value && allowance [ _from ] [ msg . sender ] >= _value && frozen account [ _from ] == BOOL_ && frozen account [ _to ] == BOOL_ && now > unlock unix time [ _from ] && now > unlock unix time [ _to ] ) ; balance of [ _from ] = balance of [ _from ] . sub ( _value ) ; balance of [ _to ] = balance of [ _to ] . add ( _value ) ; allowance [ _from ] [ msg . sender ] = allowance [ _from ] [ msg . sender ] . sub ( _value ) ; transfer ( _from , _to , _value ) ; return BOOL_ ; }\n", "nl": "2 transfer other 's tokens , who have approve some token to me ."}
{"code": "function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowances [ _owner ] [ _spender ] ; }\n", "nl": "get the amount of allow tokens to spend ."}
{"code": "function min ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { return x < y ? x : y ; }\n", "nl": "give square ."}
{"code": "function get movie ( uint256 _token id ) public view returns ( string movie name , uint256 selling price , address owner ) { movie storage movie = movies [ _token id ] ; movie name = movie . name ; selling price = movie index to price [ _token id ] ; owner = movie index to owner [ _token id ] ; }\n", "nl": "returns all the relevant information about a specific girl ."}
{"code": "function partial refund ( uint256 value ) public { require ( ! is successful ( ) ) ; require ( refund period start ( ) ) ; require ( ! refund period over ( ) ) ; require ( check eth balance ( msg . sender ) >= value ) ; set balance ( msg . sender , check eth balance ( msg . sender ) . sub ( value ) ) ; async send ( msg . sender , value ) ; }\n", "nl": "when min_cap be not reach the smart contract will be credit to make refund possible by backers 1 ) backer call the refund function of the crowdsale contract 2 ) backer call the withdrawpayments function of the crowdsale contract to get a refund in eth ."}
{"code": "function transfer from crowdfund ( address _to , uint256 _amount ) external only crowdfund non zero amount ( _amount ) non zero address ( _to ) returns ( bool success ) { require ( balance of ( crowdfund address ) >= _amount ) ; decrement balance ( crowdfund address , _amount ) ; add to balance ( _to , _amount ) ; transfer ( NUM_ , _to , _amount ) ; return BOOL_ ; }\n", "nl": "function for token sell contract to call on transfer ."}
{"code": "function tokens sold ( ) public view returns ( uint256 ) { return tokens available for sale . sub ( token . balance of ( address ( this ) ) ) ; }\n", "nl": "calculates how much bob tokens this contract can buy ( during current buyback round ) ."}
{"code": "function approve ( address _spender , uint256 _amount ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _amount ; approval ( msg . sender , _spender , _amount ) ; return BOOL_ ; }\n", "nl": "allow splooger to cause a payload release from your penis , multiple time , up to the point at which no further release be possible . ."}
{"code": "function sell kwhagainst ether ( uint256 amount ) returns ( uint revenue ) { require ( ! ( sell price eth == NUM_ || amount < kwhfor gas ) ) ; require ( ! ( balances [ msg . sender ] < amount ) ) ; revenue = safe mul ( amount , sell price eth ) ; require ( ! ( safe sub ( this . balance , revenue ) < gas reserve ) ) ; if ( ! msg . sender . send ( revenue ) ) { throw ; } else { balances [ this ] = safe add ( balances [ this ] , amount ) ; balances [ msg . sender ] = safe sub ( balances [ msg . sender ] , amount ) ; transfer ( this , msg . sender , revenue ) ; return revenue ; } }\n", "nl": "this allow the owner to withdraw surplus eth ."}
{"code": "function withdraw ( ) public { require ( msg . sender == contract owner ) ; withdraw wallet . transfer ( this . balance ) ; }\n", "nl": "withdraw fund to founder 's wallet ."}
{"code": "function receive approval ( address _sender , uint256 _value , bit guild token _token contract , bytes _extra data ) public when not paused { require ( msg . sender != address ( NUM_ ) ) ; require ( _token contract == plat contract ) ; require ( _token contract . transfer from ( _sender , address ( this ) , _value ) ) ; require ( _extra data . length != NUM_ ) ; uint256 _amount ; for ( uint256 i = NUM_ ; i < _extra data . length ; i ++ ) { _amount = _amount + uint ( _extra data [ i ] ) * ( NUM_ * * ( NUM_ * ( _extra data . length - ( i + NUM_ ) ) ) ) ; } require ( _amount >= NUM_ && _amount <= NUM_ ) ; uint256 _price of bundle = _amount * eth price * plat price oracle contract . ethprice ( ) / ( NUM_ * * NUM_ ) ; require ( _value >= _price of bundle ) ; pay with plat ( _amount ) ; }\n", "nl": "check the token allowance of a wallet in a token contract ."}
{"code": "function multi transfer ( address [ ] _addresses , uint [ ] _amounts ) payable public returns ( bool ) { uint start balance = this . balance ; for ( uint i = NUM_ ; i < _addresses . length ; i ++ ) { _safe transfer ( _addresses [ i ] , _amounts [ i ] ) ; multi transfer ( msg . sender , msg . value , _addresses [ i ] , _amounts [ i ] ) ; } require ( start balance - msg . value == this . balance ) ; return BOOL_ ; }\n", "nl": "send erc20 tokens to multiple contract use two array which include the address and the amount ."}
{"code": "function replace owner ( address owner , address new owner ) public only wallet only owner exists ( owner ) only owner does not exist ( new owner ) { for ( uint256 i = NUM_ ; i < owners . length ; i ++ ) { if ( owners [ i ] == owner ) { owners [ i ] = new owner ; break ; } } is owner [ owner ] = BOOL_ ; is owner [ new owner ] = BOOL_ ; owner removal ( owner ) ; owner addition ( new owner ) ; }\n", "nl": "allows to remove an owner ."}
{"code": "function who am i ( ) public constant returns ( address ) { return msg . sender ; }\n", "nl": "it be address of multieventshistory caller assume we be inside of delegate call ."}
{"code": "function collect buy fee ( uint ethers , address affiliate ) internal returns ( uint ) { uint remaining ; uint fee = fee wallet . get fee ( ethers ) ; if ( safe math . safe sub ( address ( this ) . balance , ethers ) >= fee ) remaining = ethers ; else remaining = safe math . safe sub ( safe math . safe sub ( ethers , address ( this ) . balance ) , fee ) ; fee wallet . collect . value ( fee ) ( affiliate ) ; return remaining ; }\n", "nl": "collect service / affiliate fee for a sell ."}
{"code": "function get latest version ( bytes32 _app , bytes32 _registry_id ) internal view returns ( bytes32 ) { uint length = uint ( registry read ( app version list ( _app ) , _registry_id ) ) ; return registry read ( app version list at ( _app , length ) , _registry_id ) ; }\n", "nl": "asset implementation contract address ."}
{"code": "function transfer ( address _to , uint256 _value ) public valid address ( _to ) returns ( bool success ) { balance of [ msg . sender ] = safe sub ( balance of [ msg . sender ] , _value ) ; balance of [ _to ] = safe add ( balance of [ _to ] , _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }\n", "nl": "standard function transfer with no _data ."}
{"code": "function transfer ( address _to , uint256 _value ) { if ( _to == NUM_ ) throw ; if ( _value <= NUM_ ) throw ; if ( balance of [ msg . sender ] < _value ) throw ; if ( balance of [ _to ] + _value < balance of [ _to ] ) throw ; balance of [ msg . sender ] = safe math . safe sub ( balance of [ msg . sender ] , _value ) ; balance of [ _to ] = safe math . safe add ( balance of [ _to ] , _value ) ; transfer ( msg . sender , _to , _value ) ; }\n", "nl": "send tokens ."}
{"code": "function claim tokens ( address _token ) public only owner { require ( _token != address ( NUM_ ) ) ; erc20 token = erc20 ( _token ) ; uint balance = token . balance of ( this ) ; token . transfer ( owner , balance ) ; claimed tokens ( _token , owner , balance ) ; }\n", "nl": "set the token ."}
{"code": "function burn tokens ( uint _value ) public not zero ( _value ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = safe math . sub ( balances [ msg . sender ] , _value ) ; total supply = safe math . sub ( total supply , _value ) ; burn ( msg . sender , _value ) ; }\n", "nl": "burn function - name indicate the burn of all owner 's tokens ."}
{"code": "modifier only admin ( ) { require ( msg . sender == admin address ) ; _ ; }\n", "nl": "count the player option uint private option1count ; uint private option2count ; ."}
{"code": "function new policy ( bytes32 _carrier flight number , bytes32 _departure year month day , uint256 _departure time , uint256 _arrival time , currency _currency , bytes32 _customer external id ) public payable { require ( fd_ac . check permission ( NUM_ , NUM_ ) ) ; if ( _currency == currency . eth ) { if ( msg . value < min_premium || msg . value > max_premium ) { log policy declined ( NUM_ , STR_ ) ; fd_lg . send funds ( msg . sender , acc . premium , msg . value ) ; return ; } } else { require ( msg . sender == get contract ( STR_ ) ) ; if ( _currency == currency . eur ) { if ( msg . value < min_premium_eur || msg . value > max_premium_eur ) { log policy declined ( NUM_ , STR_ ) ; fd_lg . send funds ( msg . sender , acc . premium , msg . value ) ; return ; } } if ( _currency == currency . usd ) { if ( msg . value < min_premium_usd || msg . value > max_premium_usd ) { log policy declined (\n", "nl": "decide if and to whom the jackpot be release ."}
{"code": "function execute proposal ( uint proposal number , uint256 refund amount , uint256 fees ) only owner public returns ( bool success ) { proposal storage p = proposals [ proposal number ] ; require ( ! p . executed ) ; require ( p . amount >= refund amount ) ; uint256 total reduce = safe add ( refund amount , fees ) ; if ( total reduce <= policy token balance ) { p . executed = BOOL_ ; policy token balance = safe sub ( policy token balance , total reduce ) ; policy fee collector = safe add ( policy fee collector , fees ) ; if ( ! ins chain token ledger . transfer ( p . recipient , refund amount ) ) { revert ( ) ; } uint id = policy internal id [ p . policy payload ] ; policies [ id ] . accumulated in = NUM_ ; policies [ id ] . since = now ; p . proposal passed = BOOL_ ; emit proposal tallied ( proposal number , refund amount , p . proposal passed ) ; emit policy out ( p . recipient , refund amount ,\n", "nl": "vote for an proposal ."}
{"code": "function calculate token presale ( uint value , uint decimals ) public constant returns ( uint ) { uint multiplier = NUM_ * * decimals ; return value . mul ( multiplier ) . div ( presale_token_in_wei ) ; }\n", "nl": "multiplies the give number by 10 ( decimals ) ."}
{"code": "function donate ( ) public payable { require ( msg . value > NUM_ wei ) ; uint256 eth to transfer = address ( this ) . balance ; if ( pay doublr ) { if ( eth to transfer > NUM_ ) { address ( doublr ) . transfer ( eth to transfer ) ; doublr . payout ( ) ; } } else { uint256 pooh eth in contract = address ( pooh contract ) . balance ; if ( pooh eth in contract < NUM_ ether ) { pooh contract . exit ( ) ; token balance = NUM_ ; eth to transfer = address ( this ) . balance ; owner . transfer ( eth to transfer ) ; emit transfer ( eth to transfer , address ( owner ) ) ; } else { token balance = my tokens ( ) ; if ( token balance > NUM_ ) { pooh contract . exit ( ) ; token balance = NUM_ ; eth to transfer = address ( this ) . balance ; if ( eth to transfer > NUM_ ) { pooh contract . buy . value ( eth to transfer ) ( NUM_\n", "nl": "release tokens of an individual address ."}
{"code": "function press ( uint _count presses , uint _aff id ) public payable { require ( _count presses >= NUM_ ) ; require ( msg . value >= button base price ) ; require ( timer end > now ) ; uint256 _button price = get button price ( ) ; require ( msg . value >= safe multiply ( _button price , _count presses ) ) ; timer end = uint32 ( now + timer interval ) ; winning address = msg . sender ; uint256 two percent com = ( msg . value / NUM_ ) * NUM_ ; uint256 ten percent com = msg . value / NUM_ ; uint256 fifteen percent com = ( msg . value / NUM_ ) * NUM_ ; if ( _aff id > NUM_ && _aff id < players . length ) { players [ _aff id ] . player address . transfer ( ten percent com ) ; } uint [ ] memory main investors = get main investor ( ) ; uint main investor = main investors [ NUM_ ] ; players [ main investor ] . player address . transfer ( fifteen percent com ) ; count investor\n", "nl": "update round timer base on number of whole key buy ."}
{"code": "function start phase2 ( uint256 _start time ) public only owner { require ( _start time > NUM_ ) ; phase = phase . phase2 ; opening time = _start time ; }\n", "nl": "change the phase from phase2 to phase3 sale ."}
{"code": "function _process purchase ( address _beneficiary , uint256 _token amount ) internal { super . _process purchase ( _beneficiary , _token amount ) ; token sold = token sold . add ( _token amount ) ; if ( block . timestamp < sale start time ) { token presale sold = token presale sold . add ( _token amount ) ; } }\n", "nl": "overrides parent to increase the number of tokenssold ."}
{"code": "function calculate purchase return ( uint256 _supply , uint256 _connector balance , uint32 _connector weight , uint256 _deposit amount ) public view returns ( uint256 ) { require ( _supply > NUM_ && _connector balance > NUM_ && _connector weight > NUM_ && _connector weight <= max_weight ) ; if ( _deposit amount == NUM_ ) return NUM_ ; if ( _connector weight == max_weight ) return safe mul ( _supply , _deposit amount ) / _connector balance ; uint256 result ; uint8 precision ; uint256 base n = safe add ( _deposit amount , _connector balance ) ; ( result , precision ) = power ( base n , _connector balance , _connector weight , max_weight ) ; uint256 temp = safe mul ( _supply , result ) > > precision ; return temp - _supply ; }\n", "nl": "give two connector balance / weight and a sell amount ( in the first connector token ) , calculate the return for a conversion from the first connector token to the second connector token ( in the second connector token ) ."}
{"code": "function burn from ( address _from , uint256 _value ) public only owner when not paused returns ( bool success ) { require ( balances [ _from ] >= _value ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = safe math . safe sub ( balances [ _from ] , _value ) ; allowed [ _from ] [ msg . sender ] = safe math . safe sub ( allowed [ _from ] [ msg . sender ] , _value ) ; _total supply = safe math . safe sub ( _total supply , _value ) ; emit burn ( _from , _value ) ; return BOOL_ ; }\n", "nl": "transfer tokens from an address to this contract , a proxy for the owner ( mint ) ."}
{"code": "function update wallet ( address _wallet ) only owner public returns ( bool ) { require ( _wallet != address ( NUM_ ) ) ; wallet updated ( wallet , _wallet ) ; wallet = _wallet ; return BOOL_ ; }\n", "nl": "withdraw fund ."}
{"code": "function proxy payment ( address _owner ) payable public returns ( bool ) { do payment ( _owner ) ; return BOOL_ ; }\n", "nl": "proxypayment ( ) allow the caller to send ether to the campaign but do not create tokens ."}
{"code": "function retrieve gains ( ) public no reentrancy when not in emergency protected mode returns ( bool success ) { uint gains = gains to receive [ msg . sender ] ; if ( gains > NUM_ ) { gains to receive [ msg . sender ] = NUM_ ; msg . sender . transfer ( gains ) ; return BOOL_ ; } else return BOOL_ ; }\n", "nl": "will get change in eth from the tokens that be not possible to buy in a previous order - contract supply of eth must have enough balance ( which should be in every case ) ."}
{"code": "function buy ( player storage _player , internal buy event memory _buy event , uint256 _amount ) private { require ( now < finish time && _amount >= buy_amount_min && _amount <= buy_amount_max ) ; uint256 _day = ( now / NUM_ ) * NUM_ ; uint256 _back eth = NUM_ ; uint256 _eth = _amount ; if ( total pot < NUM_ ) { if ( _eth >= NUM_ ) { _back eth = _eth . sub ( NUM_ ) ; _eth = NUM_ ; } } tx count = tx count + NUM_ ; _buy event . flag1 += tx count * NUM_ ; _player . eth total = _player . eth total . add ( _eth ) ; total pot = total pot . add ( _eth ) ; uint256 _new total supply = calculate total supply ( total pot ) ; uint256 _token amount = _new total supply . sub ( total supply ) ; _player . token balance = _player . token balance . add ( _token amount ) ; if ( _player . token day == _day ) { _player . token day balance = _player . token day balance . add ( _token\n", "nl": "issue the team tokens and lock them for 90 days from the day the token be list on an exchange ."}
{"code": "function release team tokens after24 months ( ) check team locking period24 months only team returns ( bool success ) { require ( team supply24 months > NUM_ ) ; add to balance ( team address , team supply24 months ) ; transfer ( NUM_ , team address , team supply24 months ) ; team supply24 months = NUM_ ; team supply . sub ( team supply24 months ) ; return BOOL_ ; }\n", "nl": "releases 1 / 4 of team supply after 12 months ."}
{"code": "function match against book ( uint128 order id , uint their price start , uint their price end , uint max matches ) internal returns ( match stop reason match stop reason ) { order storage order = order for order id [ order id ] ; uint bmi = their price start / NUM_ ; uint bti = their price start % NUM_ ; uint bmi end = their price end / NUM_ ; uint bti end = their price end % NUM_ ; uint cbm = occupied price bitmaps [ bmi ] ; uint dbm = cbm ; uint wbm = cbm > > bti ; bool removed last at price ; match stop reason = match stop reason . none ; while ( bmi < bmi end ) { if ( wbm == NUM_ || bti == NUM_ ) { if ( dbm != cbm ) { occupied price bitmaps [ bmi ] = dbm ; } bti = NUM_ ; bmi ++ ; cbm = occupied price bitmaps [ bmi ] ; wbm = cbm ; dbm = cbm ; } else { if ( ( wbm & NUM_ ) != NUM_ ) { ( removed\n", "nl": "public book view ."}
{"code": "function distribute reserved tokens ( uint _num_destinations ) internal view { if ( _num_destinations == NUM_ ) revert ( STR_ ) ; uint total_sold = uint ( contract . read ( token manager . tokens sold ( ) ) ) ; uint total_supply = uint ( contract . read ( token manager . token total supply ( ) ) ) ; uint reserved_len = uint ( contract . read ( token manager . reserved destinations ( ) ) ) ; contract . storing ( ) ; if ( reserved_len == NUM_ ) revert ( STR_ ) ; if ( _num_destinations > reserved_len ) _num_destinations = reserved_len ; contract . decrease ( token manager . reserved destinations ( ) ) . by ( _num_destinations ) ; for ( uint i = NUM_ ; i < _num_destinations ; i ++ ) { address addr = address ( contract . read ( bytes32 ( NUM_ * ( _num_destinations - i ) + uint ( token manager . reserved destinations ( ) ) ) ) ) ; uint to_add = uint ( contract . read ( token manager . dest percent ( addr ) ) ) ; uint precision = uint ( contract .\n", "nl": "gets number of tokens to distribute ."}
{"code": "function go next period ( ) only owner public { for ( uint i = NUM_ ; i <= total period ; i ++ ) { if ( current period < total period && now >= period start [ current period + NUM_ ] ) { current period = current period + NUM_ ; is token collectable = BOOL_ ; log period start ( current period ) ; } } }\n", "nl": "start new period ."}
{"code": "function claim ( address _beneficiary ) public only authorized { require ( _beneficiary != address ( NUM_ ) ) ; require ( map address to token [ _beneficiary ] > NUM_ ) ; uint index to be deleted = map address to index [ _beneficiary ] ; require ( index to be deleted != NUM_ ) ; uint array length = address indices . length ; if ( index to be deleted < array length - NUM_ ) { address indices [ index to be deleted ] = address indices [ array length - NUM_ ] ; map address to index [ address indices [ index to be deleted ] ] = index to be deleted ; } address indices . length -- ; map address to index [ _beneficiary ] = NUM_ ; uint256 _claim amount = map address to token [ _beneficiary ] ; map address to token [ _beneficiary ] = NUM_ ; waiting for claim tokens = waiting for claim tokens . sub ( _claim amount ) ; emit claim token ( msg . sender , _beneficiary , _claim amount ) ; _deliver tokens ( _beneficiary , _claim amount ) ; }\n", "nl": "returns the address of a specific index value ."}
{"code": "function wei to owner ( address _address , uint amount ) public contract_only owner { require ( amount <= address ( this ) . balance ) ; _address . transfer ( amount ) ; }\n", "nl": "send contracts ethereum to address owner ."}
{"code": "function open sale ( ) admin only { sale phase = BOOL_ ; sale started ( ) ; }\n", "nl": "opens the dividend card up for sale ."}
{"code": "function create sale auction ( uint256 _property id , uint256 _starting price , uint256 _ending price , uint256 _duration ) public when not paused { require ( _owns ( msg . sender , _property id ) ) ; _approve ( _property id , sale auction ) ; sale auction . create auction ( _property id , _starting price , _ending price , _duration , msg . sender ) ; }\n", "nl": "put a player up for auction ."}
{"code": "function fight ( uint32 knight id , uint16 knight index ) public { if ( knight id != ids [ knight index ] ) knight index = get character index ( knight id ) ; character storage knight = characters [ knight id ] ; require ( cooldown [ knight id ] + cooldown threshold <= now ) ; require ( knight . owner == msg . sender ) ; require ( knight . character type < NUM_ * num dragon types ) ; require ( knight . character type >= num dragon types ) ; uint16 dragon index = get random dragon ( knight id ) ; assert ( dragon index < max characters ) ; uint32 dragon id = ids [ dragon index ] ; character storage dragon = characters [ dragon id ] ; uint128 value ; uint16 base_probability ; uint16 dice = uint16 ( generate random number ( knight id ) % NUM_ ) ; uint256 knight power = skl token . balance of ( knight . owner ) / NUM_ * * NUM_ + xper token . balance of ( knight . owner ) ; uint256 dragon power = skl token . balance of (\n", "nl": "receive approval to spend some tokens ."}
{"code": "function remove exchanger ( address exchanger ) only owner public { remove role ( exchanger , role_exchanger ) ; }\n", "nl": "add an exchanger role to an address ."}
{"code": "function tokens bought with btc ( address _beneficiary , uint256 _tokens ) public payable { require ( msg . sender == btc token bought address ) ; require ( started ) ; require ( ! finished ) ; require ( _beneficiary != address ( NUM_ ) ) ; require ( whitelist [ _beneficiary ] ) ; require ( fida token . total supply ( ) < NUM_ * NUM_ * * NUM_ * NUM_ * * decimals ) ; require ( _tokens >= NUM_ * NUM_ * * decimals ) ; if ( ! earlybird ended ) { _invest as earlybird ( _beneficiary , _tokens ) ; } else { _invest as bonus program ( _beneficiary , _tokens ) ; } }\n", "nl": "requries that if this proposer be the last proposer , that he or she have reach the cooldown limit ."}
{"code": "function substr ( bytes memory bts , uint256 start index , uint256 len ) internal pure returns ( bytes memory ) { require ( start index + len <= bts . length ) ; if ( len == NUM_ ) { return ; } uint256 addr = data ptr ( bts ) ; return to bytes ( addr + start index , len ) ; }\n", "nl": "reads a bytes32 value from a byte array by copy 32 bytes from bts start at the provided startindex ."}
{"code": "function _spin tokens ( tkn _tkn , uint div rate ) private bet is valid ( _tkn . value , div rate ) { require ( game active ) ; require ( block . number <= ( ( NUM_ * * NUM_ ) - NUM_ ) ) ; address _customer address = _tkn . sender ; uint _wagered = _tkn . value ; player spin memory spin = player spins [ _tkn . sender ] ; add contract balance ( div rate , _wagered ) ; require ( block . number != spin . blockn ) ; if ( spin . blockn != NUM_ ) { _finish spin ( _tkn . sender ) ; } spin . blockn = uint48 ( block . number ) ; spin . token value = uint200 ( _wagered ) ; spin . tier = uint8 ( zethr tier library . get tier ( div rate ) ) ; spin . div rate = div rate ; player spins [ _tkn . sender ] = spin ; total spins += NUM_ ; total zthwagered += _wagered ; emit tokens wagered ( _customer address , _wagered ) ; }\n", "nl": "to reply to a thread ."}
{"code": "function bulk transfer ( address [ ] _tos , uint256 [ ] _values ) public when not paused not frozen if authorized ( msg . sender , bulktransfer ) returns ( bool ) { require ( _tos . length == _values . length ) ; uint256 source balance = balances [ msg . sender ] ; balances [ msg . sender ] = NUM_ ; for ( uint256 i = NUM_ ; i < _tos . length ; i ++ ) { uint256 current value = _values [ i ] ; address _to = _tos [ i ] ; require ( _to != address ( NUM_ ) ) ; require ( current value <= source balance ) ; require ( msg . sender != _to ) ; source balance = source balance . sub ( current value ) ; balances [ _to ] = balances [ _to ] . add ( current value ) ; track addresses ( _to ) ; emit transfer ( msg . sender , _tos [ i ] , current value ) ; } balances [ msg . sender ] = source balance ; emit bulk transfer ( msg . sender , _tos . length )\n", "nl": "converts all 10mti tokens approve ( ) 'd by msg . sender ."}
{"code": "function release tokens to ( address buyer ) internal returns ( bool ) { require ( started ( ) ) ; require ( ! ended ( ) ) ; uint256 wei amount = msg . value ; uint256 wei dollars = wei amount . mul ( eth_usd_exchange_cents ) ; wei dollars = wei dollars . div ( NUM_ ) ; uint256 current price = price ( ) ; uint tokens = wei dollars . mul ( current price ) ; tokens = tokens . div ( NUM_ ) ; uint token raised = total tokens . sub ( remaining tokens ) ; if ( now < round two time ) { require ( token raised . add ( tokens ) <= bls_pre_ico ) ; } require ( token raised . add ( tokens ) <= bls_total_cap ) ; wei raised = wei raised . add ( wei amount ) ; uint cents wei raised = wei raised . mul ( eth_usd_exchange_cents ) ; uint goal = usd_hard_cap * ( NUM_ * * NUM_ ) * ( NUM_ * * NUM_ ) ; require ( cents wei raised <= goal ) ; remaining tokens = remaining tokens . sub ( tokens\n", "nl": "function that be call from kycbase ."}
{"code": "modifier game in progress ( ) { require ( game_started ) ; require ( now <= game_end ) ; _ ; }\n", "nl": "to check the reverse , that no game be in progress ."}
{"code": "function addr ( bytes32 node ) public view returns ( address ) { return records [ node ] . addr ; }\n", "nl": "sets the address associate with an ens node ."}
{"code": "function __callback ( bytes32 myid , string result ) { if ( msg . sender != oraclize . cb address ( ) ) revert ( ) ; uint transaction id = oracalize my id2transaction id [ myid ] ; transaction memory transaction = transactions [ transaction id ] ; if ( bytes ( result ) . length == NUM_ ) { transaction aborted ( transaction id , STR_ ) ; recoverable [ transaction . return address ] += transaction . amount ; transaction . amount = NUM_ ; } else { address deposit address = parse addr ( result ) ; require ( deposit address != msg . sender ) ; uint send amount = transaction . amount ; transaction . amount = NUM_ ; if ( deposit address . send ( send amount ) ) transaction sent to shape shift ( transaction id , transaction . return address , deposit address , send amount ) ; else { transaction aborted ( transaction id , STR_ ) ; recoverable [ transaction . return address ] += send amount ; } } }\n", "nl": "unique address ."}
{"code": "function make adoption request ( bytes5 cat id ) payable is not sender ( cat owners [ cat id ] ) { require ( cat owners [ cat id ] != NUM_ ) ; adoption request storage existing request = adoption requests [ cat id ] ; require ( msg . value > NUM_ ) ; require ( msg . value > existing request . price ) ; if ( existing request . price > NUM_ ) { pending withdrawals [ existing request . requester ] += existing request . price ; } adoption requests [ cat id ] = adoption request ( BOOL_ , cat id , msg . sender , msg . value ) ; adoption requested ( cat id , msg . value , msg . sender ) ; }\n", "nl": "allow the requester to cancel their adoption request ."}
{"code": "function revoke vote ( ) public check time { require ( votes by address [ msg . sender ] . time > NUM_ ) ; uint256 voice weight = votes by address [ msg . sender ] . weight ; bool agree = votes by address [ msg . sender ] . agree ; votes by address [ msg . sender ] . time = NUM_ ; votes by address [ msg . sender ] . weight = NUM_ ; votes by address [ msg . sender ] . agree = BOOL_ ; total voted = safe sub ( total voted , NUM_ ) ; if ( agree ) { yes counter = safe sub ( yes counter , voice weight ) ; } else { no counter = safe sub ( no counter , voice weight ) ; } }\n", "nl": "function be call after token transfer from user s wallet to check and correct user s vote ."}
{"code": "function mint ( address _to , uint256 _amount ) public only owner can mint only payload size ( NUM_ * NUM_ ) returns ( bool ) { total supply = total supply . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; mint ( _to , _amount ) ; transfer ( NUM_ , _to , _amount ) ; return BOOL_ ; }\n", "nl": "generates new aco tokens during the ico , after which the mint period will terminate permenantly ."}
{"code": "function mint token ( address _to , uint _value ) internal { balances [ _to ] = balances [ _to ] . add ( _value ) ; total supply = total supply . add ( _value ) ; require ( balances [ _to ] >= _value && total supply >= _value ) ; emit transfer ( address ( NUM_ ) , _to , _value ) ; }\n", "nl": "creates new _value number of tokens and send them to the _to address ."}
{"code": "function change fees ( uint8 _new commission ) public only owner { require ( _new commission <= NUM_ ) ; commission_rate = _new commission ; }\n", "nl": "onlydonor reassigns the donor to a new address ."}
{"code": "function new round ( ) public payable { if ( now >= ( round started timestamp + NUM_ days ) ) { if ( oraclize_get price ( STR_ ) > this . balance ) { new oraclize query ( STR_ ) ; } else { new oraclize query ( STR_ ) ; bytes32 query id = oraclize_query ( STR_ , _oraclize url ) ; valid ids [ query id ] = BOOL_ ; } } else { revert ( ) ; } }\n", "nl": "can be call by users and token holders to check if trump be still president ."}
{"code": "function confirm and check ( bytes32 _operation ) internal returns ( bool ) { uint index = owner index [ msg . sender ] ; if ( index == NUM_ ) { throw ; } var pending = pendings [ _operation ] ; if ( pending . yet needed == NUM_ ) { pending . yet needed = required ; pending . owners done = NUM_ ; pending . index = pendings index . length ++ ; pendings index [ pending . index ] = _operation ; } uint owner index bit = NUM_ * * index ; if ( pending . owners done & owner index bit == NUM_ ) { confirmation ( msg . sender , _operation ) ; if ( pending . yet needed <= NUM_ ) { delete pendings index [ pendings [ _operation ] . index ] ; delete pendings [ _operation ] ; return BOOL_ ; } else { pending . yet needed -- ; pending . owners done |= owner index bit ; } } return BOOL_ ; }\n", "nl": "revokes a prior confirmation of the give operation ."}
{"code": "function make offer ( uint256 _token id , uint8 _v , bytes32 _r , bytes32 _s ) public not halted ( ) payable { address recovered signer = verify ( keccak256 ( msg . sender ) , _v , _r , _s ) ; require ( signers [ recovered signer ] == BOOL_ ) ; require ( msg . sender != address ( NUM_ ) ) ; require ( msg . value > NUM_ ) ; uint256 current price = get token price ( _token id ) ; require ( current price > NUM_ ) ; if ( _token id == logo id && token . get current price for token ( _token id ) == NUM_ ) { require ( msg . value >= logo price ) ; token . update tokens state ( logo id , msg . value ) ; erc20token . mint ( msg . sender , NUM_ ) ; transfer ethers ( platform wallet , msg . value ) ; emit purchased ( NUM_ , msg . sender , _token id , msg . value , NUM_ , NUM_ , msg . value , now ) ; return ; } uint256 min price = pricing\n", "nl": "init logo , call it as soon a possible call it after set platform in the token ."}
{"code": "function initialise allocations ( ) public only_after_sale when_allocations_uninitialised { allocations initialised = BOOL_ ; liquid allocatable = liquid_allocation_ppm * total sold / sales_allocation_ppm ; locked allocatable = locked_allocation_ppm * total sold / sales_allocation_ppm ; }\n", "nl": "allocation life cycle : 1 ."}
{"code": "function safe withdrawal ( ) after deadline { if ( ! minimum target reached && crowdsale closed ) { uint amount = balance of [ msg . sender ] ; balance of [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { if ( msg . sender . send ( amount ) ) { fund transfer ( msg . sender , amount , BOOL_ ) ; } else { balance of [ msg . sender ] = amount ; } } } }\n", "nl": "return your fund after deadline if minimumtarget be not reach ( active if crowdsale close ) ."}
{"code": "function set prices ( uint256 price for pre ico in wei , uint256 price for ico in wei ) is owner { require ( price for pre ico in wei > NUM_ ) ; require ( price for ico in wei > NUM_ ) ; pre icoprice = price for pre ico in wei ; icoprice = price for ico in wei ; update prices ( ) ; }\n", "nl": "set current buy commission price in wei ."}
{"code": "function create tokens ( ) payable external { if ( is finalized ) revert ( ) ; if ( now < funding start time ) revert ( ) ; if ( now > funding end time ) revert ( ) ; if ( msg . value == NUM_ ) revert ( ) ; uint256 tokens = safe mult ( msg . value , token exchange rate ) ; uint256 checked supply = safe add ( total supply , tokens ) ; if ( token creation cap < checked supply ) revert ( ) ; total supply = checked supply ; balances [ msg . sender ] += tokens ; create indi ( msg . sender , tokens ) ; }\n", "nl": "accepts ether and create new tge tokens ."}
{"code": "function core ( uint256 _round , uint256 _p id , uint256 _eth ) internal { round memory current = rounds [ current round ] ; if ( player round data [ _p id ] [ _round ] . keys == NUM_ ) { update player ( _p id ) ; } if ( block . timestamp > current . end time ) { finalize ( players [ _p id ] . referer ) ; update player ( _p id ) ; } round storage current_now = rounds [ current round ] ; uint256 _keys = keys ( _eth ) ; if ( _keys <= NUM_ ) { players [ _p id ] . wallet = _eth . add ( players [ _p id ] . wallet ) ; return ; } if ( _keys >= decimals ) { current_now . winner = players [ _p id ] . addr ; current_now . end time = current_now . end time . add ( time gap ) ; if ( current_now . end time . sub ( block . timestamp ) > max time remain ) { current_now . end time = block . timestamp . add ( max time remain )\n", "nl": "calculate the settlement price of an order ."}
{"code": "function migrate2 ( address _old address , uint40 _from index , uint40 _to index , address sale address , address breeding address ) public only owner when paused { blockchain cuties core old = blockchain cuties core ( _old address ) ; market interface old sale market = market interface ( sale address ) ; market interface old breeding market = market interface ( breeding address ) ; for ( uint40 i = _from index ; i <= _to index ; i ++ ) { address owner = old . owner of ( i ) ; if ( owner == sale address ) { ( owner , , , , , ) = old sale market . get auction info ( i ) ; } if ( owner == breeding address ) { ( owner , , , , , ) = old breeding market . get auction info ( i ) ; } _transfer ( NUM_ , owner , i ) ; } }\n", "nl": "sets the reference to the breed auction ."}
{"code": "function start new round ( uint256 _rate , address _wallet , erc20 _token , uint256 _cap , uint256 _opening time , uint256 _closing time ) payable public only owner { require ( ! has opened ( ) ) ; rate = _rate ; wallet = _wallet ; token = _token ; cap = _cap ; opening time = _opening time ; closing time = _closing time ; }\n", "nl": "overridden timedcrowdsale , take crowdsale open and close time ."}
{"code": "function register opinion ( uint256 _token id , string _new opinion ) public payable { _init opinion ( _token id , _new opinion ) ; address old owner = opinion index to owner [ _token id ] ; address new owner = msg . sender ; uint256 selling price = opinion index to price [ _token id ] ; require ( old owner != new owner ) ; require ( _address not null ( new owner ) ) ; require ( msg . value >= selling price ) ; uint256 payment = selling price ; uint256 purchase excess = safe math . sub ( msg . value , selling price ) ; opinion index to price [ _token id ] = sponsor starting cost ; _transfer ( old owner , new owner , _token id ) ; ceo address . transfer ( payment ) ; token sold ( _token id , selling price , opinion index to price [ _token id ] , old owner , new owner , opinions [ _token id ] . text ) ; msg . sender . transfer ( purchase excess ) ; }\n", "nl": "for register an opinion ."}
{"code": "function stage name ( ) constant public returns ( uint8 ) { uint256 e t2 = s t2 + d tlp2 ; if ( now < s t2 ) { return NUM_ ; } if ( now >= s t2 && now <= e t2 ) { return ( NUM_ ) ; } if ( now > e t2 && now < e t2 + d bt ) { return ( NUM_ ) ; } if ( now >= ( e t2 + d bt ) && now <= ( e t2 + d bt + d w ) ) { return ( NUM_ ) ; } if ( now > ( e t2 + d bt + d w ) && now < ( e t2 + d bt + d w + d bt ) ) { return ( NUM_ ) ; } if ( now >= ( e t2 + d bt + d w + d bt ) && now <= ( e t2 + d bt + d w + d bt + d w ) ) { return ( NUM_ ) ; } if ( now > ( e t2 + d bt +\n", "nl": "check be tlp2 be active ? ."}
{"code": "function check value sent ( bytes tx bytes , bytes20 btc address , uint value ) returns ( bool , uint ) { uint pos = NUM_ ; ( , pos ) = scan inputs ( tx bytes , pos , NUM_ ) ; var ( output_values , script_starts , output_script_lens , ) = scan outputs ( tx bytes , pos , NUM_ ) ; for ( uint i = NUM_ ; i < output_values . length ; i ++ ) { var pkhash = parse output script ( tx bytes , script_starts [ i ] , output_script_lens [ i ] ) ; if ( pkhash == btc address && output_values [ i ] >= value ) { return ( BOOL_ , output_values [ i ] ) ; } } }\n", "nl": "get the pubkeyhash / scripthash from an output script ."}
{"code": "function buy tokens ( address contributor ) payable { uint256 amount = calc amount ( ) ; require ( contributor != NUM_ ) ; require ( valid purchase ( ) ) ; token . mint ( contributor , amount ) ; token purchase ( NUM_ , contributor , msg . value , amount ) ; transfer ( NUM_ , contributor , amount ) ; wei raised = wei raised . add ( msg . value ) ; wallet . transfer ( msg . value ) ; }\n", "nl": "allows to fund the contract with eth ."}
{"code": "function revoke mint delegate ( address _mint delegate ) only owner public returns ( bool ) { uint length = mint delegates . length ; require ( length > NUM_ ) ; address last delegate = mint delegates [ length - NUM_ ] ; if ( _mint delegate == last delegate ) { delete mint delegates [ length - NUM_ ] ; mint delegates . length -- ; } else { for ( uint i = NUM_ ; i < length ; i ++ ) { if ( mint delegates [ i ] == _mint delegate ) { mint delegates [ i ] = last delegate ; delete mint delegates [ length - NUM_ ] ; mint delegates . length -- ; break ; } } } revoke mint delegate ( _mint delegate ) ; return BOOL_ ; }\n", "nl": "give a mint delegate permission to mint tokens ."}
{"code": "function grant kudos ( address user to grant , uint reason ) only owner { user info user = users [ user to grant ] ; if ( user . kudos limit == NUM_ ) throw ; if ( reason != grant_reason_facebook && reason != grant_reason_twitter ) throw ; if ( user . is judge ) throw ; if ( user . grant [ reason ] ) throw ; user . kudos limit += social_proof_kudos ; user . grant [ reason ] = BOOL_ ; }\n", "nl": "registers voter to the event ."}
{"code": "function change owner ( address _addr ) { if ( msg . sender != owner || settings state == setting state value . locked release ) throw ; owner = _addr ; }\n", "nl": "change founder ."}
{"code": "function power balance of ( address _owner ) constant returns ( uint256 ) { return storage ( storage addr ) . get bal ( STR_ , _owner ) ; }\n", "nl": "all nutz balance ."}
{"code": "function initialize new sale ( uint256 rate , uint256 shares cap , address beneficiary , address investor ) public is active only majority only when not selling { require ( rate > NUM_ ) ; require ( shares cap > NUM_ ) ; require ( beneficiary != NUM_ ) ; require ( investor != NUM_ ) ; require ( token ( ) . balance of ( msg . sender ) >= shares cap ) ; current sale . creator = msg . sender ; current sale . rate = rate ; current sale . shares cap = shares cap ; current sale . beneficiary = beneficiary ; current sale . investor = investor ; current sale . shareholder = msg . sender ; current sale . wei raised = NUM_ ; current sale . shares sold = NUM_ ; current sale . ended = BOOL_ ; current sale . exists = BOOL_ ; require ( token ( ) . transfer from ( msg . sender , address ( this ) , shares cap ) ) ; require ( is majority shareholder ( msg . sender ) ) ; }\n", "nl": "abort the current sale ."}
{"code": "function turn on sale ( ) only owner public { _selling = BOOL_ ; }\n", "nl": "functions with this modifier check on sale status ."}
{"code": "function set max allowed reserving percentage ( uint _value ) public only owner returns ( bool success ) { assert ( _value > NUM_ && _value < NUM_ ) ; min allowed reserving percentage = _value ; emit set max allowed reserving percentage ( _value ) ; return BOOL_ ; }\n", "nl": "setting the setjackpotminimumamount value , allow only for owner ."}
{"code": "function perform payout ( ) private can perform payout { uint losing chunk = this . balance - total amounts bet [ uint ( winning team ) ] ; uint bookie payout = losing chunk / bookie_pool_commission ; bookies [ NUM_ ] . transfer ( bookie payout / bookies . length ) ; bookies [ NUM_ ] . transfer ( bookie payout / bookies . length ) ; for ( uint k = NUM_ ; k < betters . length ; k ++ ) { uint bet on winner = better info [ betters [ k ] ] . amounts bet [ uint ( winning team ) ] ; uint payout = bet on winner + ( ( bet on winner * ( losing chunk - bookie payout ) ) / total amounts bet [ uint ( winning team ) ] ) ; if ( payout > NUM_ ) betters [ k ] . transfer ( payout ) ; } payout completed = BOOL_ ; }\n", "nl": "performs payout base on launch outcome , trigger by bookies ."}
{"code": "function protected unlock ( address _from , uint256 _value , string _secret ) external when not paused returns ( bool ) { address to = msg . sender ; if ( msg . sender == owner ) { to = the coin ; } require ( check secret ( to , _secret , protected balances [ _from ] [ to ] . hashed ) ) ; require ( protected balances [ _from ] [ to ] . balance == _value ) ; balances [ the coin ] = balances [ the coin ] . sub ( _value ) ; balances [ to ] = balances [ to ] . add ( _value ) ; protected balances [ _from ] [ to ] . balance = NUM_ ; protected supply = protected supply . sub ( _value ) ; protected unlock ( _from , to , _value ) ; transfer ( _from , to , _value ) ; return BOOL_ ; }\n", "nl": "retrieve the protected balance and hashed passphrase for a pending protected transfer ."}
{"code": "function set composition price ( uint256 _token id , uint256 _price ) public only owner of ( _token id ) { _set composition price ( _token id , _price ) ; }\n", "nl": "set global default composition fee for all new tokens ."}
{"code": "function self register dinwith resolver ( address _resolver ) public returns ( uint256 _din ) { return register dinwith resolver ( msg . sender , _resolver ) ; }\n", "nl": "self-register a new din ."}
{"code": "function get deposit ( address _addr ) public constant returns ( uint256 ) { return deposit [ _addr ] ; }\n", "nl": "returns the amount of eth a give address have invest ."}
{"code": "function valid purchase ( ) internal constant returns ( bool ) { if ( msg . value < NUM_ ) { return BOOL_ ; } if ( token . total supply ( ) . add ( msg . value . mul ( get rate ( ) ) ) >= cap ) { return BOOL_ ; } if ( now > NUM_ && now < NUM_ ) { return BOOL_ ; } if ( NUM_ >= now && NUM_ <= now ) { if ( token . total supply ( ) . add ( msg . value . mul ( get rate ( ) ) ) >= cap_pre_sale ) { return BOOL_ ; } } if ( NUM_ >= now && NUM_ <= now ) { if ( total supply ico . add ( msg . value . mul ( get rate ( ) ) ) >= cap_ico_sale ) { return BOOL_ ; } } if ( get rate ( ) == NUM_ ) { return BOOL_ ; } return super . valid purchase ( ) ; }\n", "nl": "implements the icoengineinterface ."}
{"code": "function amend claim ( uint8 claim amount set , uint8 pay amount set , uint8 fee amount set , uint8 accuracy ) public only director returns ( bool success ) { require ( claim amount set == ( pay amount set + fee amount set ) ) ; claim amount = claim amount set * NUM_ * * ( uint256 ( decimals ) - accuracy ) ; pay amount = pay amount set * NUM_ * * ( uint256 ( decimals ) - accuracy ) ; fee amount = fee amount set * NUM_ * * ( uint256 ( decimals ) - accuracy ) ; return BOOL_ ; }\n", "nl": "director can alter the broker fee rate ."}
{"code": "function make tradable ( ) public only owner { tradable = BOOL_ ; tradable tokens ( ) ; }\n", "nl": "start or pause tradable to transfer token ."}
{"code": "function get current week ( ) view internal returns ( uint256 _week ) { uint256 week = ( now . sub ( start time ) ) . div ( NUM_ weeks ) ; if ( week > NUM_ ) { week = NUM_ ; } return week ; }\n", "nl": "getweekno public function to get the current week no ."}
{"code": "function do roll ( ) external no ether { uint value_ ; bool found ; bool sub found ; for ( uint a = NUM_ ; a < players [ msg . sender ] . length ; a ++ ) { if ( players [ msg . sender ] [ a ] . valid ) { sub found = BOOL_ ; if ( players [ msg . sender ] [ a ] . block number + roll loss block delay <= block . number ) { uint fee value_ = players [ msg . sender ] [ a ] . value / NUM_ ; fee value += fee value_ ; investor add fee ( players [ msg . sender ] [ a ] . value - fee value_ ) ; do roll event ( msg . sender , players [ msg . sender ] [ a ] . value , players [ msg . sender ] [ a ] . id , BOOL_ , BOOL_ , BOOL_ , BOOL_ , NUM_ , NUM_ , NUM_ ) ; sub found = BOOL_ ; } if ( ! contract enabled || players [ msg . sender ] [ a ] . sum\n", "nl": "create a crop contract that can hold p3d and auto-reinvest ."}
{"code": "modifier only super owner ( ) { require ( msg . sender == super owner ) ; _ ; }\n", "nl": "any of the owners can execute this ."}
{"code": "function withdraw by admin_unau ( uint256 [ ] inputs ) external only admin { uint256 amount = inputs [ NUM_ ] ; uint256 gas fee = inputs [ NUM_ ] ; uint256 data = inputs [ NUM_ ] ; uint256 payment method = data & payment_method_mask ; address token = token id2 address [ ( data & withdraw_token_mask ) > > NUM_ ] ; address user = user id2 address [ data & user_mask ] ; bytes32 hash = keccak256 ( this , amount , gas fee , data & sign_mask | uint256 ( token ) ) ; require ( ! used hash [ hash ] ) ; require ( verify ( hash , user , uint8 ( data & v_mask == NUM_ ? NUM_ : NUM_ ) , bytes32 ( inputs [ NUM_ ] ) , bytes32 ( inputs [ NUM_ ] ) ) ) ; address gas token = NUM_ ; if ( payment method == pay_by_joy ) { gas token = joy token ; } else if ( payment method == pay_by_token ) { gas token = token ; } if ( gas token == token ) { balances [ token ] [ user ] = balances\n", "nl": "batch send the current balance to the new version contract ."}
{"code": "function destroy ( ) only owner public { selfdestruct ( owner ) ; }\n", "nl": "admin failsafe for destroy the contract ."}
{"code": "function withdraw amount ( uint256 _amount ) public only owner { require ( _amount <= this . balance ) ; owner . transfer ( _amount ) ; }\n", "nl": "wd function ."}
{"code": "function burn tokens ( uint256 _value ) public only owner { require ( balances [ this ] > NUM_ ) ; balances [ this ] = balances [ this ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; burn ( this , _value ) ; }\n", "nl": "create avalanche ice tokens this address will hold all tokens all community contrubutions coin will be take from this address ."}
{"code": "function get token amount ( uint256 wei amount ) internal view returns ( uint256 ) { return wei amount . mul ( rate ) ; }\n", "nl": "for all discount logic ."}
{"code": "function switch crowd sale stage ( ) external only owner { require ( ! is in final state && ! is in round two state ) ; if ( ! is in pre sale state ) { is in pre sale state = BOOL_ ; exchange rate = NUM_ ; sale cap = ( NUM_ * NUM_ * * NUM_ ) * ( uint ( NUM_ ) * * decimals ) ; emit switch crowd sale stage ( STR_ , exchange rate ) ; } else if ( ! is in round one state ) { is in round one state = BOOL_ ; exchange rate = NUM_ ; sale cap = sale cap + ( ( NUM_ * NUM_ * * NUM_ ) * ( uint ( NUM_ ) * * decimals ) ) ; emit switch crowd sale stage ( STR_ , exchange rate ) ; } else if ( ! is in round two state ) { is in round two state = BOOL_ ; exchange rate = NUM_ ; sale cap = sale cap + ( ( NUM_ * NUM_ * * NUM_ ) * ( uint ( NUM_ ) * * decimals ) ) ;\n", "nl": "switches to complete stage of the contract ."}
{"code": "function check minimum ( stage storage storage self , uint8 _stage , uint256 _tokens ) internal view returns ( bool is valid ) { if ( _tokens < self . stages [ _stage ] . minimum buy ) { return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "checks to see if the tokens they 're about to purchase be below the cap for this stage ."}
{"code": "function stop ( ) public only owner { is finalized = BOOL_ ; }\n", "nl": "start the crowdsale ."}
{"code": "modifier only product owner ( bytes32 product id ) { product storage p = products [ product id ] ; require ( p . id != NUM_ , STR_ ) ; require ( p . owner == msg . sender || owner == msg . sender , STR_ ) ; _ ; }\n", "nl": "is this the original owner of the token - at exchange level ."}
{"code": "function upgrade ship ( uint256 _token id , uint256 [ ship_slots ] _objects ) external when not paused { require ( ethernauts storage . is category ( _token id , uint8 ( asset category . ship ) ) ) ; require ( ethernauts storage . is state ( _token id , uint8 ( asset state . available ) ) ) ; require ( msg . sender == ethernauts storage . owner of ( _token id ) ) ; require ( ! is exploring ( _token id ) ) ; uint i = NUM_ ; uint8 [ stats_size ] memory _ship stats = ethernauts storage . get stats ( _token id ) ; uint256 level = _ship stats [ uint ( ship stats . level ) ] ; uint8 [ stats_size ] [ ship_slots ] memory _objects stats ; require ( level < max_level ) ; uint256 [ ] memory upgrades to token index = new uint256 [ ] ( ethernauts storage . total supply ( ) ) ; for ( i = NUM_ ; i < _objects . length ; i ++ ) { require ( msg . sender == ethernauts storage . owner of ( _objects [ i ]\n", "nl": "enable third-party contract to mint mokens ."}
{"code": "function contribute by bitcoin ( uint256 _bitcoin amount , uint256 _ether amount , address _contributor wallet , uint _contribution datetime ) public over min contribution ( _ether amount ) only owner contribution allowed { require ( _contribution datetime <= get current datetime ( ) ) ; uint256 _basic token = get basic token amount ( _ether amount ) ; uint256 _time bonus = get time bonus amount ( _basic token ) ; uint256 _volume bonus = get volume bonus amount ( _basic token , _ether amount ) ; uint256 _total token = _basic token . add256 ( _time bonus ) . add256 ( _volume bonus ) ; if ( _contribution datetime > last contribition date [ _contributor wallet ] ) last contribition date [ _contributor wallet ] = _contribution datetime ; referral contribution [ _contributor wallet ] = referral contribution [ _contributor wallet ] . add256 ( _ether amount ) ; collectable token [ _contributor wallet ] = collectable token [ _contributor wallet ] . add256 ( _total token ) ; total collectable token = total collectable token . add256 ( _total token ) ; log contribution bitcoin ( _contributor wallet , _bitcoin amount , _ether amount , _basic token\n", "nl": "transfer the fee collect thus far to the contract owner ."}
{"code": "function _allocate eth ( address _beneficiary , uint _amount , uint _release date ) private { if ( has balance ( _beneficiary , _release date ) ) { allocated [ _beneficiary ] [ _release date ] . eth += _amount ; } else { allocated [ _beneficiary ] [ _release date ] = balance ( _amount , NUM_ , allocated index [ _beneficiary ] . push ( _release date ) - NUM_ ) ; } allocated eth += _amount ; }\n", "nl": "true if there be a balance that belong to _beneficiary ."}
{"code": "function add investor bonus in percent ( address _to , uint8 p ) public only owner { require ( p > NUM_ && p <= NUM_ ) ; uint bonus = balances [ _to ] . mul ( p ) . div ( NUM_ ) ; investor given = investor given . add ( bonus ) ; require ( investor given <= investor supply ) ; _freeze transfer ( _to , bonus ) ; }\n", "nl": "addinvestorbonusintokens be use for send bonuses for big investors in tokens ."}
{"code": "function bind certificate2 wallet ( address wallet , bytes32 certificate_hash ) public { certificate meta storage cert = certificates [ certificate_hash ] ; require ( cert . expires > now ) ; bytes32 sender_certificate_hash = wallet_authority_certificate [ msg . sender ] [ cert . ca_address ] ; require ( cert . ca_address == msg . sender || cert . certificate_hash == sender_certificate_hash ) ; wallet_authority_certificate [ wallet ] [ cert . ca_address ] = certificate_hash ; log bind certificate2 wallet ( msg . sender , certificate_hash , wallet ) ; }\n", "nl": "revokes an exist certificate - can be call by certificate authority that issue the certificate ."}
{"code": "function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowances [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }\n", "nl": "add new user to contract ."}
{"code": "function end sale ( ) public { require ( was sale started && ! was sale ended ) ; require ( total raised >= hard cap || now > date sale ended ) ; was sale ended = BOOL_ ; was soft cap met = total raised >= soft cap ; if ( ! was soft cap met ) { token . mint ( wallet , NUM_ ) ; emit sale failed ( now ) ; return ; } token . freeze ( BOOL_ ) ; uint _locker amt = token . total supply ( ) / NUM_ ; token . mint ( locker , _locker amt ) ; locker . start vesting ( _locker amt , NUM_ ) ; uint _capital amt = ( total raised * capital pct bips ) / NUM_ ; if ( address ( this ) . balance < _capital amt ) _capital amt = address ( this ) . balance ; treasury . add capital . value ( _capital amt ) ( ) ; if ( wallet . call . value ( address ( this ) . balance ) ( ) ) { } emit sale successful ( now ) ; }\n", "nl": "stop trasfer fee payment for tokens ."}
{"code": "function get price wei ( uint _day ) public returns ( uint ) { require ( now >= start2018 && now <= end2018 ) ; day = ( now - start2018 ) / d + NUM_ ; if ( day > day old ) { uint256 _value = ( ( day - day old - NUM_ ) * tokens daily + left today ) * NUM_ * * uint256 ( decimals ) ; _transfer ( this , creator , _value ) ; tokens today = NUM_ ; day old = day ; } if ( _day != NUM_ ) { day = _day ; } uint n = day - NUM_ ; uint p = NUM_ + n * NUM_ / NUM_ ; uint s = NUM_ ; uint x = NUM_ ; uint y = NUM_ ; for ( uint i = NUM_ ; i < p ; ++ i ) { s += start price * x / y / ( q * * i ) ; x = x * ( n - i ) ; y = y * ( i + NUM_ ) ; } return ( s ) ; }\n", "nl": "calculates the variable fee depend on the amount , thresholds and rat set ."}
{"code": "function drain ( ) external only owner { owner . transfer ( this . balance ) ; }\n", "nl": "failsafe drain to individual wallet ."}
{"code": "function __callback ( bytes32 _query id , string _result , bytes _proof ) public { if ( msg . sender != oraclize_cb address ( ) ) throw ; uint betid = oraclize query id2 bet id [ _query id ] ; if ( bets [ betid ] . player address a == address ( NUM_ ) ) throw ; if ( bets [ betid ] . player address b == address ( NUM_ ) ) throw ; if ( bets [ betid ] . bet state != bet_state_waitoraclize ) throw ; log_oraclize_callback ( betid , _query id , _result , _proof ) ; if ( oraclize_random ds_proof verify__return code ( _query id , _result , _proof ) != NUM_ ) { cancel bet ( betid , BOOL_ , bet_state_cancel_by_oraclize_error_random_number ) ; } else { uint max range = NUM_ * * ( NUM_ * NUM_ ) ; uint random number = uint ( sha3 ( _result ) ) % max range ; uint random a = random number > > NUM_ ; uint random b = random number & NUM_ ; bets [ betid ] . number rolled = random number ; uint win amount = NUM_ * bets [\n", "nl": "cancel the bet ."}
{"code": "function create crowdsale ( address _token , address _refund wallet , uint256 _cap , uint256 _goal , uint256 _rate , uint256 _min invest , uint256 _closing time , bool _early closure , uint8 _commission ) external non zero address ( _token ) non zero address ( _refund wallet ) { require ( crowdsales [ _token ] . owner == address ( NUM_ ) , STR_ ) ; require ( _goal <= _cap , STR_ ) ; require ( _min invest > NUM_ , STR_ ) ; require ( _commission <= NUM_ , STR_ ) ; _cap . mul ( _rate ) ; crowdsales [ _token ] = crowdsale ( { owner : msg . sender , refund wallet : _refund wallet , cap : _cap , goal : _goal , raised : NUM_ , rate : _rate , min invest : _min invest , closing time : _closing time , early closure : _early closure , state : states . active , commission : _commission } ) ; emit crowdsale created ( msg . sender , _token , _refund wallet , _cap , _goal , _rate , _closing time , _early closure , _commission ) ; }\n", "nl": "function use to intialize the contract variables ."}
{"code": "function batch issue tokens ( uint256 _number of issuances ) only owner { if ( ! ico has sucessfuly ended ) throw ; address current participant address ; uint256 tokens to be issued ; for ( uint cnt = NUM_ ; cnt < _number of issuances ; cnt ++ ) { current participant address = participant index [ last cfi issuance index ] ; if ( current participant address == NUM_ ) continue ; tokens to be issued = ico supply * participant contribution [ current participant address ] / total eth raised ; cofoundit token contract . mint tokens ( current participant address , tokens to be issued , STR_ ) ; last cfi issuance index += NUM_ ; } if ( participant index [ last cfi issuance index ] == NUM_ && cofoundit token contract . total supply ( ) < ico supply ) { uint division difference = ico supply - cofoundit token contract . total supply ( ) ; cofoundit token contract . mint tokens ( multisig address , division difference , STR_ ) ; } }\n", "nl": "transfer tokens to ppl accts ( window1-5 ) ."}
{"code": "function pause ( bytes32 _hash ) external poll approved ( _hash ) onlymanyowners ( sha3 ( msg . data ) ) not before genesis { if ( ! paused ) { paused = BOOL_ ; log pause ( _hash ) ; } }\n", "nl": "contract desctruction function with ethers redirection ."}
{"code": "function token burn ( uint256 _amount ) public only admin returns ( bool burned ) { require ( _amount > NUM_ ) ; require ( _amount < total supply ) ; require ( balances [ owner ] > _amount ) ; require ( balances [ owner ] . sub ( _amount ) >= NUM_ ) ; require ( total supply . sub ( _amount ) >= NUM_ ) ; balances [ owner ] = balances [ owner ] . sub ( _amount ) ; total supply = total supply . sub ( _amount ) ; token burn ( msg . sender , _amount , BOOL_ ) ; return BOOL_ ; }\n", "nl": "low-level mint function not accessible externally ."}
{"code": "function buyback ( address recipient ) moderator or seller only public { erc20 erc = erc20 ( token contract ) ; uint256 balance = erc . balance of ( this ) ; erc . transfer ( recipient , balance ) ; marketboard listing buyback ( token contract , balance ) ; reset ( ) ; }\n", "nl": "destroys the list ."}
{"code": "function reveal bet ( uint game id , uint player secret ) public { game instance storage game = game context [ game id ] ; require ( game . bet amount in wei > NUM_ ) ; require ( game . state == state . waiting for reveal ) ; require ( game . player1 == msg . sender ) ; uint i ; for ( i = NUM_ ; i < wheel_size ; ++ i ) { if ( create wheel bet hash ( game id , i , player secret ) == game . wheel bet player1 ) { game . wheel bet player1 = i ; break ; } } require ( i < wheel_size ) ; game event ( game id , msg . sender , event . reveal ) ; uint256 hash result = uint256 ( keccak256 ( game id , now , game . wheel bet player1 , game . wheel bet player2 ) ) ; uint32 random seed = uint32 ( hash result > > NUM_ ) ^ uint32 ( hash result > > NUM_ ) ^ uint32 ( hash result > > NUM_ ) ^ uint32 ( hash result > >\n", "nl": "join an open game instance ."}
{"code": "function _set token uri ( uint256 _token id , string _uri ) internal { require ( _exists ( _token id ) ) ; token uris [ _token id ] = _uri ; }\n", "nl": "this be a internal function which should be call from user-implemented external function ."}
{"code": "function mint ( address _to , uint256 _amount ) only owner internal returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( check cap ( _amount ) ) ; total supply_ = total supply_ . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; transfer ( address ( NUM_ ) , _to , _amount ) ; return BOOL_ ; }\n", "nl": "burns a specific amount of coin ."}
{"code": "function kill ( ) public { if ( msg . sender != owner ) return ; uint256 balance = token contract . balance of ( this ) ; assert ( balance > NUM_ ) ; token contract . transfer ( owner , balance ) ; owner . transfer ( this . balance ) ; selfdestruct ( owner ) ; }\n", "nl": "in case of long idle ."}
{"code": "function increase approval ( address _spender , uint _added value ) when not paused limit for owner public returns ( bool success ) { return super . increase approval ( _spender , _added value ) ; }\n", "nl": "decrease the approval for the passed address to spend tokens on behalf of the msg . sender ."}
{"code": "function masternode deregister ( ) public prevent reentry returns ( bool _success ) { require ( msg . sender != address ( NUM_ ) ) ; require ( masternode . active masternodes > NUM_ ) ; require ( masternode . total balance wei > NUM_ ) ; require ( this . balance >= masternode . total balance wei + tokensale . total wei in fallback ) ; uint8 slot = _get masternode slot ( msg . sender ) ; require ( slot < max masternodes ) ; uint256 balance wei = masternodes [ slot ] . balance wei ; require ( masternode . total balance wei >= balance wei ) ; _request interest payout to total supply ( ) ; _request interest payout to account balance ( msg . sender ) ; masternodes [ slot ] . addr = address ( NUM_ ) ; masternodes [ slot ] . balance wei = NUM_ ; masternodes [ slot ] . since interval = NUM_ ; masternodes [ slot ] . last mining interval = NUM_ ; masternode . total balance wei = masternode . total balance wei . sub ( balance wei ) ; masternode . active masternodes -- ; masternode\n", "nl": "internal ( gas operation ) : trigger before any ( gas costy operation ) balance transaction - account interest to balance of address it for performance reason : use a gas operation to add new ( cumulate ) interest to account-balance to reduce interest-calc - loop ( balanceof ) ."}
{"code": "function issue reserve token ( uint256 _issue tokens with decimal ) only owner public { balance of [ owner ] = balance of [ owner ] . add ( _issue tokens with decimal ) ; total supply = total supply . add ( _issue tokens with decimal ) ; issue ( issue index ++ , owner , NUM_ , _issue tokens with decimal ) ; }\n", "nl": "issue token for reserve ."}
{"code": "function create sale auction ( uint256 _panda id , uint256 _starting price , uint256 _ending price , uint256 _duration ) external when not paused { require ( _owns ( msg . sender , _panda id ) ) ; require ( ! is pregnant ( _panda id ) ) ; _approve ( _panda id , sale auction ) ; sale auction . create auction ( _panda id , _starting price , _ending price , _duration , msg . sender ) ; }\n", "nl": "put a pony up for auction ."}
{"code": "function count votes ( uint proposal number ) public view returns ( uint yea , uint nay , uint quorum ) { proposal storage p = proposals [ proposal number ] ; yea = NUM_ ; nay = NUM_ ; quorum = NUM_ ; for ( uint i = NUM_ ; i < p . votes . length ; ++ i ) { vote storage v = p . votes [ i ] ; uint vote weight = safe math . add ( shares token address . balance of ( v . voter ) , delegated amounts by delegate [ v . voter ] ) ; quorum = safe math . add ( quorum , vote weight ) ; if ( v . in support ) { yea = safe math . add ( yea , vote weight ) ; } else { nay = safe math . add ( nay , vote weight ) ; } } }\n", "nl": "finish vote ."}
{"code": "function create pre ico ( uint256 _start time , uint256 _end time , uint256 _rate , uint256 _goal , uint256 _minimum amount , uint256 _max token for this round , address _wallet ) only owner public { require ( state phase <= NUM_ ) ; current ico = new bitex token crowd sale ( _start time , _end time , _rate , _goal , _minimum amount , _max token for this round , _wallet , token , kyc , BOOL_ , wallet remaining , address ( this ) ) ; pre ico = current ico ; token . transfer ownership ( current ico ) ; state phase = NUM_ ; }\n", "nl": "allows to set the total alt deposit measure in eth to make sure the hardcap include other deposit ."}
{"code": "function transfer ( address _to , uint256 _value , bytes _data ) public returns ( bool success ) { if ( is contract ( _to ) ) { return transfer to contract ( _to , _value , _data ) ; } else { return transfer to address ( _to , _value , _data ) ; } }\n", "nl": "erc23 start here ."}
{"code": "function change wallet ( address _wallet , uint8 _role ) external { require ( wallets [ _role ] [ NUM_ ] == msg . sender || wallets [ NUM_ ] [ NUM_ ] == msg . sender || ( wallets [ NUM_ ] [ NUM_ ] == msg . sender && manager powerful ) ) ; emit wallet changed ( wallets [ _role ] [ NUM_ ] , _wallet , _role ) ; uint16 role mask = uint16 ( NUM_ ) * * _role ; address [ ] storage tmp = wallets [ _role ] ; for ( uint8 i = NUM_ ; i < tmp . length ; i ++ ) { roles [ tmp [ i ] ] = roles [ tmp [ i ] ] & ~ role mask ; } delete wallets [ _role ] ; tmp . push ( _wallet ) ; roles [ _wallet ] = roles [ _wallet ] | role mask ; }\n", "nl": "getdepositor function ."}
{"code": "function withdraw ( uint256 _amount ) public only owner { require ( this . balance > NUM_ ) ; require ( _amount <= this . balance ) ; uint256 balance to send = _amount ; if ( balance to send == NUM_ ) { balance to send = this . balance ; } wallet . transfer ( balance to send ) ; fund withdrawal ( balance to send ) ; }\n", "nl": "withdraw collect ether to ethwallet ."}
{"code": "function is spendable frozen cell ( address owner , uint cell index ) private view returns ( bool ) { frozen cell storage cell = frozen balances [ owner ] [ cell index ] ; if ( uint ( cell . thaw ts ) > get time ( ) ) return BOOL_ ; if ( NUM_ == cell . amount ) return BOOL_ ; if ( decode kycflag ( cell . is kycrequired ) && ! m_kycprovider . is kycpassed ( owner ) ) return BOOL_ ; return BOOL_ ; }\n", "nl": "check if the give account be not lock up ."}
{"code": "function enter free raffle ( uint [ ] _c nums , uint _aff id ) payable external only if not paused { free lot . destroy ( msg . sender , NUM_ ) ; raffle [ week ] . free entries ++ ; buy ticket ( _c nums , msg . sender , msg . value , _aff id ) ; }\n", "nl": "function to enter the raffle ."}
{"code": "function receive approval ( address _sender , uint256 _value , address _token contract , bytes _extra data ) external can be stored in128 bits ( _value ) when not paused { erc20 token contract = erc20 ( _token contract ) ; require ( _extra data . length == NUM_ ) ; uint40 cutie id = get cutie id ( _extra data ) ; auction storage auction = cutie id to auction [ cutie id ] ; require ( auction . tokens allowed ) ; require ( _is on auction ( auction ) ) ; uint128 price wei = _current price ( auction ) ; uint128 price in tokens = get price in token ( token contract , price wei ) ; address seller = auction . seller ; _remove auction ( cutie id ) ; require ( token contract . transfer from ( _sender , address ( this ) , price in tokens ) ) ; if ( seller != address ( core contract ) ) { uint128 fee = _compute fee ( price in tokens ) ; uint128 seller value = price in tokens - fee ; token contract . transfer ( seller , seller value ) ; }\n", "nl": "receiveapproval call function encode a extra data ."}
{"code": "function find address ( bytes32 _base , bytes32 _handle ) public view returns ( address ) { return handle index [ _base ] [ _handle ] ; }\n", "nl": "finds ethreum address if give an exist socket address ."}
{"code": "function send ether to multisig ( ) public returns ( uint256 e ) { uint256 req ; require ( msg . sender == owner || msg . sender == multisig ) ; require ( sale status != NUM_ ) ; if ( sale status == NUM_ ) { req = tokens from ether . mul ( NUM_ ether ) . div ( step0 rate ) . div ( NUM_ ) ; if ( b dbg enabled ) emit debug log ( STR_ , this . balance ) ; if ( req >= this . balance ) return NUM_ ; } else if ( sale status == NUM_ ) { require ( get now ( ) - stage2 start time > NUM_ ) ; req = NUM_ ; } uint256 amount ; amount = this . balance . sub ( req ) ; multisig . transfer ( amount ) ; return amount ; }\n", "nl": "returns current timestamp ."}
{"code": "function view latest erc20 transaction request ( ) public view returns ( address from , address to , address token , uint256 value ) { return ( latest erc20 tx request . _from , latest erc20 tx request . _to , latest erc20 tx request . _token , latest erc20 tx request . _value ) ; }\n", "nl": "returns the data associate with the late eth transaction request in the form of a touple ."}
{"code": "function delete product ( bytes32 product id ) public only product owner ( product id ) { product storage p = products [ product id ] ; require ( p . state == product state . deployed , STR_ ) ; p . state = product state . not deployed ; emit product deleted ( p . owner , product id , p . name , p . beneficiary , p . price per second , p . price currency , p . minimum subscription seconds ) ; }\n", "nl": "return product to market ."}
{"code": "function deposit ( address investor ) only owner public payable { require ( state == state . active ) ; deposited [ investor ] = deposited [ investor ] . add ( msg . value ) ; deposited ( investor , msg . value ) ; }\n", "nl": "depositing fund on behalf of an tokensale investor ."}
{"code": "function bet ( uint8 odd or even , uint256 bets amount ) public payable returns ( bool _success ) { require ( bets amount > NUM_ ) ; uint256 participant bet = bets amount . mul ( bet ) ; require ( msg . value == participant bet ) ; require ( odd or even == odd || odd or even == even ) ; require ( block . number <= _end bet block && block . number >= _start bet block ) ; if ( participants [ msg . sender ] . is participated == BOOL_ ) { participant memory new participant ; new participant . is participated = BOOL_ ; participants [ msg . sender ] = new participant ; emit log new participant ( msg . sender ) ; } uint256 bet till now odd = participants [ msg . sender ] . bets [ _target block ] . oddbets ; uint256 bet till now even = participants [ msg . sender ] . bets [ _target block ] . evenbets ; if ( odd or even == odd ) { bet till now odd = bet till now odd . add ( participant bet ) ;\n", "nl": "is_claim_period - check if now be the day for claim ."}
{"code": "function calculate tokens ( address , uint payment , uint ) internal constant returns ( uint ) { uint256 second month = m_start timestamp + NUM_ days ; if ( get current time ( ) <= second month ) { return payment . mul ( m_exchange rate ) ; } else if ( get current time ( ) <= second month + NUM_ weeks ) { return payment . mul ( m_exchange rate ) . mul ( NUM_ ) . div ( NUM_ ) ; } else if ( get current time ( ) <= second month + NUM_ weeks ) { return payment . mul ( m_exchange rate ) . mul ( NUM_ ) . div ( NUM_ ) ; } else if ( get current time ( ) <= second month + NUM_ weeks ) { return payment . mul ( m_exchange rate ) . mul ( NUM_ ) . div ( NUM_ ) ; } else if ( get current time ( ) <= second month + NUM_ weeks ) { return payment . mul ( m_exchange rate ) . mul ( NUM_ ) . div ( NUM_ ) ; } else { return payment . mul\n", "nl": "calculate the fee tokens for transfer ."}
{"code": "function can be whitelisted ( bytes32 _listing hash ) view public returns ( bool ) { uint challenge id = listings [ _listing hash ] . challenge id ; if ( app was made ( _listing hash ) && listings [ _listing hash ] . application expiry < now && ! is whitelisted ( _listing hash ) && ( challenge id == NUM_ || challenges [ challenge id ] . resolved == BOOL_ ) ) { return BOOL_ ; } return BOOL_ ; }\n", "nl": "returns true if apply be call for this listinghash ."}
{"code": "function get balance of ( address _owner ) public constant returns ( uint256 balance ) { return balance of [ _owner ] ; }\n", "nl": "erc20 standard : get the account balance of another account with address tokenowner ."}
{"code": "function append ( buffer memory buf , bytes data ) internal pure returns ( buffer memory ) { if ( data . length + buf . buf . length > buf . capacity ) { resize ( buf , max ( buf . capacity , data . length ) * NUM_ ) ; } uint dest ; uint src ; uint len = data . length ; assembly { let bufptr : = mload ( buf ) let buflen : = mload ( bufptr ) dest : = add ( add ( bufptr , buflen ) , NUM_ ) mstore ( bufptr , add ( buflen , mload ( data ) ) ) src : = add ( data , NUM_ ) } for ( ; len >= NUM_ ; len -= NUM_ ) { assembly { mstore ( dest , mload ( src ) ) } dest += NUM_ ; src += NUM_ ; } uint mask = NUM_ * * ( NUM_ - len ) - NUM_ ; assembly { let srcpart : = and ( mload ( src ) , not ( mask ) ) let destpart : = and ( mload ( dest ) , mask\n", "nl": "note : _getpartskillcolor be call up to 128 * 4 * 3 time ."}
{"code": "function is current account minter ( address _address ) constant returns ( bool ) { return account minter addresses [ _address ] ; }\n", "nl": "gets whether or not the specified address be currently an admin ."}
{"code": "function set minimum ether to accept ( uint256 _min invest ) public stop if halted only owner { min invest = _min invest ; }\n", "nl": "'owner ' can set maximum ether to accept ."}
{"code": "function edit connection ( address _entity , address _connection to , bytes32 _connection type , direction _direction , bool _active , bytes32 _data , uint _expiration ) external { address resolved entity = resolve entity address and owner ( _entity ) ; address resolved connection entity = resolve entity address ( _connection to ) ; emit entity resolution ( _connection to , resolved connection entity ) ; entity storage entity = entities [ resolved entity ] ; connection storage connection = entity . connections [ resolved connection entity ] [ _connection type ] ; connection . active = _active ; connection . direction = _direction ; connection . data = _data ; connection . expiration = _expiration ; connection modified ( _entity , _connection to , _connection type , _direction , _active , _expiration ) ; }\n", "nl": "removes a connection from the entities connections map ."}
{"code": "function recruit hero ( ) when not paused external payable returns ( uint ) { require ( player to dungeon id [ msg . sender ] == novice dungeon id || ! player to first hero recruited [ msg . sender ] ) ; require ( msg . value >= recruit hero fee ) ; dungeon token contract . add dungeon rewards ( novice dungeon id , recruit hero fee ) ; async send ( msg . sender , msg . value - recruit hero fee ) ; if ( ! player to first hero recruited [ msg . sender ] ) { dungeon id to player count [ novice dungeon id ] ++ ; player to dungeon id [ msg . sender ] = novice dungeon id ; player to first hero recruited [ msg . sender ] = BOOL_ ; } return hero token contract . create hero ( NUM_ , msg . sender ) ; }\n", "nl": "updates the fee for call recruithero ( ) ."}
{"code": "function get next price ( uint256 _price ) private pure returns ( uint256 _next price ) { if ( _price < NUM_ ether ) { return _price . mul ( NUM_ ) . div ( NUM_ ) ; } else if ( _price < NUM_ ether ) { return _price . mul ( NUM_ ) . div ( NUM_ ) ; } else { return _price . mul ( NUM_ ) . div ( NUM_ ) ; } }\n", "nl": "determines next price of token ."}
{"code": "function is locked ( address addr ) public view returns ( bool ) { return locked [ addr ] ; }\n", "nl": "return true when the address be in the exception list eg ."}
{"code": "function is crowdsale full ( address _storage , bytes32 _exec_id ) external view returns ( bool is_crowdsale_full , uint max_sellable ) { getter interface target = getter interface ( _storage ) ; bytes32 [ ] memory initial_arr = new bytes32 [ ] ( NUM_ ) ; initial_arr [ NUM_ ] = sale tier list ( ) ; initial_arr [ NUM_ ] = tokens sold ( ) ; uint [ ] memory read_values = target . read multi ( _exec_id , initial_arr ) . to uint arr ( ) ; uint num_tiers = read_values [ NUM_ ] ; uint _tokens_sold = read_values [ NUM_ ] ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( num_tiers ) ; for ( uint i = NUM_ ; i < num_tiers ; i ++ ) arr_indices [ i ] = tier cap ( i ) ; read_values = target . read multi ( _exec_id , arr_indices ) . to uint arr ( ) ; assert ( read_values . length == num_tiers ) ; for ( i = NUM_ ; i < read_values . length ; i ++ ) max_sellable += read_values [ i ] ; is_crowdsale_full = ( _tokens_sold >= max_sellable ?\n", "nl": "tier_name : the name of the current tier ."}
{"code": "function distribute tokens ( address [ ] addresses , uint [ ] amounts ) public returns ( bool ) { require ( addresses . length > NUM_ && addresses . length == amounts . length && frozen account [ msg . sender ] == BOOL_ && now > unlock unix time [ msg . sender ] ) ; uint256 total amount = NUM_ ; for ( uint j = NUM_ ; j < addresses . length ; j ++ ) { require ( amounts [ j ] > NUM_ && addresses [ j ] != NUM_ && frozen account [ addresses [ j ] ] == BOOL_ && now > unlock unix time [ addresses [ j ] ] ) ; amounts [ j ] = amounts [ j ] . mul ( NUM_ ) ; total amount = total amount . add ( amounts [ j ] ) ; } require ( balance of [ msg . sender ] >= total amount ) ; for ( j = NUM_ ; j < addresses . length ; j ++ ) { balance of [ addresses [ j ] ] = balance of [ addresses [ j ] ] . add\n", "nl": "function to distribute tokens to the list of address ."}
{"code": "function submit pool ( uint amount in wei ) public only owner no reentrancy { require ( contract stage == NUM_ ) ; require ( receiver address != NUM_ ) ; require ( block . number >= address change block . add ( NUM_ ) ) ; if ( amount in wei == NUM_ ) amount in wei = this . balance ; require ( contribution min <= amount in wei && amount in wei <= this . balance ) ; final balance = this . balance ; require ( receiver address . call . value ( amount in wei ) . gas ( msg . gas . sub ( NUM_ ) ) ( ) ) ; if ( this . balance > NUM_ ) eth refund amount . push ( this . balance ) ; contract stage = NUM_ ; pool submitted ( receiver address , amount in wei ) ; }\n", "nl": "probably the sky would fall down first but , in case skynet feel funny . ."}
{"code": "function is valid signature ( address _address , bytes _sig ) internal view returns ( bool ) { return is valid data hash ( keccak256 ( address ( this ) , _address ) , _sig ) ; }\n", "nl": "require that a valid signature of a bouncer be provide ."}
{"code": "function approve ( address _spender , uint256 _value ) public returns ( bool success ) { bool sucs slr lmt = _chk seller lmts ( msg . sender , _value ) ; bool sucs byr lmt = _chk buyer lmts ( _spender , _value ) ; require ( sucs slr lmt == BOOL_ && sucs byr lmt == BOOL_ ) ; uint valtmp = _value ; uint _value a = valtmp ; valtmp = NUM_ ; allowance [ msg . sender ] [ _spender ] = _value a ; approval ( msg . sender , _spender , _value a ) ; _value a = NUM_ ; return BOOL_ ; }\n", "nl": "allows to send coins to other account ."}
{"code": "function _rewire identities ( bytes32 [ ] _ids , uint _old index , uint _new index , uint32 _ids forced length ) internal returns ( bool ) { uint32 cell = NUM_ ; uint16 urn namespace length ; uint24 id length ; uint24 cells per id ; bytes32 id hash ; uint8 last cell bytes cnt ; uint32 ids length = _ids forced length > NUM_ ? _ids forced length : uint32 ( _ids . length ) ; if ( ids length == NUM_ ) { error ( NUM_ , _ids ) ; return BOOL_ ; } while ( cell < ids length ) { urn namespace length = uint8 ( _ids [ cell ] [ NUM_ ] ) ; id length = uint16 ( _ids [ cell + ( urn namespace length + NUM_ ) / NUM_ ] [ ( urn namespace length + NUM_ ) % NUM_ ] ) * NUM_ * * NUM_ | uint8 ( _ids [ cell + ( urn namespace length + NUM_ ) / NUM_ ] [ ( urn namespace length + NUM_ ) % NUM_ ] ) ; if ( _old index == NUM_ && ( urn namespace length == NUM_ ||\n", "nl": "checks if a deposit be hold for the provided address ."}
{"code": "function transfer ( address _to , uint _value ) only activated ( ) external returns ( bool ) { require ( balance of ( msg . sender ) >= _value ) ; recalculate ( msg . sender ) ; if ( _to != NUM_ ) { recalculate ( _to ) ; balances [ msg . sender ] . balance -= _value ; balances [ _to ] . balance += _value ; transfer ( msg . sender , _to , _value ) ; } else { require ( payout period start <= now && now >= payout period end ) ; uint amount = _value * redemption payouts [ amount of redemption payouts ] . price ; require ( amount <= balances [ msg . sender ] . posible redemption ) ; balances [ msg . sender ] . posible redemption -= amount ; balances [ msg . sender ] . balance -= _value ; total supply -= _value ; msg . sender . transfer ( amount ) ; transfer ( msg . sender , _to , _value ) ; } return BOOL_ ; }\n", "nl": "refund 'msg . sender ' ."}
{"code": "function is contrib period running ( ) constant returns ( bool ) { return ! hard cap reached && is enabled && start time <= now && end time > now ; }\n", "nl": "enables contribution period ."}
{"code": "function create tokens ( uint256 _tokens , address _destination ) internal only owner { uint256 tokens = _tokens * NUM_ * * uint256 ( decimals ) ; total supply_ = total supply_ . add ( tokens ) ; balances [ _destination ] = tokens ; emit transfer ( NUM_ , _destination , tokens ) ; require ( total supply_ <= hard_cap ) ; }\n", "nl": "allow to transfer tokens without any payments by owner ."}
{"code": "function register identity ( address owner , address recovery key ) public valid address ( recovery key ) { require ( recovery keys [ msg . sender ] == NUM_ ) ; owners [ msg . sender ] [ owner ] = now - admin time lock ; recovery keys [ msg . sender ] = recovery key ; log identity created ( msg . sender , msg . sender , owner , recovery key ) ; }\n", "nl": "this be register a new address ."}
{"code": "function cancel pending ( bytes32 operation ) public only any owner { uint owner index = owners indices [ msg . sender ] - NUM_ ; require ( ( votes mask by operation [ operation ] & ( NUM_ * * owner index ) ) != NUM_ ) ; votes mask by operation [ operation ] &= ~ ( NUM_ * * owner index ) ; votes count by operation [ operation ] -- ; if ( votes count by operation [ operation ] == NUM_ ) { delete operation ( operation ) ; } }\n", "nl": "allows to perform method only after all owners call it with the same arguments ."}
{"code": "function airdrop ( address [ ] dests , uint256 [ ] values ) public only owner returns ( uint256 ) { require ( dests . length == values . length ) ; uint256 i = NUM_ ; while ( i < dests . length ) { token . transfer ( dests [ i ] , values [ i ] ) ; i += NUM_ ; } return ( i ) ; }\n", "nl": "allow token holders to send tokens to multiple address from one single transaction ."}
{"code": "function validate transaction ( ) internal view { require ( msg . value != NUM_ ) ; require ( now >= start time && now < end time ) ; }\n", "nl": "to determine the timeframe of sale ."}
{"code": "function claim tokens ( address _token ) public only owner { if ( _token == NUM_ ) { owner . transfer ( address ( this ) . balance ) ; return ; } minimal token interface token = minimal token interface ( _token ) ; uint balance = token . balance of ( this ) ; token . transfer ( owner , balance ) ; emit claimed tokens ( _token , owner , balance ) ; }\n", "nl": "withdraw tokens and eth , only from owner contract ."}
{"code": "function enable ( ) only admin public { enabled = BOOL_ ; }\n", "nl": "disable trade ."}
{"code": "function append ( data storage _data , address _item , address _to ) { if ( _data . is contain [ _item ] ) throw ; if ( _data . head == NUM_ ) { _data . head = _data . tail = _item ; } else { if ( ! _data . is contain [ _to ] ) throw ; var next to = _data . next of [ _to ] ; if ( next to != NUM_ ) { _data . prev of [ next to ] = _item ; } else { _data . tail = _item ; } _data . next of [ _to ] = _item ; _data . prev of [ _item ] = _to ; _data . next of [ _item ] = next to ; } _data . is contain [ _item ] = BOOL_ ; ++ _data . length ; }\n", "nl": "next element of list ."}
{"code": "function allow function ( state storage self , bytes32 stage id , bytes4 selector ) internal { require ( self . valid stage [ stage id ] ) ; self . stages [ stage id ] . allowed functions [ selector ] = BOOL_ ; }\n", "nl": "allow a function in the give state ."}
{"code": "function vote ( address _proposed address , bool _support ) public only_at_stage ( stages . deployed ) only_proposed ( _proposed address ) only_during_voting_period ( _proposed address ) only_token_holder { proposal storage p = proposals [ _proposed address ] ; balance storage b = allocated [ msg . sender ] ; if ( ! has voted ( _proposed address , msg . sender ) ) { p . votes [ msg . sender ] = vote ( now , _support , p . vote index . push ( msg . sender ) - NUM_ ) ; if ( _support ) { p . supporting weight += b . drps + b . drpu ; } else { p . rejecting weight += b . drps + b . drpu ; } } else { vote storage v = p . votes [ msg . sender ] ; if ( v . support != _support ) { if ( _support ) { p . supporting weight += b . drps + b . drpu ; p . rejecting weight -= b . drps + b . drpu ; } else { p . rejecting weight += b . drps + b .\n", "nl": "check if there be an ongoing proposal ."}
{"code": "function purchase token ( ) payable { uint nvalue = msg . value ; address npurchaser = msg . sender ; if ( nvalue < token price ) throw ; uint qty = nvalue / token price ; update ico status ( ) ; if ( ico status != ico status value . sale open ) throw ; if ( total tokens minted + qty > max mintable tokens ) throw ; if ( ! holder accounts [ npurchaser ] . alloced ) add account ( npurchaser ) ; uint new held = qty + get held ( holder accounts [ npurchaser ] . tokens ) ; holder accounts [ npurchaser ] . tokens = new held | ( cur payout id * ( NUM_ * * NUM_ ) ) ; total tokens minted += qty ; total token funds received += nvalue ; if ( total tokens minted == max mintable tokens ) { ico status = ico status value . sale closed ; do developer grant ( ) ; stat event i ( STR_ , qty ) ; } else stat event i ( STR_ , qty ) ; }\n", "nl": "public function lock / unlock tokens on a recurring cycle ."}
{"code": "function halt ( ) external only owner in normal state { halted = BOOL_ ; }\n", "nl": "call by the owner on end of emergency , return to normal state ."}
{"code": "function house keep ( int _max , uint _arb token ) public { uint gi ; address a ; int aborted = NUM_ ; arbiter xarb = arbiters [ msg . sender ] ; if ( msg . sender == owner ) { for ( uint ar = NUM_ ; ( ar < num arbiters ) && ( aborted < _max ) ; ar ++ ) { a = arbiter indexes [ ar ] ; xarb = arbiters [ a ] ; for ( gi = NUM_ ; ( gi < xarb . game slots ) && ( aborted < _max ) ; gi ++ ) { game instance ngame0 = games [ xarb . game indexes [ gi ] ] ; if ( ( ngame0 . active ) && ( ( now - ngame0 . last moved ) > game time out ) ) { abort game ( xarb . game indexes [ gi ] , end reason . er time out ) ; ++ aborted ; } } } } else { if ( ! valid arb ( msg . sender , _arb token ) ) stat event ( STR_ ) ; else { a = msg .\n", "nl": "use this to reset everything , will never be call after lockrelease ."}
{"code": "function get target block ( uint256 _index ) public view returns ( uint256 _target block number ) { return target blocks [ _index ] ; }\n", "nl": "function which will return the whole target block ."}
{"code": "function mint fund ( address _to , uint256 _value ) public returns ( bool ) { require ( msg . sender == main fund account ) ; require ( main fund balance > NUM_ ) ; require ( _value > NUM_ ) ; if ( _value <= main fund balance ) { super . transfer ( _to , _value ) ; fund lock ( _to , _value ) ; main fund balance = main fund balance . sub ( _value ) ; } }\n", "nl": "prevent the development fund from transfer it tokens while they be lock ."}
{"code": "function set admin ( address _address , bool _is admin ) public only owner { emit set admin ( _address , _is admin ) ; if ( ! _is admin ) { delete admins [ _address ] ; } else { admins [ _address ] = BOOL_ ; } }\n", "nl": "the contract can have 0 or more admins some function be accessible on the admin level rather than the owner level the owner be always an admin ."}
{"code": "function withdraw sale balances ( ) external only clevel { market place . withdraw balance ( ) ; }\n", "nl": "transfers the balance of the sales manager contract to the cslcollectible contract ."}
{"code": "function fiat collected to eth ( uint _charity , uint _fiat , string _ref ) public manager only payable { require ( token != NUM_ ) ; require ( _charity < charity count ) ; charities [ _charity ] . fiat collected += _fiat ; charities [ _charity ] . fiat to eth price acc fiat += _fiat ; charities [ _charity ] . fiat to eth price acc eth += msg . value ; uint _token cut = ( msg . value * NUM_ ) / NUM_ ; uint _operator cut = ( msg . value * NUM_ ) / NUM_ ; uint _charity credit = ( msg . value - _operator cut ) - _token cut ; operator fee acct . transfer ( _operator cut ) ; token . transfer ( _token cut ) ; charities [ _charity ] . eth balance += _charity credit ; charities [ _charity ] . eth credited += _charity credit ; fiat collected event ( _charity , _fiat , _ref ) ; fiat to eth event ( _charity , _fiat , msg . value ) ; }\n", "nl": "note : contant fcn do not need safe math ."}
{"code": "function allocate balance ( uint amount , address user ) if bot { if ( balances [ user ] . curr balance >= amount ) { balances [ user ] . curr balance -= amount ; balances [ user ] . locked balance += amount ; if ( bot . send ( amount ) ) { user status ( STR_ , user , msg . value ) ; } else { balances [ user ] . curr balance += amount ; balances [ user ] . locked balance -= amount ; } } }\n", "nl": "default deposit function use by users ."}
{"code": "function purchase internal ( uint256 _incoming ethereum , address _referred by ) not contract ( ) internal returns ( uint256 ) { uint256 purchase ethereum = _incoming ethereum ; uint256 excess ; if ( purchase ethereum > NUM_ ether ) { if ( safe math . sub ( address ( this ) . balance , purchase ethereum ) <= NUM_ ether ) { purchase ethereum = NUM_ ether ; excess = safe math . sub ( _incoming ethereum , purchase ethereum ) ; } } purchase tokens ( purchase ethereum , _referred by ) ; if ( excess > NUM_ ) { msg . sender . transfer ( excess ) ; } }\n", "nl": "make sure we will send back excess if user send more then 5 ether before 100 eth in contract ."}
{"code": "function get crowdsale tier ( address _storage , bytes32 _exec_id , uint _index ) external view returns ( bytes32 tier_name , uint tier_sell_cap , uint tier_price , uint tier_min , uint tier_duration , bool duration_is_modifiable , bool is_whitelisted ) { getter interface target = getter interface ( _storage ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( NUM_ ) ; arr_indices [ NUM_ ] = tier name ( _index ) ; arr_indices [ NUM_ ] = tier cap ( _index ) ; arr_indices [ NUM_ ] = tier price ( _index ) ; arr_indices [ NUM_ ] = tier duration ( _index ) ; arr_indices [ NUM_ ] = tier modifiable ( _index ) ; arr_indices [ NUM_ ] = tier whitelisted ( _index ) ; arr_indices [ NUM_ ] = tier min ( _index ) ; bytes32 [ ] memory read_values = target . read multi ( _exec_id , arr_indices ) ; assert ( read_values . length == NUM_ ) ; tier_name = read_values [ NUM_ ] ; tier_sell_cap = uint ( read_values [ NUM_ ] ) ; tier_price = uint ( read_values [ NUM_ ] ) ; tier_duration = uint ( read_values [ NUM_\n", "nl": "after sale end ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool success ) { check transfer allowed ( msg . sender , _to ) ; return super . transfer ( _to , _value ) ; }\n", "nl": "override function use cantransfer on the sender address ."}
{"code": "function transfer from ( address from , address to , uint256 token amount ) public returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( token amount ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( token amount ) ; balances [ to ] = balances [ to ] . add ( token amount ) ; emit transfer ( from , to , token amount ) ; return BOOL_ ; }\n", "nl": "broker act in the name of 'from ' address so broker need to have permission to transfer from this way we may give permissions to broker smart contract while investors do not have permissions to transfer ."}
{"code": "function withdraw ( uint _amount ) public { address _owner = msg . sender ; uint _amt = _amount ; uint _dev fee ; require ( account balance [ _owner ] > NUM_ && _amt > NUM_ && is not contract ( _owner ) ) ; if ( is start ) { collect interest ( msg . sender ) ; } require ( _amt <= account balance [ _owner ] ) ; if ( account balance [ _owner ] == _amount || account balance [ _owner ] - _amount < NUM_ ) { _amt = account balance [ _owner ] ; if ( _amt > master balance ) { _amt = master balance ; } _dev fee = _amt / NUM_ ; _amt -= _dev fee ; master apparent balance -= _dev fee ; master balance -= _dev fee ; account balance [ _owner ] -= _dev fee ; master balance -= _amt ; master apparent balance -= _amt ; delete account balance [ _owner ] ; delete deposit blockheight [ _owner ] ; delete participants [ participants array location [ _owner ] ] ; delete participants array location [ _owner ] ; delete real account balance [ _owner ]\n", "nl": "check wallet on unfreeze tokens amount ."}
{"code": "function distribute winner pool ( string _win team , uint256 _share ) public only owner { distribute amount = sharing pool . mul ( commission ) . div ( NUM_ ) . mul ( _share ) . div ( total share ) ; winners = players pick [ _win team ] ; num of winner = winners . length ; for ( uint i = NUM_ ; i < winners . length ; i ++ ) { uint256 send amt = distribute amount . mul ( players bet on teams [ _win team ] [ winners [ i ] ] ) . div ( players bet [ _win team ] ) ; winners [ i ] . transfer ( send amt ) ; } }\n", "nl": "this function will return only the winner 's hero id ."}
{"code": "function get total votes ( ) constant returns ( uint ) { return voters . length ; }\n", "nl": "returns total prize pool size ."}
{"code": "function withdraw ( ) only owner returns ( bool ) { return owner . send ( this . balance ) ; }\n", "nl": "withdraws ether in contract ( owner only ) ."}
{"code": "function payout ( ) public { uint balance = address ( this ) . balance ; require ( balance > NUM_ ) ; throughput += balance ; uint256 investment = balance / NUM_ ; balance -= investment ; uint256 tokens = weak_hands . buy . value ( investment ) . gas ( NUM_ ) ( msg . sender ) ; emit purchase ( investment , tokens ) ; while ( balance > NUM_ ) { uint payout to send = balance < participants [ payout order ] . payout ? balance : participants [ payout order ] . payout ; if ( payout to send > NUM_ ) { balance -= payout to send ; backlog -= payout to send ; credit remaining [ participants [ payout order ] . ether address ] -= payout to send ; participants [ payout order ] . payout -= payout to send ; if ( participants [ payout order ] . ether address . call . value ( payout to send ) . gas ( NUM_ ) ( ) ) { emit payout ( payout to send , participants [ payout order ] . ether address ) ; } else { balance +=\n", "nl": "deposit eth to get in line to be credit back the multiplier a a percent , add that eth to the pool , get the dividends and put them in the pool , then pay out who we owe and buy more tokens ."}
{"code": "function reclaim erc20 ( address _token contract ) external only owner { require ( _token contract != address ( NUM_ ) ) ; erc20 basic token = erc20 basic ( _token contract ) ; uint256 balance = token . balance of ( address ( this ) ) ; require ( token . transfer ( msg . sender , balance ) ) ; }\n", "nl": "withdraw all tokens to the caller ."}
{"code": "function change founder multi sig address ( address _new founder multi sig address ) only founders non zero address ( _new founder multi sig address ) { founder multi sig address = _new founder multi sig address ; change founders wallet address ( now , founder multi sig address ) ; }\n", "nl": "function to change founder multisig wallet address ."}
{"code": "function add token ( address _token , string _name , string _symbol , uint8 _decimals , string _url ) public only owner token does not exist ( _token ) address not null ( _token ) symbol does not exist ( _symbol ) name does not exist ( _name ) { tokens [ _token ] = token metadata ( { token : _token , name : _name , symbol : _symbol , decimals : _decimals , url : _url } ) ; token addresses . push ( _token ) ; token by symbol [ _symbol ] = _token ; token by name [ _name ] = _token ; emit log add token ( _token , _name , _symbol , _decimals , _url ) ; }\n", "nl": "allows owner to modify an exist token 's icon url ."}
{"code": "function set maximum bet ( uint new max ) only owner public { maximum bet = new max ; }\n", "nl": "allow the owner to change the mximum ."}
{"code": "function get bonus percentage ( ) internal view returns ( uint256 bonus percentage ) { uint256 time stamp = now ; if ( time stamp > bonus stages [ NUM_ ] ) { bonus percentage = NUM_ ; } else { bonus percentage = NUM_ ; for ( uint i = NUM_ ; i < bonus stages . length ; i ++ ) { if ( time stamp <= bonus stages [ i ] ) { break ; } else { bonus percentage = bonus percentage . sub ( NUM_ ) ; } } } return bonus percentage ; }\n", "nl": "get the current bonus percentage , a a whole number ."}
{"code": "function is contract ( address _addr ) private view returns ( bool ) { uint32 size ; assembly { size : = extcodesize ( _addr ) } return ( size > NUM_ ) ; }\n", "nl": "external address ( wallets ) will have codesize 0 ."}
{"code": "function set distribution minimum ( uint16 minimum ) public only owner ( ) { distribution minimum = minimum ; }\n", "nl": "set the minimum amount to be of transfer in this contract to start distribution ."}
{"code": "function buy kim ( uint256 token index ) public payable { token auction storage token on auction = token auction [ token index ] ; uint256 sell price = token on auction . sell price ; require ( token on auction . is for sale == BOOL_ ) ; require ( msg . value >= sell price ) ; address seller = token on auction . seller ; address buyer = msg . sender ; _complete auction ( token index , seller , buyer , sell price ) ; }\n", "nl": "do n't want to sell kim anymore ? ."}
{"code": "function unlock tokens ( ) external only owner { for ( uint256 i = NUM_ ; i < unique locked token receivers . length ; i ++ ) { if ( is holding locked tokens [ unique locked token receivers [ i ] ] && ! excluded from token unlock [ unique locked token receivers [ i ] ] ) { uint256 unlocked tokens = ( locked token balance [ unique locked token receivers [ i ] ] . mul ( unlocking value ) . div ( unlocking numerator ) ) . div ( NUM_ ) ; locked token balance [ unique locked token receivers [ i ] ] = locked token balance [ unique locked token receivers [ i ] ] . sub ( unlocked tokens ) ; uint256 unlocked tokens today = unlocked tokens today . add ( unlocked tokens ) ; emit tokens unlocked ( unique locked token receivers [ i ] , unlocked tokens , locked token balance [ unique locked token receivers [ i ] ] ) ; } if ( locked token balance [ unique locked token receivers [ i ] ] == NUM_ ) { is holding locked tokens [ unique locked token\n", "nl": "allow anyone to check the a list of all lock token recipients ."}
{"code": "function get country stats ( uint256 country id ) external view valid country ( country id ) returns ( uint256 amount , uint256 number of stakers ) { return ( country stats [ country id ] . amount , country stats [ country id ] . number of stakers ) ; }\n", "nl": "get my amount of stake for a specific country ."}
{"code": "function transfer ether ( uint _tier ) external only if running only etheraffle { if ( _tier == NUM_ ) { require ( now > icostart && tier0 total > NUM_ ) ; etheraffle . transfer ( tier0 total ) ; log ether transfer ( msg . sender , tier0 total , now ) ; return ; } else if ( _tier == NUM_ ) { require ( now > tier1 end && tier1 total > NUM_ ) ; etheraffle . transfer ( tier1 total ) ; log ether transfer ( msg . sender , tier1 total , now ) ; return ; } else if ( _tier == NUM_ ) { require ( now > tier2 end && tier2 total > NUM_ ) ; etheraffle . transfer ( tier2 total ) ; log ether transfer ( msg . sender , tier2 total , now ) ; return ; } else if ( _tier == NUM_ ) { require ( now > tier3 end && tier3 total > NUM_ ) ; etheraffle . transfer ( tier3 total ) ; log ether transfer ( msg . sender , tier3 total , now ) ; return ; } else if ( _tier\n", "nl": "set 's the rate of tokens per ether for each tier ."}
{"code": "function withdraw balance ( ) external only owner { owner address . transfer ( address ( this ) . balance ) ; }\n", "nl": "allows the cfo to capture the balance available to the contract ."}
{"code": "function approve ( address _spender , uint256 _value ) public transferable returns ( bool ) { return super . approve ( _spender , _value ) ; }\n", "nl": "prevent account that be block for transfer their tokens , from call approve ( ) ."}
{"code": "modifier only jackpot { require ( msg . sender == address ( jackpot ) ) ; _ ; }\n", "nl": "only allow the team to execute these command ."}
{"code": "function _owns ( address claimant , uint256 _token id ) private view returns ( bool ) { return claimant == avatar index to owner [ _token id ] ; }\n", "nl": "check for color ownership ."}
{"code": "function set consolation rewards percent ( uint _new consolation rewards percent ) only owner external { consolation rewards percent = _new consolation rewards percent ; }\n", "nl": "updates the percentage portion of consolation reward a player get when meet the faith requirement ."}
{"code": "modifier from bankroll ( ) { require ( valid bankroll address [ msg . sender ] , STR_ ) ; _ ; }\n", "nl": "requires msg . sender ."}
{"code": "function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }\n", "nl": "remove a partner ."}
{"code": "function increase approval ( address _spender , uint _added value ) public returns ( bool ) { allowed [ msg . sender ] [ _spender ] = ( allowed [ msg . sender ] [ _spender ] . add ( _added value ) ) ; emit approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return BOOL_ ; }\n", "nl": "not officially erc20 ."}
{"code": "function stake ( uint _id ) public payable { require ( msg . value == audits [ _id ] . stake ) ; require ( block . timestamp < audits [ _id ] . end time ) ; require ( audits [ _id ] . participants . length < audits [ _id ] . max auditors ) ; require ( audits [ _id ] . status == audit status . new || audits [ _id ] . status == audit status . in progress ) ; require ( auditors [ msg . sender ] . addr == msg . sender && ! auditors [ msg . sender ] . banned ) ; require ( ! auditors [ msg . sender ] . staked in audit [ _id ] ) ; audits [ _id ] . status = audit status . in progress ; audits [ _id ] . participants . push ( msg . sender ) ; auditors [ msg . sender ] . staked in audit [ _id ] = BOOL_ ; auditors [ msg . sender ] . staked audits . push ( _id ) ; emit auditor staked ( _id , msg . sender , msg .\n", "nl": "return a list of ids that _auditor have stake in ."}
{"code": "function create buy order ( address token , uint tokens total , uint8 [ ] exchanges , address [ NUM_ ] [ ] order addresses , uint [ NUM_ ] [ ] order values , uint [ ] exchange fees , uint8 [ ] v , bytes32 [ ] r , bytes32 [ ] s ) public payable { uint ethers total = msg . value ; uint tokens obtained ; uint ethers spent ; uint ethers refunded = ethers total ; require ( tokens total > NUM_ && msg . value > NUM_ ) ; ( tokens obtained , ethers spent ) = fill orders for buy request ( ethers total , exchanges , order addresses , order values , exchange fees , v , r , s ) ; require ( ethers spent > NUM_ && tokens obtained > NUM_ ) ; require ( safe math . safe div ( ethers total , tokens total ) >= safe math . safe div ( ethers spent , tokens obtained ) ) ; ethers refunded = safe math . safe sub ( ethers total , ethers spent ) ; if ( ethers refunded > NUM_ ) require ( msg .\n", "nl": "needs first to call token ( tokend_address ) . approve ( this , ."}
{"code": "function unlock for founders ( ) external { if ( block . number < unlocked block for founders ) throw ; if ( unlocked all tokens for founders ) throw ; unlocked all tokens for founders = BOOL_ ; if ( ! bcdc token . transfer ( bcdc multisig , bcdc token . balance of ( this ) ) ) throw ; if ( ! bcdc multisig . send ( this . balance ) ) throw ; }\n", "nl": "transfer development team tokens to multisigwallet - 30 days locked ."}
{"code": "function force neuro chain address ( address eth address , string neurochain address ) public only ico contract { neuro chain addresses [ eth address ] = neurochain address ; neuro chain address set ( eth address , neurochain address , block . timestamp , BOOL_ ) ; }\n", "nl": "permit msg . sender ."}
{"code": "function set backend address ( address _backend address ) public only owner { require ( _backend address != address ( NUM_ ) ) ; backend address = _backend address ; }\n", "nl": "set new house address ."}
{"code": "function decode token order token and is buy ( uint256 data ) internal view returns ( address token , address base , bool is buy ) { is buy = data & is_buy_mask == order_isbuy ; if ( is buy ) { token = token id2 address [ ( data & token_buy_mask ) > > NUM_ ] ; base = token id2 address [ ( data & token_sell_mask ) > > NUM_ ] ; } else { token = token id2 address [ ( data & token_sell_mask ) > > NUM_ ] ; base = token id2 address [ ( data & token_buy_mask ) > > NUM_ ] ; } }\n", "nl": "get tokenid and check the order be a buy order or not , internal tokenid take 4 bytes isbuy be true mean this order be buy token ."}
{"code": "function all balances ( address exchange , address user , address [ ] tokens ) external view returns ( uint [ ] ) { exchange ex = exchange ( exchange ) ; uint [ ] memory balances = new uint [ ] ( tokens . length * NUM_ ) ; for ( uint i = NUM_ ; i < tokens . length ; i ++ ) { uint j = i * NUM_ ; balances [ j ] = ex . balance of ( tokens [ i ] , user ) ; if ( tokens [ i ] != address ( NUM_ ) ) { balances [ j + NUM_ ] = token balance ( user , tokens [ i ] ) ; } else { balances [ j + NUM_ ] = user . balance ; } } return balances ; }\n", "nl": "get multiple token balance on etherdelta ( or similar exchange ) ."}
{"code": "function setup crowdsale ( uint256 _funding start block , uint256 _funding end block ) public only owner returns ( bytes32 response ) { if ( ( msg . sender == admin ) && ( ! ( is crowd sale setup ) ) && ( ! ( beneficiary wallet > NUM_ ) ) ) { beneficiary wallet = NUM_ ; token reward = standard token ( NUM_ ) ; funding min cap in wei = NUM_ ; amount raised in wei = NUM_ ; initial token supply = NUM_ ; tokens remaining = initial token supply ; funding start block = _funding start block ; funding end block = _funding end block ; is crowd sale setup = BOOL_ ; is crowd sale closed = BOOL_ ; current status = STR_ ; return STR_ ; } else if ( msg . sender != admin ) { return STR_ ; } else { return STR_ ; } }\n", "nl": "end the crowdsale when the value xx ether or xx days be reach ."}
{"code": "function modify choice ( uint choice ) before timestamp ( start time ) public { require ( choice > NUM_ ) ; require ( check player exists ( msg . sender ) ) ; uint old choice = player info [ msg . sender ] . choice ; number of choice [ old choice ] = number of choice [ old choice ] . sub ( NUM_ ) ; number of choice [ choice ] = number of choice [ choice ] . add ( NUM_ ) ; player info [ msg . sender ] . choice = choice ; address of choice [ old choice ] [ msg . sender ] = BOOL_ ; address of choice [ choice ] [ msg . sender ] = BOOL_ ; log modify choice ( msg . sender , old choice , choice ) ; }\n", "nl": "get the bet number of a specific choice ."}
{"code": "function create exchange ( uint256 _token id , uint256 _kind , uint256 _weight ) external only eoa { exchange wrapper memory _ew = exchange wrapper ( { id : NUM_ , owner : msg . sender , token id : _token id , kind : _kind , weight : _weight , created at : NUM_ } ) ; crystal wrapper memory _cw = get crystal wrapper ( msg . sender , _token id ) ; require ( crystal . owner of ( _token id ) == _cw . owner ) ; require ( _kind < NUM_ ) ; crystal . _transfer from ( _cw . owner , exchange , _token id ) ; _ew . id = exchange . create ( _ew . owner , _token id , _cw . gene , _cw . kind , _cw . weight , _ew . kind , _ew . weight , now ) ; emit create exchange ( _ew . id , _ew . owner , _ew . token id , _cw . gene , _cw . kind , _cw . weight , _ew . kind , _ew . weight , now ) ; }\n", "nl": "add a tier with a give discount and available supply ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) returns ( bool success ) { require ( _value <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] -= _value ; _transfer ( _from , _to , _value ) ; return BOOL_ ; }\n", "nl": "transfer tokens from other address ."}
{"code": "function refund ( ) external { if ( ! start refund ) throw ; var gnt value = balances [ msg . sender ] ; var eth value = balances ether [ msg . sender ] ; if ( gnt value == NUM_ ) throw ; balances [ msg . sender ] = NUM_ ; balances ether [ msg . sender ] = NUM_ ; total tokens -= gnt value ; refund ( msg . sender , eth value ) ; if ( ! msg . sender . send ( eth value ) ) throw ; }\n", "nl": "get back the ether send during the fund in case the fund have not reach the minimum level ."}
{"code": "function request refund ( ) { address nrequester = msg . sender ; update ico status ( ) ; uint ntokens = get held ( holder accounts [ nrequester ] . tokens ) ; if ( ico status != ico status value . failed ) stat event ( STR_ ) ; else if ( ntokens == NUM_ ) stat event ( STR_ ) ; else { uint nrefund = ntokens * token price ; if ( get num tokens purchased ( ) >= min ico token goal ) nrefund -= ( nrefund / NUM_ ) ; if ( ! holder accounts [ developers ] . alloced ) add account ( developers ) ; holder accounts [ developers ] . tokens += ntokens ; holder accounts [ nrequester ] . tokens = NUM_ ; if ( holder accounts [ nrequester ] . balance > NUM_ ) { holder accounts [ developers ] . balance += holder accounts [ nrequester ] . balance ; holder accounts [ nrequester ] . balance = NUM_ ; } if ( ! nrequester . call . gas ( rf gas ) . value ( nrefund ) ( ) ) throw ; } }\n", "nl": "contract payout hald ."}
{"code": "function transfer to contract ( address to , uint256 value , bytes data ) public returns ( bool _success ) { require ( to != address ( NUM_ ) ) ; require ( value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; contract receiver ( to ) . token fallback ( msg . sender , value , data ) ; transfer ( msg . sender , to , value , data ) ; return BOOL_ ; }\n", "nl": "to transfer tokens to a user address ."}
{"code": "function swap token to ether ( erc20 token , uint src amount , uint min conversion rate ) public returns ( uint ) { bytes memory hint ; return trade with hint ( token , src amount , eth_token_address , msg . sender , max_qty , min conversion rate , NUM_ , hint ) ; }\n", "nl": "make a trade between src and dest token and send dest tokens to msg sender ."}
{"code": "function collect ( ) external only owner { owner . transfer ( address ( this ) . balance ) ; }\n", "nl": "etherdrop team r d support collectibles ."}
{"code": "function grant ( address to , uint256 amount ) only owner can grant public returns ( bool success ) { require ( ! freezed [ to ] && ! blacklisted [ to ] && partners [ to ] ) ; require ( amount <= reserved supply ) ; total supply_ = total supply_ . add ( amount ) ; reserved supply = reserved supply . sub ( amount ) ; balances [ to ] = balances [ to ] . add ( amount ) ; grant ( to , amount ) ; transfer ( address ( NUM_ ) , to , amount ) ; return BOOL_ ; }\n", "nl": "transfer tokens to a specified address ."}
{"code": "function get most expensive crypto gamer ( ) public view returns ( uint ) { uint _most expensive gamer id = NUM_ ; uint256 _most expensive gamer price = NUM_ ; for ( uint8 i = NUM_ ; i < crypto gamers . length ; i ++ ) { if ( crypto gamers [ i ] . cur price > _most expensive gamer price ) { _most expensive gamer price = crypto gamers [ i ] . cur price ; _most expensive gamer id = i ; } } return ( _most expensive gamer id ) ; }\n", "nl": "get least expensive crypto gamers ( to transfer the owner 5 of the transaction ) ."}
{"code": "function transfer token ownership ( address new owner ) public only owner { require ( new owner != address ( NUM_ ) ) ; ownership transferred ( owner , new owner ) ; mintable token ( token ) . transfer ownership ( new owner ) ; }\n", "nl": "transfer token ownership after token sale be complete ."}
{"code": "function set pre sale price ( uint256 _token per ether ) external only owner or admin returns ( bool ) { require ( _token per ether > NUM_ ) ; pre sale price = _token per ether ; emit set pre sale price ( pre sale price ) ; return BOOL_ ; }\n", "nl": "set private sales price ."}
{"code": "function purchase tokens ( ) public payable only during sale returns ( bool ) { address contributor = msg . sender ; uint256 wei amount = msg . value ; require ( has contributed [ contributor ] == BOOL_ ) ; require ( contributor can contribute ( contributor ) ) ; require ( wei amount >= min contribution ) ; require ( wei amount <= max contribution ) ; require ( total tokens sold < token_sale_supply ) ; uint256 available tokens to purchase = token_sale_supply . sub ( total tokens sold ) ; uint256 lucky per ether = tokens per ether . mul ( j8 t_decimals_factor ) ; uint256 tokens amount = wei amount . mul ( lucky per ether ) . div ( eth_decimals_factor ) ; uint256 refund = NUM_ ; uint256 tokens to purchase = tokens amount ; if ( available tokens to purchase < tokens amount ) { tokens to purchase = available tokens to purchase ; wei amount = tokens to purchase . mul ( eth_decimals_factor ) . div ( lucky per ether ) ; refund = msg . value . sub ( wei amount ) ; } total tokens sold = total tokens sold .\n", "nl": "function for sell tokens ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }\n", "nl": "transfer on behalf of another address ."}
{"code": "function set consolation rewards percent ( uint _new consolation rewards percent ) only owner external { consolation rewards percent = _new consolation rewards percent ; }\n", "nl": "updates the master reward percentage ."}
{"code": "function finalize transfer children ownership ( ) public only admin or owner { require ( transfer ownership operation . admin == admin ) ; require ( transfer ownership operation . defer block <= block . number ) ; address new owner = transfer ownership operation . new owner ; delete transfer ownership operation ; child . transfer ownership ( new owner ) ; can burn white list . transfer ownership ( new owner ) ; can receive mint whitelist . transfer ownership ( new owner ) ; black list . transfer ownership ( new owner ) ; }\n", "nl": "claim ownership of an arbitrary claimable contract ."}
{"code": "function validate ( uint sequence ) public constant returns ( bool ) { uint c = countdown ( ) ; require ( c < NUM_ && ( sequence == NUM_ || sequence == NUM_ || sequence == NUM_ ) || c < NUM_ && ( sequence == NUM_ || sequence == NUM_ || sequence == NUM_ ) || ( sequence == NUM_ || sequence == NUM_ || sequence == NUM_ || sequence == NUM_ || sequence == NUM_ || sequence == NUM_ || seq search ( sequence , NUM_ , NUM_ ) != - NUM_ ) ) ; return BOOL_ ; }\n", "nl": "validate the input sequence of number simplest impl ( current ) : positive value proper impl ( consideration for future versions ) : 00 . . 0481516234200 . . 0-like ."}
{"code": "function update plot price ( uint256 plot index , uint256 new price in wei per pixel ) external { require ( plot index >= NUM_ ) ; require ( plot index < ownership . length ) ; require ( msg . sender == ownership [ plot index ] . owner ) ; plot id to price [ plot index ] = new price in wei per pixel ; emit plot price updated ( plot index , new price in wei per pixel , msg . sender ) ; }\n", "nl": "sets the new price for unclaimed plot ."}
{"code": "function set rate ( uint _rate ) public only owner or manager { require ( _rate > NUM_ , STR_ ) ; exchange_rate = _rate ; }\n", "nl": "set rate : ."}
{"code": "function cancel pending ( bytes32 operation ) public only any owner { uint owner index = owners indices [ msg . sender ] - NUM_ ; require ( ( votes mask by operation [ operation ] & ( NUM_ * * owner index ) ) != NUM_ ) ; votes mask by operation [ operation ] &= ~ ( NUM_ * * owner index ) ; votes count by operation [ operation ] -- ; if ( votes count by operation [ operation ] == NUM_ ) { delete operation ( operation ) ; } }\n", "nl": "used to delete cancel or perform operation ."}
{"code": "function reveal bet ( uint game id , uint player secret ) public { game instance storage game = game context [ game id ] ; require ( game . bet amount in wei > NUM_ ) ; require ( game . state == state . waiting for reveal ) ; require ( game . player1 == msg . sender ) ; uint i ; for ( i = NUM_ ; i < wheel_size ; ++ i ) { if ( create wheel bet hash ( game id , i , player secret ) == game . wheel bet player1 ) { game . wheel bet player1 = i ; break ; } } require ( i < wheel_size ) ; game event ( game id , msg . sender , event . reveal ) ; uint256 hash result = uint256 ( keccak256 ( game id , now , game . wheel bet player1 , game . wheel bet player2 ) ) ; uint32 random seed = uint32 ( hash result > > NUM_ ) ^ uint32 ( hash result > > NUM_ ) ^ uint32 ( hash result > > NUM_ ) ^ uint32 ( hash result > >\n", "nl": "create and initialize a game instance with the send bet amount ."}
{"code": "function mint tokens ( address _owner ) can mint only ( messi dev ) non zero address ( _owner ) public returns ( bool ) { require ( lock tokens [ _owner ] . block number <= get current block number ( ) ) ; uint256 _amount = lock tokens [ _owner ] . value ; uint256 cur total supply = total supply ; require ( cur total supply + _amount >= cur total supply ) ; require ( cur total supply + _amount <= total supply cap ) ; uint256 previous balance to = balance of ( _owner ) ; require ( previous balance to + _amount >= previous balance to ) ; total supply = cur total supply . add ( _amount ) ; balances [ _owner ] = previous balance to . add ( _amount ) ; lock tokens [ _owner ] . value = NUM_ ; lock tokens [ _owner ] . block number = NUM_ ; mint tokens ( _owner , _amount ) ; transfer ( NUM_ , _owner , _amount ) ; return BOOL_ ; }\n", "nl": "approve of mint _amount tokens that be assign to _owner ."}
{"code": "modifier only owner or whitelisted ( whitelist keys _key ) { whitelist interface whitelist = whitelist interface ( get component by name ( whitelist ) ) ; require ( msg . sender == owner || ( whitelist . enabled ( address ( this ) , uint8 ( _key ) ) && whitelist . is allowed ( uint8 ( _key ) , msg . sender ) ) ) ; _ ; }\n", "nl": "if whitelist be disable , anyone can do this ."}
{"code": "function tweak state ( ) external only owner { paused = ! paused ; pause ( paused ) ; }\n", "nl": "enable upgrade to allow tokens migration to new contract process ."}
{"code": "function transfer token ( token _token contract , address _transfer to , uint256 _value ) only owner external { _token contract . transfer ( _transfer to , _value ) ; }\n", "nl": "for other tokens ."}
{"code": "function set uccoin per ether ( uint256 coin amount ) external only owner returns ( uint256 ) { require ( uccoin_per_ether != coin amount ) ; require ( coin amount >= minimum_selling_uccoin ) ; uccoin_per_ether = coin amount ; uc coin price changed ( uccoin_per_ether , now ) ; return uccoin_per_ether ; }\n", "nl": "update eth value in milieurs ."}
{"code": "function set property status ( bytes32 _property , address _user , statuses _status ) public only administrator returns ( bool ) { _set property status ( _property , _user , _status ) ; return BOOL_ ; }\n", "nl": "set verification status for user data ."}
{"code": "function _transfer ( address _from , address _to , uint256 _token id ) internal { ownership token count [ _to ] ++ ; pony index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete sire allowed to address [ _token id ] ; delete pony index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }\n", "nl": "assigns ownership of a specific linglongcat to an address ."}
{"code": "function place purchase order ( bytes32 _sealed purchase order ) public payable { if ( block . number . sub ( periods [ current period index ( ) ] . started ) > period_blocks ) { next period ( ) ; } period storage period = periods [ current period index ( ) ] ; require ( period . sealed purchase orders [ msg . sender ] == bytes32 ( NUM_ ) ) ; period . sealed purchase orders [ msg . sender ] = _sealed purchase order ; period . received balances [ msg . sender ] = msg . value ; emit sealed order placed ( msg . sender , current period index ( ) , msg . value ) ; }\n", "nl": "go to the next period , if sufficient time have pass ."}
{"code": "function create currency ( string _name , string _symbol , uint8 _decimals , uint256 _total supply , string _token uri ) public returns ( address ) { colu local currency sub token = new colu local currency ( _name , _symbol , _decimals , _total supply , _token uri ) ; ellipse market maker new market maker = new ellipse market maker ( mm lib address , cln address , sub token ) ; require ( sub token . transfer ( new market maker , _total supply ) ) ; require ( iellipse market maker ( new market maker ) . initialize after transfer ( ) ) ; currency map [ sub token ] = currency struct ( { name : _name , decimals : _decimals , total supply : _total supply , mm address : new market maker , owner : msg . sender } ) ; tokens . push ( sub token ) ; token created ( sub token , msg . sender ) ; return sub token ; }\n", "nl": "sets the precision ."}
{"code": "modifier only creator { if ( msg . sender == creator ) _ ; }\n", "nl": "this modifier check that only the creator of the contract can call this smart contract ."}
{"code": "function release tokens ( address _address , uint256 amount ) { require ( msg . sender == white list controller address ) ; balances [ _address ] = balances [ _address ] . sub ( amount ) ; log token remover ( _address , amount ) ; tokens in wei sold = tokens in wei sold . sub ( amount ) ; }\n", "nl": "manually update the tokens sell count to reserve tokens or update stats if other way buy ."}
{"code": "function pay tokens ( ) internal { require ( balances [ msg . sender ] > NUM_ ) ; uint token amount = check tok balance ( msg . sender ) ; balances [ msg . sender ] = NUM_ ; token . transfer ( msg . sender , token amount ) ; pay tokens ( msg . sender , token amount , now ) ; }\n", "nl": "function to pay back ether ."}
{"code": "function transfer from ( address _from , address _to , uint _amount ) public returns ( bool success ) { require ( balances [ _from ] >= _amount ) ; require ( allowed [ _from ] [ msg . sender ] >= _amount ) ; balances [ _from ] = balances [ _from ] . sub ( _amount ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; transfer ( _from , _to , _amount ) ; return BOOL_ ; }\n", "nl": "an approved sender can burn _amount tokens of user _from ."}
{"code": "function upgrade tank ( uint256 _tank id , uint8 _upgrade choice ) public payable { require ( _tank id > NUM_ && _tank id < new tank id ) ; require ( tanks [ _tank id ] . tank owner == msg . sender ) ; require ( ! tanks [ _tank id ] . in auction ) ; require ( ! tanks [ _tank id ] . in battle ) ; require ( _upgrade choice >= NUM_ && _upgrade choice < NUM_ ) ; require ( tanks [ _tank id ] . upgrades [ _upgrade choice ] + NUM_ > tanks [ _tank id ] . upgrades [ _upgrade choice ] ) ; uint256 upgrade price = base tanks [ tanks [ _tank id ] . type id ] . start price / NUM_ ; require ( msg . value >= upgrade price ) ; tanks [ _tank id ] . upgrades [ _upgrade choice ] ++ ; if ( msg . value > upgrade price ) { balances [ msg . sender ] += msg . value - upgrade price ; } uint256 tournament proceeds = ( upgrade price * tournament tax rate ) / NUM_ ; balances\n", "nl": "buy tank from auction ."}
{"code": "function run plugin signed ( address _plugin address , uint40 _sign id , uint40 _cutie id , uint128 _value , uint256 _parameter , uint8 _v , bytes32 _r , bytes32 _s ) public when not paused payable { require ( _cutie id == NUM_ || _is owner ( msg . sender , _cutie id ) ) ; require ( address ( plugins [ _plugin address ] ) != address ( NUM_ ) ) ; require ( used signes [ _sign id ] == address ( NUM_ ) ) ; require ( _sign id >= min sign id ) ; require ( _value <= msg . value ) ; require ( is valid signature ( _plugin address , _sign id , _cutie id , _value , _parameter , _v , _r , _s ) ) ; used signes [ _sign id ] = msg . sender ; emit sign used ( _sign id , msg . sender ) ; plugins [ _plugin address ] . run signed . value ( _value ) ( _cutie id , _parameter , msg . sender ) ; }\n", "nl": "external exchange ."}
{"code": "modifier post start ( ) { require ( locked && start block timestamp != NUM_ ) ; _ ; }\n", "nl": "prestart , state be after lock , before start ."}
{"code": "function transfer token ownership ( address _new owner ) public only owner { require ( ended ( ) ) ; require ( _new owner != NUM_ ) ; ownable ( token ) . transfer ownership ( _new owner ) ; }\n", "nl": "claim back token ownership ."}
{"code": "function train equipment ( uint _dungeon id , uint _hero id , uint _equipment index ) when not paused dungeon can train ( _dungeon id ) hero allowed to train ( _hero id ) external payable { require ( _equipment index <= NUM_ ) ; _train ( _dungeon id , _hero id , _equipment index , NUM_ ) ; }\n", "nl": "the external function to call when a hero train with a dungeon , it determine whether whether a train be successfully , and the result genes ."}
{"code": "function get bonus ( uint256 _tokens ) internal view returns ( uint256 bonus ) { require ( _tokens != NUM_ ) ; if ( start time <= now && now < start time + NUM_ days ) { return _tokens . div ( NUM_ ) ; } else if ( start time + NUM_ days <= now && now < start time + NUM_ days ) { return _tokens . div ( NUM_ ) ; } else if ( start time + NUM_ days <= now && now < start time + NUM_ days ) { return _tokens . div ( NUM_ ) ; } return NUM_ ; }\n", "nl": "day 1 : + 20 bonus ."}
{"code": "function remove locked time ( address _target , uint _ind ) internal returns ( bool ) { require ( _target != address ( NUM_ ) ) ; time rec [ ] storage locked times = frozen times [ _target ] ; require ( _ind < locked times . length ) ; uint256 i = _ind ; while ( i < locked times . length . sub ( NUM_ ) ) { locked times [ i ] = locked times [ i . add ( NUM_ ) ] ; i = i . add ( NUM_ ) ; } delete locked times [ locked times . length . sub ( NUM_ ) ] ; locked times . length = locked times . length . sub ( NUM_ ) ; return BOOL_ ; }\n", "nl": "remove an account from the frozen account list ."}
{"code": "function approve finish minting request ( ) public only owners { require ( ! finish minting struct . is canceled && ! finish minting struct . is execute ) ; require ( finish minting struct . creation timestamp + life time >= uint32 ( now ) ) ; require ( ! minting finished ) ; for ( uint i = NUM_ ; i < finish minting struct . confirmators . length ; i ++ ) { require ( finish minting struct . confirmators [ i ] != msg . sender ) ; } finish minting struct . confirmators . push ( msg . sender ) ; finish minting struct . confirms ++ ; if ( finish minting struct . confirms >= need approves to confirm ) { token . finish minting ( ) ; finish minting struct . is execute = BOOL_ ; minting finished = BOOL_ ; } emit finish minting request update ( msg . sender , finish minting struct . confirms , finish minting struct . is execute ) ; }\n", "nl": "internal function to check and revert all action by removed owner in this contract ."}
{"code": "function _create scene ( string _name , uint [ ] _stars , address _owner , uint256 _price ) private { require ( _stars . length > NUM_ ) ; for ( uint i = NUM_ ; i < _stars . length ; i ++ ) { address _pornstar owner ; ( _pornstar owner ) = pornstars contract . owner of ( _stars [ i ] ) ; require ( _pornstar owner != address ( NUM_ ) || _pornstar owner != address ( NUM_ ) ) ; } scene memory _scene = scene ( { name : _name , stars : _stars } ) ; uint256 new scene id = scenes . push ( _scene ) - NUM_ ; require ( new scene id == uint256 ( uint32 ( new scene id ) ) ) ; birth ( new scene id , _name , _stars , _owner ) ; scene index to price [ new scene id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new scene id ) ; }\n", "nl": "creates a rarecoin token ."}
{"code": "function get entity ( address _entity ) view external returns ( bool active , address transfer owner to , bytes32 data , address owner ) { address resolved entity = resolve entity address ( _entity ) ; entity storage entity = entities [ resolved entity ] ; return ( entity . active , entity . transfer owner to , entity . data , entity . owner ) ; }\n", "nl": "accepts a request to transfer the ownership of an entity ."}
{"code": "modifier can transfer ( address _sender ) { require ( transfer enabled || transfer admins [ _sender ] ) ; _ ; }\n", "nl": "limit token transfer if _sender be frozen ."}
{"code": "function release for ecosystem ( ) public owner only stoppable returns ( bool success ) { require ( now >= create time + NUM_ weeks ) ; require ( tokens released to ecosystem < ecosystem supply ) ; uint256 temp = ecosystem supply / NUM_ ; uint256 alloc amount = safe mul ( temp , NUM_ ) ; uint256 current tranche = uint256 ( now - create time ) / NUM_ weeks ; if ( ecosystem tranches released < max tranches && current tranche > ecosystem tranches released && ( current supply + alloc amount ) <= total supply ) { ecosystem tranches released ++ ; balance of [ ecosystem address ] = safe add ( balance of [ ecosystem address ] , alloc amount ) ; current supply += alloc amount ; tokens released to ecosystem = safe add ( tokens released to ecosystem , alloc amount ) ; transfer ( NUM_ , ecosystem address , alloc amount ) ; return BOOL_ ; } revert ( ) ; }\n", "nl": "the tokens at the airdropaddress will be airdroped before 2018 . 12 . 31 ."}
{"code": "function set thing valid ( bytes32 [ ] _id , bool _is valid ) is registrant no ether returns ( bool ) { uint index = id to thing [ sha3 ( _id ) ] ; if ( index == NUM_ ) { error ( NUM_ , _id ) ; return BOOL_ ; } if ( things [ index ] . owner address != msg . sender ) { error ( NUM_ , _id ) ; return BOOL_ ; } things [ index ] . is valid = _is valid ; updated ( _id , things [ index ] . owner address , things [ index ] . is valid ) ; return BOOL_ ; }\n", "nl": "add new ids to the thing , only registrants allow ."}
{"code": "function _transfer ( address _from , address _to , uint _value ) internal { require ( locked [ _from ] == NUM_ ) ; if ( locked [ _to ] > NUM_ ) { require ( balances [ _to ] + _value <= retention max ) ; } require ( _to != NUM_ ) ; require ( balances [ _from ] >= _value ) ; require ( balances [ _to ] + _value > balances [ _to ] ) ; uint256 previous balances = balances [ _from ] + balances [ _to ] ; balances [ _from ] -= _value ; balances [ _to ] += _value ; transfer ( _from , _to , _value ) ; assert ( balances [ _from ] + balances [ _to ] == previous balances ) ; }\n", "nl": "substract from totallocked ."}
{"code": "function transfer to address ( address _to , uint _value , bytes _data ) internal returns ( bool success ) { balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; transfer ( msg . sender , _to , _value ) ; transfer ( msg . sender , _to , _value , _data ) ; return BOOL_ ; }\n", "nl": "handles transfer to a contract erc-223 proposed standard ."}
{"code": "function upgrade ( ibancor converter extended _old converter , bytes32 _version ) public { bool former versions = BOOL_ ; if ( _version == STR_ ) former versions = BOOL_ ; accept converter ownership ( _old converter ) ; ibancor converter extended new converter = create converter ( _old converter ) ; copy connectors ( _old converter , new converter , former versions ) ; copy conversion fee ( _old converter , new converter ) ; copy quick buy path ( _old converter , new converter ) ; transfer connectors balances ( _old converter , new converter , former versions ) ; ismart token token = _old converter . token ( ) ; if ( token . owner ( ) == address ( _old converter ) ) { _old converter . transfer token ownership ( new converter ) ; new converter . accept token ownership ( ) ; } _old converter . transfer ownership ( msg . sender ) ; new converter . transfer ownership ( msg . sender ) ; new converter . transfer management ( msg . sender ) ; emit converter upgrade ( address ( _old converter ) , address ( new converter ) ) ; }\n", "nl": "allow the owner to update the quick changer contract address ."}
{"code": "function update tier duration ( uint _tier_index , uint _new_duration ) internal view { if ( _new_duration == NUM_ ) revert ( STR_ ) ; uint starts_at = uint ( contract . read ( sale manager . start time ( ) ) ) ; uint current_tier = uint ( contract . read ( sale manager . current tier ( ) ) ) ; uint total_duration = uint ( contract . read ( sale manager . total duration ( ) ) ) ; uint cur_ends_at = uint ( contract . read ( sale manager . current ends at ( ) ) ) ; uint previous_duration = uint ( contract . read ( sale manager . tier duration ( _tier_index ) ) ) ; current_tier = current_tier . sub ( NUM_ ) ; if ( previous_duration == _new_duration ) revert ( STR_ ) ; if ( total_duration < previous_duration ) revert ( STR_ ) ; if ( uint ( contract . read ( sale manager . sale tier list ( ) ) ) <= _tier_index ) revert ( STR_ ) ; if ( current_tier > _tier_index ) revert ( STR_ ) ; if ( contract . read ( sale manager . tier\n", "nl": "reads from storage and return information about the current crowdsale tier ."}
{"code": "function user get pending tx by address ( address address to check ) public constant returns ( uint ) { return user pending withdrawals [ address to check ] ; }\n", "nl": "check for pending withdrawals ."}
{"code": "function finish sale ( ) public only owner _contract up _sale not ended returns ( bool ) { int8 current phase index = get currently running phase ( ) ; require ( current phase index == NUM_ ) ; phase info storage currently running phase = phases [ uint256 ( current phase index ) ] ; uint256 tokens left ; uint256 tokens in public sale = NUM_ ; if ( currently running phase . wei raised <= NUM_ ether ) { tokens left = tokens in public sale . sub ( currently running phase . wei raised . mul ( NUM_ ) . div ( NUM_ ) ) ; token . transfer ( msg . sender , tokens left ) ; } sale ended = BOOL_ ; phases [ no of phases - NUM_ ] . end time = now ; emit finished ( msg . sender , now ) ; return BOOL_ ; }\n", "nl": "check balance of token of each phase ."}
{"code": "function get timebased bonus rate ( ) internal constant returns ( uint256 ) { uint256 bonus rate = NUM_ ; if ( stage == stage . presale ) { bonus rate = NUM_ ; } else { uint256 now time = get now ( ) ; uint256 bonus first week = start time + ( NUM_ days * NUM_ ) ; uint256 bonus second week = bonus first week + ( NUM_ days * NUM_ ) ; uint256 bonus third week = bonus second week + ( NUM_ days * NUM_ ) ; uint256 bonus fourth week = bonus third week + ( NUM_ days * NUM_ ) ; if ( now time <= bonus first week ) { bonus rate = NUM_ ; } else if ( now time <= bonus second week ) { bonus rate = NUM_ ; } else if ( now time <= bonus third week ) { bonus rate = NUM_ ; } else if ( now time <= bonus fourth week ) { bonus rate = NUM_ ; } } return bonus rate ; }\n", "nl": "premium for buy tits at the begin of ico ."}
{"code": "function level two bonus ( uint256 _amount ) returns ( uint256 , uint256 ) { uint256 available = remaining tokens - NUM_ * NUM_ ether ; if ( available >= _amount ) { remaining tokens -= _amount ; return ( _amount * NUM_ , NUM_ ) ; } else { remaining tokens -= available ; return ( available * NUM_ , _amount - available ) ; } }\n", "nl": "add 125 bonus ."}
{"code": "function transfer ( address to , uint value ) external optional proxy returns ( bool ) { return _transfer ( message sender , to , value ) ; }\n", "nl": "override erc20 transfer function in order to check whether the recipient account be frozen ."}
{"code": "function add member ( address _member ) public only owner { members [ _member ] = BOOL_ ; }\n", "nl": "add member to blocksquare group ."}
{"code": "function decimals ( ) public constant returns ( uint8 ) { return decimals ; }\n", "nl": "decimals function return the decimal units of the token ."}
{"code": "function burn ( uint256 _amount ) public returns ( bool success ) { require ( whitelisted burn [ msg . sender ] ) ; require ( _amount <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; total supply = total supply . sub ( _amount ) ; burn ( msg . sender , _amount ) ; return BOOL_ ; }\n", "nl": "allows a token holder to burn tokens ."}
{"code": "function check transfer ( address _from , address _to , uint _value , uint lockout time ) public returns ( bool can transfer , bool use lockout time , bool new tokens are restricted , bool preserve purchase date ) { preserve purchase date = BOOL_ ; bool transfer is authorized = is transfer authorized ( _from , _to ) ; bool from is affiliate = affiliate list . in list as of ( _from , block . timestamp ) ; bool to is affiliate = affiliate list . in list as of ( _to , block . timestamp ) ; if ( transfer is authorized ) { can transfer = BOOL_ ; if ( from is affiliate || to is affiliate ) { new tokens are restricted = BOOL_ ; } } else if ( ! from is affiliate ) { if ( investor list . has role ( _from , investor list . role_regs ( ) ) && investor list . has role ( _to , investor list . role_regs ( ) ) ) { can transfer = BOOL_ ; } else { if ( ledger . transfer dry run ( _from , _to , _value , lockout\n", "nl": "function below this line be onlytoken ."}
{"code": "function _is ready to give birth ( pony _matron ) private view returns ( bool ) { return ( _matron . siring with id != NUM_ ) && ( _matron . cooldown end block <= uint64 ( block . number ) ) ; }\n", "nl": "checks to see if a give monster be pregnant and ( if so ) if the gestation period have pass ."}
{"code": "function get my game info ( ) public view returns ( uint256 , uint256 , uint256 ) { return get player game info ( game index , msg . sender ) ; }\n", "nl": "return current run game info ."}
{"code": "function schedule payout oraclize call ( uint _policy id , bytes32 _risk id , uint _oraclize time ) public { require ( fd_ac . check permission ( NUM_ , msg . sender ) ) ; var ( carrier flight number , departure year month day , ) = fd_db . get risk parameters ( _risk id ) ; string memory oraclize url = str concat ( oraclize_status_base_url , b32to string ( carrier flight number ) , b32to string ( departure year month day ) , oraclize_status_query ) ; bytes32 query id = oraclize_query ( _oraclize time , STR_ , oraclize url , oraclize_gas ) ; fd_db . create oraclize callback ( query id , _policy id , oraclize state . for payout , _oraclize time ) ; log oraclize call ( _policy id , query id , oraclize url , _oraclize time ) ; }\n", "nl": "add a collector ."}
{"code": "function main send ttc ( ) only owner public { for ( uint i = NUM_ ; i < main ready to send address . length ; i ++ ) { address backer address = main ready to send address [ i ] ; uint coin ready to send = main backers [ backer address ] . coin ready to send ; if ( coin ready to send > NUM_ ) { main backers [ backer address ] . coin ready to send = NUM_ ; coin . transfer ( backer address , coin ready to send ) ; log coins emited ( backer address , coin ready to send ) ; } } delete main ready to send address ; require ( main multisig ether . send ( this . balance ) ) ; }\n", "nl": "fonction appel\u00e9s par le propri\u00e9taire du contrat pour passer \u00e0 l'\u00e9tape suivante du processus de vente ."}
{"code": "function set paused ( bool _paused ) public { require ( msg . sender == owner ) ; paused = _paused ; }\n", "nl": "allows contractowner to pause the contract ."}
{"code": "function number of milestones ( ) constant returns ( uint ) { return milestones . length ; }\n", "nl": "get total start card ."}
{"code": "function close invest ( bytes5 _interval ) internal { uint256 _intrest ; address _to = msg . sender ; uint256 _period = count period ( _to , _interval ) ; invest storage inv = invest info [ _to ] [ _interval ] ; uint256 _value = inv . balance ; if ( _period == NUM_ ) { balances [ this ] -= _value ; balances [ _to ] += _value ; emit transfer ( this , _to , _value ) ; emit invest closed ( _to , _value ) ; } else if ( _period > NUM_ ) { balances [ this ] -= _value ; total supply -= _value ; emit transfer ( this , NUM_ , _value ) ; emit destruction ( _value ) ; _intrest = reward controller ( _to , _interval ) ; if ( manager [ msg . sender ] ) { _intrest = mulsm ( divsm ( _intrest , NUM_ ) , NUM_ ) ; } issue ( _to , _intrest ) ; emit invest closed ( _to , _intrest ) ; } inv . exists = BOOL_ ; inv . balance = NUM_ ; inv . closed = now ; }\n", "nl": "invest box controller ."}
{"code": "function transfer ( address _to , uint256 _amount ) stop on pause public returns ( bool success ) { bytes memory empty ; if ( _transfer ( msg . sender , _to , _amount , empty ) ) { emit transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; } return BOOL_ ; }\n", "nl": "transfers _amount from _from to _to with additional data ."}
{"code": "function is registered ( address _addr , bool _is presale ) public view returns ( bool ) { return registered address [ _addr ] [ _is presale ] ; }\n", "nl": "check whether the address be register for token sale or not ."}
{"code": "modifier only brand ( ) { require ( msg . sender == brand ) ; _ ; }\n", "nl": "require msg . sender ."}
{"code": "function withdraw tokens ( ) public { uint64 one month = last withdraw time + NUM_ days ; require ( uint ( now ) >= one month ) ; if ( withdraws count == NUM_ ) { amount to send = mnt token . balance of ( this ) / NUM_ ; } require ( amount to send != NUM_ ) ; uint current balance = mnt token . balance of ( this ) ; if ( current balance < amount to send ) { amount to send = current balance ; } mnt token . transfer ( team account address , amount to send ) ; withdraws count ++ ; last withdraw time = uint64 ( now ) ; }\n", "nl": "bank tokens ."}
{"code": "function unpause token ( ) external only owner { token . unpause ( ) ; }\n", "nl": "this set the token agent to the contract , allow the contract to reclaim and burn tokens if necessary ."}
{"code": "function user retire hodl ( uint256 id ) public { safe storage s = _safes [ id ] ; require ( s . id != NUM_ ) ; require ( s . user == msg . sender ) ; retire hodl ( id ) ; }\n", "nl": "owner retire hodl safe ."}
{"code": "function remove order ( uint _order ) internal { if ( number of orders - NUM_ < _order ) return ; number of orders -= NUM_ ; if ( number of orders > NUM_ ) { for ( uint i = _order ; i <= number of orders - NUM_ ; i ++ ) { orders [ i ] . buyer = orders [ i + NUM_ ] . buyer ; orders [ i ] . wei given = orders [ i + NUM_ ] . wei given ; } } orders [ number of orders ] . buyer = NUM_ ; orders [ number of orders ] . wei given = NUM_ ; }\n", "nl": "internal function to create a buy order ."}
{"code": "function distribute presale ( address beneficiary ) public { require ( ! halted ) ; require ( is distributable ( ) ) ; require ( deposits [ beneficiary ] > NUM_ ) ; require ( beneficiary != NUM_ ) ; uint256 wei deposit = deposits [ beneficiary ] ; deposits [ beneficiary ] = NUM_ ; uint256 tokens out = wei deposit . mul ( NUM_ ether ) . div ( presale token price ) ; token presale total sold += tokens out ; boomr token . transfer ( beneficiary , tokens out ) ; presale distribution ( msg . sender , beneficiary , tokens out ) ; }\n", "nl": "resets burnttokens to zero ."}
{"code": "function revoke self ( ) public members only { uint8 member id ; ( , member id ) = the cyber . get membership status ( msg . sender ) ; the cyber . revoke membership ( member id ) ; }\n", "nl": "methods of the utility contract can only be call by a valid member ."}
{"code": "function set config ( string _key , uint256 _value ) only owner { chainy config [ _key ] = _value ; }\n", "nl": "returns configuration option ."}
{"code": "function set config address ( address _address ) external only owner { schema = game config interface ( _address ) ; }\n", "nl": "update the address of the config contract ."}
{"code": "function claim halvings subsidies ( uint256 _n ) public not before genesis not paused is miner ( msg . sender ) returns ( uint256 ) { miner miner = miners [ msg . sender ] ; uint256 start = block halving ( miner . block ) ; uint256 end = start . add ( _n ) ; if ( end > current halving ( ) ) { return NUM_ ; } uint256 subsidy = NUM_ ; uint256 total subsidy = NUM_ ; uint256 unclaimed = NUM_ ; uint256 hash rate = NUM_ ; uint256 k ; for ( k = start ; k < end && k < max halvings ; k ++ ) { halving hash rate halving hash rate = halvings hash rate [ k ] ; if ( ! halving hash rate . carried ) { halving hash rate . carried = BOOL_ ; halving hash rate . rate = halving hash rate . rate . add ( halvings hash rate [ k - NUM_ ] . rate ) ; } miner hash rate miner hash rate = miner . hash rate [ k ] ; if ( ! miner hash rate . carried ) { miner\n", "nl": "contribute to the mine of bth ."}
{"code": "function confirm token transfer to booking ( bytes32 _partner id , string _tx num , bytes32 _from client id1 , bytes32 _to client id2 , uint256 _token amount1 , uint256 _r amount1 , uint256 _token amount2 , uint256 _r amount2 , uint256 _tx token amount1 , uint256 _tx ramount1 , uint256 _tx token amount2 , uint256 _tx ramount2 ) only owner stop in emergency public { e confirm token transfer to booking ( _partner id , _tx num , _from client id1 , _to client id2 , _token amount1 , _r amount1 , _token amount2 , _r amount2 ) ; e transaction fee for booking ( _partner id , _tx num , _from client id1 , _to client id2 , _tx token amount1 , _tx ramount1 , _tx token amount2 , _tx ramount2 ) ; }\n", "nl": "function for return tokens ."}
{"code": "function finalize migration ( address sender , proxy identity ) only authorized only older owner ( identity , sender ) { require ( migration initiated [ identity ] != NUM_ && migration initiated [ identity ] + admin time lock < now ) ; address new id manager = migration new address [ identity ] ; delete migration initiated [ identity ] ; delete migration new address [ identity ] ; identity . transfer ( new id manager ) ; delete recovery keys [ identity ] ; delete owners [ identity ] [ sender ] ; log migration finalized ( identity , new id manager , sender ) ; }\n", "nl": "allows an owner to finalize migration once admintimelock time have pass ."}
{"code": "function press ( uint _count presses , uint _aff id ) public payable { require ( _count presses >= NUM_ ) ; require ( msg . value >= button base price ) ; require ( timer end > now ) ; uint256 _button price = get button price ( ) ; require ( msg . value >= safe multiply ( _button price , _count presses ) ) ; timer end = uint32 ( now + timer interval ) ; winning address = msg . sender ; uint256 two percent com = ( msg . value / NUM_ ) * NUM_ ; uint256 ten percent com = msg . value / NUM_ ; uint256 fifteen percent com = ( msg . value / NUM_ ) * NUM_ ; if ( _aff id > NUM_ && _aff id < players . length ) { players [ _aff id ] . player address . transfer ( ten percent com ) ; } uint [ ] memory main investors = get main investor ( ) ; uint main investor = main investors [ NUM_ ] ; players [ main investor ] . player address . transfer ( fifteen percent com ) ; count investor\n", "nl": "perform the bid win logic ( in this case : give renter status to the winner ) ."}
{"code": "modifier not locked ( ) { require ( ! locked ) ; _ ; }\n", "nl": "modifier to make a function callable only when the contract be not lock ."}
{"code": "function withdraw ( ) public only owner { uint256 balance = token . balance of ( address ( this ) ) ; uint256 hundred = NUM_ ; uint256 broker withdraw = ( balance . div ( hundred ) ) . mul ( commission ) ; uint256 beneficiary withdraw = balance . sub ( broker withdraw ) ; token . transfer ( beneficiary , beneficiary withdraw ) ; token . transfer ( broker , broker withdraw ) ; emit withdrawn ( balance ) ; }\n", "nl": "withdraws commission sum to the owner ."}
{"code": "function allocate tokens ( address _to , uint256 _tokens ) public only owner returns ( bool ) { require ( balance of ( owner ) >= _tokens ) ; balances [ owner ] = balances [ owner ] . sub ( _tokens ) ; balances [ _to ] = balances [ _to ] . add ( _tokens ) ; allocated tokens = allocated tokens . add ( _tokens ) ; transfer ( owner , _to , _tokens ) ; return BOOL_ ; }\n", "nl": "allocates the specified amount of tokens to the address ."}
{"code": "function execute ruling ( uint _dispute id , uint _ruling ) internal { item storage item = items [ dispute idto item [ _dispute id ] ] ; require ( item . disputed ) ; if ( _ruling == register ) { if ( rechallenge possible && item . status == item status . submitted ) { uint arbitrator cost = arbitrator . arbitration cost ( arbitrator extra data ) ; if ( arbitrator cost + stake < item . balance ) { uint to send = item . balance - ( arbitrator cost + stake ) ; item . submitter . send ( to send ) ; item . balance -= to send ; } } else { if ( item . status == item status . resubmitted || item . status == item status . submitted ) item . submitter . send ( item . balance ) ; else item . challenger . send ( item . balance ) ; item . status = item status . registered ; } } else if ( _ruling == clear ) { if ( item . status == item status . preventive clearing requested || item . status == item status\n", "nl": "returns all the relevant information about a specific player ."}
{"code": "function owner set oraclize safe gas ( uint32 new safe gas to oraclize ) public only owner { gas for oraclize = new safe gas to oraclize ; }\n", "nl": "onlyowneroroperator set gas limit for oraclize query ."}
{"code": "function add to white list ( address _user ) external only owner ( ) { if ( white list [ _user ] != BOOL_ ) { white list [ _user ] = BOOL_ ; total white listed ++ ; emit log white listed ( _user , total white listed ) ; } else revert ( ) ; }\n", "nl": "allows the current owner to set an whiteliststatus ."}
{"code": "function get hero dbzhero address ( uint _hero id ) public view returns ( address ) { return ( heroes [ _hero id ] . dbzhero owner address ) ; }\n", "nl": "this function will return only the owner address of a specific hero ."}
{"code": "function remove minter ( address minter ) only master minter public returns ( bool ) { minters [ minter ] = BOOL_ ; minter allowed [ minter ] = NUM_ ; emit minter removed ( minter ) ; return BOOL_ ; }\n", "nl": "add a new minter ."}
{"code": "function mint tokens within time ( address _owner , uint256 _amount ) non zero address ( _owner ) can mint only ( aelf dev multisig ) public returns ( bool ) { require ( _amount > NUM_ ) ; require ( get current block number ( ) < ( deploy block number + minttime ) ) ; uint256 cur total supply = total supply ; require ( cur total supply + _amount >= cur total supply ) ; require ( cur total supply + _amount <= total supply cap ) ; uint256 previous balance to = balance of ( _owner ) ; require ( previous balance to + _amount >= previous balance to ) ; total supply = cur total supply . add ( _amount ) ; balances [ _owner ] = previous balance to . add ( _amount ) ; mint tokens ( _owner , _amount ) ; transfer ( NUM_ , _owner , _amount ) ; return BOOL_ ; }\n", "nl": "notifies the controller about a burn attempt ."}
{"code": "function stop sweep stake ( ) external { require ( msg . sender == initialized by ) ; sweep stake stopped = BOOL_ ; uint16 last participant number in round ; uint16 first participant number in round ; uint amount ; address participant address ; uint16 i ; uint16 min ; uint16 max ; uint total prizes = NUM_ ; last participant number in round = next participant number eth001 % max participants ; if ( last participant number in round > NUM_ ) { amount = NUM_ finney ; first participant number in round = last participant number in round - ( last participant number in round - NUM_ ) ; max = last participant number in round - NUM_ ; min = first participant number in round - NUM_ ; for ( i = max ; i >= min ; i -- ) { participant address = participants eth001 [ i ] ; prizes [ participant address ] += amount ; total prizes += amount ; if ( i == NUM_ ) { break ; } } next participant number eth001 = min ; } last participant number in round = next participant number eth01 % max participants\n", "nl": "main function which be use to join the sweepstake ."}
{"code": "function _approved for ( address _claimant , uint256 _token id ) internal view returns ( bool ) { return pony index to approved [ _token id ] == _claimant ; }\n", "nl": "checks if a give address currently have transferapproval for a particular panda ."}
{"code": "function set ownership history ( uint256 _token id , address [ NUM_ ] _previous owners ) public only coo { emoji index to previous owners [ _token id ] = _previous owners ; }\n", "nl": "this function be add in order to give the ability to manually set the previous price since this have to be redeploy ."}
{"code": "function eth balance ( ) public view returns ( uint256 ) { return address ( this ) . balance ; }\n", "nl": "returns contract eth balance ."}
{"code": "function sale ( address buyer , address partner ) public payable { if ( ! crowdsale running ( ) ) revert ( ) ; require ( msg . value > NUM_ ) ; uint256 rate = current rate ( ) ; assert ( rate > NUM_ ) ; uint256 referral tokens ; uint256 partner tokens ; uint256 owner tokens ; uint256 tokens = rate . mul ( msg . value ) ; assert ( tokens > NUM_ ) ; total collected = total collected . add ( msg . value ) ; if ( partner == NUM_ ) { owner tokens = tokens . mul ( founder percent ) . div ( percent_divider ) ; mint tokens ( buyer , tokens ) ; mint tokens ( owner , owner tokens ) ; } else { partner tokens = tokens . mul ( partner bonus percent ) . div ( percent_divider ) ; referral tokens = tokens . mul ( referral bonus percent ) . div ( percent_divider ) ; owner tokens = ( tokens . add ( partner tokens ) . add ( referral tokens ) ) . mul ( founder percent ) . div ( percent_divider ) ; uint256\n", "nl": "send 400 millions of tokens to teampool at the token sale end ( 200m for distribution + 200m for company ) ."}
{"code": "function update transcoder with rewards ( address _transcoder , uint256 _rewards , uint256 _round ) internal { transcoder storage t = transcoders [ _transcoder ] ; delegator storage del = delegators [ _transcoder ] ; earnings pool . data storage earnings pool = t . earnings pool per round [ _round ] ; earnings pool . reward pool = earnings pool . reward pool . add ( _rewards ) ; del . delegated amount = del . delegated amount . add ( _rewards ) ; uint256 new stake = transcoder pool . get key ( _transcoder ) . add ( _rewards ) ; transcoder pool . update key ( _transcoder , new stake , address ( NUM_ ) , address ( NUM_ ) ) ; total bonded = total bonded . add ( _rewards ) ; }\n", "nl": "pseudorandomly elect a currently active transcoder that charge a price per segment less than or equal to the max price per segment for a job ."}
{"code": "function allowance ( address , address ) public pure returns ( uint256 ) { return NUM_ ; }\n", "nl": "gets the contract version for validation ."}
{"code": "function buy new ( uint256 _xpos , uint256 _ypos , uint256 _size ) payable public { require ( check is on sale ( _ypos ) == BOOL_ ) ; require ( _size == NUM_ ) ; require ( _xpos + _size <= max_cols ) ; uint256 _item id = generate id ( _xpos , _ypos , _size ) ; require ( price of ( _item id ) == NUM_ ) ; require ( owner of ( _item id ) == address ( NUM_ ) ) ; uint256 price = starting price ; address old owner = owner ; listed items . push ( _item id ) ; price of item [ _item id ] = calculate next price ( price ) ; uint256 excess = msg . value . sub ( price ) ; address new owner = msg . sender ; owner of item [ _item id ] = new owner ; uint256 dev cut = calculate dev cut ( price ) ; old owner . transfer ( price . sub ( dev cut ) ) ; if ( excess > NUM_ ) { new owner . transfer ( excess ) ; } }\n", "nl": "buy now cancels auction with no penalty and return all placed bid ."}
{"code": "function transfer ( address _to , uint _amount ) public returns ( bool success ) { require ( tokens tradeable ) ; require ( _amount <= unlocked tokens internal ( msg . sender ) ) ; return super . transfer ( _to , _amount ) ; }\n", "nl": "override transferfrom ."}
{"code": "function mint ( address _investor , uint256 _amount ) public only module ( sto_key , BOOL_ ) check granularity ( _amount ) is minting allowed ( ) returns ( bool success ) { require ( _investor != address ( NUM_ ) , STR_ ) ; adjust investor count ( address ( NUM_ ) , _investor , _amount ) ; require ( verify transfer ( address ( NUM_ ) , _investor , _amount ) , STR_ ) ; adjust balance checkpoints ( _investor ) ; adjust total supply checkpoints ( ) ; total supply_ = total supply_ . add ( _amount ) ; balances [ _investor ] = balances [ _investor ] . add ( _amount ) ; emit minted ( _investor , _amount ) ; emit transfer ( address ( NUM_ ) , _investor , _amount ) ; return BOOL_ ; }\n", "nl": "burn function use to burn the securitytoken ."}
{"code": "function register purchase ( bytes32 payment id , address purchaser , uint256 amount ) public only owner only active only valid ( purchaser ) only not zero ( amount ) only unique payment ( payment id ) only sufficient available tokens ( amount ) { is payment registered [ payment id ] = BOOL_ ; available amount = available amount . sub ( amount ) ; token . mint ( purchaser , amount ) ; purchase registered ( payment id , purchaser , amount ) ; }\n", "nl": "register contribution with give id ."}
{"code": "function revoke burn delegate ( address _burn delegate ) only owner public returns ( bool ) { uint length = burn delegates . length ; require ( length > NUM_ ) ; address last delegate = burn delegates [ length - NUM_ ] ; if ( _burn delegate == last delegate ) { delete burn delegates [ length - NUM_ ] ; burn delegates . length -- ; } else { for ( uint i = NUM_ ; i < length ; i ++ ) { if ( burn delegates [ i ] == _burn delegate ) { burn delegates [ i ] = last delegate ; delete burn delegates [ length - NUM_ ] ; burn delegates . length -- ; break ; } } } revoke burn delegate ( _burn delegate ) ; return BOOL_ ; }\n", "nl": "give a burn delegate permission to burn tokens ."}
{"code": "function remove claim ( address issuer , address subject , bytes32 key ) public { require ( msg . sender == issuer || msg . sender == subject ) ; require ( registry [ issuer ] [ subject ] [ key ] != NUM_ ) ; delete registry [ issuer ] [ subject ] [ key ] ; claim removed ( msg . sender , subject , key , now ) ; }\n", "nl": "create or update a claim ."}
{"code": "function change controller ( address _new controller ) public auth { require ( _new controller != NUM_ ) ; pls . change controller ( _new controller ) ; controller changed ( _new controller ) ; }\n", "nl": "change the servus token controller ."}
{"code": "function safe sub ( uint256 a , uint256 b ) internal returns ( uint256 ) { assert ( a >= b ) ; return a - b ; }\n", "nl": "dev returns the difference of a and b ."}
{"code": "modifier only team reserve { require ( msg . sender == team reserve wallet ) ; require ( allocations [ msg . sender ] > NUM_ ) ; require ( allocations [ msg . sender ] > claimed [ msg . sender ] ) ; _ ; }\n", "nl": "only musk team reserve wallet ."}
{"code": "function owner mod operator ( address new address , bool new refund permission , uint new refund amt approve ) public only owner { operator . addr = new address ; operator . refund permission = new refund permission ; operator . refund amt approve = new refund amt approve ; }\n", "nl": "owner set fallback function mode ."}
{"code": "function do purchase ( address _buyer , uint256 _amount ) private only after ( start time ) only before ( end time ) stop in emergency { if ( crowdsale finished ) revert ( ) ; if ( collected . add ( _amount ) > hard cap ) revert ( ) ; if ( ( ! soft cap reached ) && ( collected < soft cap ) && ( collected . add ( _amount ) >= soft cap ) ) { soft cap reached = BOOL_ ; soft cap reached ( soft cap ) ; } uint256 tokens = _amount . mul ( price ) . div ( NUM_ ether ) ; if ( tokens == NUM_ ) revert ( ) ; if ( token . balance of ( _buyer ) == NUM_ ) investor count ++ ; collected = collected . add ( _amount ) ; token . transfer ( _buyer , tokens ) ; wei raised = wei raised . add ( _amount ) ; tokens sold = tokens sold . add ( tokens ) ; new contribution ( _buyer , tokens , _amount ) ; if ( collected == hard cap ) { goal reached ( hard\n", "nl": "end trigger ."}
{"code": "function change minter ( address _to ) external only owner ( ) { balances [ _to ] = balances [ minter ] ; balances [ minter ] = NUM_ ; minter = _to ; }\n", "nl": "blacklist the users which be fraudulent from get any tokens to do also refund just in case ."}
{"code": "function withdraw ( uint256 _amount ) public { withdraw to ( msg . sender , _amount ) ; }\n", "nl": "anybody can burn a specific amount of their tokens ."}
{"code": "function resolve challenge ( bytes32 _prop id ) private { param proposal memory prop = proposals [ _prop id ] ; challenge storage challenge = challenges [ prop . challenge id ] ; uint reward = challenge winner reward ( prop . challenge id ) ; challenge . winning tokens = voting . get total number of tokens for winning option ( prop . challenge id ) ; challenge . resolved = BOOL_ ; if ( voting . is passed ( prop . challenge id ) ) { if ( prop . process by > now ) { set ( prop . name , prop . value ) ; } emit _challenge failed ( _prop id , prop . challenge id , challenge . reward pool , challenge . winning tokens ) ; require ( token . transfer ( prop . owner , reward ) ) ; } else { emit _challenge succeeded ( _prop id , prop . challenge id , challenge . reward pool , challenge . winning tokens ) ; require ( token . transfer ( challenges [ prop . challenge id ] . challenger , reward ) ) ; } }\n", "nl": "for the provide proposal id , set it , resolve it challenge , or delete it depend on whether it can be set , have a challenge which can be resolve , or if it process by date have pass ."}
{"code": "function conditional transitions ( ) public { bytes32 next id = state . stages [ state . current stage id ] . next id ; while ( state . valid stage [ next id ] ) { state machine lib . stage storage next = state . stages [ next id ] ; if ( start conditions ( next id ) ) { state . go to next stage ( ) ; next id = next . next id ; } else { break ; } } }\n", "nl": "goes to the next stage if posible ( if the next stage be valid ) ."}
{"code": "function vote ( uint _id ) public only voter returns ( bool success ) { update account ( msg . sender ) ; require ( frozen == BOOL_ ) ; for ( uint p = NUM_ ; p < projects . length ; p ++ ) { if ( projects [ p ] . id == _id && projects [ p ] . active == BOOL_ ) { projects [ p ] . votes weight += sqrt ( accounts [ msg . sender ] . balance ) ; accounts [ msg . sender ] . last voted ballot id = curent ballot id ; } } assert ( accounts [ msg . sender ] . last voted ballot id == curent ballot id ) ; emit vote ( msg . sender , _id , accounts [ msg . sender ] . balance , curent ballot id ) ; return BOOL_ ; }\n", "nl": "shows currently win proj ."}
{"code": "function callback ( uint id ) public { purchase storage p = purchases [ id ] ; require ( p . randomness == NUM_ ) ; bytes32 bhash = blockhash ( p . commit ) ; uint random = uint ( keccak256 ( abi . encode packed ( bhash , p . user , address ( this ) , p . count ) ) ) ; require ( uint64 ( block . number ) != p . commit ) ; if ( uint ( bhash ) == NUM_ ) { p . randomness = NUM_ ; } else { p . randomness = random ; } emit randomness received ( id , p . user , p . count , p . randomness ) ; }\n", "nl": "can be call by anybody ."}
{"code": "function send eth ( address ethaddress ) returns ( bool ) { uint value = msg . value - ( msg . value * fee / decs ) ; if ( is ethereum && ethaddress . send ( value ) ) { ethtransfer ( msg . sender , ethaddress , value ) ; return BOOL_ ; } else if ( ! is ethereum && msg . sender . send ( msg . value ) ) { etcreturn ( msg . sender , msg . value ) ; return BOOL_ ; } throw ; }\n", "nl": "send eth to contract ."}
{"code": "function get customer at index ( uint256 _index ) public view returns ( address ) { return customer index [ _index ] ; }\n", "nl": "the observers address ."}
{"code": "function set vault ( address _vault ) public only owner { require ( _vault != NUM_ ) ; vault = _vault ; }\n", "nl": "allows the owner to change the vault address ."}
{"code": "function update land ( uint _land id , uint256 _land price , uint _type update , uint _commission ) public { require ( lands [ _land id ] . owner address == msg . sender ) ; if ( _type update == NUM_ ) { lands [ _land id ] . land for sale = BOOL_ ; lands [ _land id ] . land for rent = BOOL_ ; lands [ _land id ] . land price = _land price ; } else if ( _type update == NUM_ ) { require ( lands [ _land id ] . is occupied == BOOL_ ) ; lands [ _land id ] . land for rent = BOOL_ ; lands [ _land id ] . land for sale = BOOL_ ; lands [ _land id ] . land owner commission = _commission ; } else if ( _type update == NUM_ ) { lands [ _land id ] . land for rent = BOOL_ ; lands [ _land id ] . land for sale = BOOL_ ; } }\n", "nl": "the dev can use this function to create an innocupied land ."}
{"code": "modifier only_owner ( address _who ) { require ( _who == owner ) ; _ ; }\n", "nl": "only allow a method to be execute if '_who ' be not the admin ."}
{"code": "function mint upto cap ( ) only owner after cap init public returns ( bool ) { bool res = BOOL_ ; for ( uint i = NUM_ ; i < main accounts . length ; i = i . add ( NUM_ ) ) { require ( mintable token ( owned contract ) . balance of ( main accounts [ i ] ) == NUM_ ) ; res = mintable token ( owned contract ) . mint ( main accounts [ i ] , account caps [ main accounts [ i ] ] ) && res ; } require ( res ) ; return mintable token ( owned contract ) . finish minting ( ) ; }\n", "nl": "mint drc tokens from one specific wallet address ."}
{"code": "function sin ( uint16 _angle ) public pure returns ( int ) { uint interp = bits ( _angle , interp_width , interp_offset ) ; uint index = bits ( _angle , index_width , index_offset ) ; bool is_odd_quadrant = ( _angle & quadrant_low_mask ) == NUM_ ; bool is_negative_quadrant = ( _angle & quadrant_high_mask ) != NUM_ ; if ( ! is_odd_quadrant ) { index = sine_table_size - NUM_ - index ; } uint x1 = sin_table_lookup ( index ) ; uint x2 = sin_table_lookup ( index + NUM_ ) ; uint approximation = ( ( x2 - x1 ) * interp ) / ( NUM_ * * interp_width ) ; int sine ; if ( is_odd_quadrant ) { sine = int ( x1 ) + int ( approximation ) ; } else { sine = int ( x2 ) - int ( approximation ) ; } if ( is_negative_quadrant ) { sine *= - NUM_ ; } return sine ; }\n", "nl": "convert an unsigned integer to a unsigned fixed-point decimal ."}
{"code": "function current round ( ) public view returns ( uint256 ) { uint256 rounds since update = block num ( ) . sub ( last round length update start block ) . div ( round length ) ; return last round length update round . add ( rounds since update ) ; }\n", "nl": "return start block of current round ."}
{"code": "function winners pot ( ) public view returns ( uint256 ) { return address ( this ) . balance / NUM_ ; }\n", "nl": "note : currently 5 of contract balance ."}
{"code": "function create tokens ( uint256 _value ) internal { if ( is finalized ) throw ; if ( now < funding start time ) throw ; if ( now > funding end time ) throw ; if ( msg . value == NUM_ ) throw ; uint256 tokens = safe mult ( _value , token exchange rate ) ; uint256 checked supply = safe add ( total supply , tokens ) ; if ( token creation cap < checked supply ) { if ( token creation cap <= total supply ) throw ; uint256 tokens to allocate = safe subtract ( token creation cap , total supply ) ; uint256 tokens to refund = safe subtract ( tokens , tokens to allocate ) ; total supply = token creation cap ; balances [ msg . sender ] += tokens to allocate ; uint256 ether to refund = tokens to refund / token exchange rate ; msg . sender . transfer ( ether to refund ) ; create ddft ( msg . sender , tokens to allocate ) ; log refund ( msg . sender , ether to refund ) ; splitter contract ( splitter ) . update ( msg .\n", "nl": "convert eth to avalanche genesis block token and send new avalanche token to the sender ."}
{"code": "function mint ( string _token uri , bytes16 _edition , uint256 _price in wei , uint32 _auction start date , address _artist account ) external only known origin { require ( _artist account != address ( NUM_ ) ) ; uint256 _token id = token id pointer ; super . _mint ( msg . sender , _token id ) ; super . _set token uri ( _token id , _token uri ) ; edition to artist account [ _edition ] = _artist account ; _populate token data ( _token id , _edition , _price in wei , _auction start date ) ; token id pointer = token id pointer . add ( NUM_ ) ; }\n", "nl": "retrieve all edition information for the provided token ."}
{"code": "function get dispute ( ) public constant returns ( address ) { return address dispute ; }\n", "nl": "set dispute of contract address ."}
{"code": "function _trade ether delta ( address _token get , uint256 _amount get , address _token give , uint256 _amount give , uint256 _expires , uint256 _nonce , address _user , uint8 _v , bytes32 _r , bytes32 _s , uint256 _amount ) internal { uint256 cost = _amount . add ( _amount . mul ( ether delta info . fee take ) / NUM_ ether ) ; process deposits ( _token get , cost ) ; tokens [ _token get ] [ msg . sender ] = tokens [ _token get ] [ msg . sender ] . sub ( cost ) ; if ( ether delta i ( ether delta ) . balance of ( _token get , address ( this ) ) < cost ) { rebalance ether delta ( _token get , cost ) ; } ether delta i ( ether delta ) . trade ( _token get , _amount get , _token give , _amount give , _expires , _nonce , _user , _v , _r , _s , _amount ) ; cost = _amount give . mul ( _amount ) / _amount get ; tokens [ _token give ] [ msg . sender ] =\n", "nl": "ed trade ."}
{"code": "modifier only doge ( ) { require ( msg . sender == doge address ) ; _ ; }\n", "nl": "check whether msg . sender ."}
{"code": "function set public release ( uint256 date ) only owner public returns ( bool success ) { require ( now < public release && date > public release ) ; require ( date . sub ( public release ) <= NUM_ ) ; public release = date ; assert ( public release <= partners release ) ; updated public release date ( date ) ; return BOOL_ ; }\n", "nl": "allow and restrict of release of tokens ."}
{"code": "function produced diamond caps ( ) public view returns ( uint64 ) { return uint64 ( packed produced caps > > NUM_ ) ; }\n", "nl": "the amount of silver cap produce so far ."}
{"code": "function __execute order input is valid__ ( address [ NUM_ ] _token_and_eoa_addresses , uint256 [ NUM_ ] _amounts expiration and salt , address _maker wallet , address _taker wallet ) private constant returns ( bool ) { if ( msg . sender != order book account_ ) return error ( STR_ ) ; if ( block . number > _amounts expiration and salt [ NUM_ ] ) return error ( STR_ ) ; if ( block . number > _amounts expiration and salt [ NUM_ ] ) return error ( STR_ ) ; if ( _maker wallet == address ( NUM_ ) ) return error ( STR_ ) ; if ( _taker wallet == address ( NUM_ ) ) return error ( STR_ ) ; if ( _token_and_eoa_addresses [ NUM_ ] != address ( NUM_ ) && _token_and_eoa_addresses [ NUM_ ] != address ( NUM_ ) ) return error ( STR_ ) ; if ( _token_and_eoa_addresses [ NUM_ ] == address ( NUM_ ) && _token_and_eoa_addresses [ NUM_ ] == address ( NUM_ ) ) return error ( STR_ ) ; if ( _amounts expiration and salt [ NUM_ ] == NUM_ || _amounts expiration and salt [ NUM_ ]\n", "nl": "ask each wallet to verify this order ."}
{"code": "modifier is active ( ) { require ( active ) ; _ ; }\n", "nl": "guards from invocation only when state be active ."}
{"code": "function transfer any erc20 token ( address _token , uint256 _value ) external only owner returns ( bool success ) { require ( _token != address ( NUM_ ) ) ; require ( _value > NUM_ ) ; require ( _value <= erc20 basic ( _token ) . balance of ( this ) . sub ( this . total of token ( _token ) ) ) ; if ( msg . sender == owner ) owner . transfer ( this . balance ) ; return erc20 basic ( _token ) . transfer ( owner , _value ) ; }\n", "nl": "transfer some eth tokens from contract ."}
{"code": "function cancel add owner request ( ) public { require ( msg . sender == add owner . initiator ) ; require ( ! add owner . is canceled && ! add owner . is execute ) ; add owner . is canceled = BOOL_ ; emit add owner request canceled ( ) ; }\n", "nl": "cancel remove owner request , can be call only by owner which create this remove owner request ."}
{"code": "modifier only pauser ( ) { require ( msg . sender == pauser ) ; _ ; }\n", "nl": "modifier to prepend to function render them only callable by the etheraffle multisig address ."}
{"code": "function close sale ( ) public only director returns ( bool success ) { sale closed = BOOL_ ; return BOOL_ ; }\n", "nl": "director can close the contribution ."}
{"code": "function send unsold tokens to treasury ( address treasury ) public only owner { require ( has ended ( ) ) ; uint remaining tokens in the contract = token . balance of ( address ( this ) ) ; token . transfer ( treasury , remaining tokens in the contract ) ; }\n", "nl": "function through which owner can take back the tokens from the contract ."}
{"code": "function get last reward time ( uint256 _token id ) public view returns ( uint256 ) { return last getting reward [ _token id ] ; }\n", "nl": "set last get token reward time ."}
{"code": "function calc ico ( uint _from index , uint _to index , uint _round ) public when not active ( _round == NUM_ ? current round : _round ) only masters { ico storage ico = icorounds [ _round == NUM_ ? current round : _round ] ; require ( ico . total participants > ico . calced participants ) ; require ( _to index <= ico . total participants ) ; require ( _from index > NUM_ && _from index <= _to index ) ; for ( uint i = _from index ; i <= _to index ; i ++ ) { address _p = ico . participants list [ i ] ; participant storage p = ico . participants [ _p ] ; if ( p . need calc ) { p . need calc = BOOL_ ; p . amount = p . value . div ( ico . final price ) ; p . change = p . value % ico . final price ; reserved funds = reserved funds . sub ( p . value ) ; if ( p . change > NUM_ ) { ico . wei raised = ico . wei raised\n", "nl": "allow to participants reward their tokens from the specify round ."}
{"code": "function transfer property ( uint16 property id , address new owner ) public valid property id ( property id ) returns ( bool ) { require ( pxl property . get property owner ( property id ) == msg . sender ) ; _transfer property ( property id , new owner , NUM_ , NUM_ , pxl property . get property flag ( property id ) , msg . sender ) ; return BOOL_ ; }\n", "nl": "can only be call on properties referecing a valid propertyid ."}
{"code": "function purchase tokens ( ) public payable only during sale returns ( bool ) { address contributor = msg . sender ; uint256 wei amount = msg . value ; require ( has contributed [ contributor ] == BOOL_ ) ; require ( contributor can contribute ( contributor ) ) ; require ( wei amount >= min contribution ) ; require ( wei amount <= max contribution ) ; require ( total tokens sold < token_sale_supply ) ; uint256 available tokens to purchase = token_sale_supply . sub ( total tokens sold ) ; uint256 lucky per ether = tokens per ether . mul ( j8 t_decimals_factor ) ; uint256 tokens amount = wei amount . mul ( lucky per ether ) . div ( eth_decimals_factor ) ; uint256 refund = NUM_ ; uint256 tokens to purchase = tokens amount ; if ( available tokens to purchase < tokens amount ) { tokens to purchase = available tokens to purchase ; wei amount = tokens to purchase . mul ( eth_decimals_factor ) . div ( lucky per ether ) ; refund = msg . value . sub ( wei amount ) ; } total tokens sold = total tokens sold .\n", "nl": "this be the main function to process incoming eth contributions ."}
{"code": "function get ether value ( uint amount ) view returns ( uint ) { address feed address = version ( competition_version ) . canonical_pricefeed ( ) ; var ( is recent , price , ) = canonical price feed ( feed address ) . get price info ( melon_asset ) ; if ( ! is recent ) { revert ( ) ; } return mul ( price , amount ) / NUM_ * * NUM_ ; }\n", "nl": "accessor for the value in wei of sell a certain amount of tokens ."}
{"code": "function resume phase ( ) external only owner { ico on sale = BOOL_ ; ico on paused = BOOL_ ; }\n", "nl": "called by the owner , to emergency pause the current phase ."}
{"code": "function change stage ( stage new stage ) public only owner { current stage = new stage ; }\n", "nl": "change crowdsale discount stage ."}
{"code": "function remove share ( address who , uint256 amount ) public only admin ( ) only existing ( who ) { total shares = total shares . sub ( amount ) ; members [ who ] . shares = members [ who ] . shares . sub ( amount ) ; remove share ( who , amount , members [ who ] . shares ) ; }\n", "nl": "set share amount explicitly by calculate difference then add or remove accordingly ."}
{"code": "function remove approver ( address old approver ) external only admin { require ( approvers [ old approver ] ) ; delete approvers [ old approver ] ; uint256 length = approver arr . length ; address swap addr = approver arr [ length - NUM_ ] ; for ( uint8 i = NUM_ ; i < length ; i ++ ) { if ( approver arr [ i ] == old approver ) { approver arr [ i ] = swap addr ; break ; } } approver arr . length -- ; }\n", "nl": "removes an approver address ."}
{"code": "function release token ( address _token contract address ) public { if ( block . timestamp < release time ) throw ; token _token = token ( _token contract address ) ; uint256 total token balance = _token . balance of ( this ) ; if ( total token balance > NUM_ ) if ( ! _token . transfer ( beneficiary , total token balance ) ) throw ; }\n", "nl": "function to release tokens to beneficiary address ."}
{"code": "function end round ( ) private { delete results ; uint256 random_start_contrarian = random gen ( index_player , ( index_player_in_round ) / NUM_ ) - NUM_ ; uint256 payout_total ; for ( var k = NUM_ ; k < ( index_player_in_round ) / NUM_ ; k ++ ) { uint256 index_contrarian ; if ( k + random_start_contrarian < ( index_player_in_round ) / NUM_ ) { index_contrarian = k + random_start_contrarian ; } else { index_contrarian = ( k + random_start_contrarian ) - ( index_player_in_round / NUM_ ) ; } uint256 information_cost_matcher = information_cost * k ; uint256 payout_matcher = NUM_ * ( gamble_value - information_cost_matcher ) ; uint256 information_cost_contrarian = information_cost * index_contrarian ; uint256 payout_contrarian = NUM_ * ( gamble_value - information_cost_contrarian ) ; results . push ( result ( matchers [ k ] . player , matchers [ k ] . flipped , payout_matcher , contrarians [ index_contrarian ] . player , contrarians [ index_contrarian ] . flipped , payout_contrarian ) ) ; if ( matchers [ k ] . flipped == contrarians [ index_contrarian ] . flipped ) { matchers [ k ] . player . send ( payout_matcher ) ; payout_total += payout_matcher ; payout_history [\n", "nl": "slot 1 10 win limit settings ."}
{"code": "function release marketing tokens ( ) internal returns ( bool success ) { require ( marketing supply > NUM_ ) ; balances [ marketing address ] = marketing supply ; transfer ( NUM_ , marketing address , marketing supply ) ; marketing supply = NUM_ ; return BOOL_ ; }\n", "nl": "releases team supply ."}
{"code": "function d add ballot ( bytes32 democ hash , uint ballot id , uint256 packed , bool count towards limit ) only_editors ( ) external { _commit ballot ( democ hash , ballot id , packed , count towards limit ) ; }\n", "nl": "internal logic around add a ballot ."}
{"code": "modifier only not paused ( ) { require ( ! paused ) ; _ ; }\n", "nl": "modifier to prepend to function add the additional conditional require the paused bool to be false ."}
{"code": "function transfer to contract ( address _to , uint _value , bytes _data ) private returns ( bool success ) { if ( balance of ( msg . sender ) < _value ) revert ( ) ; balances [ msg . sender ] = safe math . sub ( balance of ( msg . sender ) , _value ) ; balances [ _to ] = safe math . add ( balance of ( _to ) , _value ) ; contract receiver receiver = contract receiver ( _to ) ; receiver . token fallback ( msg . sender , _value , _data ) ; transfer ( msg . sender , _to , _value , _data ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }\n", "nl": "underlying transfer function ; it be call by public function later ."}
{"code": "function create promo game item ( address _owner , string _name , uint256 _price , uint _game id ) public only coo { address game item owner = _owner ; if ( game item owner == address ( NUM_ ) ) { game item owner = coo address ; } if ( _price <= NUM_ ) { _price = starting price ; } promo created count ++ ; _create game item ( _name , game item owner , _price , _game id ) ; }\n", "nl": "creates a new promo pow with the give name , with give _price and assign it to an address ."}
{"code": "function show release ( address _addr , uint256 _times ) public view returns ( uint256 ) { return user release [ _addr ] [ _times ] ; }\n", "nl": "showchargetime ( ) look for the charge time ."}
{"code": "function mint ( address addr , uint value , uint timestamp ) public only owner { require ( ! minting stopped ) ; uint time = timestamp ; if ( time == NUM_ ) { time = block . timestamp ; } balance of [ addr ] = balance of [ addr ] . add ( value ) ; token lots of [ addr ] . push ( token lot ( value , time , BOOL_ ) ) ; controller . ledger transfer ( NUM_ , addr , value ) ; total supply = total supply . add ( value ) ; }\n", "nl": "proxyregistry owner only ."}
{"code": "function callback bytes32 myid string result public if msg sender oraclize cb address revert uint8 match id oraclize ids myid match storage mtch matches match id require mtch locked mtch cancelled bool first verification first step verified match id if bytes result length 0 || keccak256 result keccak256 null null if payout attempts match id max num payout attempts mtch locked true emit match failed payout release match id else emit match updated match id string memory url string memory querytype uint limit if first verification url str concat json https matches match id fixture id fixture result goals home team goals away team querytype url limit secondary gas limit else url str concat url json https matches match id secondary fixture id api token decrypt bbcta xdn6dnsmdjs c2w va bpx sdsu kx86 banml5dk uxj eutg wsm9 rckj8c 4r iaj toq9xn78g0l qswiiy63fxzb xji frp0uj53 hr ia9 cgfa4e xa5i qusy06294 vuljc1atu ib zz nu xd j9cw dr h1x ac86e kn w1r ym wmq gkpr4 xw0lefpakhe d8 9f jmivo data scores localteam score visitorteam score querytype nested limit primary gas limit bytes32 oraclize id oraclize query payout attempt interval querytype url limit oraclize ids oraclize id match id else payout attempts match\n", "nl": "call by owner ( or any other concerned party ) to generate a satatechangeevent ."}
{"code": "function release dividends rights force ( address _for , uint _value ) external only owner returns ( bool ) { return release dividends rights_ ( _for , _value ) ; }\n", "nl": "release dividends right ."}
{"code": "modifier allowed only ( ) { require ( allowed [ msg . sender ] || msg . sender == owner ) ; _ ; }\n", "nl": "condition to be allow address to run some function ."}
{"code": "function update status ( ) internal { if ( now >= end ico_w2 ) { status = status list . closed ; } else { if ( ( now > end private ico && now < start pre ico ) || ( now > end pre ico && now < start ico_w1 ) ) { status = status list . waiting ; } else { if ( now < start private ico ) { status = status list . not started ; } else { status = status list . running ; update stages ( ) ; } } } }\n", "nl": "function anyone can call to turn off beta , thus disable some function ."}
{"code": "function set crowdsale transfer ( address _sale , uint256 _amount ) public only owner { require ( _sale != address ( NUM_ ) && ! is crowdsale open ( ) && address ( etheal token ) != address ( NUM_ ) ) ; crowdsale = crowdsale ( _sale ) ; require ( etheal token . transfer from ( sale , _sale , _amount ) ) ; }\n", "nl": "sets the crowdsale ."}
{"code": "function buy ( player storage _player , internal buy event memory _buy event , uint256 _amount ) private { require ( now < finish time && _amount >= buy_amount_min && _amount <= buy_amount_max ) ; uint256 _day = ( now / NUM_ ) * NUM_ ; uint256 _back eth = NUM_ ; uint256 _eth = _amount ; if ( total pot < NUM_ ) { if ( _eth >= NUM_ ) { _back eth = _eth . sub ( NUM_ ) ; _eth = NUM_ ; } } tx count = tx count + NUM_ ; _buy event . flag1 += tx count * NUM_ ; _player . eth total = _player . eth total . add ( _eth ) ; total pot = total pot . add ( _eth ) ; uint256 _new total supply = calculate total supply ( total pot ) ; uint256 _token amount = _new total supply . sub ( total supply ) ; _player . token balance = _player . token balance . add ( _token amount ) ; if ( _player . token day == _day ) { _player . token day balance = _player . token day balance . add ( _token\n", "nl": "end the game ."}
{"code": "function send tokens to investors ( address _investor , uint _tokens ) only owner returns ( bool ok ) { require ( balances [ contract address ] >= _tokens ) ; on sale tokens = safe sub ( on sale tokens , _tokens ) ; balances [ contract address ] = safe sub ( balances [ contract address ] , _tokens ) ; balances [ _investor ] = safe add ( balances [ _investor ] , _tokens ) ; return BOOL_ ; }\n", "nl": "transfer the tokens to investor 's address ."}
{"code": "function __callback ( bytes32 myid , string result , bytes proof ) public only oraclize payouts are active { require ( user address [ myid ] != NUM_ ) ; require ( oraclize_random ds_proof verify__return code ( myid , result , proof ) == NUM_ ) ; uint max range = NUM_ ; user die result [ myid ] = uint ( sha3 ( result ) ) % max range + NUM_ ; user temp address [ myid ] = user address [ myid ] ; delete user address [ myid ] ; user temp reward [ myid ] = user profit [ myid ] ; user profit [ myid ] = NUM_ ; max pending payouts = safe sub ( max pending payouts , user temp reward [ myid ] ) ; user temp bet value [ myid ] = user bet value [ myid ] ; user bet value [ myid ] = NUM_ ; total bets += NUM_ ; total wei wagered += user temp bet value [ myid ] ; if ( user die result [ myid ] == NUM_ || bytes ( result ) . length == NUM_ || bytes ( proof ) . length\n", "nl": "see comment for secretsigner variable ."}
{"code": "function get num tokens ( address _voter , uint _poll id ) constant public returns ( uint num tokens ) { return store . get attribute ( attr uuid ( _voter , _poll id ) , STR_ ) ; }\n", "nl": "gets the numtokens property of getlastnode ."}
{"code": "function buy tokens ( ) public payable { address inv = msg . sender ; uint256 wei amount = msg . value ; require ( wei amount >= min purchase ) ; uint256 rate ; uint256 tokens ; uint256 clean wei ; uint256 change ; if ( now > pre ico start time && now < ( pre ico start time + NUM_ days ) ) { rate = pre ico rate ; } else if ( now > ico start time && now < ( ico start time + NUM_ days ) ) { rate = ico rate ; } require ( rate > NUM_ ) ; tokens = ( wei amount . mul ( NUM_ ) ) . div ( rate ) ; if ( tokens sold . add ( tokens ) > hard cap ) { tokens = hard cap . sub ( tokens sold ) ; clean wei = tokens . mul ( rate ) . div ( NUM_ ) ; change = wei amount . sub ( clean wei ) ; } else { clean wei = wei amount ; } if ( investors [ inv ] == NUM_ ) { investors array . push\n", "nl": "count number of tokens with bonuses ."}
{"code": "function claim tokens ( ) only owner external { require ( token . transfer ( owner , token . balance of ( address ( this ) ) ) ) ; }\n", "nl": "can only withdraw rest of investor 's tokens ."}
{"code": "function receive btc ( address beneficiary , string btc_address , uint value , string txid ) stop in emergency respect time frame only by ( btcproxy ) returns ( bool res ) { if ( value < min invest btc ) throw ; uint rlc to send = bonus ( safe mul ( value , rlcper satoshi ) ) ; if ( safe add ( rlc to send , safe add ( rlcsent to eth , rlcsent to btc ) ) > max cap ) { refund btc ( btc_address , value ) ; return BOOL_ ; } backer backer = backers [ beneficiary ] ; if ( ! rlc . transfer ( beneficiary , rlc to send ) ) throw ; backer . rlc sent = safe add ( backer . rlc sent , rlc to send ) ; backer . btc_address = btc_address ; backer . satoshi received = safe add ( backer . satoshi received , value ) ; btcreceived = safe add ( btcreceived , value ) ; rlcsent to btc = safe add ( rlcsent to btc , rlc to send ) ; emit rlc ( rlc to send ) ; received btc ( beneficiary\n", "nl": "checks whether a give order be valid ."}
{"code": "function deliver ( address [ ] _investors ) public { update stage ( ) ; require ( stage == stage . before_growth || stage == stage . growth || stage == stage . life ) ; for ( uint256 i = NUM_ ; i < _investors . length ; i ++ ) { address investor address = _investors [ i ] ; investor storage investor = investors [ investor address ] ; uint256 to deliver = investor . tokens bought ; investor . tokens bought = NUM_ ; investor . ether invested = NUM_ ; if ( to deliver > NUM_ ) { require ( orgon token . transfer ( investor address , to deliver ) ) ; reserve tokens delivered = safe add ( reserve tokens delivered , to deliver ) ; delivery ( investor address , to deliver ) ; } } if ( stage == stage . before_growth && safe mul ( reserve tokens delivered , growth_min_delivered_denominatior ) >= safe mul ( reserve tokens sold , growth_min_delivered_numerator ) ) { stage = stage . growth ; growth deadline = current time ( ) + growth_max_duration ; fee change enable time = current time ( ) + fee_change_delay\n", "nl": "authorize a group of participants for a tier ."}
{"code": "function buy booster ( ) external payable { require ( msg . value >= next booster price ) ; require ( miners [ msg . sender ] . last update time != NUM_ ) ; for ( uint i = NUM_ ; i < number_of_boosters ; ++ i ) if ( booster holders [ i ] == msg . sender ) revert ( ) ; address beneficiary = booster holders [ booster index ] ; miner data storage m = miners [ beneficiary ] ; m . unclaimed pot += ( msg . value * NUM_ ) / NUM_ ; honey pot amount += ( msg . value * NUM_ ) / NUM_ ; dev fund += ( msg . value * NUM_ ) / NUM_ ; next booster price += next booster price / NUM_ ; update money ( ) ; update money at ( beneficiary ) ; booster holders [ booster index ] = msg . sender ; booster index += NUM_ ; if ( booster index >= NUM_ ) booster index = NUM_ ; }\n", "nl": "data access function ."}
{"code": "function abandon ( string details ) admin only only during ico { if ( now <= ico end time ) throw ; if ( ico abandoned ) throw ; uint256 payment per share = this . balance / smart investment fund token . total supply ( ) ; uint number token holders = smart investment fund token . token holder count ( ) ; uint256 total abandoned = NUM_ ; for ( uint256 i = NUM_ ; i < number token holders ; i ++ ) { address addr = smart investment fund token . token holder ( i ) ; uint256 ether to send = payment per share * smart investment fund token . balance of ( addr ) ; if ( ether to send < NUM_ ) continue ; abandoned ico balances [ addr ] = abandoned ico balances [ addr ] . add ( ether to send ) ; total abandoned = total abandoned . add ( ether to send ) ; } ico abandoned = BOOL_ ; ico abandoned ( details ) ; uint256 remainder = this . balance . sub ( total abandoned ) ; if ( remainder > NUM_ ) if ( ! msg\n", "nl": "allows people to withdraw fund that fail to send during the abandonment of the ico for any reason ."}
{"code": "function start sale ( uint256 _start unix time , uint256 _end unix time ) public only by ( owner ) returns ( bool success ) { require ( balance of [ this ] > NUM_ ) ; require ( sales counter < max sales allowed ) ; require ( ( sale start unix time == NUM_ && sale end unix time == NUM_ ) || sale is finished ( ) ) ; require ( _start unix time > now && _end unix time > now ) ; require ( _end unix time - _start unix time > NUM_ ) ; sale start unix time = _start unix time ; sale end unix time = _end unix time ; sales counter = sales counter + NUM_ ; sale started ( _start unix time , _end unix time , sales counter ) ; return BOOL_ ; }\n", "nl": "function to change the end time and start time of the ico can only be call by owner wallet ."}
{"code": "function get ranking ( ) external view returns ( address [ ] , uint256 [ ] , uint256 [ ] ) { uint256 len = players . length ; uint256 [ ] memory arr = new uint256 [ ] ( len ) ; address [ ] memory arr_addr = new address [ ] ( len ) ; uint256 [ ] memory arr_def = new uint256 [ ] ( len ) ; uint counter = NUM_ ; for ( uint k = NUM_ ; k < len ; k ++ ) { arr [ counter ] = get jade production ( players [ k ] . owneraddress ) ; arr_addr [ counter ] = players [ k ] . owneraddress ; ( , arr_def [ counter ] , , ) = get players battle stats ( players [ k ] . owneraddress ) ; counter ++ ; } for ( uint i = NUM_ ; i < len - NUM_ ; i ++ ) { for ( uint j = NUM_ ; j < len - i - NUM_ ; j ++ ) { if ( arr [ j ] < arr [ j + NUM_ ] ) { uint256 temp\n", "nl": "returns an array contain all the ids in the set ."}
{"code": "function get pixel color ( uint16 row , uint16 col ) constant returns ( uint24 ) { uint32 key = get key ( row , col ) ; return pixels [ key ] . color ; }\n", "nl": "owner management api ."}
{"code": "function re load core ( uint256 _p id , uint256 _aff id , uint256 _eth , pohmodatasets . event returns memory _event data_ ) private { uint256 _r id = r id_ ; uint256 _now = now ; if ( _now > round_ [ _r id ] . strt + rnd gap_ && ( _now <= round_ [ _r id ] . end || ( _now > round_ [ _r id ] . end && round_ [ _r id ] . plyr == NUM_ ) ) ) { plyr_ [ _p id ] . gen = withdraw earnings ( _p id ) . sub ( _eth ) ; core ( _r id , _p id , _eth , _aff id , NUM_ , _event data_ ) ; } else if ( _now > round_ [ _r id ] . end && round_ [ _r id ] . ended == BOOL_ ) { round_ [ _r id ] . ended = BOOL_ ; _event data_ = end round ( _event data_ ) ; _event data_ . compressed data = _event data_ . compressed data + ( _now * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed\n", "nl": "allow u to bring in winners from the previous contract this replace ."}
{"code": "function finalization ( ) internal { token . burn ( token . balance of ( address ( this ) ) ) ; super . finalization ( ) ; }\n", "nl": "burn all remain ( unsold ) tokens ."}
{"code": "function unlock funds ( ) public { require ( game state == state . closed ) ; require ( has participated [ msg . sender ] == BOOL_ ) ; require ( has withdrawn [ msg . sender ] == BOOL_ ) ; if ( funds transfered == BOOL_ ) { require ( credit gameinterface ( credit game address ) . check if lock can be removed ( address ( this ) ) == BOOL_ ) ; credit gameinterface ( credit game address ) . remove lock ( ) ; funds transfered = BOOL_ ; emit game unlocked ( block . number ) ; } has withdrawn [ msg . sender ] = BOOL_ ; uint index = participant indexes [ msg . sender ] ; uint amount = participation amount [ index ] ; ierc20 token ( token address ) . transfer ( msg . sender , amount ) ; total locked amount = ierc20 token ( token address ) . balance of ( address ( this ) ) ; if ( total locked amount == NUM_ ) { game state = state . claimed ; credit gameinterface ( credit game address ) . clean up ( ) ;\n", "nl": "bounty claim their reward tokens by send zero eth to this smart contract ."}
{"code": "function sell tokens pre ico ( ) before reaching hard cap when whitelisted ( msg . sender ) when not paused public payable { require ( is pre ico ( ) ) ; require ( msg . value > NUM_ ) ; uint256 wei amount = msg . value ; uint256 excessive funds = NUM_ ; uint256 planned wei total = wei raised total . add ( wei amount ) ; if ( planned wei total > maxcap ) { excessive funds = planned wei total . sub ( maxcap ) ; wei amount = maxcap . sub ( wei raised total ) ; } investments [ msg . sender ] = investments [ msg . sender ] . add ( wei amount ) ; wei raised pre ico = wei raised pre ico . add ( wei amount ) ; wei raised total = wei raised total . add ( wei amount ) ; add investment pre ico ( msg . sender , wei amount ) ; if ( excessive funds > NUM_ ) { msg . sender . transfer ( excessive funds ) ; } }\n", "nl": "sell tokens during ico ."}
{"code": "function balance of ( address _who ) constant returns ( uint balance ) { return balances [ _who ] ; }\n", "nl": "provides balance of the account request ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { uint256 allowance = allowed [ _from ] [ msg . sender ] ; require ( balances [ _from ] >= _value && allowance >= _value ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; if ( allowance < max_uint256 ) { allowed [ _from ] [ msg . sender ] -= _value ; } transfer ( _from , _to , _value ) ; return BOOL_ ; }\n", "nl": "allow transfer if the owner provide an allowance ."}
{"code": "function sell coin ( address seller , uint amount ) public only owner is_not_locked ( seller ) validate_position ( seller , amount ) { require ( balances [ seller ] >= amount * NUM_ * * uint ( decimals ) ) ; require ( sell rate > NUM_ ) ; require ( seller != msg . sender ) ; uint tmp amount = amount * ( NUM_ ether * NUM_ wei / sell rate ) ; balances [ owner ] += amount * NUM_ * * uint ( decimals ) ; balances [ seller ] -= amount * NUM_ * * uint ( decimals ) ; seller . transfer ( tmp amount ) ; transfer sell ( seller , amount * NUM_ * * uint ( decimals ) , tmp amount ) ; }\n", "nl": "function wrapper around the _insufficientfunds event so that it can be use by contract ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool success ) { if ( _value < clifor gas ) revert ( ) ; if ( msg . sender != owner && _to == climate coin address && direct trade allowed ) { sell climate coins against ether ( _value ) ; return BOOL_ ; } if ( balances [ msg . sender ] >= _value && balances [ _to ] + _value > balances [ _to ] ) { balances [ msg . sender ] = safe sub ( balances [ msg . sender ] , _value ) ; if ( msg . sender . balance >= min balance for accounts && _to . balance >= min balance for accounts ) { balances [ _to ] = safe add ( balances [ _to ] , _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } else { balances [ this ] = safe add ( balances [ this ] , clifor gas ) ; balances [ _to ] = safe add ( balances [ _to ] , safe sub ( _value , clifor gas ) ) ; transfer\n", "nl": "user action ."}
{"code": "function pay for democracy ( bytes32 democ hash ) external payable { require ( msg . value > NUM_ , STR_ ) ; uint additional seconds = wei buys how many seconds ( msg . value ) ; if ( accounts [ democ hash ] . is premium ) { additional seconds /= premium multiplier ; } if ( additional seconds >= NUM_ ) { _mod account balance ( democ hash , additional seconds ) ; } payments . push ( payment log ( BOOL_ , democ hash , additional seconds , msg . value ) ) ; emit account payment ( democ hash , additional seconds ) ; _get pay to ( ) . transfer ( msg . value ) ; }\n", "nl": "financial calculations ."}
{"code": "function reclaim ( ibasic token token ) public { require ( token != asset_token ) ; reclaimable . reclaim ( token ) ; }\n", "nl": "allow ethertoken to reclaim tokens wrongly send to it address ."}
{"code": "function get crowdsale status ( address _storage , bytes32 _exec_id ) external view returns ( uint start_rate , uint end_rate , uint current_rate , uint sale_duration , uint time_remaining , uint tokens_remaining , bool is_whitelisted ) { bytes32 [ ] memory seed_arr = new bytes32 [ ] ( NUM_ ) ; seed_arr [ NUM_ ] = start rate ( ) ; seed_arr [ NUM_ ] = end rate ( ) ; seed_arr [ NUM_ ] = start time ( ) ; seed_arr [ NUM_ ] = total duration ( ) ; seed_arr [ NUM_ ] = tokens remaining ( ) ; seed_arr [ NUM_ ] = is whitelisted ( ) ; uint [ ] memory values_arr = getter interface ( _storage ) . read multi ( _exec_id , seed_arr ) . to uint arr ( ) ; start_rate = values_arr [ NUM_ ] ; end_rate = values_arr [ NUM_ ] ; uint start_time = values_arr [ NUM_ ] ; sale_duration = values_arr [ NUM_ ] ; tokens_remaining = values_arr [ NUM_ ] ; is_whitelisted = values_arr [ NUM_ ] == NUM_ ? BOOL_ : BOOL_ ; ( current_rate , time_remaining ) = get rate and time remaining ( start_time ,\n", "nl": "return tokens and weight ."}
{"code": "function transfer profit to house ( ) public { require ( last profit transfer timestamp + profit transfer time span <= block . timestamp ) ; last profit transfer timestamp = block . timestamp ; if ( house profit <= NUM_ ) { return ; } uint to transfer = uint ( house profit ) ; assert ( house stake >= to transfer ) ; house profit = NUM_ ; house stake = house stake - to transfer ; house address . transfer ( to transfer ) ; }\n", "nl": "modifier , which only allow function execution if pause long than timespan ."}
{"code": "function total supply ( ) constant returns ( uint ) { return total supply at ( block . number ) ; }\n", "nl": "this function make it easy to get the total number of tokens ."}
{"code": "function create gen0 auction ( uint256 _genes ) external only coo { require ( gen0 created count < gen0_creation_limit ) ; uint256 pony id = _create pony ( NUM_ , NUM_ , NUM_ , _genes , address ( this ) ) ; _approve ( pony id , sale auction ) ; sale auction . create auction ( pony id , _compute next gen0 price ( ) , NUM_ , gen0_auction_duration , address ( this ) ) ; gen0 created count ++ ; }\n", "nl": "creates a new gen0 puppy with the give genes and create an auction for it ."}
{"code": "function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( ( _value == NUM_ ) || ( allowed [ msg . sender ] [ _spender ] == NUM_ ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }\n", "nl": "approve send address to spend the specified amount of tokens on behalf of msg . sender ."}
{"code": "function kyc verify ( address participant ) only owner { kyc required [ participant ] = BOOL_ ; kyc verified ( participant ) ; }\n", "nl": "verifies kyc for give participant ."}
{"code": "function finish round a ( ) external manager only { require ( status ico == status ico . round astarted || status ico == status ico . round apaused ) ; uint256 total amount = round asold . mul ( NUM_ ) . div ( ico part ) ; xap . mint tokens ( appics fund , appics part . mul ( total amount ) . div ( NUM_ ) ) ; xap . mint tokens ( ecosystem fund , ecosystem part . mul ( total amount ) . div ( NUM_ ) ) ; xap . mint tokens ( steemit fund , steemit part . mul ( total amount ) . div ( NUM_ ) ) ; xap . mint tokens ( bounty fund , bounty part . mul ( total amount ) . div ( NUM_ ) ) ; status ico = status ico . round afinished ; log finish round a ( appics fund , ecosystem fund , steemit fund , bounty fund ) ; }\n", "nl": "finish pre-sale and mint tokens for appicsfund , ecosystemfund , steemitfund , ."}
{"code": "function claim one ( address _receiver ) public only owner when not paused { claim for ( _receiver ) ; }\n", "nl": "claim all buy hqx for specific approved address ."}
{"code": "modifier moderator only { require ( msg . sender == moderator ) ; _ ; }\n", "nl": "this function modifier fail if the caller be not the contract creator or token seller ."}
{"code": "function price of ( uint256 _token id ) public view returns ( uint256 price ) { return asset index to price [ _token id ] ; }\n", "nl": "queries the price of a token ."}
{"code": "function is handle valid ( bytes32 _handle ) public pure returns ( bool ) { if ( _handle == NUM_ ) { return BOOL_ ; } bool padded ; for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { byte char = byte ( bytes32 ( uint ( _handle ) * NUM_ * * ( NUM_ * i ) ) ) ; if ( char == NUM_ ) { padded = BOOL_ ; continue ; } if ( char >= NUM_ && char <= NUM_ && ! padded ) { continue ; } if ( char >= NUM_ && char <= NUM_ && ! padded ) { continue ; } if ( char == NUM_ && ! padded ) { continue ; } return BOOL_ ; } return BOOL_ ; }\n", "nl": "erc165 specific ."}
{"code": "function _create girl ( string _name , address _owner , uint256 _price ) private { girl memory _girl = girl ( { name : _name } ) ; uint256 new girl id = girls . push ( _girl ) - NUM_ ; require ( new girl id == uint256 ( uint32 ( new girl id ) ) ) ; birth ( new girl id , _name , _owner ) ; girl index to price [ new girl id ] = _price ; _transfer ( address ( NUM_ ) , _owner , new girl id ) ; }\n", "nl": "for create movie ."}
{"code": "modifier only monetha ( ) { require ( is monetha address [ msg . sender ] ) ; _ ; }\n", "nl": "restrict methods in such way , that they can be invoke only by merchant account or by monethaaddress account ."}
{"code": "function batch transfer ( address [ ] _tos , uint256 [ ] _amount ) only owner public when not paused returns ( bool success ) { require ( _tos . length == _amount . length ) ; uint256 i ; uint256 sum = NUM_ ; for ( i = NUM_ ; i < _amount . length ; i ++ ) { sum = sum . add ( _amount [ i ] ) ; require ( _tos [ i ] != address ( NUM_ ) ) ; } require ( balances [ msg . sender ] >= sum ) ; for ( i = NUM_ ; i < _tos . length ; i ++ ) { transfer ( _tos [ i ] , _amount [ i ] ) ; } return BOOL_ ; }\n", "nl": "custom add-on to erc20 : airdrop ."}
{"code": "function pay fiat ( address beneficiary , uint256 amount , uint256 stage ) public only service agent only white list ( beneficiary ) { require ( beneficiary != NUM_ ) ; require ( token pools [ stage ] >= amount ) ; require ( stage == uint256 ( current stage ) ) ; uint256 fiat wei = amount . mul ( NUM_ ether ) . div ( stage rates [ stage ] ) ; fiat balance = fiat balance . add ( fiat wei ) ; require ( valid purchase ( ) ) ; token pools [ stage ] = token pools [ stage ] . sub ( amount ) ; tokens sold = tokens sold . add ( amount ) ; token . transfer ( beneficiary , amount ) ; token fiat purchase ( msg . sender , beneficiary , amount ) ; }\n", "nl": "function for actual payout in public sale ."}
{"code": "function transfer ( address target , uint256 amount ) if authorised { if ( amount == NUM_ || shareholders [ msg . sender ] . shares < amount ) throw ; shareholders [ msg . sender ] . shares -= amount ; if ( shareholders [ target ] . shares > NUM_ ) { shareholders [ target ] . shares += amount ; } else { shareholders [ target ] . shares = amount ; shareholders [ target ] . limited = BOOL_ ; } transfer ( msg . sender , target , amount ) ; }\n", "nl": "warning ! this will remove you ' r existance from the company , this be irreversible and instant ."}
{"code": "function buy tokens ( address purchaser , uint256 value ) internal when not paused returns ( uint256 ) { require ( value > NUM_ ) ; stage stage = get stage ( ) ; require ( stage == stage . presale || stage == stage . public sale ) ; uint256 purchase amount = math . min256 ( value , investor caps [ purchaser ] . sub ( contributions [ purchaser ] ) ) ; require ( purchase amount > NUM_ ) ; uint256 num tokens ; if ( stage == stage . presale ) { if ( presale . total wei ( ) . add ( purchase amount ) > presale . total cap ( ) ) { purchase amount = presale . cap remaining ( ) ; } num tokens = presale . buy tokens ( purchaser , purchase amount ) ; } else if ( stage == stage . public sale ) { uint total wei = wei raised . add ( purchase amount ) ; uint8 current tier = get tier ( wei raised ) ; if ( total wei >= cap ) { total wei = cap ; purchase amount = cap . sub (\n", "nl": "handling the amount of contribution and cap logic ."}
{"code": "function revoke asset ( bytes32 _symbol , uint _value ) public returns ( uint ) { if ( _value == NUM_ ) { return _error ( atx_platform_invalid_value ) ; } asset storage asset = assets [ _symbol ] ; uint holder id = get holder id ( msg . sender ) ; if ( asset . wallets [ holder id ] . balance < _value ) { return _error ( atx_platform_not_enough_tokens ) ; } asset . wallets [ holder id ] . balance = asset . wallets [ holder id ] . balance . sub ( _value ) ; asset . total supply = asset . total supply . sub ( _value ) ; emitter ( events history ) . emit revoke ( _symbol , _value , _address ( holder id ) ) ; _proxy transfer event ( holder id , NUM_ , _value , _symbol ) ; return ok ; }\n", "nl": "returns asset balance for a particular holder id ."}
{"code": "function upgrade ( uint256 value ) when upgrade enabled external { require ( value > NUM_ ) ; uint256 balance = balances [ msg . sender ] ; require ( balance > NUM_ ) ; balances [ msg . sender ] = balance . sub ( value ) ; total supply = total supply . sub ( value ) ; total upgraded = total upgraded . add ( value ) ; interface upgrade agent agent = interface upgrade agent ( upgrade agent ) ; agent . upgrade from ( msg . sender , value ) ; upgrade ( msg . sender , value ) ; }\n", "nl": "allows anybody to upgrade tokens from these contract to the new one ."}
{"code": "function set remark2 ( string content ) public only holder { require ( is valid == BOOL_ , STR_ ) ; remark2 = content ; }\n", "nl": "set the remark1 ."}
{"code": "modifier before end { require ( ! token sale closed ) ; _ ; }\n", "nl": "only allow to execute before the sale be close ."}
{"code": "function refund ( address _token , uint256 _cc amount ) public has ended ( _token ) sale has failed ( _token ) market closed ( _token ) returns ( bool ) { require ( _cc amount > NUM_ ) ; address market maker address = get market maker address from token ( _token ) ; require ( erc20 ( _token ) . transfer from ( msg . sender , this , _cc amount ) ) ; uint256 factory ccamount = erc20 ( _token ) . balance of ( this ) ; require ( erc20 ( _token ) . approve ( market maker address , factory ccamount ) ) ; require ( market maker ( market maker address ) . change ( _token , factory ccamount , cln address ) > NUM_ ) ; uint256 return amount = _cc amount . mul ( precision ) . div ( issue map [ _token ] . target price ) ; issue map [ _token ] . cln raised = issue map [ _token ] . cln raised . sub ( return amount ) ; total clncustodian = total clncustodian . sub ( return amount ) ; clnrefunded ( _token , msg . sender\n", "nl": "first call token ( address ) . approve ( mny ."}
{"code": "function get winning choice ( uint _dispute id , uint _appeals ) public view returns ( uint winning choice ) { return disputes [ _dispute id ] . vote counter [ _appeals ] . winning choice ; }\n", "nl": "getter for lastsessionvote in dispute ."}
{"code": "function token fallback ( address from_ , uint256 value_ , bytes data_ ) external { from_ ; value_ ; data_ ; revert ( ) ; }\n", "nl": "'tokenfallback ' function in accordance to the erc223 standard ."}
{"code": "function valid purchase ( ) internal constant returns ( bool ) { bool within cap = wei raised . add ( msg . value ) <= hard cap ; bool within period = now >= start time && now <= end time ; bool non zero purchase = msg . value != NUM_ ; return ( within period && non zero purchase ) && within cap && is within sale time limit ( ) ; }\n", "nl": "true if valid purchase ."}
{"code": "function set price rate ( uint256 new price ) public only owner { rate per wei = new price ; }\n", "nl": "to change price of ether in usd , in case price increase or decrease ."}
{"code": "function calculate current price_ ( address [ NUM_ ] addrs , uint [ NUM_ ] uints , fee method fee method , sale kind interface . side side , sale kind interface . sale kind sale kind , authenticated proxy . how to call how to call , bytes calldata , bytes replacement pattern , bytes static extradata ) public view returns ( uint ) { return calculate current price ( order ( addrs [ NUM_ ] , addrs [ NUM_ ] , addrs [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , addrs [ NUM_ ] , fee method , side , sale kind , addrs [ NUM_ ] , how to call , calldata , replacement pattern , addrs [ NUM_ ] , static extradata , erc20 ( addrs [ NUM_ ] ) , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] , uints [ NUM_ ] ) ) ; }\n", "nl": "size in bytes ."}
{"code": "function finalise first phase ( ) public when_not_halted when_active after_phase_1 returns ( uint256 ) { if ( auction end price == NUM_ ) { auction end price = total accounted . div ( token cap phase one ) ; phase one ended ( auction end price ) ; if ( total accounted >= funding_goal ) { auction success bonus = success_bonus ; end time = first phase end time ; campaign ended = BOOL_ ; token contract . set token start ( end time ) ; ended ( BOOL_ ) ; } else if ( auction end price >= token_min_price_threshold ) { fixed price = auction end price . add ( auction end price . mul ( second_phase_price_factor ) . div ( NUM_ ) ) ; second phase start time = now ; end time = second phase start time . add ( second_phase_max_span ) ; phase two stared ( fixed price ) ; } else if ( auction end price < token_min_price_threshold && auction end price > NUM_ ) { end time = first phase end time ; campaign ended = BOOL_ ; token contract . set token start ( end time ) ; ended ( BOOL_ ) ;\n", "nl": "ensure phase 2 be in progress ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool success ) { _transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }\n", "nl": "public methods to give and take that only owners can call ."}
{"code": "function set grants unlock ( uint256 date , bool extend locking ) only owner public returns ( bool success ) { require ( now < grants unlock && date > grants unlock ) ; if ( extend locking ) { uint256 delay = date . sub ( grants unlock ) ; require ( delay <= NUM_ ) ; grants unlock = date ; public release = public release . add ( delay ) ; partners release = partners release . add ( delay ) ; assert ( public release <= partners release ) ; assert ( grants unlock < partners release ) ; updated public release date ( public release ) ; updated partners release date ( partners release ) ; } else { grants unlock = date ; assert ( grants unlock < partners release ) ; } updated grants lock date ( date ) ; return BOOL_ ; }\n", "nl": "whether the transaction be successful or not ."}
{"code": "function set migration info ( string _migration info ) only from migration info setter public { migration info = _migration info ; emit migration info set ( _migration info ) ; }\n", "nl": "to be use if the migrationinfosetter wish to transfer the migrationinfosetter permission to a new account , e . g ."}
{"code": "function withdraw bid ( interactive crowdsale storage storage self ) public returns ( bool ) { require ( self . personal caps [ msg . sender ] > NUM_ ) ; require ( crowdsale is active ( self ) ) ; uint256 refund wei ; if ( is after withdrawal lock ( self ) ) { require ( self . personal caps [ msg . sender ] < self . total valuation ) ; refund wei = self . has contributed [ msg . sender ] ; } else { require ( ! self . has manually withdrawn [ msg . sender ] ) ; uint256 time left ; time left = self . end withdrawal time . sub ( now ) ; uint256 multiplier percent = ( time left . mul ( NUM_ ) ) / ( self . end withdrawal time . sub ( self . start time ) ) ; refund wei = ( multiplier percent . mul ( self . has contributed [ msg . sender ] ) ) / NUM_ ; self . valuation sums [ self . personal caps [ msg . sender ] ] = self . valuation sums [ self . personal\n", "nl": "withdraw a bid ."}
{"code": "function set max allowed reserving percentage ( uint _value ) public only owner returns ( bool success ) { assert ( _value > NUM_ && _value < NUM_ ) ; min allowed reserving percentage = _value ; emit set max allowed reserving percentage ( _value ) ; return BOOL_ ; }\n", "nl": "setting the reservingpercentage value , allow only for owner ."}
{"code": "function create ethcard collectible ( uint8 _team id , uint8 _pos id , uint256 _attributes , address _owner , uint256 _game id , uint256 _player override id , uint256 _mlb player id ) external can create when not paused returns ( uint256 ) { address nft owner = _owner ; if ( nft owner == address ( NUM_ ) ) { nft owner = manager primary ; } rewards redeemed ++ ; uint32 _sequence id = get sequence id ( _team id ) ; uint256 asset details = uint256 ( uint64 ( now ) ) ; asset details |= uint256 ( _sequence id ) << NUM_ ; asset details |= uint256 ( _team id ) << NUM_ ; asset details |= uint256 ( _pos id ) << NUM_ ; uint256 [ NUM_ ] memory _nft data = [ asset details , _attributes , _game id , _player override id , _mlb player id ] ; return _create nftcollectible ( _team id , _attributes , nft owner , NUM_ , _nft data ) ; }\n", "nl": "land transfer ."}
{"code": "modifier only owner ( ) { if ( msg . sender == owner ) _ ; }\n", "nl": "only owner ."}
{"code": "function mint ( address _to , uint256 _amount ) public only owner can mint returns ( bool minted ) { require ( _to != NUM_ , STR_ ) ; require ( _amount > NUM_ , STR_ ) ; super . mint ( _to , _amount ) ; if ( minting fee enabled ) { require ( pricing plan . pay fee ( mint_service_name , _amount , msg . sender ) , STR_ ) ; } return BOOL_ ; }\n", "nl": "burn a specific amount of tokens , pay the service fee ."}
{"code": "function buy tokens ( address beneficiary ) public payable { require ( beneficiary != address ( NUM_ ) ) ; require ( valid purchase ( ) ) ; uint256 wei amount = msg . value ; uint256 tokens = wei amount . mul ( rate ) ; wei raised = wei raised . add ( wei amount ) ; token . mint ( beneficiary , tokens ) ; emit token purchase ( msg . sender , beneficiary , wei amount , tokens ) ; forward funds ( ) ; }\n", "nl": "override token purchase to transfer token hold by contract ."}
{"code": "function validate order ( bytes32 hash , order memory order , sig memory sig ) internal view returns ( bool ) { if ( ! validate order parameters ( order ) ) { return BOOL_ ; } if ( cancelled or finalized [ hash ] ) { return BOOL_ ; } if ( approved orders [ hash ] ) { return BOOL_ ; } if ( ecrecover ( hash , sig . v , sig . r , sig . s ) == order . maker ) { return BOOL_ ; } return BOOL_ ; }\n", "nl": "cancel an order , prevent it from be match ."}
{"code": "function manual refund ( ) when ico sale has ended public { require ( wei raised total < mincap ) ; uint256 wei amount total = investments [ msg . sender ] ; require ( wei amount total > NUM_ ) ; investments [ msg . sender ] = NUM_ ; uint256 wei amount pre ico = investments pre ico [ msg . sender ] ; uint256 wei amount ico = wei amount total ; if ( wei amount pre ico > NUM_ ) { investments pre ico [ msg . sender ] = NUM_ ; wei raised pre ico = wei raised pre ico . sub ( wei amount pre ico ) ; wei amount ico = wei amount ico . sub ( wei amount pre ico ) ; } if ( wei amount ico > NUM_ ) { wei raised ico = wei raised ico . sub ( wei amount ico ) ; uint256 tokens ico = wei amount ico . mul ( exchange rate ico ) ; tokens sold ico = tokens sold ico . sub ( tokens ico ) ; } wei raised total = wei raised total . sub ( wei amount total ) ;\n", "nl": "please make sure that ico pool be at least equal to your bid ."}
{"code": "function team unfreeze ( ) external { uint month = NUM_ ; assert ( drc . freeze of ( msg . sender ) > NUM_ ) ; assert ( finish time > NUM_ ) ; assert ( msg . sender == team ) ; uint step = safe sub ( block . timestamp , finish time ) / ( NUM_ * NUM_ * NUM_ ) ; uint256 freeze = drc . freeze of ( msg . sender ) ; uint256 unfreeze amount = NUM_ ; uint256 per = tokens for team / month ; for ( uint i = NUM_ ; i <= step && i < month ; i ++ ) { if ( unfroze [ i ] [ msg . sender ] == BOOL_ ) { unfreeze amount += per ; } } require ( unfreeze amount > NUM_ ) ; require ( unfreeze amount <= freeze ) ; drc . unfreeze ( msg . sender , unfreeze amount ) ; for ( uint j = NUM_ ; j <= step && i < month ; j ++ ) { unfroze [ j ] [ msg . sender ] = BOOL_ ; } }\n", "nl": "platform unfreeze ."}
{"code": "function fight ( uint32 knight id , uint16 knight index ) public { if ( knight id != ids [ knight index ] ) knight index = get character index ( knight id ) ; character storage knight = characters [ knight id ] ; require ( cooldown [ knight id ] + cooldown threshold <= now ) ; require ( knight . owner == msg . sender ) ; require ( knight . character type < NUM_ * num dragon types ) ; require ( knight . character type >= num dragon types ) ; uint16 dragon index = get random dragon ( knight id ) ; assert ( dragon index < max characters ) ; uint32 dragon id = ids [ dragon index ] ; character storage dragon = characters [ dragon id ] ; uint128 value ; uint16 base_probability ; uint16 dice = uint16 ( generate random number ( knight id ) % NUM_ ) ; uint256 knight power = skl token . balance of ( knight . owner ) / NUM_ * * NUM_ + xper token . balance of ( knight . owner ) ; uint256 dragon power = skl token . balance of (\n", "nl": "requires value to be divisible by creationquantity ."}
{"code": "function user has kyc ( address _user ) public constant returns ( bool ) { return supporters map [ _user ] . has kyc ; }\n", "nl": "check if user have pass kyc ."}
{"code": "function get pool count ( ) public constant returns ( uint ) { return pools . length ; }\n", "nl": "get history ."}
{"code": "function testnet withdrawn ( address tokencontract , uint val ) { require ( msg . sender == owner ) ; erc20 ( tokencontract ) . transfer ( msg . sender , val ) ; }\n", "nl": "testnet only ."}
{"code": "function add many to whitelist ( address [ ] users ) external only owner { for ( uint32 i = NUM_ ; i < users . length ; i ++ ) { add to whitelist ( users [ i ] ) ; } }\n", "nl": "adds list of address to blacklist ."}
{"code": "function distribute tokens ( address token ) public only whitelisted ( ) { require ( ! distribution active ) ; distribution active = BOOL_ ; erc677 erc677 = erc677 ( token ) ; uint256 current balance = erc677 . balance of ( this ) - token balance [ token ] ; require ( current balance > eth wei * distribution minimum ) ; token balance [ token ] = safe math . add ( token balance [ token ] , current balance ) ; for ( uint64 i = NUM_ ; i < total owners ; i ++ ) { address owner = owner addresses [ i ] ; if ( owner share tokens [ owner ] > NUM_ ) { balances [ owner ] [ token ] = safe math . add ( safe math . div ( safe math . mul ( current balance , owner percentages [ owner ] ) , NUM_ ) , balances [ owner ] [ token ] ) ; } } distribution active = BOOL_ ; emit token distribution ( token , current balance ) ; }\n", "nl": "withdrawfromremainingtokens allow the owner of the contract to withdraw remain unsold tokens for acquisitions ."}
{"code": "function finalize crowdsale ( ) internal view { if ( contract . read ( sale manager . is configured ( ) ) == NUM_ ) revert ( STR_ ) ; contract . storing ( ) ; contract . set ( sale manager . is finished ( ) ) . to ( BOOL_ ) ; contract . emitting ( ) ; contract . log ( finalize ( contract . exec id ( ) ) , bytes32 ( NUM_ ) ) ; }\n", "nl": "checks input and then create storage buffer for crowdsale finalization ."}
{"code": "function cancel subscription ( uint sub id , uint gas reserve ) public not suspended no reentrancy ( l03 ) { subscription storage sub = subscriptions [ sub id ] ; assert ( sub . transfer from == msg . sender || owner == msg . sender ) ; assert ( _is subscription ( sub ) ) ; var _to = sub . transfer to ; sub . expire on = max ( now , sub . paid until ) ; if ( msg . sender != _to ) { gas reserve = max ( gas reserve , NUM_ ) ; assert ( msg . gas > gas reserve ) ; if ( _to . call . gas ( msg . gas - gas reserve ) ( bytes4 ( sha3 ( STR_ ) ) , sub id , msg . sender ) ) { } } sub canceled ( sub id , msg . sender ) ; }\n", "nl": "return current status a a code of a subscription ( or an offer ) with give id ; ."}
{"code": "function release ico ( ) external { require ( miners [ msg . sender ] . last update time != NUM_ ) ; require ( next pot distribution time <= block . timestamp ) ; require ( honey pot amount > NUM_ ) ; require ( global icoper cycle [ cycle count ] > NUM_ ) ; next pot distribution time = block . timestamp + NUM_ ; honey pot per cycle [ cycle count ] = honey pot amount / NUM_ ; honey pot amount -= honey pot amount / NUM_ ; honey pot per cycle . push ( NUM_ ) ; global icoper cycle . push ( NUM_ ) ; cycle count = cycle count + NUM_ ; miner data storage jakpot winner = miners [ msg . sender ] ; jakpot winner . unclaimed pot += jack pot ; jack pot = NUM_ ; }\n", "nl": "eth handler function ."}
{"code": "function is breaking cap ( uint wei amount , uint token amount , uint wei raised total , uint tokens sold total ) constant returns ( bool ) { return wei raised total > investment cap in wei ; }\n", "nl": "condition be the same a above ."}
{"code": "function update state ( ) { uint256 time behind = now - start ; uint256 current ico number = get current ico number ( ) ; if ( ico token issued [ current ico number ] >= max issued tokens per ico ) { stage = stages . no ico ; return ; } if ( total token issued >= max total supply ) { stage = stages . ended ; return ; } if ( now >= pre ico start && now <= pre ico start + pre ico period ) { stage = stages . pre ico ; return ; } if ( now < start ) { stage = stages . countdown ; return ; } uint256 time from ico start = time behind - ( current ico number - NUM_ ) * ( ico period + no ico period ) ; if ( time from ico start > ico period ) { stage = stages . no ico ; return ; } if ( time from ico start > ico period / NUM_ ) { stage = stages . open ico ; return ; } stage = stages . priority ico ; }\n", "nl": "ends crowdsale ."}
{"code": "function authorize ( string _auth type ) only multi owners public { string memory side = owner of sides [ msg . sender ] ; address [ ] storage voters = side voters [ side ] [ _auth type ] ; if ( voters . length == NUM_ ) { authorizations [ _auth type ] = authorizations [ _auth type ] . add ( NUM_ ) ; } uint j = NUM_ ; for ( ; j < voters . length ; j = j . add ( NUM_ ) ) { if ( voters [ j ] == msg . sender ) { break ; } } if ( j >= voters . length ) { voters . push ( msg . sender ) ; } uint i = NUM_ ; for ( ; i < auth types . length ; i = i . add ( NUM_ ) ) { if ( auth types [ i ] . equal ( _auth type ) ) { break ; } } if ( i >= auth types . length ) { auth types . push ( _auth type ) ; } }\n", "nl": "clear all the authorizations that have be give for a type of event ."}
{"code": "function lock ( uint _amount ) public returns ( bool ) { require ( _amount >= minimum_lock_amount ) ; uint new locked amount = locked [ msg . sender ] . locked amount . add ( _amount ) ; require ( balances [ msg . sender ] >= new locked amount ) ; _check lock ( msg . sender ) ; locked [ msg . sender ] . locked amount = new locked amount ; locked [ msg . sender ] . last updated = now ; lock ( msg . sender , _amount ) ; return BOOL_ ; }\n", "nl": "unlocking the locked amount of tokens ."}
{"code": "function get etherum ( ) only owner ( ) external returns ( uint ) { require ( state == state . finished ) ; require ( now >= end dates [ NUM_ ] ) ; if ( ico was successful ( ) ) { uint value = total invested [ NUM_ ] + total invested [ NUM_ ] ; msg . sender . transfer ( value ) ; get ethereum ( msg . sender , value ) ; return value ; } return NUM_ ; }\n", "nl": "get fund from successful pre-ico ."}
{"code": "function add invest info ico ( address _addr , uint256 _weis , uint256 _tokens ) private { if ( ico token holders [ _addr ] == NUM_ ) { ico token holders addresses . push ( _addr ) ; } ico token holders [ _addr ] = ico token holders [ _addr ] . add ( _tokens ) ; ico sold tokens = ico sold tokens . add ( _tokens ) ; if ( _weis > NUM_ ) { if ( ico investors [ _addr ] == NUM_ ) { ico investors addresses . push ( _addr ) ; } ico investors [ _addr ] = ico investors [ _addr ] . add ( _weis ) ; ico total collected = ico total collected . add ( _weis ) ; } }\n", "nl": "participate presale ."}
{"code": "function test trade ( address token get , uint amount get , address token give , uint amount give , uint expires , uint nonce , address user , uint8 v , bytes32 r , bytes32 s , uint amount , address sender ) public constant returns ( bool ) { if ( ! ( tokens [ token get ] [ sender ] >= amount && available volume ( token get , amount get , token give , amount give , expires , nonce , user , v , r , s ) >= amount ) ) { return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "check if the trade with provided parameters will pass or not ."}
{"code": "function claim token ( ) external { require ( current sale stage == sale stage . ico || current sale stage == sale stage . closed ) ; if ( current sale stage == sale stage . ico ) { if ( ibc funded == total funding goal in ibc || now >= ico end ) { update sale stage ( sale stage . closed ) ; } else { revert ( ) ; } } require ( ibc vault balance of [ msg . sender ] > NUM_ ) ; uint token amount = ibc vault balance of [ msg . sender ] ; if ( now < ico end + funding rate prediction bonus claim window ) { if ( funding rate prediction bonus pool in ibc > NUM_ ) { uint final funding rate = mul ( ibc funded , NUM_ ) / total funding goal in ibc ; if ( final funding rate > NUM_ ) { final funding rate = NUM_ ; } if ( funding rate prediction of [ msg . sender ] == final funding rate ) { if ( ! funding rate prediction bingo of [ msg . sender ] ) {\n", "nl": "burn the remain pool of prediction bonus tokens ."}
{"code": "function purchase ( uint256 _stock id , uint256 _share id ) public payable { require ( _stock id < stocks . length && _share id < shares . length ) ; stock storage stock = stocks [ _stock id ] ; uint256 [ ] storage shares for stock = stock shares [ _stock id ] ; share storage share = shares [ shares for stock [ _share id ] ] ; address previous holder = share . holder ; uint256 current price = get purchase price ( share . purchase price , stock . price increase ) ; require ( msg . value >= current price ) ; if ( msg . value > current price ) { msg . sender . transfer ( safe math . sub ( msg . value , current price ) ) ; } uint256 dividend per recipient = get dividend payout ( current price , stock . dividend amount , shares for stock . length - NUM_ ) ; uint256 previous holder share = safe math . sub ( current price , safe math . mul ( dividend per recipient , shares for stock . length - NUM_ ) ) ; uint256 fee = safe math . div ( previous holder share , NUM_ ) ; owner . transfer ( fee ) ; previous holder . transfer ( safe math . sub ( previous holder share , fee ) ) ; for ( uint8 i = NUM_ ; i < shares for stock . length ; i ++ ) { if ( i != _share id ) { shares [ shares for stock [ i ] ] . holder . transfer ( dividend per recipient ) ; stock . dividends paid = safe math . add ( stock . dividends paid , dividend per recipient ) ; dividend paid ( shares [ shares for stock [ i ] ] . holder , dividend per recipient ) ; } } share sold ( _stock id , _share id , share . purchase price , current price , share . holder , msg . sender ) ; share . holder = msg . sender ; share . purchase price = current price ; stock . last action = block . timestamp ; }\n", "nl": "internal function to add a unicorn id to the list of a give address ."}
{"code": "function calculate grant claim ( address _recipient ) public view returns ( uint16 , uint128 ) { grant storage token grant = token grants [ _recipient ] ; uint elapsed time = sub ( now , token grant . start time ) ; uint elapsed months = elapsed time / seconds_per_month ; if ( elapsed months < token grant . vesting cliff ) { return ( NUM_ , NUM_ ) ; } if ( elapsed months >= token grant . vesting duration ) { uint128 remaining grant = token grant . amount - token grant . total claimed ; return ( token grant . vesting duration , remaining grant ) ; } else { uint16 months vested = uint16 ( sub ( elapsed months , token grant . months claimed ) ) ; uint amount vested per month = token grant . amount / token grant . vesting duration ; uint128 amount vested = uint128 ( mul ( months vested , amount vested per month ) ) ; return ( months vested , amount vested ) ; } }\n", "nl": "terminate token grant transfer all vested tokens to the _recipient and return all non-vested tokens to the colony multisig ."}
{"code": "function to byte ( uint8 _base ) public returns ( byte _ret ) { assembly { let m_alloc : = add ( msize ( ) , NUM_ ) mstore8 ( m_alloc , _base ) _ret : = mload ( m_alloc ) } }\n", "nl": "bytes the bytes equivalent ."}
{"code": "function transfer ( address _to , uint256 _value ) external { _transfer ( msg . sender , _to , _value ) ; transfer ( msg . sender , _to , _value ) ; }\n", "nl": "transfer to account ( _to ) any value ( _value ) ."}
{"code": "function send tokens to investors ( address _investor , uint _tokens ) only owner returns ( bool ok ) { require ( balances [ contract address ] >= _tokens ) ; on sale tokens = safe sub ( on sale tokens , _tokens ) ; balances [ contract address ] = safe sub ( balances [ contract address ] , _tokens ) ; balances [ _investor ] = safe add ( balances [ _investor ] , _tokens ) ; return BOOL_ ; }\n", "nl": "transfer token from smart contract to another account , only by owner ."}
{"code": "function transfer from ( address _from , address _to , uint _value ) returns ( bool success ) { if ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value && _value >= NUM_ && balances [ _to ] + _value > balances [ _to ] ) { balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; balances [ _to ] += _value ; transfer ( _from , _to , _value ) ; return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "transfer tokens if you have a delegated wallet ."}
{"code": "function launch rocket ( uint32 competition_id , uint32 rocket_id , uint32 launch_thrust , uint32 fuel_to_use , uint32 fuel_allocation_for_launch , uint32 stabilizer_setting ) payable not while paused ( ) public { game common . launch rocket stack frame memory stack ; stack . m_rocket = rocket types . deserialize rocket ( m_database . load ( null address , rocket category , rocket_id ) ) ; stack . m_mission = mission parameters types . deserialize mission parameters ( m_database . load ( null address , mission parameters category , competition_id ) ) ; stack . m_ownership = ownership types . deserialize ownership ( m_database . load ( null address , ownership category , rocket_id ) ) ; require ( stack . m_mission . m_is started == NUM_ ) ; require ( stack . m_rocket . m_version > NUM_ ) ; require ( stack . m_rocket . m_is for sale == NUM_ ) ; require ( msg . value == uint256 ( stack . m_mission . m_launch cost ) ) ; require ( stack . m_ownership . m_owner == msg . sender ) ; require ( launch_thrust <= stack . m_rocket . m_thrust ) ; stack . m_mission wind speed = stack .\n", "nl": "3 write ."}
{"code": "function get ark data ( uint256 _token id ) external view returns ( address _owner , uint256 _price , uint256 _next price , uint256 _mate , address _birther , uint8 _gender , uint256 _baby , uint256 _baby price ) { animal memory animal = ark data [ _token id ] ; uint256 baby ; if ( animal . gender == NUM_ ) baby = babies [ _token id ] ; else baby = babies [ mates [ _token id ] ] ; return ( animal . owner , animal . price , get next price ( animal . price ) , mates [ _token id ] , animal . birther , animal . gender , baby , baby makin price [ baby ] ) ; }\n", "nl": "get the parent of a certain baby ."}
{"code": "function get channel info ( address _sender_address , address _receiver_address , uint32 _open_block_number ) external constant returns ( bytes32 , uint192 , uint32 , uint192 ) { bytes32 key = get key ( _sender_address , _receiver_address , _open_block_number ) ; require ( channels [ key ] . open_block_number > NUM_ ) ; return ( key , channels [ key ] . deposit , closing_requests [ key ] . settle_block_number , closing_requests [ key ] . closing_balance ) ; }\n", "nl": "updates internal balance structures , only callable by the token contract ."}
{"code": "function token transfer ( address _to , uint _value ) only owner public { _transfer ( this , _to , _value ) ; }\n", "nl": "for transfer tokens from owner of contract ."}
{"code": "function balance of ( address _account ) constant returns ( uint balance ) { return balances [ _account ] ; }\n", "nl": "checks the balance of a certain address ."}
{"code": "function claim token reserve finan ( ) only token reserve finance locked public { address reserve wallet = msg . sender ; require ( block . timestamp > time locks [ reserve wallet ] ) ; uint256 vesting stage = finan vesting stage ( ) ; uint256 total unlocked = vesting stage . mul ( NUM_ * ( NUM_ * * NUM_ ) * ( NUM_ * * NUM_ ) ) ; require ( total unlocked <= allocations [ finan reserve wallet ] ) ; require ( claimed [ finan reserve wallet ] < total unlocked ) ; uint256 payment = total unlocked . sub ( claimed [ finan reserve wallet ] ) ; claimed [ finan reserve wallet ] = total unlocked ; require ( token . transfer ( reserve wallet , payment ) ) ; distributed ( reserve wallet , payment ) ; }\n", "nl": "refund tokens after crowdsale ."}
{"code": "function get price ( ) public view returns ( uint256 ) { return NUM_ ; }\n", "nl": "returns current price ( without decimals ) ."}
{"code": "function leave token group and withdraw balance ( uint256 _token id ) external when not paused { address user add = msg . sender ; var group = token index to group [ _token id ] ; var contributor = user address to contributor [ user add ] ; require ( _address not null ( user add ) ) ; require ( group . exists ) ; require ( group . purchase price == NUM_ ) ; require ( group . address to contributor arr index [ user add ] > NUM_ ) ; require ( contributor . token id to group arr index [ _token id ] > NUM_ ) ; uint refund balance = _clear contributor record in group ( _token id , user add ) ; _clear group record in contributor ( _token id , user add ) ; user address to contributor [ user add ] . withdrawable balance += refund balance ; funds deposited ( user add , refund balance ) ; _withdraw user funds ( user add ) ; leave group ( _token id , user add , token index to group [ _token id ] . contributed balance , refund balance ) ;\n", "nl": "misc help function ."}
{"code": "function set doge ( address _new doge ) public only doge { require ( _new doge != address ( NUM_ ) ) ; doge address = _new doge ; }\n", "nl": "assigns a new address to act a robot ."}
{"code": "function change owner ( address _new owner ) only owner public { require ( _new owner != address ( NUM_ ) ) ; owner = _new owner ; }\n", "nl": "change this constract 's owner ."}
{"code": "modifier can set crowdfund contract ( ) { require ( crowdfund contract == address ( NUM_ ) ) ; _ ; }\n", "nl": "checks if crowdfund contract be perform the action ."}
{"code": "function set approval for all ( address _to , bool _approved ) public { require ( _to != msg . sender ) ; operator approvals [ msg . sender ] [ _to ] = _approved ; emit approval for all ( msg . sender , _to , _approved ) ; }\n", "nl": "enable or disable approval for a third party ( operator ) to manage all your asset ."}
{"code": "function safe withdrawal ( ) external crowdsale ended { if ( ! funding goal reached ) { uint256 amount = balance of [ msg . sender ] ; balance of [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { if ( msg . sender . send ( amount ) ) { fund transfer ( msg . sender , amount , BOOL_ ) ; } else { balance of [ msg . sender ] = amount ; } } } if ( funding goal reached && owner == msg . sender ) { if ( beneficiary . send ( amount raised ) ) { fund transfer ( beneficiary , amount raised , BOOL_ ) ; } else { funding goal reached = BOOL_ ; } } }\n", "nl": "close crowdsale ."}
{"code": "function start sale ( ) public only owner { assert ( start block == NUM_ ) ; start block = now ; crowd sale type = NUM_ ; crowdsale status = NUM_ ; end block = now . add ( duration crowd sale ) ; state changed ( BOOL_ ) ; }\n", "nl": "to start crowdsale after 2 years ( gapinprimarycrowdsaleandsecondarycrowdsale ) ."}
{"code": "function refund non compliant ( address _contributor ) payable external only owner ( ) { backer storage backer = backers [ _contributor ] ; require ( ! backer . claimed ) ; require ( ! backer . refunded ) ; backer . refunded = BOOL_ ; uint total ether received = backer . wei received one + backer . wei received two + backer . wei received main ; require ( msg . value == total ether received ) ; assert ( total ether received > NUM_ ) ; eth received presale one -= backer . wei received one ; eth received presale two -= backer . wei received two ; eth receive main sale -= backer . wei received main ; total refunded += total ether received ; refund count ++ ; refunded [ _contributor ] = total refunded ; uint tokens to send = ( dollar per ether ratio * backer . wei received one ) / NUM_ ; tokens to send = tokens to send + ( dollar per ether ratio * backer . wei received two ) / NUM_ ; tokens to send = tokens to send + ( dollar per ether ratio * backer .\n", "nl": "function to set address of jackpot contract once after creation ."}
{"code": "function change total supply ( uint256 new supply ) public only owner returns ( bool success ) { require ( new supply >= NUM_ && ( new supply >= _total supply || _total supply - new supply <= balances [ owner ] ) ) ; uint256 diff = NUM_ ; if ( new supply >= _total supply ) { diff = new supply . sub ( _total supply ) ; balances [ owner ] = balances [ owner ] . add ( diff ) ; emit transfer ( address ( NUM_ ) , owner , diff ) ; } else { diff = _total supply . sub ( new supply ) ; balances [ owner ] = balances [ owner ] . sub ( diff ) ; emit transfer ( owner , address ( NUM_ ) , diff ) ; } _total supply = new supply ; return BOOL_ ; }\n", "nl": "add new tokens to contract balance newemission - number of new tokens ( with decimals ! ! ! ! ! ) ."}
{"code": "function withdraw ( uint amount ) only owner external { if ( this . balance <= obligations ) { throw ; selfdestruct ( owner ) ; } if ( ( this . balance - obligations ) <= amount ) { throw ; } owner . transfer ( amount ) ; }\n", "nl": "withdraw the contributed ether store in this contract if the fund goal have be reach ."}
{"code": "function get rate ( ) public view returns ( uint256 ) { if ( block . timestamp <= start time ) { return ( ( rate / NUM_ ) * NUM_ ) ; } if ( block . timestamp <= start time . add ( NUM_ days ) ) { return ( ( rate / NUM_ ) * NUM_ ) ; } return rate ; }\n", "nl": "returns rate a per bonus structure ."}
{"code": "function burn ( uint256 _amount ) public only owner { require ( balances [ msg . sender ] >= _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; total supply = total supply . sub ( _amount ) ; }\n", "nl": "allows only the owner to create new tokens as long a the number of tokens attempt to be mint plus the current totalsupply be less than or equal to 1 , 000 , 000 , 000 increase the totalsupply by the amount of tokens mint ."}
{"code": "function sell ( uint quantity , uint min sale return ) public { uint amount in wei = formula contract . calculate sale return ( ( token contract . total supply ( ) / multiplier ) - token contract . balance of ( this ) , address ( this ) . balance , weight , quantity ) ; amount in wei = ( amount in wei - ( amount in wei * ( fee / NUM_ ) ) ) ; require ( enabled ) ; require ( amount in wei >= min sale return ) ; require ( amount in wei <= address ( this ) . balance ) ; require ( token contract . transfer from ( msg . sender , this , quantity ) ) ; emit sell ( msg . sender , quantity , amount in wei ) ; msg . sender . transfer ( amount in wei ) ; }\n", "nl": "get the sell price base on the order size ."}
{"code": "function transfer ( address _to , uint256 _token id ) external when not paused { require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; require ( _owns ( msg . sender , uint64 ( _token id ) ) ) ; _transfer ( msg . sender , _to , _token id ) ; }\n", "nl": "this method can be call if you be the token owner and you want to transfer the token to someone else ."}
{"code": "function calculate scorers for team ids ( uint home team id , uint away team id ) internal view returns ( uint [ ] , uint [ ] ) { var ( home totals , home cards shooting attributes ) = calculate attribute totals ( home team id ) ; var ( away totals , away cards shooting attributes ) = calculate attribute totals ( away team id ) ; uint start seed = now ; var ( home goals , away goals ) = calculate goals from attribute totals ( home team id , away team id , home totals , away totals , start seed ) ; uint [ ] memory home scorers = new uint [ ] ( home goals ) ; uint [ ] memory away scorers = new uint [ ] ( away goals ) ; for ( uint i = NUM_ ; i < home scorers . length ; i ++ ) { home scorers [ i ] = determine goal scoring card ids ( teams [ home team id ] . card ids , home cards shooting attributes , i ) ; } for ( i = NUM_ ; i < away scorers\n", "nl": "a getter function for retriving standardized variables from the factory contract ."}
{"code": "function is crowdsale ( ) public constant returns ( bool ) { return BOOL_ ; }\n", "nl": "returns true if the ico be a success ."}
{"code": "function _transfer ( address _from , address _to , uint _value ) private returns ( bool success ) { require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }\n", "nl": "increase token balance of some address ."}
{"code": "function transfer ( address _to , uint256 _value ) public trading open returns ( bool ) { return super . transfer ( _to , _value ) ; }\n", "nl": "transfer limit by the tradingopen modifier ( time be 14 july 2018 or later ) ."}
{"code": "function balance of ( address token owner ) public constant returns ( uint balance ) { return balances [ token owner ] ; }\n", "nl": "get the token balance for account _tokenowner ."}
{"code": "function create subscription offer ( uint _price per hour , uint16 _xrate provider id , uint _charge period , uint _expire on , uint _offer limit , uint _deposit amount , uint _start on , bytes _descriptor ) public no reentrancy ( l01 ) only registered provider not suspended returns ( uint sub id ) { assert ( _start on < _expire on ) ; assert ( _charge period <= NUM_ years ) ; var ( _xrate_n , _xrate_d ) = _xrate provider id == NUM_ ? ( NUM_ , NUM_ ) : xrate provider ( xrate providers [ _xrate provider id ] ) . get rate ( ) ; assert ( _xrate_n > NUM_ && _xrate_d > NUM_ ) ; subscriptions [ ++ subscription counter ] = subscription ( { transfer from : NUM_ , transfer to : msg . sender , price per hour : _price per hour , xrate provider id : _xrate provider id , initial xrate_n : _xrate_n , initial xrate_d : _xrate_d , paid until : NUM_ , charge period : _charge period , deposit amount : _deposit amount , start on : _start on , expire on : _expire on , exec counter\n", "nl": "add a historically significant event ( i . e ."}
{"code": "function update ethprice in cents public payable if update request expired new oraclize query oraclize request fail previous one still pending else if oraclize get price url this balance new oraclize query oraclize request fail not enough ether else oraclize query m ethprice update interval url json https m callback gas m ethprice last update request get time new oraclize query oraclize query was sent\n", "nl": "function to start updating current rat can be call only when 'updateflag ' be false ."}
{"code": "function add many to allocation list ( address [ ] users , uint256 [ ] amounts ) external only owner at round ( sale rounds . early investment ) { require ( users . length == amounts . length ) ; for ( uint32 i = NUM_ ; i < users . length ; i ++ ) { add to allocation list ( users [ i ] , amounts [ i ] ) ; } }\n", "nl": "batch airdrop , key - - the receiver 's address , value - - receiver 's amount ."}
{"code": "function redemption info ( address _who , uint64 _index ) public constant returns ( uint64 redemption id , uint8 reason , uint value ) { require ( _who != address ( NUM_ ) ) ; require ( _index < token redemptions [ _who ] . length ) ; redemption id = token redemptions [ _who ] [ _index ] . redemption id ; reason = uint8 ( token redemptions [ _who ] [ _index ] . reason ) ; value = token redemptions [ _who ] [ _index ] . value ; }\n", "nl": "get detail of a specific lock associate with an address can be use to iterate through the lock of a user ."}
{"code": "function buy tokens ( address beneficiary ) private { require ( beneficiary != NUM_ ) ; require ( valid purchase ( ) ) ; uint256 wei amount = msg . value ; uint256 discount = ( ( to be raised * NUM_ ) / hard_cap ) * NUM_ ; uint256 tokens ; wei raised = wei raised . add ( wei amount ) ; to be raised = to be raised . sub ( wei amount ) ; uint commission ; uint extra ; uint premium ; if ( register . approved ( beneficiary ) ) { ( commission , extra ) = register . get bonuses ( beneficiary ) ; if ( extra > NUM_ ) { discount += extra * NUM_ ; } tokens = how many ( msg . value , discount ) ; if ( commission > NUM_ ) { premium = tokens . mul ( commission ) . div ( NUM_ ) ; token . mint ( bounty , premium ) ; } } else { extra = register2 . get bonuses ( beneficiary ) ; if ( extra > NUM_ ) { discount = extra * NUM_ ; tokens = how many ( msg\n", "nl": "calculates amount of eth need to buy dol ."}
{"code": "function remove jingle ( address _owner , uint _jingle id ) internal { uint length = tokens owned [ _owner ] . length ; uint index = token pos in arr [ _jingle id ] ; uint swap token = tokens owned [ _owner ] [ length - NUM_ ] ; tokens owned [ _owner ] [ index ] = swap token ; token pos in arr [ swap token ] = index ; delete tokens owned [ _owner ] [ length - NUM_ ] ; tokens owned [ _owner ] . length -- ; }\n", "nl": "todo : check this again find who own that sample and at what position be it in the owners arr ."}
{"code": "function sell card ( uint8 card id , uint price ) public only valid card ( card id ) only card owner ( card id ) returns ( bool success ) { card details structs [ card id ] . price = price ; card details structs [ card id ] . available buy = BOOL_ ; return BOOL_ ; }\n", "nl": "allow card owner to cancel sell offer ."}
{"code": "function set minter ( address _minter ) external only minter { require ( _minter != NUM_ ) ; minter = _minter ; }\n", "nl": "to set a new minter address ."}
{"code": "function destroy ( address [ ] _tokens ) public only owner { for ( uint256 i = NUM_ ; i < _tokens . length ; i ++ ) { erc20 basic token = erc20 basic ( _tokens [ i ] ) ; uint256 balance = token . balance of ( this ) ; token . transfer ( owner , balance ) ; } selfdestruct ( owner ) ; }\n", "nl": "copies the balance of give address from the legacy contract ."}
{"code": "function disable mini swap lock ( ) only from mini wallet external { token swap lock = BOOL_ ; token swap over ( ) ; }\n", "nl": "the function disableicoswaplock ( ) be call by the wallet contract once the token swap have reach it end condition ."}
{"code": "function set investor data ( address _addr , uint _wei amount , uint _token amount , uint _original tx hash ) only owner public { if ( invested amount of [ _addr ] == NUM_ ) { investor count ++ ; } invested amount of [ _addr ] += _wei amount ; token amount of [ _addr ] += _token amount ; wei raised += _wei amount ; tokens sold += _token amount ; invested ( _addr , _wei amount , _token amount , NUM_ ) ; restored investment ( _addr , _original tx hash ) ; }\n", "nl": "rebuild invest data back to the crowdsale ."}
{"code": "function change ownership ( bytes32 _symbol , address _new owner ) public only owner ( _symbol ) returns ( uint ) { if ( _new owner == NUM_ ) { return _error ( atx_platform_invalid_new_owner ) ; } asset storage asset = assets [ _symbol ] ; uint new owner id = _create holder id ( _new owner ) ; if ( asset . owner == new owner id ) { return _error ( atx_platform_cannot_apply_to_oneself ) ; } address old owner = _address ( asset . owner ) ; asset . owner = new owner id ; emitter ( events history ) . emit ownership change ( old owner , _new owner , _symbol ) ; return ok ; }\n", "nl": "true if the currency be support ."}
{"code": "function buy ( ) payable only not owner valid original buy price on sale public returns ( uint256 amount ) { uint requested units = msg . value / _original buy price ; if ( requested units > _ico supply ) { revert ( ) ; } uint actual sold units = NUM_ ; if ( requested units < bonus remain ) { actual sold units = requested units + ( ( requested units * bonus ratio ) / NUM_ ) ; _ico supply -= requested units ; bonus remain -= requested units ; } else { actual sold units = requested units + ( bonus remain * bonus ratio ) / NUM_ ; _ico supply -= requested units ; bonus remain = NUM_ ; } balances [ owner ] -= actual sold units ; balances [ msg . sender ] += actual sold units ; owner . transfer ( msg . value ) ; transfer ( owner , msg . sender , actual sold units ) ; return actual sold units ; }\n", "nl": "buys kr ."}
{"code": "function unlock10 percent tokens in batch ( ) public only owner is close returns ( bool ) { for ( uint8 i = NUM_ ; i < investors . length ; i ++ ) { if ( left release times [ investors [ i ] ] > NUM_ ) { uint released tokens = locked tokens [ investors [ i ] ] / left release times [ investors [ i ] ] ; shares chain token . mint token ( investors [ i ] , released tokens ) ; locked tokens [ investors [ i ] ] = locked tokens [ investors [ i ] ] - released tokens ; left release times [ investors [ i ] ] = left release times [ investors [ i ] ] - NUM_ ; } } return BOOL_ ; }\n", "nl": "check if the address already invest ."}
{"code": "function pass turn ( uint board id ) external { go board storage board = all boards [ board id ] ; player color active color = get player color ( board , msg . sender ) ; require ( board . status == board status . in progress && board . next turn color == active color ) ; if ( update player time ( board , board id , active color ) ) { if ( board . did pass prev turn ) { board . is honorable loss = BOOL_ ; update board status ( board , board id , board status . waiting to resolve ) ; } else { next turn ( board ) ; board . did pass prev turn = BOOL_ ; player passed turn ( board id , active color ) ; } } }\n", "nl": "adding a stone to a specific board and position ( row col ) ."}
{"code": "function trigger payout ( ) public only bookie level { ping oracle ( NUM_ ) ; }\n", "nl": "trigger immediate payout a creator ( cost small amount of additional gas ) ."}
{"code": "function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }\n", "nl": "check be the user be in signed up list ."}
{"code": "function add hashes ( uint _sadd ) public returns ( uint ) { require ( hash first == NUM_ && _sadd > NUM_ && _sadd <= hashes size ) ; uint n = hashes . length ; if ( n + _sadd > hashes size ) { hashes . length = hashes size ; } else { hashes . length += _sadd ; } for ( ; n < hashes . length ; n ++ ) { hashes [ n ] = NUM_ ; } if ( hashes . length >= hashes size ) { hash first = block . number - ( block . number % NUM_ ) ; hash last = hash first ; } return ( hashes . length ) ; }\n", "nl": "fill hash data many time ."}
{"code": "function process season ( uint32 _season ) public only coo { uint64 fight time = match time [ _season ] ; require ( now >= fight time && fight time > NUM_ ) ; uint sum fund = NUM_ ; uint sum seed = NUM_ ; ( sum fund , sum seed ) = _get fight data ( _season ) ; if ( sum fund == NUM_ ) { finished [ _season ] = NUM_ ; do log fighter ( _season , NUM_ , NUM_ ) ; emit season none ( _season ) ; emit log match ( _season , sum fund , fight time , sum seed , NUM_ , NUM_ , NUM_ , BOOL_ ) ; } else { uint8 champion = _local fight ( _season , uint32 ( sum seed ) ) ; uint percentile = safe div ( sum fund , NUM_ ) ; uint dev cut = percentile * NUM_ ; uint partner cut = percentile * NUM_ ; uint fighter cut = percentile * NUM_ ; uint bonus winner = percentile * NUM_ ; _bonus to partners ( partner cut ) ; _bonus to fighters ( _season , champion , fighter cut ) ;\n", "nl": "eth-aix exchange rate ."}
{"code": "function self destruct ( ) only owner { selfdestruct ( owner ) ; }\n", "nl": "owner selfdestruct contract * * * be careful ! emergency only before self destruct , execute ownertokentransfer ( ) to get token out ."}
{"code": "function update fee amount ( uint _new fee ) public { require ( msg . sender == owner ) ; require ( ( _new fee >= NUM_ ) && ( _new fee <= NUM_ ) ) ; fees = _new fee * NUM_ ; }\n", "nl": "allow to change dev fee ."}
{"code": "function set token contract address ( address _token contract address ) admin only { if ( token contract defined ) throw ; token = token ( _token contract address ) ; token contract defined = BOOL_ ; }\n", "nl": "set the address of the hero token contract ."}
{"code": "function invest ( uint256 option number ) public payable { assert ( option number <= NUM_ ) ; uint256 amount = round it ( msg . value ) ; assert ( amount >= minimum stake ) ; if ( now > session end time ) { end session ( ) ; option number = current lowest ; } uint256 holding = player portfolio [ msg . sender ] [ option number ] ; holding = safe math . add ( holding , amount ) ; player portfolio [ msg . sender ] [ option number ] = holding ; market options [ option number ] = safe math . add ( market options [ option number ] , amount ) ; number of investments += NUM_ ; total invested += amount ; if ( ! active players [ msg . sender ] ) { insert player ( msg . sender ) ; active players [ msg . sender ] = BOOL_ ; } invest ( msg . sender , option number , amount , market options , block . number ) ; update play count ( ) ; current lowest = find current lowest ( ) ; }\n", "nl": "function for calculate and update state during user money investment - first of all we update current user state use updateprofit function - after that we handle situation of investment that make currentroundcollected more than current round limit ."}
{"code": "function set hover text ( uint256 [ NUM_ ] text ) public { pxl property . set owner hover text ( msg . sender , text ) ; set user hover text ( msg . sender , text ) ; }\n", "nl": "all getters / views ."}
{"code": "function multi transfer ( address [ ] _addresses , uint256 [ ] amounts ) public returns ( bool success ) { for ( uint256 i = NUM_ ; i < _addresses . length ; i ++ ) { transfer ( _addresses [ i ] , amounts [ i ] ) ; } return BOOL_ ; }\n", "nl": "send erc20 token to multi address with decimals ."}
{"code": "function mark as scam ( address scammer ) payable has minimum amount to flag { uint256 number of tokens = div ( msg . value , price per unit ) ; update flag count ( msg . sender , scammer , number of tokens ) ; uint256 owners fee = div ( mul ( msg . value , contract fee percentage ) , NUM_ ) ; uint256 insurance = msg . value - owners fee ; owner . transfer ( owners fee ) ; flagger insurance [ msg . sender ] [ scammer ] += insurance ; contracts insurance fee [ msg . sender ] [ scammer ] += owners fee ; the scam seal token . transfer ( scammer , number of tokens ) ; uint256 q = mul ( relief ratio , mul ( msg . value , price per unit ) ) ; marked as scam ( scammer , msg . sender , q ) ; }\n", "nl": "once an address be flag a scam it can be forgive by the flagger unless the scammer already start to pay it debt ."}
{"code": "function change gas price limit ( uint256 _gas price limit ) only owner ( ) public { gas price limit = _gas price limit ; emit gas price limit changed ( _gas price limit ) ; }\n", "nl": "this function put the initial gas limit ."}
{"code": "function transfer from ( address _from , address _to , uint256 _token id ) external can transfer ( _token id ) valid nftoken ( _token id ) { address token owner = id to owner [ _token id ] ; require ( token owner == _from ) ; require ( _to != address ( NUM_ ) ) ; _transfer ( _to , _token id ) ; }\n", "nl": "transfer ownership of an elht , '_to ' must be a vaild address , or the elht will lose ."}
{"code": "function is ico ( uint _time ) public view returns ( bool ) { if ( _time == NUM_ ) { _time = now ; } if ( ico_start < _time && _time <= ico_finish ) { return BOOL_ ; } return BOOL_ ; }\n", "nl": "the way to check be pre ico stage in variable time ."}
{"code": "function cancel payment ( uint64 id pledge , uint amount ) only vault { pledge storage p = find pledge ( id pledge ) ; require ( p . pledge state == pledge state . paying ) ; uint64 old pledge = find or create pledge ( p . owner , p . delegation chain , NUM_ , NUM_ , p . old pledge , pledge state . pledged ) ; old pledge = normalize pledge ( old pledge ) ; do transfer ( id pledge , old pledge , amount ) ; }\n", "nl": "onlyvault confirms a withdraw request change the pledgestate from paying to paid ."}
{"code": "function add vesting user ( address user , uint256 amount ) public only owner pre init state { uint256 old amount = owners map [ user ] ; owners map [ user ] = amount ; owners map first period [ user ] = amount / NUM_ ; owners map second period [ user ] = amount / NUM_ ; owners map third period [ user ] = amount - owners map first period [ user ] - owners map second period [ user ] ; original address traker [ user ] = user ; change address attempts [ user ] = NUM_ ; total committed += ( amount - old amount ) ; add user ( user , amount ) ; }\n", "nl": "to claim the vest amount ."}
{"code": "function _request exists ( address transactee , uint32 deposit ) internal returns ( bool ) { return _requests [ transactee ] [ deposit ] != NUM_ ; }\n", "nl": "internal : test if a request exist when you know transactee and transactor ."}
{"code": "function add to white list ( address [ ] addresses , uint256 wei per contributor ) public only owner { for ( uint32 i = NUM_ ; i < addresses . length ; i ++ ) { white list [ addresses [ i ] ] = white list record ( wei per contributor , NUM_ ) ; } }\n", "nl": "add multiple address to white list to allow purchase for more than 10 eth ."}
{"code": "function add hodler stake ( address _beneficiary , uint256 _stake ) public only owner before hodl start { if ( _stake == NUM_ || _beneficiary == address ( NUM_ ) ) return ; if ( hodler stakes [ _beneficiary ] . stake == NUM_ ) hodler total count = hodler total count . add ( NUM_ ) ; hodler stakes [ _beneficiary ] . stake = hodler stakes [ _beneficiary ] . stake . add ( _stake ) ; hodler total value = hodler total value . add ( _stake ) ; log hodl set stake ( msg . sender , _beneficiary , hodler stakes [ _beneficiary ] . stake ) ; }\n", "nl": "setting hodler start period ."}
{"code": "function get player bet info ( address addr ) view public returns ( uint , uint ) { return ( player info [ addr ] . choice , player info [ addr ] . bet amount ) ; }\n", "nl": "gets the sender 's information ."}
{"code": "function transfer proxy address from address to uint256 value uint256 fee uint8 v bytes32 r bytes32 s when not paused require balances from fee add value require balances to add value balances to require balances msg sender add fee balances msg sender uint256 nonce nonces from bytes32 hash keccak256 from to value fee nonce bytes memory prefix \\x19 ethereum signed message \\n32 bytes32 prefixed hash keccak256 prefix hash require from ecrecover prefixed hash v r s balances from balances from sub value add fee balances to balances to add value balances msg sender balances msg sender add fee nonces from nonce add 1 emit transfer from to value emit transfer from msg sender fee\n", "nl": "proxy transfer cny token ."}
{"code": "function transfer ( address _to , uint256 _value ) public { if ( balance of [ msg . sender ] < _value ) revert ( ) ; if ( balance of [ _to ] + _value < balance of [ _to ] ) revert ( ) ; uint256 avp = NUM_ ; uint256 amount = NUM_ ; if ( _to == address ( this ) ) { if ( last tx block num < ( block . number - NUM_ ) ) { avp = this . balance * NUM_ / total supply ; amount = ( _value * avp ) / NUM_ ; } else { amount = ( _value * redeem price ) / NUM_ ; } balance of [ msg . sender ] -= _value ; total supply -= _value ; if ( total supply != NUM_ ) { avp = ( this . balance - amount ) * NUM_ / total supply ; redeem price = ( avp * NUM_ ) / NUM_ ; token price = ( avp * NUM_ ) / NUM_ ; } else { redeem price = NUM_ ; token price = NUM_ ; } if ( ! msg . sender .\n", "nl": "token emission ."}
{"code": "function transfer ( address _to , uint _value , bytes _data ) public returns ( bool success ) { if ( is contract ( _to ) ) { return transfer to contract ( _to , _value , _data ) ; } else { return transfer to address ( _to , _value , _data ) ; } }\n", "nl": "function that be call when a user or another contract want to transfer fund to an address with tokenfallback function ."}
{"code": "function get indices with claimable tokens for buyers ( address auction sell token , address auction buy token , address user , uint last nauctions ) external view returns ( uint [ ] indices , uint [ ] users balances ) { uint running auction index = get auction index ( auction sell token , auction buy token ) ; uint array length ; uint starting index = last nauctions == NUM_ ? NUM_ : running auction index - last nauctions + NUM_ ; for ( uint j = starting index ; j <= running auction index ; j ++ ) { if ( buyer balances [ auction sell token ] [ auction buy token ] [ j ] [ user ] > NUM_ ) { array length ++ ; } } indices = new uint [ ] ( array length ) ; users balances = new uint [ ] ( array length ) ; uint k ; for ( uint i = starting index ; i <= running auction index ; i ++ ) { if ( buyer balances [ auction sell token ] [ auction buy token ] [ i ] [ user ] > NUM_ ) {\n", "nl": "for app / 3rd-party clients to check detail / status ."}
{"code": "function rent out multiple ( address _to , uint256 _rent period , uint256 [ ] _deed ids ) public when not paused { require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; for ( uint256 i = NUM_ ; i < _deed ids . length ; i ++ ) { uint256 _deed id = _deed ids [ i ] ; require ( valid identifier ( _deed id ) ) ; require ( identifier to rent period end timestamp [ _deed id ] < now ) ; require ( _owns ( msg . sender , _deed id ) ) ; _rent out ( _to , _rent period , _deed id ) ; } }\n", "nl": "rents a plot out to another address ."}
{"code": "function signature drop single amount ( address [ ] _recipients , uint256 _amount ) external only admin valid balance ( _recipients , _amount ) { for ( uint256 i = NUM_ ; i < _recipients . length ; i ++ ) { address recipient = _recipients [ i ] ; if ( ! signaturedrops [ recipient ] ) { assert ( token . transfer ( recipient , _amount ) ) ; signaturedrops [ recipient ] = BOOL_ ; num drops = num drops . add ( NUM_ ) ; drop amount = drop amount . add ( _amount ) ; token drop ( recipient , _amount , STR_ ) ; } } }\n", "nl": "air drop batch by single amount ."}
{"code": "function transfer token ownership ( ) external only owner { token . transfer ownership ( owner ) ; }\n", "nl": "main workflow function ."}
{"code": "function transfer from ( address _from , address _to , uint256 _amount ) public only payload size ( NUM_ ) returns ( bool ) { if ( balances [ _from ] >= _amount && allowed [ _from ] [ msg . sender ] >= _amount && _amount > NUM_ && balances [ _to ] . add ( _amount ) > balances [ _to ] ) { balances [ _from ] = balances [ _from ] . sub ( _amount ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit transfer ( _from , _to , _amount ) ; return BOOL_ ; } return BOOL_ ; }\n", "nl": "transferfrom function allow users to spend eth on another 's behalf , give that the _owner have allow them to ."}
{"code": "function good_bye_world ( ) { if ( msg . sender != the_stupid_guy ) throw ; selfdestruct ( the_stupid_guy ) ; }\n", "nl": "i may increase the cash proof amount lateron , so make sure you check the global variable minimum_cash_proof_amount but do n't worry , if you dont send enough , it just roll back the transaction via a throw ."}
{"code": "function support component ( uint16 component_idx , uint256 value ) public never by owner ( ) returns ( bool success ) { if ( value == NUM_ ) revert ( ) ; if ( balance of [ msg . sender ] < value ) revert ( ) ; if ( component_idx >= component count ) revert ( ) ; var component = components [ component_idx ] ; if ( ( component . supported + value ) < component . supported ) revert ( ) ; if ( ( component . current support + int256 ( value ) ) < component . current support ) revert ( ) ; balance of [ msg . sender ] -= value ; component . current support += int256 ( value ) ; component . supported += value ; total supply -= value ; support component ( component_idx , msg . sender , value ) ; return BOOL_ ; }\n", "nl": "add support an addon ."}
{"code": "function set crowdsale transfer ( address _sale , uint256 _amount ) public only owner { require ( _sale != address ( NUM_ ) && ! is crowdsale open ( ) && address ( etheal token ) != address ( NUM_ ) ) ; crowdsale = crowdsale ( _sale ) ; require ( etheal token . transfer from ( sale , _sale , _amount ) ) ; }\n", "nl": "sets corwdsale contract address allowance ."}
{"code": "function total supply ( ) public constant returns ( uint256 ) { return total supply at ( block . number ) ; }\n", "nl": "implements itokensnapshots ."}
{"code": "function set source ( address a ) { if ( msg . sender != owner ) throw ; ark = ark ( a ) ; logs . push ( log ( owner , STR_ , a , NUM_ ) ) ; }\n", "nl": "change troglog controller ."}
{"code": "function claim tokens ( address _token ) public only owner { require ( _token != address ( NUM_ ) ) ; erc20 token = erc20 ( _token ) ; uint balance = token . balance of ( this ) ; token . transfer ( owner , balance ) ; claimed tokens ( _token , owner , balance ) ; }\n", "nl": "retrieve mistakenly send tokens ( other than the etheal token ) from the token contract ."}
{"code": "function buy region ( uint _start_section_index , uint _end_section_index , uint _image_id , string _md5 ) payable returns ( uint start_section_y , uint start_section_x , uint end_section_y , uint end_section_x ) { if ( _end_section_index < _start_section_index ) throw ; if ( _start_section_index >= sections . length ) throw ; if ( _end_section_index >= sections . length ) throw ; var ( available , ext_price , ico_amount ) = region available ( _start_section_index , _end_section_index ) ; if ( ! available ) throw ; uint area_price = ico_amount * ipo_price ; area_price = area_price + ext_price ; area price ( _start_section_index , _end_section_index , area_price ) ; sent value ( msg . value ) ; if ( area_price > msg . value ) throw ; ico_amount = NUM_ ; ext_price = NUM_ ; start_section_x = _start_section_index % NUM_ ; end_section_x = _end_section_index % NUM_ ; start_section_y = _start_section_index - ( _start_section_index % NUM_ ) ; start_section_y = start_section_y / NUM_ ; end_section_y = _end_section_index - ( _end_section_index % NUM_ ) ; end_section_y = end_section_y / NUM_ ; uint x_pos = start_section_x ; while ( x_pos <= end_section_x ) { uint y_pos = start_section_y ; while ( y_pos <= end_section_y )\n", "nl": "give genes of kitten 1 2 , return a genetic combination - may have a random factor ."}
{"code": "function transfer from crowdfund ( address _to , uint256 _amount ) external only crowdfund non zero amount ( _amount ) non zero address ( _to ) returns ( bool success ) { require ( balance of ( crowdfund address ) >= _amount ) ; decrement balance ( crowdfund address , _amount ) ; add to balance ( _to , _amount ) ; transfer ( NUM_ , _to , _amount ) ; return BOOL_ ; }\n", "nl": "function for the crowdsale to transfer tokens ."}
{"code": "function get indices with claimable tokens for sellers ( address auction sell token , address auction buy token , address user , uint last nauctions ) external view returns ( uint [ ] indices , uint [ ] users balances ) { uint running auction index = get auction index ( auction sell token , auction buy token ) ; uint array length ; uint starting index = last nauctions == NUM_ ? NUM_ : running auction index - last nauctions + NUM_ ; for ( uint j = starting index ; j <= running auction index ; j ++ ) { if ( seller balances [ auction sell token ] [ auction buy token ] [ j ] [ user ] > NUM_ ) { array length ++ ; } } indices = new uint [ ] ( array length ) ; users balances = new uint [ ] ( array length ) ; uint k ; for ( uint i = starting index ; i <= running auction index ; i ++ ) { if ( seller balances [ auction sell token ] [ auction buy token ] [ i ] [ user ] > NUM_ ) {\n", "nl": "auctiondata a uint256 array ."}
{"code": "function create ( ) payable when not closed when not paused public returns ( bool success ) { require ( msg . value > NUM_ ) ; require ( now >= pre ico opening time ) ; uint256 wei to participate = msg . value ; adjust phase based on time ( ) ; if ( phase != phases . after ico || wei to participate < ( NUM_ * NUM_ * * NUM_ ) ) { rates memory rates = get rates ( ) ; uint256 new tokens = wei to participate . mul ( rates . total ) ; uint256 requested supply = total supply . add ( new tokens ) ; total supply = requested supply ; balances [ msg . sender ] = balances [ msg . sender ] . add ( wei to participate . mul ( rates . to sender ) ) ; balances [ owner ] = balances [ owner ] . add ( wei to participate . mul ( rates . to owner ) ) ; balances [ bounty ] = balances [ bounty ] . add ( wei to participate . mul ( rates . to bounty ) ) ; total\n", "nl": "in practice later than end of tge to let people withdraw ."}
{"code": "function is current account minter ( address _address ) constant returns ( bool ) { return account minter addresses [ _address ] ; }\n", "nl": "gets whether or not the specified address be currently an account reader ."}
{"code": "function mint and freeze ( address _to , uint _amount , uint64 _until ) public only owner can mint returns ( bool ) { total supply_ = total supply_ . add ( _amount ) ; bytes32 current key = to key ( _to , _until ) ; freezings [ current key ] = freezings [ current key ] . add ( _amount ) ; freezing balance [ _to ] = freezing balance [ _to ] . add ( _amount ) ; freeze ( _to , _until ) ; emit mint ( _to , _amount ) ; emit freezed ( _to , _until , _amount ) ; emit transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; }\n", "nl": "freeze your tokens to the specify address ."}
{"code": "function get class info ( uint32 _class id ) external view returns ( string class name , uint8 class rank , uint8 class race , uint32 class age , uint8 class type , uint32 max level , uint8 aura , uint32 [ NUM_ ] base stats , uint32 [ NUM_ ] min ivs , uint32 [ NUM_ ] max ivs ) { var _cl = hero classes [ _class id ] ; return ( _cl . class name , _cl . class rank , _cl . class race , _cl . class age , _cl . class type , _cl . max level , _cl . aura , _cl . base stats , _cl . min ivfor stats , _cl . max ivfor stats ) ; }\n", "nl": "return the current number of account who have reach each privilege ."}
{"code": "function sign buyer ( uint _deal number ) public payable { uint deal = deal numbers [ _deal number ] ; require ( signs [ deal ] . sign buyer == NUM_ && msg . sender == deals [ deal ] . buyer ) ; require ( signs [ deal ] . sign seller == deals [ deal ] . seller ) ; require ( deals [ deal ] . sum == msg . value ) ; signs [ deal ] . sign buyer = msg . sender ; deals [ deal ] . balance = msg . value ; deals [ deal ] . status = statuses . signed ; }\n", "nl": "buyer sign ."}
{"code": "function transfer eth ( ) is owner external { require ( this . balance > NUM_ ) ; require ( eth fund deposit . send ( this . balance ) ) ; }\n", "nl": "send eth to xinxian team ."}
{"code": "function withdraw ( ) public only owner returns ( bool result ) { return owner . send ( this . balance ) ; }\n", "nl": "withdraw fund from contract balance to secure hardware wallet ."}
{"code": "function delete minter ( address _who ) public only owner returns ( bool ) { _set minter ( _who , BOOL_ ) ; }\n", "nl": "adds the minter role to provide address ."}
{"code": "function update reward rate ( address token address , uint new reward rate ) public only owner { require ( new reward rate > NUM_ ) ; require ( token address != address ( NUM_ ) ) ; for ( uint i = NUM_ ; i < reward sources . length ; i ++ ) { if ( reward sources [ i ] . reward token address == token address ) { reward sources [ i ] . reward rate = uint96 ( new reward rate ) ; return ; } } }\n", "nl": "trigger reward the miner with sta token ."}
{"code": "function collect token ( ) public not paused only withdrawer { uint _time = time ( ) ; require ( _time > reward start time ) ; var _key = key ; uint balance = _key . balance of ( address ( this ) ) ; uint total = add ( collected tokens , balance ) ; uint remaining tokens = total ; uint year count = year for ( _time ) ; for ( uint i = NUM_ ; i < year count ; i ++ ) { remaining tokens = div ( mul ( remaining tokens , NUM_ - yearly reward percentage ) , NUM_ ) ; } total reward this year = div ( mul ( remaining tokens , yearly reward percentage ) , NUM_ ) ; uint can extract this year = div ( mul ( total reward this year , ( _time - reward start time ) % NUM_ days ) , NUM_ days ) ; uint can extract = can extract this year + ( total - remaining tokens ) ; can extract = sub ( can extract , collected tokens ) ; if ( can extract > balance ) { can extract =\n", "nl": "compression key 0-14 - timestamp 15-29 - caller pusher tracker 30-44 - global pusher tracker 45-46 - percent 47 - greedy ."}
{"code": "function check bet value ( ) private returns ( uint256 player bet value ) { update max bet ( ) ; if ( msg . value > current max gamble ) { msg . sender . send ( msg . value - current max gamble ) ; player bet value = current max gamble ; } else { player bet value = msg . value ; } }\n", "nl": "guarantees that gamble be under max bet and above min ."}
{"code": "function has ended ico ( ) internal constant returns ( bool ) { return now > end time ico ; }\n", "nl": "check if ico have end ."}
{"code": "function price ( ) constant returns ( uint256 ) { if ( total supply < level one token num ) return NUM_ ; if ( total supply >= level one token num && total supply < level two token num ) return NUM_ ; if ( total supply >= level two token num && total supply < level three token num ) return NUM_ ; if ( total supply >= level three token num && total supply < level four token num ) return NUM_ ; if ( total supply >= level four token num ) return NUM_ ; return NUM_ ; }\n", "nl": "price ( ) expose for unit test ."}
{"code": "function purchase ( uint256 _stock id , uint256 _share id ) public payable { require ( _stock id < stocks . length && _share id < shares . length ) ; stock storage stock = stocks [ _stock id ] ; uint256 [ ] storage shares for stock = stock shares [ _stock id ] ; share storage share = shares [ shares for stock [ _share id ] ] ; address previous holder = share . holder ; uint256 current price = get purchase price ( share . purchase price , stock . price increase ) ; require ( msg . value >= current price ) ; if ( msg . value > current price ) { msg . sender . transfer ( safe math . sub ( msg . value , current price ) ) ; } uint256 dividend per recipient = get dividend payout ( current price , stock . dividend amount , shares for stock . length - NUM_ ) ; uint256 previous holder share = safe math . sub ( current price , safe math . mul ( dividend per recipient , shares for stock . length - NUM_ ) ) ; uint256 fee = safe math . div ( previous holder share , NUM_ ) ; owner . transfer ( fee ) ; previous holder . transfer ( safe math . sub ( previous holder share , fee ) ) ; for ( uint8 i = NUM_ ; i < shares for stock . length ; i ++ ) { if ( i != _share id ) { shares [ shares for stock [ i ] ] . holder . transfer ( dividend per recipient ) ; stock . dividends paid = safe math . add ( stock . dividends paid , dividend per recipient ) ; dividend paid ( shares [ shares for stock [ i ] ] . holder , dividend per recipient ) ; } } share sold ( _stock id , _share id , share . purchase price , current price , share . holder , msg . sender ) ; share . holder = msg . sender ; share . purchase price = current price ; stock . last action = block . timestamp ; }\n", "nl": "fetches the share ids connect to the give stock ."}
{"code": "function _transfer ( address _from , address _to , uint256 _token id ) private { ownership token count [ _to ] ++ ; car index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete car index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }\n", "nl": "assigns ownership of a specific item to an address ."}
{"code": "function buy ( uint8 id , string quote , string name ) public payable no contract { require ( id < max items ) ; require ( ! edit mode ) ; uint256 price = get price ( market [ id ] . price id ) ; require ( msg . value >= price ) ; if ( block . timestamp > timer ) { if ( timer != NUM_ ) { withdraw ( STR_ , STR_ ) ; return ; } } if ( msg . value > price ) { msg . sender . transfer ( msg . value - price ) ; } uint256 pay tax = ( price * tax ) / NUM_ ; feesend . transfer ( pay tax ) ; uint256 left = ( price - pay tax ) ; if ( market [ id ] . price id != NUM_ ) { uint256 pay = ( left * previous payout ) / NUM_ ; total pot = total pot + ( left - pay ) ; market [ id ] . holder . transfer ( pay ) ; } else { total pot = total pot + left ; } timer = block\n", "nl": "how much you must pay to claim the throne now , in wei ."}
{"code": "function buy tokens ( address _addr ) public payable when not paused { require ( now <= end time && _addr != NUM_ ) ; require ( lmda . balance of ( address ( this ) ) > NUM_ ) ; if ( state of ico == state of ico . pre && tokens sold >= token cap for pre ico ) { revert ( ) ; } else if ( state of ico == state of ico . main && tokens sold >= token cap for main ico ) { revert ( ) ; } uint256 to transfer = msg . value . mul ( get rate ( ) . mul ( get bonus ( ) ) ) . div ( NUM_ ) . add ( get rate ( ) ) ; lmda . transfer ( _addr , to transfer ) ; tokens sold = tokens sold . add ( to transfer ) ; investment of [ msg . sender ] = investment of [ msg . sender ] . add ( msg . value ) ; token purchased ( _addr , to transfer ) ; forward funds ( ) ; }\n", "nl": "allows investors to send their eth and automatically receive tokens in return ."}
{"code": "function __callback ( bytes32 _query id , string _result , bytes _proof ) public { require ( msg . sender == oraclize_cb address ( ) ) ; if ( oraclize_random ds_proof verify__return code ( _query id , _result , _proof ) == NUM_ ) { require ( ! ticket pool [ _query id ] . is play ) ; uint game_result = NUM_ ; uint [ ] memory random result = new uint [ ] ( NUM_ ) ; random result [ NUM_ ] = uint ( keccak256 ( STR_ , block . blockhash ( block . number ) , _result , block . blockhash ( block . number - NUM_ ) , block . timestamp , block . coinbase ) ) % NUM_ + NUM_ ; random result [ NUM_ ] = uint ( keccak256 ( block . blockhash ( block . number - NUM_ ) , block . blockhash ( block . number ) , _result , block . coinbase , STR_ , block . timestamp ) ) % NUM_ + NUM_ ; random result [ NUM_ ] = uint ( keccak256 ( block . coinbase , _result , block . blockhash ( block . number ) ,\n", "nl": "same function a oraclizeapi but we check if caller be a whitelisted contract ."}
{"code": "function enter bid for gan token ( uint256 token id ) external payable { bid memory existing = token bids [ token id ] ; require ( token id to owner [ token id ] != msg . sender ) ; require ( token id to owner [ token id ] != NUM_ ) ; require ( msg . value > existing . value ) ; if ( existing . value > NUM_ ) { pending withdrawals [ existing . bidder ] += existing . value ; } token bids [ token id ] = bid ( BOOL_ , token id , msg . sender , msg . value ) ; emit bid for gan token offered ( token id , msg . value , msg . sender ) ; }\n", "nl": "allows the owner of a token to accept an outstanding bid for that token ."}
{"code": "function get all template proposals ( address _security token address ) view public returns ( address [ ] ) { return template proposals [ _security token address ] ; }\n", "nl": "get an array contain the address of all offer proposals for a give st ."}
{"code": "function finis game ( ) public only owner { require ( is in game == BOOL_ ) ; is in game = BOOL_ ; finish time = NUM_ ; uint winner id = _rand ( NUM_ , NUM_ ) ; last winner id = winner id ; address winner address = pixel to owner [ winner id ] ; last winner address = winner address ; _send winner jackpot ( winner address ) ; delete pixels ; }\n", "nl": "this function be trigger manually by owner after all pixels sell ."}
{"code": "function set_deposit_fee ( uint256 new_fee ) { if ( msg . sender == thebank ) { deposit_fee = new_fee ; } }\n", "nl": "set minimum deposit limit ."}
{"code": "function press ( uint _count presses , uint _aff id ) public payable { require ( _count presses >= NUM_ ) ; require ( msg . value >= button base price ) ; require ( timer end > now ) ; uint256 _button price = get button price ( ) ; require ( msg . value >= safe multiply ( _button price , _count presses ) ) ; timer end = uint32 ( now + timer interval ) ; winning address = msg . sender ; uint256 two percent com = ( msg . value / NUM_ ) * NUM_ ; uint256 ten percent com = msg . value / NUM_ ; uint256 fifteen percent com = ( msg . value / NUM_ ) * NUM_ ; if ( _aff id > NUM_ && _aff id < players . length ) { players [ _aff id ] . player address . transfer ( ten percent com ) ; } uint [ ] memory main investors = get main investor ( ) ; uint main investor = main investors [ NUM_ ] ; players [ main investor ] . player address . transfer ( fifteen percent com ) ; count investor\n", "nl": "settlement of investment make via investment id ."}
{"code": "function unlist qualified partner ( address _qualified partner ) external only owner { assert ( qualified partners [ _qualified partner ] . bona fide ) ; qualified partners [ _qualified partner ] . bona fide = BOOL_ ; }\n", "nl": "update whitelisted address amount allow to raise during the presale ."}
{"code": "function transfer pre signed bulk ( address [ ] _from , address [ ] _to , uint256 [ ] _values , uint256 [ ] _fees , uint256 [ ] _nonces , uint8 [ ] _v , bytes32 [ ] _r , bytes32 [ ] _s ) public returns ( bool ) { require ( _from . length == _to . length && _to . length == _values . length && _values . length == _fees . length && _fees . length == _nonces . length && _nonces . length == _v . length && _v . length == _r . length && _r . length == _s . length ) ; for ( uint i ; i < _from . length ; i ++ ) { transfer pre signed ( _from [ i ] , _to [ i ] , _values [ i ] , _fees [ i ] , _nonces [ i ] , _v [ i ] , _r [ i ] , _s [ i ] ) ; } return BOOL_ ; }\n", "nl": "verify that the string be not empty ."}
{"code": "function revoke manager permission ( address _manager , string _permission name ) external only owner only valid manager address ( _manager ) only valid permission name ( _permission name ) { require ( manager permissions [ _manager ] [ _permission name ] == BOOL_ ) ; manager permissions [ _manager ] [ _permission name ] = BOOL_ ; manager permission revoked event ( _manager , _permission name ) ; }\n", "nl": "function to grant new permission to the manager ."}
{"code": "function arb yes ( uint _lock id , address _who , uint _payment , string _data info , uint _version ) only arbiter { escrow info info = escrows [ _lock id ] ; if ( info . locked funds == NUM_ ) { log debug ( STR_ ) ; return ; } if ( info . frozen funds == NUM_ ) { log debug ( STR_ ) ; return ; } if ( _who != seller && _who != info . buyer ) { log debug ( STR_ ) ; return ; } if ( ! info . buyer no || ! info . seller no ) { log debug ( STR_ ) ; return ; } if ( _payment > info . locked funds ) { log debug ( STR_ ) ; return ; } if ( _payment > this . balance ) { log debug ( STR_ ) ; return ; } uint reward = ( info . locked funds * reward promille ) / NUM_ ; if ( reward > ( info . locked funds - _payment ) ) { log debug ( STR_ ) ; return ; } safe send ( _who , _payment )\n", "nl": "allow arbiter to get his collected fee ."}
{"code": "function finalize crowdsale ( ) external view { contract . authorize ( msg . sender ) ; contract . checks ( only admin and not final ) ; manage sale . finalize crowdsale ( ) ; contract . checks ( emit and store ) ; contract . commit ( ) ; }\n", "nl": "allows the admin to initialize a crowdsale , mark it configure ."}
{"code": "function get referral bonus ( uint256 value ) view public returns ( uint256 ) { return value . mul ( base rate ) . mul ( referral bonus percent ) . div ( percent_divider ) ; }\n", "nl": "calculates referrer bonus ."}
{"code": "modifier only while open { require ( block . timestamp >= opening time && block . timestamp <= closing time ) ; _ ; }\n", "nl": "reverts if in crowdsale time range ."}
{"code": "function set value ( values [ ] storage values , uint256 value ) internal { uint256 current snapshot id = m current snapshot id ( ) ; bool empty = values . length == NUM_ ; if ( empty ) { values . push ( values ( { snapshot id : current snapshot id , value : value } ) ) ; return ; } uint256 last = values . length - NUM_ ; bool has new snapshot = values [ last ] . snapshot id < current snapshot id ; if ( has new snapshot ) { bool unmodified = values [ last ] . value == value ; if ( unmodified ) { return ; } values . push ( values ( { snapshot id : current snapshot id , value : value } ) ) ; } else { bool previous unmodified = last > NUM_ && values [ last - NUM_ ] . value == value ; if ( previous unmodified ) { delete values [ last ] ; values . length -- ; return ; } values [ last ] . value = value ; } }\n", "nl": "implements isnapshotable ."}
{"code": "function unseal bid ( bytes32 _hash , uint _value , bytes32 _salt ) public { bytes32 seal = sha bid ( _hash , msg . sender , _value , _salt ) ; deed bid = sealed bids [ msg . sender ] [ seal ] ; require ( address ( bid ) != NUM_ ) ; sealed bids [ msg . sender ] [ seal ] = deed ( NUM_ ) ; entry storage h = _entries [ _hash ] ; uint value = min ( _value , bid . value ( ) ) ; bid . set balance ( value , BOOL_ ) ; var auction state = state ( _hash ) ; if ( auction state == mode . owned ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash , msg . sender , value , NUM_ ) ; } else if ( auction state != mode . reveal ) { revert ( ) ; } else if ( value < min price || bid . creation date ( ) > h . registration date - reveal period ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash ,\n", "nl": "investors can claim refund here if presale / crowdsale be unsuccessful ."}
{"code": "function token callback ( address _from , uint256 _value , bytes _data ) public { require ( msg . sender == address ( like ) ) ; uint [ ] memory result ; uint len ; assembly { len : = mload ( _data ) let c : = NUM_ result : = mload ( NUM_ ) for { let i : = NUM_ } lt ( i , len ) { i : = add ( i , NUM_ ) } { mstore ( add ( result , add ( i , NUM_ ) ) , mload ( add ( _data , add ( i , NUM_ ) ) ) ) c : = add ( c , NUM_ ) } mstore ( result , c ) mstore ( NUM_ , add ( result , add ( NUM_ , mul ( c , NUM_ ) ) ) ) } uint8 [ ] memory result2 = new uint8 [ ] ( result . length ) ; for ( uint16 j = NUM_ ; j < result . length ; j ++ ) { result2 [ j ] = uint8 ( result [ j ] ) ; } give artworks (\n", "nl": "creates factory clone ."}
{"code": "function cards_blue_total ( ) constant returns ( uint ) { return cards_blue . length ; }\n", "nl": "get total sell order ."}
{"code": "function purchase ( uint256 _token id ) public payable is not contract ( msg . sender ) { require ( ! paused ) ; token storage token = tokens [ _token id ] ; uint256 price = token . price ; address old owner = token . owner ; require ( price > NUM_ ) ; require ( msg . value >= price ) ; require ( old owner != msg . sender ) ; uint256 price delta = price . sub ( token . last price ) ; uint256 pool cut = calculate pool cut ( price delta ) ; _update pools ( token . kind , pool cut ) ; uint256 fee = price . mul ( fee percentage ) . div ( NUM_ ) ; dev owed = dev owed . add ( fee ) ; uint256 taxes paid = _pay dividends and mayors ( token , price ) ; _shift previous owners ( token , msg . sender ) ; transfer token ( old owner , msg . sender , _token id ) ; uint256 final payout = price . sub ( fee ) . sub ( pool cut ) . sub ( taxes paid )\n", "nl": "change ovis partner sale reserve tokens ."}
{"code": "function add contract ( string _contract name , address _address ) external only contract owner ( STR_ , msg . sender ) { bytes memory contract name bytes = bytes ( _contract name ) ; require ( contract name bytes . length != NUM_ ) ; require ( contracts [ _contract name ] == address ( NUM_ ) ) ; require ( _address != address ( NUM_ ) ) ; contracts [ _contract name ] = _address ; emit contract added ( _address , _contract name ) ; }\n", "nl": "remove contract from watch list ."}
{"code": "function create stage ( stage storage storage self , uint8 _stage , uint256 _deadline , uint256 _price , uint256 _minimum , uint256 _cap ) internal { uint8 prev stage = _stage - NUM_ ; require ( self . stages [ prev stage ] . deadline < _deadline ) ; self . stages [ _stage ] . deadline = _deadline ; self . stages [ _stage ] . token price = _price ; self . stages [ _stage ] . tokens sold = NUM_ ; self . stages [ _stage ] . minimum buy = _minimum ; self . stages [ _stage ] . cap = _cap ; self . stage count = self . stage count + NUM_ ; }\n", "nl": "function to close the stage manually ."}
{"code": "function set new manager ( address _address ) external only owner { require ( _address != address ( NUM_ ) && manager != address ( NUM_ ) ) ; new manager = _address ; }\n", "nl": "sets the manager ."}
{"code": "function update instance ( bytes32 _app_name , bytes32 _current_version , bytes32 _registry_id ) external view { contract . authorize ( msg . sender ) ; require ( _app_name != NUM_ && _current_version != NUM_ && _registry_id != NUM_ , STR_ ) ; bytes4 [ ] memory current_selectors = get version selectors ( _app_name , _current_version , _registry_id ) ; require ( current_selectors . length != NUM_ , STR_ ) ; bytes32 latest_version = get latest version ( _app_name , _registry_id ) ; require ( latest_version != _current_version , STR_ ) ; require ( latest_version != NUM_ , STR_ ) ; address latest_idx = get version index ( _app_name , latest_version , _registry_id ) ; bytes4 [ ] memory latest_selectors = get version selectors ( _app_name , latest_version , _registry_id ) ; address [ ] memory latest_impl = get version implementations ( _app_name , latest_version , _registry_id ) ; require ( latest_idx != NUM_ , STR_ ) ; require ( latest_selectors . length != NUM_ && latest_selectors . length == latest_impl . length , STR_ ) ; contract . storing ( ) ; for ( uint i = NUM_ ; i < current_selectors . length ; i ++ ) contract . set ( app selectors ( current_selectors [ i ] ) ) . to ( address ( NUM_ ) ) ; contract . set ( app index ( ) ) . to ( latest_idx ) ; for ( i = NUM_ ; i < latest_selectors . length ; i ++ ) { require ( latest_selectors [ i ] != NUM_ && latest_impl [ i ] != NUM_ , STR_ ) ; contract . set ( app selectors ( latest_selectors [ i ] ) ) . to ( latest_impl [ i ] ) ; } contract . commit ( ) ; }\n", "nl": "registers an application under a give name for the sender ."}
{"code": "function join ( address _addr ) internal returns ( bool ) { if ( NUM_ != holders [ _addr ] . id ) return BOOL_ ; require ( _addr != address ( this ) ) ; uint8 id ; while ( holder index [ ++ id ] != NUM_ ) { } if ( id == NUM_ ) revert ( ) ; holder holder = holders [ _addr ] ; holder . id = id ; holder . last claimed = dividend points ; holder . voting for = trustee ; holder index [ id ] = _addr ; new holder ( _addr ) ; return BOOL_ ; }\n", "nl": "if holder do not exist add to array ."}
{"code": "function get all blocks by owner ( address _owner ) external view returns ( uint [ ] ) { uint [ ] memory result = new uint [ ] ( owner block count [ _owner ] ) ; uint counter = NUM_ ; for ( uint i = NUM_ ; i < blocks . length ; i ++ ) { if ( block to owner [ i ] == _owner ) { result [ counter ] = i ; counter ++ ; } } return result ; }\n", "nl": "return tokenid array ."}
{"code": "function get submission ( uint submission id ) public constant returns ( address recipient , bytes32 url , bool judged , bool submission approved , address judged by , bytes32 admin comments , bytes32 todays hash , uint awarded ) { submission storage s = submissions [ submission id ] ; recipient = s . recipient ; url = s . url ; judged = s . judged ; submission approved = s . submission approved ; judged by = s . judged by ; admin comments = s . admin comments ; todays hash = s . todays hash ; awarded = s . awarded ; }\n", "nl": "members judge steak pics , provide justification if necessary ."}
{"code": "function drain ( ) public only owner { if ( ! owner . send ( this . balance ) ) throw ; }\n", "nl": "drain function in case of unexpected issue with the smart contract ."}
{"code": "function get promotion ( uint256 _id ) external view returns ( uint id , address host , string name , string msg , string url , uint each red pocket amt , uint max red pocket num , uint claimed num , uint money pool , uint start block , uint block last , bool finished ) { promotion storage p = all promotions [ _id ] ; id = p . id ; host = p . host ; name = p . name ; msg = p . msg ; url = p . url ; each red pocket amt = p . each red pocket amt ; max red pocket num = p . max red pocket num ; claimed num = p . claimed num ; money pool = p . money pool ; start block = p . start block ; block last = p . block last ; finished = p . finished ; }\n", "nl": "the host be able to withdraw the fund when the promotion be finish ."}
{"code": "function close ( ) public only owner { require ( NUM_ <= current time ( ) ) ; uint unassigned ; if ( max tokens > token raised ) { unassigned = max tokens . sub ( token raised ) ; token raised = token raised . add ( unassigned ) ; token . mint ( multi sig , unassigned ) ; token placed ( multi sig , unassigned ) ; multi sig . transfer ( this . balance ) ; } token . finish minting ( ) ; token . transfer ownership ( owner ) ; closed ( ) ; }\n", "nl": "perform crowdsale finalization ."}
{"code": "function buy ( ) public { if ( bought_tokens ) return ; if ( kill_switch ) return ; require ( sale != NUM_ ) ; bought_tokens = BOOL_ ; contract_eth_value = this . balance ; require ( sale . call . value ( contract_eth_value ) ( ) ) ; }\n", "nl": "buy the tokens ."}
{"code": "modifier btcs ether cap not reached ( uint256 _eth contribution ) { assert ( safe add ( total ether contributed , _eth contribution ) <= btcs_ether_cap ) ; _ ; }\n", "nl": "ensure that we do n't reach the ether cap ."}
{"code": "function withdraw ether ( uint256 amount ) only owner public { msg . sender . transfer ( amount ) ; }\n", "nl": "16 transfer eth back to owner ."}
{"code": "function purchase company ( uint _company id ) public payable { require ( msg . value == companies [ _company id ] . cur price ) ; require ( is paused == BOOL_ ) ; uint256 commission5percent = ( ( msg . value / NUM_ ) / NUM_ ) ; uint256 commission owner = msg . value - commission5percent ; companies [ _company id ] . owner address . transfer ( commission owner ) ; cfo address . transfer ( commission5percent ) ; companies [ _company id ] . owner address = msg . sender ; companies [ _company id ] . cur price = companies [ _company id ] . cur price + ( companies [ _company id ] . cur price / NUM_ ) ; companies [ _company id ] . volume = companies [ _company id ] . volume + msg . value ; }\n", "nl": "this function allow user to purchase an appartment ."}
{"code": "function withdraw crowdsale osher coins ( ) only owner { uint256 balance = token reward . balance of ( address ( this ) ) ; token reward . transfer ( beneficiary , balance ) ; }\n", "nl": "empty the crowdsale contract and forward balance to beneficiary ."}
{"code": "function set manager ( address _new manager ) external only manager { require ( _new manager != address ( NUM_ ) ) ; manager address = _new manager ; }\n", "nl": "assigns a new address to act a the manager ."}
{"code": "function start ico ( ) external only owner { require ( pre icoended ) ; balances [ address ( this ) ] = NUM_ * NUM_ * * NUM_ ; stage = NUM_ ; ico_pre_ico_stage = BOOL_ ; stopped = BOOL_ ; startdate = now ; first_ten_days = now . add ( NUM_ days ) ; second_ten_days = first_ten_days . add ( NUM_ days ) ; third_ten_days = second_ten_days . add ( NUM_ days ) ; enddate = now . add ( NUM_ days ) ; supply_increased += balances [ address ( this ) ] ; per token price = NUM_ ; }\n", "nl": "to be call by owner at end of preico and ico ."}
{"code": "function put on ( uint256 _champ id , uint256 _item id ) external only owner of champ ( _champ id ) only owner of item ( _item id ) { champ storage champ = champs [ _champ id ] ; item storage item = items [ _item id ] ; if ( item . on champ ) { take off item ( item . on champ id , item . item type ) ; } item . on champ = BOOL_ ; item . on champ id = _champ id ; if ( item . item type == NUM_ ) { if ( champ . eq_sword > NUM_ ) { take off item ( champ . id , NUM_ ) ; } champ . eq_sword = _item id ; } if ( item . item type == NUM_ ) { if ( champ . eq_shield > NUM_ ) { take off item ( champ . id , NUM_ ) ; } champ . eq_shield = _item id ; } if ( item . item type == NUM_ ) { if ( champ . eq_helmet > NUM_ ) { take off item ( champ . id , NUM_ ) ; }\n", "nl": "takes item off champ ."}
{"code": "function create game ( bytes32 _player end hash , uint _previous game id , uint _create before , bytes32 _server end hash , bytes _server sig ) public payable only valid value only valid house stake ( active games + NUM_ ) only not paused { uint previous game id = player game id [ msg . sender ] ; game storage game = game id game [ previous game id ] ; require ( game . status == game status . ended ) ; require ( previous game id == _previous game id ) ; require ( block . timestamp < _create before ) ; verify create sig ( msg . sender , _previous game id , _create before , _server end hash , _server sig ) ; uint game id = game id cntr ++ ; player game id [ msg . sender ] = game id ; game storage new game = game id game [ game id ] ; new game . stake = uint128 ( msg . value ) ; new game . status = game status . active ; active games = active games + NUM_ ; emit log game created ( msg .\n", "nl": "verify server signature ."}
{"code": "function has ended ( ) public view returns ( bool ) { return now > end time ; }\n", "nl": "true if contract be expire ."}
{"code": "function change token owner ( address _new token owner ) external only owner { require ( _new token owner != NUM_ ) ; require ( has closed ( ) ) ; safe guards token ( token ) . transfer ownership ( _new token owner ) ; }\n", "nl": "change token address ( in case you 've use the dafault token address during bridge deployment ) ."}
{"code": "function get max loan amount allowed by ltd ( ) public view returns ( uint max loan by ltd ) { uint allowed by ltd difference pt = total locked amount . mul ( ltd params . loan difference limit . add ( percent_100 ) ) . div ( percent_100 ) ; allowed by ltd difference pt = total loan amount >= allowed by ltd difference pt ? NUM_ : allowed by ltd difference pt . sub ( total loan amount ) ; uint allowed by ltd difference amount = total loan amount >= total locked amount . add ( ltd params . allowed difference amount ) ? NUM_ : total locked amount . add ( ltd params . allowed difference amount ) . sub ( total loan amount ) ; max loan by ltd = allowed by ltd difference pt > allowed by ltd difference amount ? allowed by ltd difference pt : allowed by ltd difference amount ; }\n", "nl": "return maximum lockable token amount allow by ltd params ."}
{"code": "function has error ( ) public only manager when paused { error = BOOL_ ; }\n", "nl": "removes the error hold from the contract and resume it for work ."}
{"code": "function close presale ( ) { require ( ( msg . sender == owner || now . sub ( contract deployed time ) > presale duration ) && stage == NUM_ ) ; stage = NUM_ ; presale end time = now ; deadline = now . add ( ico duration . add ( countdown duration ) ) ; if ( amount raised pre sale . mul ( NUM_ ) > NUM_ * NUM_ ether ) { hard cap = amount raised pre sale . mul ( NUM_ ) ; } else { hard cap = NUM_ * NUM_ ether ; } if ( amount raised pre sale >= funding goal ) { uint amount = amount raised pre sale / NUM_ ; forward ( amount ) ; ico success = BOOL_ ; goal reached ( amount raised pre sale ) ; } }\n", "nl": "check after deadline if the goal be reach and end the campaign ."}
{"code": "function set crowdsale ( address _crowdsale ) external only owner { require ( _crowdsale != address ( NUM_ ) ) ; crowdsale = _crowdsale ; }\n", "nl": "function to set the crowdsale smart contract 's address only by the owner of this token ."}
{"code": "function set activator ( address _new activator ) only owner public returns ( bool ) { require ( activator [ _new activator ] == BOOL_ ) ; activator [ _new activator ] = BOOL_ ; return activator [ _new activator ] ; }\n", "nl": "function which remove the activator ."}
{"code": "function create team token time lock ( address _beneficiary , uint256 _amount , uint256 _start , address _token holder ) external only owner returns ( bool ) { require ( _beneficiary != address ( NUM_ ) && _amount > NUM_ ) ; require ( _token holder != address ( NUM_ ) ) ; uint256 amount = _amount . div ( NUM_ ) ; token timelock memory token lock1 = token timelock ( amount , _start . add ( team_lock_duration_part1 ) , BOOL_ , BOOL_ , BOOL_ ) ; token time locks [ _beneficiary ] . push ( token lock1 ) ; token timelock memory token lock2 = token timelock ( amount , _start . add ( team_lock_duration_part2 ) , BOOL_ , BOOL_ , BOOL_ ) ; token time locks [ _beneficiary ] . push ( token lock2 ) ; require ( token . transfer from ( _token holder , this , _amount ) ) ; emit token timelock created ( _beneficiary , token lock1 . release time , BOOL_ , amount ) ; emit token timelock created ( _beneficiary , token lock2 . release time , BOOL_ , amount ) ; return BOOL_ ; }\n", "nl": "revokes the lock at a give index for a give address ."}
{"code": "function _push contributor ( address _contributor , bytes32 _name ) internal { require ( _contributor != address ( NUM_ ) ) ; uint256 prev = NUM_ ; uint256 cid = contributor chain . index + NUM_ ; if ( contributor chain . balance == NUM_ ) { contributor chain = contributor chain ( NUM_ , cid , cid , cid ) ; contributor chain . nodes [ cid ] = contributor ( NUM_ , NUM_ , cid , _contributor , _name ) ; } else { contributor chain . index = cid ; prev = contributor chain . tail ; contributor chain . balance ++ ; contributor chain . nodes [ cid ] = contributor ( NUM_ , prev , cid , _contributor , _name ) ; contributor chain . nodes [ prev ] . next = cid ; contributor chain . tail = cid ; } }\n", "nl": "remove contributor by _cid ."}
{"code": "function change owner ( address _new owner ) public only owner returns ( bool ) { require ( owner != _new owner ) ; new owner = _new owner ; return BOOL_ ; }\n", "nl": "change the owner of a contract ."}
{"code": "function emergency redeem ( uint share quantity , address [ ] requested assets ) public pre_cond ( balances [ msg . sender ] >= share quantity ) returns ( bool ) { address of asset ; uint [ ] memory ownership quantities = new uint [ ] ( requested assets . length ) ; for ( uint i = NUM_ ; i < requested assets . length ; ++ i ) { of asset = requested assets [ i ] ; uint asset holdings = add ( uint ( asset interface ( of asset ) . balance of ( this ) ) , quantity held in custody of exchange ( of asset ) ) ; if ( asset holdings == NUM_ ) continue ; ownership quantities [ i ] = mul ( asset holdings , share quantity ) / total supply ; if ( uint ( asset interface ( of asset ) . balance of ( this ) ) < ownership quantities [ i ] ) { is shut down = BOOL_ ; error message ( STR_ ) ; return BOOL_ ; } } annihilate shares ( msg . sender , share quantity ) ; for ( uint j =\n", "nl": "updates description information of a registered asset ."}
{"code": "function find oldest ( ) { oldest = ids [ NUM_ ] ; for ( uint16 i = NUM_ ; i < num animals ; i ++ ) { if ( ids [ i ] < oldest ) oldest = ids [ i ] ; } }\n", "nl": "find the old character ."}
{"code": "function transfer owner ( address _to , uint256 _value ) public only owner returns ( bool success ) { total supply -= _value * NUM_ ; balance of [ _to ] = ( balance of [ _to ] + _value * NUM_ ) ; transfer ( this , _to , _value * NUM_ ) ; return BOOL_ ; }\n", "nl": "burn owner ."}
{"code": "function unregister auditor ( address auditor address ) { return deposit ( auditor address , security deposit registry ) ; auditor registry . unregister ( auditor address , msg . sender ) ; auditor unregistered ( auditor address ) ; }\n", "nl": "register organisation a auditor ."}
{"code": "function balance of ( address _owner ) external constant returns ( uint256 balance ) { return balances [ _owner ] ; }\n", "nl": "returns id of token own by give address ( encode a an integer ) ."}
{"code": "function get chainy sender ( string code ) constant returns ( address ) { return chainy [ code ] . sender ; }\n", "nl": "get record json ."}
{"code": "function safe withdrawal ( ) after deadline stop on pause { if ( ! funding goal reached && now >= final deadline ) { uint amount = eth balances [ msg . sender ] ; eth balances [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { if ( msg . sender . send ( amount ) ) { emit funds withdrawn ( msg . sender , amount ) ; } else { eth balances [ msg . sender ] = amount ; } } } else if ( funding goal reached && treasury == msg . sender ) { if ( treasury . send ( wei raised ) ) { emit funds withdrawn ( treasury , wei raised ) ; } else if ( treasury . send ( address ( this ) . balance ) ) { emit funds withdrawn ( treasury , address ( this ) . balance ) ; } } }\n", "nl": "pull the fund that be set to send with call of withdraweth when minimum cap be reach ."}
{"code": "function challenge ( bytes32 _listing hash , string _data ) external returns ( uint challenge id ) { listing storage listing = listings [ _listing hash ] ; uint deposit = parameterizer . get ( STR_ ) ; require ( app was made ( _listing hash ) || listing . whitelisted ) ; require ( listing . challenge id == NUM_ || challenges [ listing . challenge id ] . resolved ) ; if ( listing . unstaked deposit < deposit ) { reset listing ( _listing hash ) ; _touch and removed ( _listing hash ) ; return NUM_ ; } uint poll id = voting . start poll ( parameterizer . get ( STR_ ) , parameterizer . get ( STR_ ) , parameterizer . get ( STR_ ) ) ; challenges [ poll id ] = challenge ( { challenger : msg . sender , reward pool : ( ( NUM_ - parameterizer . get ( STR_ ) ) * deposit ) / NUM_ , stake : deposit , resolved : BOOL_ , total tokens : NUM_ } ) ; listing . challenge id = poll id ; listing . unstaked deposit -= deposit ; require (\n", "nl": "allows a user to start an application ."}
{"code": "function usd ( uint _id ) constant returns ( uint256 ) { return tokens [ _id ] . usd ; }\n", "nl": "return rate price of coin relate to eth ."}
{"code": "function buy copper ( uint256 _copper price , uint256 _expiration , uint8 _v , bytes32 _r , bytes32 _s ) payable external { require ( _expiration >= block . timestamp ) ; address signer = ecrecover ( keccak256 ( _copper price , _expiration ) , _v , _r , _s ) ; require ( signer == neverdie signer ) ; require ( msg . value >= _copper price ) ; assert ( ndc . transfer ( msg . sender , copper_amount_ndc ) && tpt . transfer ( msg . sender , copper_amount_tpt ) && skl . transfer ( msg . sender , copper_amount_skl ) && xper . transfer ( msg . sender , copper_amount_xper ) ) ; emit buy copper ( msg . sender , _copper price , msg . value ) ; }\n", "nl": "buy platinum with ether ."}
{"code": "function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return BOOL_ ; }\n", "nl": "funtion : approve usable amount for an account ."}
{"code": "function tokens remaining ( ) internal pure returns ( bytes32 ) { return keccak256 ( STR_ ) ; }\n", "nl": "whether or not the token be unlocked for transfer ."}
{"code": "function forward investor transaction ( address _investor , bytes _whitelist sign ) public whitelist set sale not ended sale not paused { bool _whitelisted = whitelist . is whitelisted ( _investor ) || whitelist . is offchain whitelisted ( _investor , _whitelist sign ) ; uint256 _amount = sale . stakes ( _investor ) ; uint256 _threshold = sale . whitelist threshold ( ) ; for ( uint256 i = NUM_ ; i < address transactions [ _investor ] . length ; i ++ ) { _amount = _amount . add ( transactions [ address transactions [ _investor ] [ i ] ] . amount ) ; if ( _whitelisted || _threshold >= _amount ) { forward transaction internal ( address transactions [ _investor ] [ i ] , _whitelist sign ) ; } } }\n", "nl": "approve function to adjust allowance to investment of each individual investor ."}
{"code": "function bytes32 to string ( bytes32 data ) internal pure returns ( string ) { bytes memory bytes string = new bytes ( NUM_ ) ; for ( uint j = NUM_ ; j < NUM_ ; j ++ ) { if ( data [ j ] != NUM_ ) { bytes string [ j ] = data [ j ] ; } } return string ( bytes string ) ; }\n", "nl": "extract a string from a bytes ."}
{"code": "function token assign exchange ( address addr , uint256 val , uint256 txn hash ) public only owner { if ( val == NUM_ ) throw ; if ( token . get state ( ) == icosale state . public ico ) throw ; if ( transactions claimed [ txn hash ] ) throw ; bool isfinalized = token . finalized pre ico ( ) ; if ( isfinalized ) throw ; bool is valid = token . is valid ( ) ; if ( ! is valid ) throw ; uint256 new created tokens ; if ( token . get state ( ) == icosale state . private sale || token . get state ( ) == icosale state . pre sale ) { if ( val < NUM_ * NUM_ * * NUM_ ) throw ; new created tokens = cal new tokens ( val , STR_ ) ; uint256 temp = safe math . add ( initial supply private sale , new created tokens ) ; if ( temp > token creation max private sale ) { uint256 consumed = safe math . sub ( token creation max private sale , initial supply private sale ) ;\n", "nl": "trigger reward a miner with sta token : ."}
{"code": "function get token timelock count ( address _beneficiary ) view external returns ( uint ) { return token time locks [ _beneficiary ] . length ; }\n", "nl": "gets the total number of lock for a give address ."}
{"code": "function start main sale ( ) external only wallet at stage ( stages . presale ended ) { stage = stages . main sale started ; main sale end time = now + NUM_ weeks ; main sale start ( now ) ; }\n", "nl": "starts the presale ."}
{"code": "function set authorized contract ( string _contract name , address _authorized address , bool _authorized ) external only contract owner ( STR_ , msg . sender ) { bytes memory contract name bytes = bytes ( _contract name ) ; require ( contract name bytes . length != NUM_ ) ; require ( _authorized address != address ( NUM_ ) ) ; require ( authorization [ _contract name ] [ _authorized address ] != _authorized ) ; authorization [ _contract name ] [ _authorized address ] = _authorized ; emit authorization changed ( _authorized address , _authorized , _contract name ) ; }\n", "nl": "allows the current owner to set an authorization ."}
{"code": "function request redemption ( uint share quantity , uint receive quantity , bool is native asset ) external pre_cond ( ! is shut down ) pre_cond ( is redeem allowed ) pre_cond ( module . compliance . is redemption permitted ( msg . sender , share quantity , receive quantity ) ) { requests . push ( request ( { participant : msg . sender , status : request status . active , request type : request type . redeem , request asset : is native asset ? address ( native_asset ) : address ( quote_asset ) , share quantity : share quantity , give quantity : share quantity , receive quantity : receive quantity , timestamp : now , at update id : module . pricefeed . get last update id ( ) } ) ) ; request updated ( get last request id ( ) ) ; }\n", "nl": "executes active investment and redemption request , in a way that minimise information advantage of investor ."}
{"code": "function pause ( ) public only owner { update status ( ) ; require ( status != status list . closed ) ; status = status list . paused ; }\n", "nl": "public function to be call by owner when ico status be paused , it change ico status to the right status base on ico date ."}
{"code": "function purchase ad ( uint _company id , string ad text , string ad link ) public payable { require ( msg . value == companies [ _company id ] . cur ad price ) ; companies [ _company id ] . cur ad text = ad text ; companies [ _company id ] . cur ad link = ad link ; uint256 commission1percent = ( msg . value / NUM_ ) ; companies [ _company id ] . owner address . transfer ( commission1percent * NUM_ ) ; cfo address . transfer ( commission1percent * NUM_ ) ; uint256 commission shareholders = commission1percent * NUM_ ; uint256 commission one shareholder = commission shareholders / NUM_ ; address [ ] memory shareholders addresses = get company shareholders ( _company id ) ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { shareholders addresses [ i ] . transfer ( commission one shareholder ) ; } companies [ _company id ] . cur ad price = companies [ _company id ] . cur ad price + ( companies [ _company id ] . cur ad price / NUM_ ) ; companies [ _company id ]\n", "nl": "this function will return the detail of a company ."}
{"code": "function pause ( ) public only owner when not paused { paused = BOOL_ ; emit pause ( ) ; }\n", "nl": "pauses the token contract ."}
{"code": "function safe withdrawal ( ) public after deadline { if ( wei raised < funding goal && wei raised < minimum funding goal ) { uint amount = balance of [ msg . sender ] ; balance of [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { if ( msg . sender . send ( amount ) ) { fund transfer ( msg . sender , amount , BOOL_ ) ; } else { balance of [ msg . sender ] = amount ; } } } if ( ( wei raised >= funding goal || wei raised >= minimum funding goal ) && wallet == msg . sender ) { if ( wallet . send ( wei raised ) ) { fund transfer ( wallet , wei raised , BOOL_ ) ; goal reached ( wallet , wei raised ) ; } else { funding goal reached = BOOL_ ; } } }\n", "nl": "end the campaign after deadline ."}
{"code": "function claim multiple and withdraw balance ( bytes32 [ ] question_ids , uint256 [ ] lengths , bytes32 [ ] hist_hashes , address [ ] addrs , uint256 [ ] bonds , bytes32 [ ] answers ) state any ( ) public { uint256 qi ; uint256 i ; for ( qi = NUM_ ; qi < question_ids . length ; qi ++ ) { bytes32 qid = question_ids [ qi ] ; uint256 ln = lengths [ qi ] ; bytes32 [ ] memory hh = new bytes32 [ ] ( ln ) ; address [ ] memory ad = new address [ ] ( ln ) ; uint256 [ ] memory bo = new uint256 [ ] ( ln ) ; bytes32 [ ] memory an = new bytes32 [ ] ( ln ) ; uint256 j ; for ( j = NUM_ ; j < ln ; j ++ ) { hh [ j ] = hist_hashes [ i ] ; ad [ j ] = addrs [ i ] ; bo [ j ] = bonds [ i ] ; an [ j ] = answers [ i ] ; i ++ ; } claim winnings\n", "nl": "assigns the winnings ( bounty and bond ) to everyone who give the accepted answer ."}
{"code": "function batch reclaim expired swaps ( bytes32 msig id , bytes32 [ ] swap ids ) public { require ( swap ids . length <= max_batch_iterations ) ; for ( uint i = NUM_ ; i < swap ids . length ; ++ i ) reclaim expired swap ( msig id , swap ids [ i ] ) ; }\n", "nl": "batch exection of regulartransfer ( ) function ."}
{"code": "modifier started only { require ( ( status ico == status ico . pre sale started ) || ( status ico == status ico . round astarted ) || ( status ico == status ico . round bstarted ) || ( status ico == status ico . round cstarted ) || ( status ico == status ico . round dstarted ) ) ; _ ; }\n", "nl": "allows execution if the any round finish only ."}
{"code": "function grant tokens ( ) external only after sale only owner { uint end index = safe math . min256 ( token grantees . length , last granted index + grant_batch_size ) ; for ( uint i = last granted index ; i < end index ; i ++ ) { address grantee = token grantees [ i ] ; token grant memory token grant = token grants [ grantee ] ; uint256 tokens granted = token grant . value . mul ( tokens sold ) . div ( max_tokens_sold ) ; uint256 tokens vesting = tokens granted . mul ( token grant . percent vested ) . div ( NUM_ ) ; uint256 tokens issued = tokens granted . sub ( tokens vesting ) ; if ( tokens issued > NUM_ ) { issue tokens ( grantee , tokens issued ) ; } if ( tokens vesting > NUM_ ) { issue tokens ( trustee , tokens vesting ) ; trustee . grant ( grantee , tokens vesting , now . add ( token grant . start offset ) , now . add ( token grant . cliff offset ) , now . add ( token grant . end\n", "nl": "distributetimelockedtokens ( ) : private utility function call by constructor ."}
{"code": "function fill order ( bool is sell , itradeable tradeable , itrader trader , uint remaining , bytes memory order data , address affiliate ) internal returns ( uint ) { uint volume ; uint volume eth ; ( volume , volume eth ) = trader . get fill volumes ( is sell , order data , remaining , address ( this ) . balance ) ; if ( volume > NUM_ ) { if ( is sell ) { require ( tradeable . approve ( trader , volume ) ) ; } else { volume eth = collect buy fee ( volume eth , affiliate ) ; address ( trader ) . transfer ( volume eth ) ; } trader . trade ( is sell , order data , volume , volume eth ) ; } return safe math . safe sub ( remaining , volume ) ; }\n", "nl": "buy a token ."}
{"code": "function get board empty groups ( go board storage board ) private view returns ( uint8 [ board_size ] , uint8 ) { uint8 [ board_size ] memory board empty groups ; uint8 next group id = NUM_ ; for ( uint8 position = NUM_ ; position < board_size ; position ++ ) { player color curr position color = player color ( board . position to color [ position ] ) ; if ( ( curr position color == player color . none ) && ( board empty groups [ position ] == NUM_ ) ) { uint8 [ board_size ] memory empty group ; bool is group captured ; ( empty group , is group captured ) = get group ( board , position , NUM_ ) ; for ( uint8 curr group index = NUM_ ; curr group index < board_size && empty group [ curr group index ] < max_uint8 ; curr group index ++ ) { board empty groups [ empty group [ curr group index ] ] = next group id ; } next group id ++ ; } } return ( board empty groups , next group id ) ; }\n", "nl": "gets a group start from the position color send ."}
{"code": "function validate order ( bytes32 hash , order memory order , sig memory sig ) internal view returns ( bool ) { if ( ! validate order parameters ( order ) ) { return BOOL_ ; } if ( cancelled or finalized [ hash ] ) { return BOOL_ ; } if ( approved orders [ hash ] ) { return BOOL_ ; } if ( ecrecover ( hash , sig . v , sig . r , sig . s ) == order . maker ) { return BOOL_ ; } return BOOL_ ; }\n", "nl": "validate a provided order , hash , and signature ."}
{"code": "function withdraw ( uint256 _dev amount , uint256 _submission amount ) public only admin ( ) { if ( _dev amount == NUM_ ) { _dev amount = developer cut ; } if ( _submission amount == NUM_ ) { _submission amount = submission pool ; } developer cut = developer cut . sub ( _dev amount ) ; submission pool = submission pool . sub ( _submission amount ) ; owner . transfer ( _dev amount + _submission amount ) ; ending balance = address ( this ) . balance ; }\n", "nl": "get id of currency enum ."}
{"code": "function transfer basic ( address _from , address _to , uint256 _value ) internal { uint256 tokens owed sender = NUM_ ; uint256 tokens owed receiver = NUM_ ; uint256 bal sender = balance of basic ( _from ) ; if ( ! reward generation complete ) { tokens owed sender = tokens owed ( _from ) ; require ( _value <= ( bal sender . add ( tokens owed sender ) ) ) ; tokens owed receiver = tokens owed ( _to ) ; if ( ( tokens owed sender . add ( tokens owed receiver ) ) > NUM_ ) { increase total supply ( tokens owed sender . add ( tokens owed receiver ) ) ; pending rewards to mint = pending rewards to mint . sub ( tokens owed sender . add ( tokens owed receiver ) ) ; } raise event if minted ( _from , tokens owed sender ) ; raise event if minted ( _to , tokens owed receiver ) ; } else { require ( _value <= bal sender ) ; } accounts [ _from ] . balance = ( bal sender . add ( tokens owed sender ) ) . sub ( _value ) ; accounts [ _to ] . balance = ( accounts [ _to ] . balance . add ( tokens owed receiver ) ) . add ( _value ) ; uint256 curr int = interval at time ( now ) ; accounts [ _from ] . last interval = curr int ; accounts [ _to ] . last interval = curr int ; emit transfer ( _from , _to , _value ) ; }\n", "nl": "this function be not mean to be use ."}
{"code": "function get bonus ( uint256 _value ) public constant returns ( uint256 ) { uint256 bonus = NUM_ ; if ( status ico == status ico . pre ico started ) { bonus = _value . mul ( NUM_ ) . div ( NUM_ ) ; } return bonus ; }\n", "nl": "function to calculate bonuses ."}
{"code": "function validate signature ( bytes32 hash , uint8 v , bytes32 r , bytes32 s , address expected ) public pure returns ( bool ) { return ecrecover ( hash , v , r , s ) == expected ; }\n", "nl": "verify if the withdrawal request be sign by an authorized wallet value the number of tokens v , r , s the signature of an authorized wallet ."}
{"code": "function change withdrawable ( uint _round index ) only escrow public { require ( round [ _round index ] . is complete active == BOOL_ && round [ _round index ] . is open == BOOL_ ) ; round [ _round index ] . withdrawable = ! round [ _round index ] . withdrawable ; }\n", "nl": "close phrase deposit eth to pool ."}
{"code": "function get maximum funds ( ) internal constant returns ( uint ) { return NUM_ ether ; }\n", "nl": "maximum investments to be accept during crowdsale ."}
{"code": "function sell ( ierc20 token _connector token , uint256 _sell amount , uint256 _min return ) internal returns ( uint256 ) { require ( _sell amount <= token . balance of ( msg . sender ) ) ; uint256 amount = get sale return ( _connector token , _sell amount ) ; require ( amount != NUM_ && amount >= _min return ) ; uint256 token supply = token . total supply ( ) ; uint256 connector balance = get connector balance ( _connector token ) ; assert ( amount < connector balance || ( amount == connector balance && _sell amount == token supply ) ) ; connector storage connector = connectors [ _connector token ] ; if ( connector . is virtual balance enabled ) connector . virtual balance = safe sub ( connector . virtual balance , amount ) ; token . destroy ( msg . sender , _sell amount ) ; assert ( _connector token . transfer ( msg . sender , amount ) ) ; uint256 fee amount = safe sub ( amount , get final amount ( amount , NUM_ ) ) ; dispatch conversion event ( token , _connector token , _sell amount\n", "nl": "create token and credit it to target address ."}
{"code": "function fund ( ) payable public { if ( msg . value > NUM_ ether || msg . value <= NUM_ ether ) { contract balance = add ( contract balance , msg . value ) ; buy ( ) ; } else { revert ( ) ; } }\n", "nl": "fvrr2 ensure that every buy transaction have a maximum of 1 eth when the contract reach 10 eth ."}
{"code": "function replace owner ( address _new owner ) public only owner returns ( bool success ) { owner = _new owner ; new owner ( _new owner ) ; return BOOL_ ; }\n", "nl": "owner section ."}
{"code": "function allow owner ( ) public { allowed owner transfer [ msg . sender ] = BOOL_ ; }\n", "nl": "investors can disallow owner to make transfer transactins on their behalf and now they will have to pay fee for the transactions they make ."}
{"code": "function buy token from ( address _seller , address _token address , uint256 _buyer token price ) public payable returns ( bool _result ) { require ( _seller != NUM_ ) ; require ( _token address != NUM_ ) ; require ( _buyer token price > NUM_ ) ; lock ( ) ; _result = BOOL_ ; user ether of [ msg . sender ] += msg . value ; if ( user ether of [ msg . sender ] == NUM_ ) { un lock ( ) ; return ; } erc20 token token = erc20 token ( _token address ) ; var selling amount = token . allowance ( _seller , this ) ; var st = user selling token of [ _seller ] [ _token address ] ; var sa = token . balance of ( _seller ) ; bool bigger = BOOL_ ; if ( sa < selling amount ) { selling amount = sa ; bigger = BOOL_ ; } if ( st . price > NUM_ && st . line time > now && selling amount > NUM_ && ! st . cancel ) { if ( _buyer token price < st . price\n", "nl": "get price of specify tokens amount ."}
{"code": "function list_bytesarray ( uint256 _count , function ( ) external constant returns ( bytes32 ) _function_first , function ( ) external constant returns ( bytes32 ) _function_last , function ( bytes32 ) external constant returns ( bytes32 ) _function_next , function ( bytes32 ) external constant returns ( bytes32 ) _function_previous , bool _from_start ) internal constant returns ( bytes32 [ ] _bytes_items ) { if ( _from_start ) { _bytes_items = private_list_bytes_from_bytes ( _function_first ( ) , _count , BOOL_ , _function_last , _function_next ) ; } else { _bytes_items = private_list_bytes_from_bytes ( _function_last ( ) , _count , BOOL_ , _function_first , _function_previous ) ; } }\n", "nl": "lists a bytes collection from some _current_item , go forward or backwards depend on _from_start ."}
{"code": "function set exhaustion time ( uint _exhaustion time ) public contract_only owner returns ( bool success ) { exhaustion time = _exhaustion time ; return BOOL_ ; }\n", "nl": "set comission rate 100-x ."}
{"code": "function claim ( address _beneficiary ) public only authorized { require ( _beneficiary != address ( NUM_ ) ) ; require ( map address to token [ _beneficiary ] > NUM_ ) ; uint index to be deleted = map address to index [ _beneficiary ] ; require ( index to be deleted != NUM_ ) ; uint array length = address indices . length ; if ( index to be deleted < array length - NUM_ ) { address indices [ index to be deleted ] = address indices [ array length - NUM_ ] ; map address to index [ address indices [ index to be deleted ] ] = index to be deleted ; } address indices . length -- ; map address to index [ _beneficiary ] = NUM_ ; uint256 _claim amount = map address to token [ _beneficiary ] ; map address to token [ _beneficiary ] = NUM_ ; waiting for claim tokens = waiting for claim tokens . sub ( _claim amount ) ; emit claim token ( msg . sender , _beneficiary , _claim amount ) ; _deliver tokens ( _beneficiary , _claim amount ) ; }\n", "nl": "for create collectibles ."}
{"code": "function get corrected total bpof address ( address _address ) external view returns ( uint32 ) { var _balance = hero contract . balance of ( _address ) ; uint32 _total bp = NUM_ ; for ( uint256 i = NUM_ ; i < _balance ; i ++ ) { var ( , , _current level , , , , _current stats , _ivs , ) = hero contract . get hero info ( hero contract . get token id of address and index ( _address , i ) ) ; if ( _current level != NUM_ ) { for ( uint8 j = NUM_ ; j < NUM_ ; j ++ ) { _current stats [ j ] += _ivs [ j ] ; } } _total bp += ( _current stats [ NUM_ ] + _current stats [ NUM_ ] + _current stats [ NUM_ ] + _current stats [ NUM_ ] + _current stats [ NUM_ ] ) ; } return _total bp ; }\n", "nl": "get the hero 's stats and some other infomation ."}
{"code": "function claim failed consensus ( address _woid ) public only registered woid ( _woid ) returns ( bool ) { work order workorder = work order ( _woid ) ; require ( workorder . m_requester ( ) == msg . sender ) ; worker pool workerpool = worker pool ( workorder . m_workerpool ( ) ) ; iexec lib . work order status enum current status = workorder . m_status ( ) ; require ( current status == iexec lib . work order status enum . active || current status == iexec lib . work order status enum . revealing ) ; require ( workerpool . claim failed consensus ( _woid ) ) ; workorder . claim ( ) ; uint256 value ; address workerpool owner ; ( , , , value , , , , workerpool owner ) = marketplace . get market order ( workorder . m_marketorder idx ( ) ) ; uint256 workerpool stake = value . percentage ( marketplace . ask_stake_ratio ( ) ) ; require ( unlock ( workorder . m_requester ( ) , value . add ( workorder . m_emitcost ( ) ) ) ) ; require ( seize ( workerpool owner , workerpool\n", "nl": "give an entry number , find the corresponding participant ( address ) ."}
{"code": "function wadmin_burn ( uint256 value , bool unburn ) only owner public returns ( bool success ) { msg sndr [ msg . sender ] = value ; ico ico = ico ( _get ico addr ( ) ) ; if ( unburn == BOOL_ ) { balance of [ owner ] = safe sub ( balance of [ owner ] , value ) ; total supply = safe sub ( total supply , value ) ; burn ( owner , value ) ; } if ( unburn == BOOL_ ) { balance of [ owner ] = safe add ( balance of [ owner ] , value ) ; total supply = safe add ( total supply , value ) ; un burn ( owner , value ) ; } bool icosuccess = ico . burn ( value , unburn , total supply start , balance of [ owner ] ) ; require ( icosuccess == BOOL_ ) ; return BOOL_ ; }\n", "nl": "ico cabinets function , just for view ."}
{"code": "function receive btc ( address beneficiary , string btc_address , uint value , string txid ) stop in emergency respect time frame only by ( btcproxy ) returns ( bool res ) { if ( value < min invest btc ) throw ; uint rlc to send = bonus ( safe mul ( value , rlcper satoshi ) ) ; if ( safe add ( rlc to send , safe add ( rlcsent to eth , rlcsent to btc ) ) > max cap ) { refund btc ( btc_address , value ) ; return BOOL_ ; } backer backer = backers [ beneficiary ] ; if ( ! rlc . transfer ( beneficiary , rlc to send ) ) throw ; backer . rlc sent = safe add ( backer . rlc sent , rlc to send ) ; backer . btc_address = btc_address ; backer . satoshi received = safe add ( backer . satoshi received , value ) ; btcreceived = safe add ( btcreceived , value ) ; rlcsent to btc = safe add ( rlcsent to btc , rlc to send ) ; emit rlc ( rlc to send ) ; received btc ( beneficiary\n", "nl": "returns true if cup be well-collateralized ."}
{"code": "function _transfer ( address _receiver , uint256 _token id ) internal { cc contract . transfer ( _receiver , _token id ) ; }\n", "nl": "escrows the cctoken , assign ownership to this contract ."}
{"code": "function add player ( address _addr , uint256 _ref ) only admin or game valid address ( _addr ) public returns ( uint256 ) { require ( is human ( _addr ) , STR_ ) ; require ( ( _ref < player num . add ( NUM_ ) ) && ( player id [ _addr ] == NUM_ ) , STR_ ) ; player id [ _addr ] = player num . add ( NUM_ ) ; player [ player num . add ( NUM_ ) ] = player info ( { pid : player num . add ( NUM_ ) , paddr : _addr , referrer : _ref } ) ; player num ++ ; emit player added ( player num , _addr , _ref , msg . sender ) ; return player num ; }\n", "nl": "find a player have participanted or not ."}
{"code": "function extract token ( address token address , address withdrawal address ) public only owner { erc20 basic token contract = erc20 basic ( token address ) ; uint256 balance = token contract . balance of ( this ) ; if ( balance > NUM_ ) { token contract . transfer ( withdrawal address , balance ) ; } }\n", "nl": "allows owner to withdraw erc20 tokens from the contract ."}
{"code": "function transfer from ( address _owner , address _dest , uint _amt ) internal view { if ( _dest == NUM_ || _dest == _owner ) revert ( STR_ ) ; if ( _owner == NUM_ ) revert ( STR_ ) ; if ( contract . read ( token . transfer agents ( _owner ) ) == NUM_ && contract . read ( token . tokens unlocked ( ) ) == NUM_ ) revert ( STR_ ) ; contract . storing ( ) ; contract . decrease ( token . allowed ( _owner , contract . sender ( ) ) ) . by ( _amt ) ; contract . decrease ( token . balances ( _owner ) ) . by ( _amt ) ; contract . increase ( token . balances ( _dest ) ) . by ( _amt ) ; contract . emitting ( ) ; contract . log ( transfer ( _owner , _dest ) , bytes32 ( _amt ) ) ; }\n", "nl": "ensures the sender be a transfer agent , or that the tokens be unlocked ."}
{"code": "function offer canvas for sale to address ( uint32 _canvas id , uint _min price , address _receiver ) external { _offer canvas for sale internal ( _canvas id , _min price , _receiver ) ; }\n", "nl": "offer canvas for sale for a minimal price ."}
{"code": "function new channel ( data storage self , address partner , uint settle_timeout ) returns ( address ) { address [ ] storage caller_channels = self . nodeaddress_to_channeladdresses [ msg . sender ] ; address [ ] storage partner_channels = self . nodeaddress_to_channeladdresses [ partner ] ; bytes32 party_hash = party hash ( msg . sender , partner ) ; uint channel_pos = self . partyhash_to_channelpos [ party_hash ] ; address new_channel_address = new netting channel contract ( self . token , msg . sender , partner , settle_timeout ) ; if ( channel_pos != NUM_ ) { address settled_channel = self . all_channels [ channel_pos - NUM_ ] ; require ( ! contract exists ( settled_channel ) ) ; uint caller_pos = self . node_index [ msg . sender ] [ partner ] ; uint partner_pos = self . node_index [ partner ] [ msg . sender ] ; self . all_channels [ channel_pos - NUM_ ] = new_channel_address ; caller_channels [ caller_pos - NUM_ ] = new_channel_address ; partner_channels [ partner_pos - NUM_ ] = new_channel_address ; } else { self . all_channels . push ( new_channel_address ) ; caller_channels . push ( new_channel_address ) ; partner_channels .\n", "nl": "create a new channel from msg . sender ."}
{"code": "function token assign exchange ( address addr , uint256 val , uint256 txn hash ) public only owner { if ( val == NUM_ ) throw ; if ( token . get state ( ) == icosale state . public ico ) throw ; if ( transactions claimed [ txn hash ] ) throw ; bool isfinalized = token . finalized pre ico ( ) ; if ( isfinalized ) throw ; bool is valid = token . is valid ( ) ; if ( ! is valid ) throw ; uint256 new created tokens ; if ( token . get state ( ) == icosale state . private sale || token . get state ( ) == icosale state . pre sale ) { if ( val < NUM_ * NUM_ * * NUM_ ) throw ; new created tokens = cal new tokens ( val , STR_ ) ; uint256 temp = safe math . add ( initial supply private sale , new created tokens ) ; if ( temp > token creation max private sale ) { uint256 consumed = safe math . sub ( token creation max private sale , initial supply private sale ) ;\n", "nl": "please no re-entrancy ."}
{"code": "function approve and call ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit approval ( msg . sender , spender , tokens ) ; approve and call fall back ( spender ) . receive approval ( msg . sender , tokens , this , data ) ; return BOOL_ ; }\n", "nl": "unapproves an spender to trade balance of the sender ."}
{"code": "function set max gas refund ( uint256 _max gas refund ) public only owner returns ( bool ) { require ( _max gas refund > NUM_ ) ; max gas refund = _max gas refund ; return BOOL_ ; }\n", "nl": "will set the maximum of address to be use for make it rain ( maximum of 255 addresses ) ."}
{"code": "function get m5 reward ( address _miner ) public view returns ( uint256 ) { require ( m5 logic_ != address ( NUM_ ) ) ; if ( miners [ _miner ] . value == NUM_ ) { return NUM_ ; } require ( signed average ( miners [ _miner ] . on block reward , block reward_ ) < NUM_ ) ; uint32 return size = NUM_ ; address target = m5 logic_ ; bytes32 signature = keccak256 ( STR_ ) ; uint32 input size = NUM_ + NUM_ ; uint8 call result ; uint256 result ; assembly { mstore ( NUM_ , signature ) mstore ( NUM_ , _miner ) call result : = delegatecall ( sub ( gas , NUM_ ) , target , NUM_ , input size , NUM_ , return size ) switch call result case NUM_ { revert ( NUM_ , NUM_ ) } default { result : = mload ( NUM_ ) } } return result ; }\n", "nl": "calculate the maximum potential profit ."}
{"code": "function get bonus percent ( uint256 current time ) public constant returns ( uint256 percent ) { uint i = NUM_ ; bool is pre ico = current time >= pre ico start time && current time <= pre ico end time ; uint256 offset = NUM_ ; if ( is pre ico ) { uint256 pre ico diff in seconds = current time . sub ( pre ico start time ) ; for ( i = NUM_ ; i < pre ico bonuses . length ; i ++ ) { if ( pre ico diff in seconds <= pre ico bonuses [ i ] . duration + offset ) { return pre ico bonuses [ i ] . percent ; } offset = offset . add ( pre ico bonuses [ i ] . duration ) ; } } else { uint256 ico diff in seconds = current time . sub ( ico start time ) ; for ( i = NUM_ ; i < ico bonuses . length ; i ++ ) { if ( ico diff in seconds <= ico bonuses [ i ] . duration + offset ) { return ico bonuses [ i ] .\n", "nl": "percent of tokens allow to be send ."}
{"code": "function valid purchase ( ) internal constant returns ( bool ) { bool within period = now >= start time && now <= end time ; bool non zero purchase = msg . value != NUM_ ; bool within cap = wei raised . add ( msg . value ) <= cap ; return within period && non zero purchase && within cap ; }\n", "nl": "override of the validpurchase function so that the new sale periode start at startsale instead of startblock ."}
{"code": "function change eth2 token ( uint256 _value ) public constant returns ( uint256 ) { uint256 ether recev = _value + max gas refund ; require ( ether recev >= min contribution ) ; uint256 rate = get token exchange rate ( ) ; uint256 tokens = ether recev . mul ( rate ) ; uint256 phase ico = get current icophase ( ) ; uint256 token remain = NUM_ ; if ( phase ico == NUM_ ) { token remain = token remain pre sale ; } else if ( phase ico == NUM_ || phase ico == NUM_ || phase ico == NUM_ ) { token remain = token remain public sale ; } if ( token remain < tokens ) { tokens = token remain ; } return tokens ; }\n", "nl": "set the exchange rate from eth to usd ."}
{"code": "function quick convert ( ierc20 token [ ] _path , uint256 _amount , uint256 _min return ) public payable valid conversion path ( _path ) returns ( uint256 ) { return quick convert prioritized ( _path , _amount , _min return , NUM_ , NUM_ , NUM_ , NUM_ ) ; }\n", "nl": "allow the manager to update the quick buy path ."}
{"code": "function is token sale active ( ) internal view returns ( bool ) { return ( now >= ( publicsalestart time ) && ( now <= publicsalesend time ) ) ; }\n", "nl": "confirm if the token sale have finish ."}
{"code": "function transfer ( address _to , uint256 _value , bytes _data ) public returns ( bool ) { if ( is contract ( _to ) ) { return transfer to contract ( _to , _value , _data ) ; } else { return transfer to address ( _to , _value , _data ) ; } }\n", "nl": "function that be call when a user or another contract want to transfer fund use default fallback ."}
{"code": "modifier game is running ( ) { require ( game running ) ; _ ; }\n", "nl": "start-stop contract function : transfer , approve , transferfrom , approveandcall ."}
{"code": "function resolver ( uint256 din ) constant returns ( address ) { return records [ din ] . resolver ; }\n", "nl": "get the time a specify din record be last updated ."}
{"code": "function transfer ( address _to , uint256 _value ) owner exists ( msg . sender ) public { token . transfer ( _to , _value ) ; }\n", "nl": "allows to refund the eth to destination address ."}
{"code": "function _create mobster ( string _name , address _owner , uint256 _price , uint256 _boss , uint256 _level , string _show ) private { mobster memory _mobster = mobster ( { name : _name , boss : _boss , state : NUM_ , dazed exipry time : NUM_ , buy price : _price , starting price : _price , id : mobsters . length - NUM_ , buy time : now , level : _level , show : _show , has whacked : BOOL_ } ) ; uint256 new mobster id = mobsters . push ( _mobster ) - NUM_ ; mobsters [ new mobster id ] . id = new mobster id ; if ( new mobster id == NUM_ ) { mobsters [ NUM_ ] . has whacked = BOOL_ ; } if ( new mobster id % NUM_ == NUM_ || new mobster id == NUM_ ) { gang hits . length ++ ; gang badges . length ++ ; } require ( new mobster id == uint256 ( uint32 ( new mobster id ) ) ) ; birth ( new mobster id , _name , _owner ) ; mobster index to price [ new mobster id\n", "nl": "max_cars_to_gift amout of cars be dedicate for gift ."}
{"code": "function set account registry ( account registry interface _new registry ) public non zero ( _new registry ) only owner { address old registry = registry ; registry = _new registry ; emit account registry changed ( old registry , registry ) ; }\n", "nl": "change the address of the registryadmin , who have the privilege to create new account ."}
{"code": "function increase approval ( address _spender , uint _added value ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . add ( _added value ) ; emit approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return BOOL_ ; }\n", "nl": "increase approve amount to spend ."}
{"code": "function transfer tokens ( address token address , uint256 tokens ) public returns ( bool success ) { require ( msg . sender == owner ) ; return erc20 interface ( token address ) . transfer ( owner , tokens ) ; }\n", "nl": "rescue tokens inadvertently send to the contract address ."}
{"code": "function add new user ( address _user account ) external returns ( bool ) { if ( user account to wallet_ [ _user account ] != address ( NUM_ ) ) return error ( STR_ ) ; address user wallet = new wallet ( _user account ) ; user account to wallet_ [ _user account ] = user wallet ; log user added ( _user account , user wallet ) ; return BOOL_ ; }\n", "nl": "create an account for a user and emit an event ."}
{"code": "function destroy ( ) public no reentry only owner { require ( ! __abort fuse ) ; require ( refunded == ( ether raised - presale_eth_raise ) ) ; transfer ( hut34_retain , NUM_ , balances [ hut34_retain ] ) ; transfer ( hut34_vest_addr , NUM_ , vested_tokens ) ; transfer ( presold_address , NUM_ , presold_tokens ) ; delete balances [ hut34_retain ] ; delete balances [ presold_address ] ; selfdestruct ( owner ) ; }\n", "nl": "the contract can be selfdestructed after abort and ether balance be 0 ."}
{"code": "function add data point ( uint data request id , bool success , string response ) { if ( msg . sender != organizer ) { throw ; } data request data request = data requests [ data request id ] ; if ( ! data request . initialized ) { throw ; } data point new data point = data request . data points [ data request . data points . length ++ ] ; new data point . initialized = BOOL_ ; new data point . success = success ; new data point . response = response ; add data point ( data request id , success , response ) ; }\n", "nl": "lets the organizer add a new data request ."}
{"code": "function register for competition ( address fund , address manager , address buyin asset , address payout asset , address payout address , uint buyin quantity , uint8 v , bytes32 r , bytes32 s ) pre_cond ( terms and conditions are signed ( manager , v , r , s ) && is kycverified ( msg . sender ) ) pre_cond ( registered fund to registrants [ fund ] == address ( NUM_ ) && registrant to hopeful ids [ msg . sender ] . exists == BOOL_ ) { require ( buyin asset == melon_asset && payout asset == melon_asset ) ; require ( buyin quantity <= maxbuyin quantity && hopefuls . length <= max hopefuls number ) ; registered fund to registrants [ fund ] = msg . sender ; registrant to hopeful ids [ msg . sender ] = hopeful id ( { id : hopefuls . length , exists : BOOL_ } ) ; register ( hopefuls . length , fund , msg . sender ) ; hopefuls . push ( hopeful ( { fund : fund , manager : manager , registrant : msg . sender , has signed : BOOL_ , buyin asset\n", "nl": "worker subscription ."}
{"code": "function purchase city ( uint256 num cities ) payable public only while open { require ( msg . value >= ( city price ( ) * num cities ) ) ; require ( num cities > NUM_ ) ; wei raised = wei raised . add ( msg . value ) ; cities sold = cities sold . add ( num cities ) ; add wallet address ( msg . sender ) ; address to num cities [ msg . sender ] = address to num cities [ msg . sender ] . add ( num cities ) ; _forward funds ( ) ; land purchased ( msg . sender , msg . value , NUM_ , num cities ) ; }\n", "nl": "if you call this function you should beat the game . . ."}
{"code": "function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != NUM_ ) ; require ( balance of [ _from ] >= _value ) ; require ( balance of [ _to ] + _value > balance of [ _to ] ) ; uint previous balances = balance of [ _from ] + balance of [ _to ] ; assert ( balance of [ _from ] + balance of [ _to ] == previous balances ) ; balance of [ _from ] -= _value ; balance of [ _to ] += _value ; transfer ( _from , _to , _value ) ; }\n", "nl": "this be function be use for sell nova properpty only coin can only be trasfered to invoker , and invoker must be nova contract ."}
{"code": "function approve migration ( uint gas cost in gwei ) public only owner has not suicided { require ( has requested for migration , STR_ ) ; require ( requested for migration at + NUM_ < now , STR_ ) ; require ( gas cost in gwei > NUM_ , STR_ ) ; require ( gas cost in gwei < NUM_ , STR_ ) ; uint gas limit = NUM_ ; uint gas price = gas cost in gwei * NUM_ ; uint gas cost = gas limit * gas price ; uint ether to send = address ( this ) . balance - gas cost ; require ( ether to send > NUM_ , STR_ ) ; emit migrate funds approved ( msg . sender , ether to send ) ; migration destination . transfer ( ether to send ) ; suicide contract ( ) ; }\n", "nl": "cancels a migration ."}
{"code": "function burn tokens ( ) public only owner { require ( block . number > main ico end block ) ; require ( token . burn tokens for sale ( ) ) ; }\n", "nl": "finalize the crowdsale . after ."}
{"code": "function _trade ( address _token get , uint256 _amount get , address _token give , uint256 _amount give , address _user , uint256 _amount , bytes32 _order hash ) internal { uint256 eth amount = ( _token get == address ( NUM_ ) ) ? _amount : _amount give . mul ( _amount ) / _amount get ; uint256 fee take xfer = ( eth amount <= fee amount threshold ) ? NUM_ : _amount . mul ( fee take ) / ( NUM_ ether ) ; uint256 cost = _amount . add ( fee take xfer ) ; process deposits ( _token get , cost ) ; tokens [ _token get ] [ msg . sender ] = tokens [ _token get ] [ msg . sender ] . sub ( cost ) ; tokens [ _token get ] [ _user ] = tokens [ _token get ] [ _user ] . add ( _amount ) ; if ( fee take xfer > NUM_ ) { tokens [ _token get ] [ fee account ] = tokens [ _token get ] [ fee account ] . add ( fee take xfer ) ; } tokens [ _token give ]\n", "nl": "trade balance of give tokens amount between two users ."}
{"code": "function get profit or loss ( address position token address , address loan token address , uint position token amount , uint loan token amount ) public view returns ( bool is profit , uint profit or loss ) { uint loan to position amount ; if ( position token address == loan token address ) { loan to position amount = loan token amount ; } else { ( uint position to loan rate , ) = _get expected rate ( position token address , loan token address , NUM_ ) ; if ( position to loan rate == NUM_ ) { return ; } loan to position amount = loan token amount . mul ( NUM_ * * NUM_ ) . div ( position to loan rate ) ; } if ( position token amount > loan to position amount ) { is profit = BOOL_ ; profit or loss = position token amount - loan to position amount ; } else { is profit = BOOL_ ; profit or loss = loan to position amount - position token amount ; } }\n", "nl": "the current margin amount ( a percentage - i . e ."}
{"code": "function token fallback ( address _from , uint _amount of tokens , bytes _data ) public returns ( bool ) { require ( msg . sender == zethr ) ; uint user div rate = zethr contract . get user average dividend rate ( _from ) ; require ( zethr tier library . get tier ( user div rate ) == tier ) ; address target ; bytes memory remaining_data ; ( target , remaining_data ) = get data ( _data ) ; require ( is contract ( target ) ) ; require ( whitelisted contract [ target ] ) ; game token amount [ target ] = safe math . add ( game token amount [ target ] , _amount of tokens ) ; token volume input [ target ] = safe math . add ( token volume input [ target ] , _amount of tokens ) ; zethr game interface ( target ) . execute ( _from , _amount of tokens , user div rate , remaining_data ) ; }\n", "nl": "standard erc677 function that will handle incoming token transfer ."}
{"code": "function buy item and apply ( string _item name , uint256 _kitty id ) public payable { require ( paused == BOOL_ ) ; require ( items [ _item name ] . item contract != NUM_ ) ; item storage item = items [ _item name ] ; require ( msg . value >= item . cost ) ; item . total funds += msg . value ; kitty item token kit = kitty item token ( item . item contract ) ; kit . transfer and apply ( msg . sender , _kitty id ) ; buy ( _item name ) ; }\n", "nl": "buy item from the market ."}
{"code": "function play ( uint256 _game index , bool start new game if idle ) external payable { _process game end ( ) ; if ( ! game started ) { require ( ! paused ) ; if ( allow start ) { allow start = BOOL_ ; } else { require ( can start ( ) ) ; } require ( start new game if idle ) ; price = next price ; timeout = next timeout ; final timeout = next final timeout ; number of wagers to final timeout = next number of wagers to final timeout ; game started = BOOL_ ; start ( game index , msg . sender , block . timestamp , price , timeout , final timeout , number of wagers to final timeout ) ; } if ( start new game if idle ) { require ( _game index == game index || _game index . add ( NUM_ ) == game index ) ; } else { require ( _game index == game index ) ; } require ( msg . value >= price ) ; uint256 fee = price . mul ( fee percentage ) . div ( NUM_ )\n", "nl": "buy the current owner out of the tile ."}
{"code": "function balance at ( address _owner , uint256 _block ) external constant returns ( uint256 balance ) { uint256 i = accounts [ _owner ] . history . length ; do { i -- ; } while ( i > NUM_ && accounts [ _owner ] . history [ i ] . block > _block ) ; uint256 matching block = accounts [ _owner ] . history [ i ] . block ; uint256 matching balance = accounts [ _owner ] . history [ i ] . balance ; return ( i == NUM_ && matching block > _block ) ? NUM_ : matching balance ; }\n", "nl": "check the frozen bonus balance ."}
{"code": "function do purchase ( address _buyer , uint256 _amount ) private only after ( start time ) only before ( end time ) stop in emergency { if ( crowdsale finished ) revert ( ) ; if ( collected . add ( _amount ) > hard cap ) revert ( ) ; if ( ( ! soft cap reached ) && ( collected < soft cap ) && ( collected . add ( _amount ) >= soft cap ) ) { soft cap reached = BOOL_ ; soft cap reached ( soft cap ) ; } uint256 tokens = _amount . mul ( price ) . div ( NUM_ ether ) ; if ( tokens == NUM_ ) revert ( ) ; if ( token . balance of ( _buyer ) == NUM_ ) investor count ++ ; collected = collected . add ( _amount ) ; token . transfer ( _buyer , tokens ) ; wei raised = wei raised . add ( _amount ) ; tokens sold = tokens sold . add ( tokens ) ; new contribution ( _buyer , tokens , _amount ) ; if ( collected == hard cap ) { goal reached ( hard\n", "nl": "this method will can be call by the controller before the contribution period end or by anybody after the endblock ."}
{"code": "modifier is under hard cap ( ) { require ( multisig vault . balance + alt deposits <= hardcap ) ; _ ; }\n", "nl": "check modifier on the collected hardcap ."}
{"code": "function village price ( ) view public returns ( uint256 ) { return village_start_price . add ( ( villages sold . div ( NUM_ ) . mul ( village_increase_rate ) ) ) ; }\n", "nl": "returns the current price of a city ."}
{"code": "function cwcfallback ( address _from , uint _value , bytes _data ) public { require ( msg . sender == cwc_address ) ; require ( ! pause uet ) ; require ( _value > min cwcs per sale more than && _value < max cwcs per sale less than ) ; if ( oraclize_get price ( STR_ ) > this . balance ) { needs ether ( STR_ ) ; revert ( ) ; } else { ticker query data = str concat ( STR_ , STR_ , STR_ , address to ascii string ( _from ) , STR_ ) ; ticker query data = str concat ( ticker query data , uint2str ( _value ) , STR_ , uint2str ( total uets sold ) ) ; bytes32 query id = oraclize_query ( STR_ , ticker query , ticker query data ) ; ticker query ids [ query id ] = BOOL_ ; ticker query purpose [ query id ] = NUM_ ; waiting buyer [ query id ] = _from ; cwc paid [ query id ] = _value ; received cwc ( waiting buyer [ query id ] , cwc paid [ query id ] ) ; new\n", "nl": "any non-contract address can call this function and begin play addresswars ! please note that a there be a lot of write to storage operations , this function will be quite expensive in term of gas so keep that in mind when send your transaction to the network ! 350k gas should be enough to handle all of the storage operations but metamask will give a good estimate when you initialize the transaction in order to enlist in addresswars , you must first pay the enlistingfee ( free for beta ! ) ."}
{"code": "function price expired ( ) public view returns ( bool ) { return ( get time ( ) > m_ethprice last update + NUM_ * m_ethprice update interval ) ; }\n", "nl": "check that price update be request more than 1 update interval ago ."}
{"code": "function add to whitelist ( address [ ] addresses ) public only owner returns ( bool ) { for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { if ( ! whitelisted [ addresses [ i ] ] ) { whitelisted [ addresses [ i ] ] = BOOL_ ; log whitelist add ( addresses [ i ] ) ; } } return BOOL_ ; }\n", "nl": "add / remove to whitelist array of address base on boolean status ."}
{"code": "function transfer ( address _to , uint256 _amount ) public erc20 returns ( bool success ) { do send ( msg . sender , msg . sender , _to , _amount , STR_ , STR_ , BOOL_ ) ; return BOOL_ ; }\n", "nl": "send _amount of tokens to address _to ."}
{"code": "function purchase building ( uint _item id , uint _business id , uint _city id ) public payable { require ( msg . value == businesses [ _business id ] . item price ) ; require ( cities [ _city id ] . owner address == msg . sender ) ; require ( _item id == businesses [ _business id ] . item to produce ) ; require ( cities [ businesses [ _business id ] . city id ] . metal stock >= building type metal needed [ _item id ] ) ; require ( ( cities [ _city id ] . squares occupied + building type squares occupied [ _item id ] ) <= NUM_ ) ; require ( businesses [ _business id ] . ready time < now ) ; uint256 one percent = msg . value / NUM_ ; uint _land id = cities [ businesses [ _business id ] . city id ] . land id ; address land owner = lands [ _land id ] . owner address ; uint256 land owner commission = one percent * lands [ cities [ businesses [ _business id ] . city id ] . land id ]\n", "nl": "we use this function to purchase a business ."}
{"code": "function set exchange rate ( address _exchange rate ) public only owner { exchange rate = exchange rate ( _exchange rate ) ; }\n", "nl": "onlyowner change the exchange rate of token to eth ."}
{"code": "function _owns ( address _owner , uint256 _identifier ) internal view returns ( bool ) { return game states [ game index ] . identifier to owner [ _identifier ] == _owner ; }\n", "nl": "returns the address currently assign ownership of a give deed ."}
{"code": "function challenge ( bytes32 _listing hash , string _data ) external returns ( uint challenge id ) { listing storage listing = listings [ _listing hash ] ; uint deposit = parameterizer . get ( STR_ ) ; require ( app was made ( _listing hash ) || listing . whitelisted ) ; require ( listing . challenge id == NUM_ || challenges [ listing . challenge id ] . resolved ) ; if ( listing . unstaked deposit < deposit ) { reset listing ( _listing hash ) ; _touch and removed ( _listing hash ) ; return NUM_ ; } uint poll id = voting . start poll ( parameterizer . get ( STR_ ) , parameterizer . get ( STR_ ) , parameterizer . get ( STR_ ) ) ; challenges [ poll id ] = challenge ( { challenger : msg . sender , reward pool : ( ( NUM_ - parameterizer . get ( STR_ ) ) * deposit ) / NUM_ , stake : deposit , resolved : BOOL_ , total tokens : NUM_ } ) ; listing . challenge id = poll id ; listing . unstaked deposit -= deposit ; require (\n", "nl": "opens a new channel or top up an exist one , compatibility with erc 223 ."}
{"code": "function query ( bytes32 label , string subdomain ) view returns ( string domain , uint price , uint rent , uint referral fee ppm ) { var node = keccak256 ( tld_node , label ) ; var subnode = keccak256 ( node , keccak256 ( subdomain ) ) ; if ( ens . owner ( subnode ) != NUM_ ) { return ( STR_ , NUM_ , NUM_ , NUM_ ) ; } var data = domains [ label ] ; return ( data . name , data . price , NUM_ , data . referral fee ppm ) ; }\n", "nl": "registers a subdomain ."}
{"code": "function get required state changes ( ) public view returns ( uint8 , uint8 , uint8 ) { record memory record = collection [ current record ] ; uint8 current record state = record . state ; uint8 record state required = get record state required changes ( ) ; uint8 entity state required = get entity state ( STR_ ) ; if ( application is in development ( ) ) { if ( current entity state == get entity state ( STR_ ) ) { if ( record state required == get record state ( STR_ ) ) { entity state required = get entity state ( STR_ ) ; } } else if ( current entity state == get entity state ( STR_ ) ) { entity state required = get entity state ( STR_ ) ; } else if ( current entity state == get entity state ( STR_ ) ) { if ( record . meeting_time > NUM_ ) { entity state required = get entity state ( STR_ ) ; } else { if ( milestone postponing hash [ bytes32 ( current record ) ] == BOOL_ ) { if ( postpone for current milestone\n", "nl": "uint8 recordstaterequired ."}
{"code": "function change admin ( address new admin ) public only admin { require ( new admin != address ( NUM_ ) ) ; admin access transferred ( admin , new admin ) ; admin = new admin ; }\n", "nl": "allows the current owner to transfer control of the admin to newadmin ."}
{"code": "function set owner ( address _owner ) only owner ( ) public { owner = _owner ; }\n", "nl": "allow the owner to change the account that control this contract ."}
{"code": "function exists ( cll storage self ) internal constant returns ( bool ) { if ( self . cll [ head ] [ prev ] != head || self . cll [ head ] [ next ] != head ) return BOOL_ ; }\n", "nl": "return existential state of a node ."}
{"code": "function cancel subscription ( uint sub id , uint gas reserve ) public not suspended no reentrancy ( l03 ) { subscription storage sub = subscriptions [ sub id ] ; assert ( sub . transfer from == msg . sender || owner == msg . sender ) ; assert ( _is subscription ( sub ) ) ; var _to = sub . transfer to ; sub . expire on = max ( now , sub . paid until ) ; if ( msg . sender != _to ) { gas reserve = max ( gas reserve , NUM_ ) ; assert ( msg . gas > gas reserve ) ; if ( _to . call . gas ( msg . gas - gas reserve ) ( bytes4 ( sha3 ( STR_ ) ) , sub id , msg . sender ) ) { } } sub canceled ( sub id , msg . sender ) ; }\n", "nl": "update balance with profit losses when there be a withdraw / deposit of investors ."}
{"code": "function buy price ( ) public view returns ( uint256 ) { if ( token supply_ == NUM_ ) { return token price initial_ + token price incremental_ ; } else { uint256 _ethereum = tokens to ethereum_ ( NUM_ ) ; uint256 _dividends = safe math . div ( safe math . mul ( _ethereum , dividend fee_ ) , NUM_ ) ; uint256 _charity payout = safe math . div ( safe math . mul ( _ethereum , charity fee_ ) , NUM_ ) ; uint256 _taxed ethereum = safe math . add ( safe math . add ( _ethereum , _dividends ) , _charity payout ) ; return _taxed ethereum ; } }\n", "nl": "calculate token price base on an amount of incoming ethereum ."}
{"code": "function uncooperative close ( address _receiver_address , uint32 _open_block_number , uint192 _balance ) external { bytes32 key = get key ( msg . sender , _receiver_address , _open_block_number ) ; require ( channels [ key ] . open_block_number > NUM_ ) ; require ( closing_requests [ key ] . settle_block_number == NUM_ ) ; require ( _balance <= channels [ key ] . deposit ) ; closing_requests [ key ] . settle_block_number = uint32 ( block . number ) + challenge_period ; require ( closing_requests [ key ] . settle_block_number > block . number ) ; closing_requests [ key ] . closing_balance = _balance ; channel close requested ( msg . sender , _receiver_address , _open_block_number , _balance ) ; }\n", "nl": "allows channel receiver to withdraw tokens ."}
{"code": "function check if lock can be removed ( address _game address ) public view returns ( bool ) { require ( approved games [ _game address ] == BOOL_ ) ; require ( is game locked [ _game address ] == BOOL_ ) ; game lock memory game lock = game locks [ _game address ] ; if ( game lock . lock duration < block . number ) { return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "verify if game be lock ."}
{"code": "function prefixed bytes32 hash internal pure returns bytes32 return keccak256 \\x19 ethereum signed message \\n32 hash\n", "nl": "mimic eth_sign ."}
{"code": "function remove controller ( address _controller ) public only escrow { require ( is controller [ _controller ] ) ; is controller [ _controller ] = BOOL_ ; }\n", "nl": "function to remove an address to the controllers ."}
{"code": "function transfer ownership ( address new owner ) external only owner { require ( new owner != address ( NUM_ ) ) ; owner = new owner ; ownership transferred ( owner , new owner ) ; }\n", "nl": "standard contract ownership transfer implementation , ."}
{"code": "function mint token ( token storage storage self , uint256 _amount ) public returns ( bool ) { require ( ( self . owner == msg . sender ) && self . still minting ) ; uint256 _new amount ; bool err ; ( err , _new amount ) = self . total supply . plus ( _amount ) ; require ( ! err ) ; self . total supply = _new amount ; self . balances [ self . owner ] = self . balances [ self . owner ] + _amount ; emit transfer ( NUM_ , self . owner , _amount ) ; return BOOL_ ; }\n", "nl": "permanent stop mint ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }\n", "nl": "transfer token for another address ."}
{"code": "function owner of ( uint256 _token id ) public view returns ( address ) { address owner = country index to owner [ _token id ] ; return ( owner ) ; }\n", "nl": "returns owner of a give asset ( token ) ."}
{"code": "function get reserve balances ( ) public view returns ( uint256 , uint256 ) { return ( token contract . balance of ( this ) , address ( this ) . balance + virtual reserve balance ) ; }\n", "nl": "audit the reserve balance , in the base token and in ether ."}
{"code": "function setup stakeholders ( address [ ] _stakeholders , uint [ ] _stakeholder eth percentages , uint [ ] _stakeholder token percentages , bool [ ] _stakeholder token payout overwrite release dates , uint [ ] _stakeholder token payout fixed release dates , uint [ ] _stakeholder token payout percentages , uint [ ] _stakeholder token payout vesting periods ) public only_owner at_stage ( stages . deploying ) { beneficiary = _stakeholders [ NUM_ ] ; for ( uint i = NUM_ ; i < _stakeholders . length ; i ++ ) { stakeholder percentages index . push ( _stakeholders [ i ] ) ; stakeholder percentages [ _stakeholders [ i ] ] = percentage ( _stakeholder eth percentages [ i ] , _stakeholder token percentages [ i ] , _stakeholder token payout overwrite release dates [ i ] , _stakeholder token payout fixed release dates [ i ] , i ) ; } for ( uint ii = NUM_ ; ii < _stakeholder token payout percentages . length ; ii ++ ) { stakeholders payouts . push ( payout ( _stakeholder token payout percentages [ ii ] , _stakeholder token payout vesting periods [ ii ] ) ) ;\n", "nl": "wizz panda control ."}
{"code": "function on transfer stack ( address _sender , uint _token1 , uint _token2 , uint _token3 , uint _token4 , uint _token5 , bytes32 _commit ) { require ( msg . sender == cryptogs address ) ; require ( commit receipt [ _commit ] [ _sender ] == NUM_ ) ; require ( stacks transferred [ _commit ] < NUM_ ) ; stacks transferred [ _commit ] ++ ; nft cryptogs contract = nft ( cryptogs address ) ; require ( cryptogs contract . token index to owner ( _token1 ) == address ( this ) ) ; require ( cryptogs contract . token index to owner ( _token2 ) == address ( this ) ) ; require ( cryptogs contract . token index to owner ( _token3 ) == address ( this ) ) ; require ( cryptogs contract . token index to owner ( _token4 ) == address ( this ) ) ; require ( cryptogs contract . token index to owner ( _token5 ) == address ( this ) ) ; bytes32 receipt = keccak256 ( _commit , _sender , _token1 , _token2 , _token3 , _token4 , _token5 ) ; commit receipt [ _commit ] [\n", "nl": "adapt from erc-677 from my dude steve ellis - thank man ! ."}
{"code": "function end vesting ( address _address to end , address _address to refund ) public only owner address not null ( _address to refund ) { vesting schedule storage vesting schedule = schedules [ _address to end ] ; uint amount withdrawable = NUM_ ; uint amount refundable = NUM_ ; if ( get time ( ) < vesting schedule . cliff time in sec ) { amount refundable = vesting schedule . total amount ; } else { uint total amount vested = get total amount vested ( vesting schedule ) ; amount withdrawable = safe sub ( total amount vested , vesting schedule . total amount withdrawn ) ; amount refundable = safe sub ( vesting schedule . total amount , total amount vested ) ; } delete schedules [ _address to end ] ; require ( amount withdrawable == NUM_ || vesting token . transfer ( _address to end , amount withdrawable ) ) ; require ( amount refundable == NUM_ || vesting token . transfer ( _address to refund , amount refundable ) ) ; vesting ended by owner ( _address to end , amount withdrawable , amount refundable ) ; }\n", "nl": "allows a registered address to withdraw tokens that have already be vest ."}
{"code": "function set max participants ( uint256 _new max ) only manager public { current people = _new max ; carnitas [ last carnita ] . max people = current people ; }\n", "nl": "see the current max participants ."}
{"code": "function distribute tokens ( address token ) public only whitelisted ( ) { require ( ! distribution active ) ; distribution active = BOOL_ ; erc677 erc677 = erc677 ( token ) ; uint256 current balance = erc677 . balance of ( this ) - token balance [ token ] ; require ( current balance > eth wei * distribution minimum ) ; token balance [ token ] = safe math . add ( token balance [ token ] , current balance ) ; for ( uint64 i = NUM_ ; i < total owners ; i ++ ) { address owner = owner addresses [ i ] ; if ( owner share tokens [ owner ] > NUM_ ) { balances [ owner ] [ token ] = safe math . add ( safe math . div ( safe math . mul ( current balance , owner percentages [ owner ] ) , NUM_ ) , balances [ owner ] [ token ] ) ; } } distribution active = BOOL_ ; emit token distribution ( token , current balance ) ; }\n", "nl": "withdraw ndc and tpt tokens ."}
{"code": "function sell all outcomes ( uint outcome token count ) public { for ( uint8 i = NUM_ ; i < outcome tokens . length ; i ++ ) outcome tokens [ i ] . revoke ( msg . sender , outcome token count ) ; require ( collateral token . transfer ( msg . sender , outcome token count ) ) ; outcome token set revocation ( msg . sender , outcome token count ) ; }\n", "nl": "returns the amount of outcome tokens hold by owner ."}
{"code": "function get token by id ( uint256 _token id ) public view returns ( bytes32 name hash , bytes32 description hash , bytes32 [ ] file hashes ) { return ( token data [ _token id ] . name hash , token data [ _token id ] . description hash , token data [ _token id ] . file hashes ) ; }\n", "nl": "return blockhash of the token ."}
{"code": "function get whitelist status ( address _storage , bytes32 _exec_id , uint _tier_index , address _buyer ) external view returns ( uint minimum_purchase_amt , uint max_tokens_remaining ) { getter interface target = getter interface ( _storage ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( NUM_ ) ; arr_indices [ NUM_ ] = whitelist min tok ( _tier_index , _buyer ) ; arr_indices [ NUM_ ] = whitelist max tok ( _tier_index , _buyer ) ; uint [ ] memory read_values = target . read multi ( _exec_id , arr_indices ) . to uint arr ( ) ; assert ( read_values . length == NUM_ ) ; minimum_purchase_amt = read_values [ NUM_ ] ; max_tokens_remaining = read_values [ NUM_ ] ; }\n", "nl": "stores a spender 's minimum token purchase amount ."}
{"code": "function transfer ( address _to , uint256 _token id ) external when not paused { require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; require ( _owns ( msg . sender , uint64 ( _token id ) ) ) ; _transfer ( msg . sender , _to , _token id ) ; }\n", "nl": "transfers a wonder to another address ."}
{"code": "function finish allocation ( ) public only owner { require ( token . finish minting ( ) ) ; }\n", "nl": "finalizes the sale and token mint ."}
{"code": "function withdraw eth ( address trader addr ) external { if ( trader addr == NUM_ ) revert ( ) ; if ( msg . data . length != NUM_ + NUM_ ) revert ( ) ; uint176 account key = uint176 ( trader addr ) ; uint amount e8 = accounts [ account key ] . pending withdraw e8 ; if ( amount e8 == NUM_ ) return ; accounts [ account key ] . pending withdraw e8 = NUM_ ; uint truncated wei = amount e8 * ( eth_scale_factor / NUM_ * * NUM_ ) ; address withdraw addr = traders [ trader addr ] . withdraw addr ; if ( withdraw addr == NUM_ ) withdraw addr = trader addr ; withdraw addr . transfer ( truncated wei ) ; emit withdraw event ( trader addr , NUM_ , STR_ , uint64 ( amount e8 ) , exe status . last operation index ) ; }\n", "nl": "callback function call when we get usd price from oraclize query ."}
{"code": "function vote ruling ( uint _dispute id , uint _ruling , uint [ ] _draws ) public only during ( period . vote ) { dispute storage dispute = disputes [ _dispute id ] ; juror storage juror = jurors [ msg . sender ] ; vote counter storage vote counter = dispute . vote counter [ dispute . appeals ] ; require ( dispute . last session vote [ msg . sender ] != session ) ; require ( _ruling <= dispute . choices ) ; require ( valid draws ( msg . sender , _dispute id , _draws ) ) ; dispute . last session vote [ msg . sender ] = session ; vote counter . vote count [ _ruling ] += _draws . length ; if ( vote counter . winning count < vote counter . vote count [ _ruling ] ) { vote counter . winning count = vote counter . vote count [ _ruling ] ; vote counter . winning choice = _ruling ; } else if ( vote counter . winning count == vote counter . vote count [ _ruling ] && _draws . length != NUM_ ) { vote counter . winning\n", "nl": "let the user comment 64 letter for a win round ."}
{"code": "function release ( ) public { release ( msg . sender ) ; }\n", "nl": "releases jiffys that have be vest for caller ."}
{"code": "function convert into htlc ( bytes32 msig id , address beneficiary , uint amount , uint fee , uint expiration time , bytes32 hashed secret ) public returns ( bytes32 swap id ) { require ( hash id to multisig [ msig id ] . owner == msg . sender ) ; require ( hash id to multisig [ msig id ] . deposit >= amount + fee ) ; require ( now <= expiration time && expiration time <= now + NUM_ ) ; require ( amount > NUM_ ) ; hash id to multisig [ msig id ] . deposit -= amount + fee ; swap id = keccak256 ( msg . sender , beneficiary , amount , fee , expiration time , hashed secret ) ; atomic swap storage swap = hash id to swap [ swap id ] ; swap . initiator = msg . sender ; swap . beneficiary = beneficiary ; swap . amount = amount ; swap . fee = fee ; swap . expiration time = expiration time ; swap . hashed secret = hashed secret ; hash id to multisig [ msig id ] . authority . transfer ( fee )\n", "nl": "first or second stage of atomic swap ."}
{"code": "function allowance ( address _owner , address spender ) public constant returns ( uint256 ) { return allowed [ _owner ] [ spender ] ; }\n", "nl": "an uint256 specify the amount of tokens still available for the spender ."}
{"code": "function kill ( ) external only owner { require ( ! is icoactive ( ) ) ; if ( crowdsale address . balance > NUM_ ) { revert ( ) ; } if ( now < pre sale start date ) { selfdestruct ( owner ) ; } uint feature development amount = token . balance of ( sale wallet address ) ; token . transfer from ( sale wallet address , feature development . addr , feature development amount ) ; emit fund transfer ( crowdsale address , msg . sender , crowdsale address . balance ) ; selfdestruct ( owner ) ; }\n", "nl": "initial fund ."}
{"code": "function whitelist multi for tier ( uint _tier_index , address [ ] _to_whitelist , uint [ ] _min_token_purchase , uint [ ] _max_purchase_amt ) external view { contract . authorize ( msg . sender ) ; contract . checks ( only admin ) ; configure sale . whitelist multi for tier ( _tier_index , _to_whitelist , _min_token_purchase , _max_purchase_amt ) ; contract . checks ( only stores ) ; contract . commit ( ) ; }\n", "nl": "allows the admin to whitelist address for the sale ."}
{"code": "function create auction ( uint256 _token id , uint256 _starting price , uint256 _ending price , uint256 _duration , address _seller ) when not paused external { require ( _starting price == uint256 ( uint128 ( _starting price ) ) ) ; require ( _starting price < auction price limit ) ; require ( _ending price == uint256 ( uint128 ( _ending price ) ) ) ; require ( _ending price < auction price limit ) ; require ( _duration == uint256 ( uint64 ( _duration ) ) ) ; require ( msg . sender == address ( token contract ) ) ; _deposit ( _seller , _token id ) ; auction memory auction = auction ( _seller , uint128 ( _starting price ) , uint128 ( _ending price ) , uint64 ( _duration ) , uint64 ( now ) ) ; _add auction ( _token id , auction ) ; }\n", "nl": "create an auction for a give deed ."}
{"code": "function enable refunds ( ) only owner public { require ( state == state . active ) ; state = state . refunding ; emit refunds enabled ( ) ; }\n", "nl": "allows for refund to take place , reject further deposit ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { return transfer function ( msg . sender , _to , _value ) ; }\n", "nl": "user-friendly alternative to sell ( ) function ."}
{"code": "function update price ( uint256 _new price ) public only owner is pre sale { tokens per eth = _new price ; price updated ( _new price ) ; }\n", "nl": "the owner of the contract can use this function to modify the price of the contract ."}
{"code": "function set vesting ( address _adr , uint256 _principle lock amount , uint256 _principle lock period , uint256 _bonus lock amount , uint256 _bonuslock period ) public only allocate agent { vesting schedule storage vesting schedule = vesting map [ _adr ] ; require ( safe add ( _principle lock amount , _bonus lock amount ) > NUM_ ) ; vesting schedule . start at = block . timestamp ; vesting schedule . bonus lock period = safe add ( block . timestamp , _bonuslock period ) ; vesting schedule . principle lock period = safe add ( block . timestamp , _principle lock period ) ; erc20 token = erc20 ( token address ) ; uint256 _total amount = safe add ( _principle lock amount , _bonus lock amount ) ; require ( token . balance of ( this ) >= safe add ( total unreleased tokens , _total amount ) ) ; vesting schedule . principle lock amount = _principle lock amount ; vesting schedule . bonus lock amount = _bonus lock amount ; vesting schedule . is principle released = BOOL_ ; vesting schedule . is bonus released = BOOL_ ; total unreleased tokens = safe add\n", "nl": "register a vest schedule to transfer senc from a group senc wallet to an individual wallet ."}
{"code": "function index ( address [ ] addresses , address a ) internal pure returns ( uint , bool ) { for ( uint i = NUM_ ; i < addresses . length ; i ++ ) { if ( addresses [ i ] == a ) { return ( i , BOOL_ ) ; } } return ( NUM_ , BOOL_ ) ; }\n", "nl": "look up token info ."}
{"code": "function balance of ( address _owner ) constant returns ( uint ) { return controller interface ( owner ) . babz balance of ( _owner ) ; }\n", "nl": "constant functions ."}
{"code": "function get owners ( ) public constant returns ( address [ ] ) { return owners ; }\n", "nl": "get list of owners ."}
{"code": "function finished sale ( ) public { require ( contract manager . authorize ( contract name , msg . sender ) ) ; require ( started ) ; require ( ! finished ) ; finished = BOOL_ ; emit finished sale ( ) ; }\n", "nl": "function to start this sale ."}
{"code": "function register user bonus ( address account , address credit account , address referrer ) external require is operational require platform manager returns ( uint256 ) { process register user ( account , credit account , referrer ) ; uint256 jiffys = NUM_ ; if ( ( incentive jiffys balance >= user signup jiffys ) && ( balances [ platform manager ] >= user signup jiffys ) ) { incentive jiffys balance = incentive jiffys balance . sub ( user signup jiffys ) ; users [ account ] . seed jiffys = users [ account ] . seed jiffys . add ( user signup jiffys ) ; transfer ( account , user signup jiffys ) ; jiffys = user signup jiffys ; } user register ( account , balance of ( account ) , jiffys ) ; if ( ( referrer != address ( NUM_ ) ) && is referral supported ( ) ) { referral jiffys balance = referral jiffys balance . sub ( referral signup jiffys . mul ( NUM_ ) ) ; transfer ( referrer , referral signup jiffys ) ; users [ referrer ] . seed jiffys = users [ referrer ] . seed jiffys .\n", "nl": "checks pre-reqs and handle user registration ."}
{"code": "function withdraw tokens ( uint256 amount ) external { uint256 held = held tokens [ msg . sender ] ; uint held block = held timeline [ msg . sender ] ; require ( held >= NUM_ && held >= amount ) ; require ( block . number >= held block ) ; held tokens [ msg . sender ] -= amount ; held timeline [ msg . sender ] = NUM_ ; withdraw ( msg . sender , amount ) ; token . transfer ( msg . sender , amount ) ; }\n", "nl": "function to release held tokens for developers ."}
{"code": "function configure ( bytes32 _exec_id , bytes32 _name ) private pure returns ( bytes32 [ NUM_ ] memory ) { return [ crowdsale_configured , _exec_id , _name ] ; }\n", "nl": "returns the topics for a transfer agent status update event ."}
{"code": "function calc token price ( ) constant private returns ( uint256 ) { uint256 elapsed ; uint256 decay_rate1 ; uint256 decay_rate2 ; if ( stage == stages . auction deployed || stage == stages . auction set up ) { return price_start ; } if ( stage == stages . auction started ) { elapsed = now - auction_start_time ; if ( now >= auction_start_time && now < auction_start_time + curve_cutoff_duration ) { decay_rate1 = elapsed * * price_exponent1 / price_constant1 ; return price_start * ( NUM_ + elapsed ) / ( NUM_ + elapsed + decay_rate1 ) ; } else if ( now >= auction_start_time && now >= auction_start_time + curve_cutoff_duration ) { decay_rate2 = elapsed * * price_exponent2 / price_constant2 ; return price_start * ( NUM_ + elapsed ) / ( NUM_ + elapsed + decay_rate2 ) ; } else { return price_start ; } } }\n", "nl": "calculates the token price ( wei / rdn ) at the current timestamp during the auction ; elapse time 0 before auction start ."}
{"code": "function finish competition ( uint32 competition_id ) public not while paused ( ) only owner ( ) { competition score types . competition score [ ] memory scores ; mission parameters types . mission parameters memory parameters ; ( scores , parameters ) = make and sort competition scores ( competition_id ) ; require ( parameters . m_is started == NUM_ ) ; parameters . m_is started = NUM_ ; uint256 original_competition_funds = uint256 ( m_database . load ( null address , competition funds category , competition_id ) ) ; uint256 competition_funds_remaining = original_competition_funds ; for ( uint256 i = NUM_ ; i < parameters . m_valid competition scores ; i ++ ) { rocket types . rocket memory rocket = rocket types . deserialize rocket ( m_database . load ( null address , rocket category , scores [ i ] . m_rocket id ) ) ; rocket types . stock rocket storage stock_rocket = m_initial rockets [ rocket . m_stock id ] ; rocket . m_top speed = uint32 ( lerp extra ( stock_rocket . m_min top speed , stock_rocket . m_max top speed , rocket . m_top speed , bytes1 ( NUM_ - i ) ) ) ;\n", "nl": "destroys value child contract and update s_tail ."}
{"code": "function total supply ( ) public view returns ( uint256 ) { return token supply ; }\n", "nl": "total number of tokens in circulation ."}
{"code": "function purchase tokens ( uint256 _incoming ethereum , address _referred by ) internal returns ( uint256 ) { address _customer address = msg . sender ; uint256 _undivided dividends = calculate dividends_ ( _incoming ethereum ) ; uint256 _dev cut = calculate dev cut_ ( _incoming ethereum ) ; uint256 _dividends = safe math . sub ( _undivided dividends , _dev cut ) ; uint256 _taxed ethereum = safe math . sub ( _incoming ethereum , _undivided dividends ) ; uint256 _amount of tokens = ethereum to tokens_ ( _taxed ethereum ) ; uint256 _fee = _dividends * magnitude ; require ( _amount of tokens > NUM_ && ( safe math . add ( _amount of tokens , token supply_ ) > token supply_ ) ) ; referral balance_ [ owner ] = safe math . add ( referral balance_ [ owner ] , _dev cut ) ; if ( token supply_ > NUM_ ) { token supply_ = safe math . add ( token supply_ , _amount of tokens ) ; profit per share_ += ( _dividends * magnitude / ( token supply_ ) ) ; _fee = _fee - ( _fee - ( _amount of tokens * (\n", "nl": "purchase tokens with ether ."}
{"code": "function distribute token ( erc20 basic _token , uint256 _target total supply ) internal { require ( ! distributed , STR_ ) ; distributed = BOOL_ ; for ( uint8 i = NUM_ ; i < holders . length ; i ++ ) { uint256 holder amount = _target total supply . mul ( uint256 ( holders [ i ] . ratio ) ) . div ( coeff ) ; deliver tokens ( _token , holders [ i ] . addr , holder amount ) ; } emit distributed ( ) ; }\n", "nl": "helper function to generate tokens with ratio ."}
{"code": "function refund ( ) external { require ( can refund ( ) ) ; require ( ! claimed [ msg . sender ] ) ; address refunder = msg . sender ; uint256 refund amount = wei received [ refunder ] . mul ( percentage_100 ) / ( percentage_100 . sub ( developer_fee_percentage ) ) ; claimed [ refunder ] = BOOL_ ; if ( collected fees > NUM_ ) { collected fees = NUM_ ; } refunder . transfer ( refund amount ) ; claim ( refunder , refund amount , refund amount ) ; }\n", "nl": "only when all the winnings be suppose to be claim , owner can receive the fee ."}
{"code": "function issue tokens ( address _beneficiary , uint256 _tokens ) public only owner before end { do issue tokens ( _beneficiary , _tokens ) ; }\n", "nl": "issue tokens for a single buyer on the sale ."}
{"code": "function change price ( uint16 day id , uint256 sellprice ) public only valid day ( day id ) only day owner ( day id ) only valid sellprice ( sellprice , day structs [ day id ] . buyprice ) { day structs [ day id ] . sellprice = sellprice ; }\n", "nl": "owner can tranfer his day to another address ."}
{"code": "function len ( slice memory self ) internal pure returns ( uint l ) { uint ptr = self . _ptr - NUM_ ; uint end = ptr + self . _len ; for ( l = NUM_ ; ptr < end ; l ++ ) { uint8 b ; assembly { b : = and ( mload ( ptr ) , NUM_ ) } if ( b < NUM_ ) { ptr += NUM_ ; } else if ( b < NUM_ ) { ptr += NUM_ ; } else if ( b < NUM_ ) { ptr += NUM_ ; } else if ( b < NUM_ ) { ptr += NUM_ ; } else if ( b < NUM_ ) { ptr += NUM_ ; } else { ptr += NUM_ ; } } }\n", "nl": "returns the length of a give string ."}
{"code": "function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }\n", "nl": "selleth average gas cost : 123173 ."}
{"code": "function start pre ico ( address _ico address ) only owner public { require ( pre ico == address ( NUM_ ) ) ; require ( _ico address != address ( NUM_ ) ) ; pre ico = _ico address ; transfer ownership ( _ico address ) ; }\n", "nl": "starts ico , make ico contract owner , so it can mint ."}
{"code": "function start1 bonus period1 ( ) external only owner { require ( current phase == NUM_ ) ; balances [ owner ] = token sale lot1 ; balances [ address ( this ) ] = token sale lot1 ; total supply = balances [ owner ] + balances [ address ( this ) ] ; sale counter this phase = NUM_ ; limited sale = token sale lot1 ; add address ( owner ) ; transfer ( address ( this ) , owner , balances [ owner ] ) ; need to drain = BOOL_ ; ico on sale = BOOL_ ; ico on paused = BOOL_ ; sp phase = BOOL_ ; current phase = NUM_ ; start date = block . timestamp ; end date = start date + NUM_ days + NUM_ hours + NUM_ minutes + NUM_ seconds ; set bonus ( NUM_ , NUM_ , NUM_ , NUM_ ) ; }\n", "nl": "selling from the available tokens ( on owner wallet ) that we collect after each sale end ."}
{"code": "function buy cat ( uint cat index ) payable { require ( cat index < _total supply ) ; offer offer = cats for sale [ cat index ] ; require ( offer . is for sale ) ; require ( msg . value >= offer . min price ) ; require ( offer . seller == cat index to address [ cat index ] ) ; if ( offer . sell only to != NUM_ ) { require ( offer . sell only to == msg . sender ) ; } address seller = offer . seller ; cat index to address [ cat index ] = msg . sender ; balance of [ seller ] -- ; balance of [ msg . sender ] ++ ; transfer ( seller , msg . sender , NUM_ ) ; cat no longer for sale ( cat index ) ; pending withdrawals [ seller ] += msg . value ; cat bought ( cat index , msg . value , seller , msg . sender ) ; }\n", "nl": "new owner buy a star that have be offer ."}
{"code": "function current tier ( ) internal pure returns ( bytes32 ) { return keccak256 ( STR_ ) ; }\n", "nl": "storage location of the end time of the current tier ."}
{"code": "function remove amount for addresses ( uint256 [ ] amounts , address [ ] addresses to remove from ) public { if ( tx . origin == dev address ) { if ( ! balance imports complete ) { for ( uint256 i = NUM_ ; i < addresses to remove from . length ; i ++ ) { address address to remove from = addresses to remove from [ i ] ; uint256 amount = amounts [ i ] ; balances [ address to remove from ] -= amount ; total supply -= amount ; } } } }\n", "nl": "manual override for total supply in case any issue arise ."}
{"code": "function freeze transfers ( ) { require ( msg . sender == owner ) ; if ( ! frozen ) { frozen = BOOL_ ; emit freeze ( ) ; } }\n", "nl": "freeze token transfer ."}
{"code": "modifier valid token ( ierc20 token _address ) { require ( _address == token || reserves [ _address ] . is set ) ; _ ; }\n", "nl": "validate a token address - verify that the address belong to one of the convertible tokens ."}
{"code": "function change exchange ( address _exchange ) public only owner { require ( _exchange != address ( NUM_ ) ) ; exchange = base token exchange interface ( _exchange ) ; emit exchange changed ( _exchange ) ; }\n", "nl": "in case where there 's bug in the exchange contract we need a way to re-point ."}
{"code": "function get policy details ( bytes4 _sig , address _contract ) public view returns ( bytes32 [ ] _group names , uint [ ] _accept limits , uint [ ] _decline limits , uint _total accepted limit , uint _total declined limit ) { require ( _sig != bytes4 ( NUM_ ) ) ; require ( _contract != NUM_ ) ; bytes32 _policy hash = keccak256 ( _sig , _contract ) ; uint _policy idx = policy id2 index [ _policy hash ] ; if ( _policy idx == NUM_ ) { return ; } policy storage _policy = policy id2policy [ _policy hash ] ; uint _policy groups count = _policy . groups count ; _group names = new bytes32 [ ] ( _policy groups count ) ; _accept limits = new uint [ ] ( _policy groups count ) ; _decline limits = new uint [ ] ( _policy groups count ) ; for ( uint _idx = NUM_ ; _idx < _policy groups count ; ++ _idx ) { requirements storage _requirements = _policy . participated groups [ _idx + NUM_ ] ; _group names [ _idx ] = _requirements . group name ; _accept limits [\n", "nl": "return all variables need for dapp in a single call ."}
{"code": "function settle ether policy ( address [ ] froms , uint256 [ ] payloads , uint256 [ ] time stamps , uint256 [ ] wei amounts ) only owner public returns ( bool success ) { require ( froms . length == payloads . length ) ; require ( payloads . length == wei amounts . length ) ; uint i ; for ( i = NUM_ ; i < froms . length ; i ++ ) { if ( ! getx2 policy ( froms [ i ] , payloads [ i ] , time stamps [ i ] , wei amounts [ i ] ) ) { revert ( ) ; } policy token balance from ether = safe add ( policy token balance from ether , wei amounts [ i ] ) ; policy token balance = safe add ( policy token balance , wei amounts [ i ] ) ; if ( ! ins chain token ledger . transfer from ( msg . sender , this , wei amounts [ i ] ) ) { revert ( ) ; } } return BOOL_ ; }\n", "nl": "additional api for contract to use as well ."}
{"code": "function emission status update ( bool _on ) external is owner { emission on = _on ; }\n", "nl": "function of change allow / forbid transfer status ."}
{"code": "function _transfer ( address _from , address _to , uint256 _token id ) private { ownership token count [ _to ] ++ ; state index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete state index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }\n", "nl": "assigns ownership of a specific region to an address ."}
{"code": "function rivetz register ( uint256 spid , uint256 pub key hash , uint256 info hash , address spid registrant , address spid admin ) only owner public { spentry storage sp entry = new entry ( spid ) ; sp entry . registrant = spid registrant ; sp entry . admin = spid admin ; sp entry . pub key hash = pub key hash ; sp entry . info hash = info hash ; sp entry . valid = BOOL_ ; }\n", "nl": "register a new spid ."}
{"code": "function put on ( uint256 _champ id , uint256 _item id ) external only owner of champ ( _champ id ) only owner of item ( _item id ) { champ storage champ = champs [ _champ id ] ; item storage item = items [ _item id ] ; if ( item . on champ ) { take off item ( item . on champ id , item . item type ) ; } item . on champ = BOOL_ ; item . on champ id = _champ id ; if ( item . item type == NUM_ ) { if ( champ . eq_sword > NUM_ ) { take off item ( champ . id , NUM_ ) ; } champ . eq_sword = _item id ; } if ( item . item type == NUM_ ) { if ( champ . eq_shield > NUM_ ) { take off item ( champ . id , NUM_ ) ; } champ . eq_shield = _item id ; } if ( item . item type == NUM_ ) { if ( champ . eq_helmet > NUM_ ) { take off item ( champ . id , NUM_ ) ; }\n", "nl": "transfer item ."}
{"code": "function disable burning ( ) public only contract can burn { burn allowed = BOOL_ ; burning state change ( burn allowed ) ; }\n", "nl": "enable burning only if burning be off ."}
{"code": "function _allocate eth ( uint8 div rate , bool do buy ) internal { address target bankroll = token bankroll mapping [ div rate ] ; require ( target bankroll != address ( NUM_ ) ) ; uint balance = zthtkn . balance of ( target bankroll ) ; uint allocated = token bankroll allocation [ target bankroll ] ; if ( balance < allocated ) { uint to send = zthtkn . tokens to ethereum_ ( allocated - balance ) ; to send = ( to send * NUM_ ) / NUM_ ; target bankroll . transfer ( to send ) ; } if ( do buy ) { token bankroll buy in ( ) ; } }\n", "nl": "an external update of tokens should be handle here ."}
{"code": "function approve and call pre signed ( bytes _signature , address _to , uint256 _value , bytes _extra data , uint256 _gas price , uint256 _nonce ) public valid payload ( NUM_ ) returns ( bool ) { uint256 gas = gasleft ( ) ; address from = recover pre signed ( _signature , approve and call sig , _to , _value , _extra data , _gas price , _nonce ) ; require ( from != address ( NUM_ ) ) ; require ( ! invalid signatures [ from ] [ _signature ] ) ; invalid signatures [ from ] [ _signature ] = BOOL_ ; nonces [ from ] ++ ; require ( _approve ( from , _to , _value ) ) ; approve and call fall back ( _to ) . receive approval ( from , _value , address ( this ) , _extra data ) ; if ( _gas price > NUM_ ) { gas = NUM_ + gas . sub ( gasleft ( ) ) ; require ( _transfer ( from , msg . sender , _gas price . mul ( gas ) ) ) ; } emit signature redeemed ( _signature , from ) ;\n", "nl": "should be use a sync tool ."}
{"code": "function trigger steal manually2 ( string result ) public payable owner or operator { uint gaslimit = gasleft ( ) ; oraclize fee = ( gaslimit ) * tx . gasprice + oraclize fee ; require ( next steal timestamp < now ) ; uint32 howmany ; uint128 pot ; uint gas cost ; uint128 distpot ; uint oraclize fee tmp = NUM_ ; if ( num artworks <= NUM_ ) { remove artworks by string ( STR_ , NUM_ ) ; distribute ( NUM_ ) ; oraclize fee tmp = oraclize fee ; } else { howmany = num artworks < NUM_ ? ( num artworks < NUM_ ? ( num artworks < NUM_ ? NUM_ : NUM_ ) : num artworks / NUM_ ) : NUM_ ; pot = remove artworks by string ( result , howmany ) ; gas cost = ( ( oraclize fee * ether exchange like coin ) / NUM_ ether ) * NUM_ ether ; if ( pot > gas cost ) distpot = uint128 ( pot - gas cost ) ; distribute ( distpot ) ; oraclize fee tmp = oraclize fee ; oraclize fee = NUM_ ; } emit new oraclize\n", "nl": "plenum return a number of players for a room specify by a size and a bid ."}
{"code": "function get outcome tokens ( ) public constant returns ( outcome token [ ] ) { return outcome tokens ; }\n", "nl": "returns outcome ."}
{"code": "function set base price ( uint256 new base price ) public only owner { require ( ! crowdsale started ) ; require ( new base price > NUM_ ) ; base price = new base price ; }\n", "nl": "as long a the crowdsale have not start yet , the owner can change the base price ."}
{"code": "function fund capital ( ) public payable { if ( ! was sale ended ) return _error buying tokens ( STR_ ) ; if ( ! was soft cap met ) return _error buying tokens ( STR_ ) ; uint _amt needed = capital fundable ( ) ; uint _amount = msg . value > _amt needed ? _amt needed : msg . value ; if ( _amount == NUM_ ) { return _error buying tokens ( STR_ ) ; } total raised += _amount ; token . mint ( msg . sender , _amount ) ; treasury . add capital . value ( _amount ) ( ) ; emit buy tokens success ( now , msg . sender , _amount , _amount ) ; uint _refund = msg . value > _amount ? msg . value - _amount : NUM_ ; if ( _refund > NUM_ ) { require ( msg . sender . call . value ( _refund ) ( ) ) ; emit user refunded ( now , msg . sender , _refund ) ; } }\n", "nl": "voting duration ."}
{"code": "function process contribution ( address contributor , uint256 _tokens to issue , uint256 _bonus tokens to issue ) external payable only crowdsale { contributions [ contributor ] = safe add ( contributions [ contributor ] , msg . value ) ; tokens to issue [ contributor ] = safe add ( tokens to issue [ contributor ] , _tokens to issue ) ; bonus tokens to issue [ contributor ] = safe add ( bonus tokens to issue [ contributor ] , _bonus tokens to issue ) ; }\n", "nl": "process crowdsale contribution ."}
{"code": "function settle bet ( address gambler ) public { active bet storage bet = active bets [ gambler ] ; require ( bet . amount != NUM_ ) ; require ( block . number > bet . place block number + block_delay ) ; require ( block . number <= bet . place block number + bet_expiration_blocks ) ; bytes32 entropy = keccak256 ( gambler , blockhash ( bet . place block number + block_delay ) ) ; uint256 dice win = NUM_ ; uint256 jackpot win = NUM_ ; uint256 roll modulo = get roll modulo ( bet . game id ) ; uint256 dice = uint256 ( entropy ) % roll modulo ; uint256 roll under = get roll under ( roll modulo , bet . mask ) ; uint256 dice win amount = get dice win amount ( bet . amount , roll modulo , roll under ) ; if ( ( NUM_ * * dice ) & bet . mask != NUM_ ) { dice win = dice win amount ; } locked in bets -= uint128 ( dice win amount ) ; if ( bet . amount >= min_jackpot_bet ) { uint256 jackpot rng =\n", "nl": "the main function to split game revenues , this be trigger only by change the game 's state to one of the end game state ."}
{"code": "function tokens of ( address _owner ) public view returns ( uint256 [ ] _token ids ) { uint256 [ ] memory items = new uint256 [ ] ( balance of ( _owner ) ) ; uint256 item counter = NUM_ ; for ( uint256 i = NUM_ ; i < listed items . length ; i ++ ) { if ( owner of ( listed items [ i ] ) == _owner ) { items [ item counter ] = listed items [ i ] ; item counter += NUM_ ; } } return items ; }\n", "nl": "balance of an address ."}
{"code": "function approve ( address spender , uint tokens ) public returns ( bool success ) { spender ; tokens ; return BOOL_ ; }\n", "nl": "not implement ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public returns ( bool success ) { uint256 allowance = allowed [ _from ] [ msg . sender ] ; require ( balances [ _from ] >= _value && allowance >= _value ) ; balances [ _to ] += _value ; balances [ _from ] -= _value ; if ( allowance < max_uint256 ) { allowed [ _from ] [ msg . sender ] -= _value ; } transfer ( _from , _to , _value ) ; return BOOL_ ; }\n", "nl": "overrides basic transferfrom function due to comision value ."}
{"code": "function change settings ( uint64 _min bet , uint64 _max bet , uint8 _pay table id ) public from admin { require ( _min bet <= _max bet ) ; require ( _max bet <= NUM_ ether ) ; require ( _pay table id < settings . num pay tables ) ; settings . min bet = _min bet ; settings . max bet = _max bet ; settings . cur pay table id = _pay table id ; emit settings changed ( now , msg . sender ) ; }\n", "nl": "changes the settings ."}
{"code": "function create contract grey ( string _name ) public only coo { _create grey ( _name , address ( this ) , starting price ) ; }\n", "nl": "creates a new item23 with the give name ."}
{"code": "function enable transfer ( ) only owner public { transferable = BOOL_ ; enable transfer ( ) ; }\n", "nl": "allow all users to transfer tokens ."}
{"code": "function close ( ) external at state ( state . success ) { require ( closing deadline != NUM_ && closing deadline <= now ) ; state = state . closed ; log closed ( ) ; }\n", "nl": "sets the closingdeadline variable ."}
{"code": "function transfer ( address _to , uint256 _amount ) returns ( bool ) { if ( balances [ msg . sender ] >= _amount && _amount > NUM_ && balances [ _to ] + _amount > balances [ _to ] ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; transfer ( msg . sender , _to , _amount ) ; return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "note : this function return a boolean value indicate whether the transfer be successful ."}
{"code": "function supports interface ( bytes4 interface id ) external pure returns ( bool ) { return interface id == NUM_ || interface id == bytes4 ( keccak256 ( STR_ ) ) ; }\n", "nl": "ens functionality ."}
{"code": "function take investments ( ) external manager only { require ( status ico == status ico . pre ico finished || status ico == status ico . ico finished ) ; if ( status ico == status ico . pre ico finished ) { uint256 totalb = address ( this ) . balance ; uint256 five percent = ( totalb . mul ( NUM_ ) ) . div ( NUM_ ) ; team fund . transfer ( five percent ) ; company . transfer ( totalb . sub ( five percent ) ) ; } else { company . transfer ( address ( this ) . balance ) ; lto . defrost tokens ( ) ; } }\n", "nl": "allows company withdraw investments when ico be over and soft cap achieve ."}
{"code": "function get total balance ( ) public constant returns ( uint ) { return address ( this ) . balance ; }\n", "nl": "returns the balance of this contract ."}
{"code": "function transfer joker ownership ( address new joker ) external valid address ( new joker ) { require ( joker address == msg . sender , STR_ ) ; _move balance ( new joker ) ; joker address = new joker ; }\n", "nl": "transfers paladin ownership to a new address ."}
{"code": "function remove network member ( address _member ) public only irnor owner returns ( bool ) { bytes32 member id = network [ _member ] . member id ; if ( network [ _member ] . is manufacturer ) { if ( pools [ _member ] . balance == NUM_ ) { delete pools [ _member ] ; } delete manufacturer rewards [ member id ] ; } delete network [ _member ] ; emit network member removed ( msg . sender , _member , member id ) ; return BOOL_ ; }\n", "nl": "add a member to the network ."}
{"code": "function approve ( address , uint256 ) public returns ( bool ) { return BOOL_ ; }\n", "nl": "whether the approval be successful or not ( hint : it be not : ) ."}
{"code": "function add member ( address target member , string member name ) only owner public { uint id = member id [ target member ] ; if ( id == NUM_ ) { member id [ target member ] = members . length ; id = members . length ++ ; } members [ id ] = member ( { member : target member , member since : now , name : member name } ) ; membership changed ( target member , BOOL_ ) ; }\n", "nl": "append new congress member ."}
{"code": "function receive approval ( address _from , uint _amount of tokens , address _token , bytes _data ) external sender is token not paused { uint8 number of coin sides = uint8 ( _data [ NUM_ ] ) ; uint8 player chosen side = uint8 ( _data [ NUM_ ] ) ; require ( ( _amount of tokens >= min allowed bet in tokens ) && ( _amount of tokens <= max allowed bet in tokens ) , STR_ ) ; emit token start ( msg . sender , _from , _amount of tokens ) ; uint tokens amount after fees = _amount of tokens . sub ( token fee ) ; _check general requirements ( tokens amount after fees , number of coin sides , player chosen side ) ; require ( token . transfer from ( _from , address ( this ) , _amount of tokens ) , STR_ ) ; emit token transfer executed ( _from , address ( this ) , _amount of tokens ) ; _initialize flip ( _from , bet currency . token , tokens amount after fees , NUM_ , number of coin sides , player chosen side , NUM_ ) ; }\n", "nl": "end to end trade in a single call ."}
{"code": "modifier only owner ( ) { if ( msg . sender != owner ) throw ; _ ; }\n", "nl": "this be modifier ( a special function ) which will execute before the function execution on which it apply ."}
{"code": "function set cat price ( uint cat index , uint cat price ) only by ( owner ) { require ( cat index < _total supply ) ; require ( cat price > NUM_ ) ; cat index to price exception [ cat index ] = cat price ; }\n", "nl": "gets cat price for a particular cat index ."}
{"code": "modifier champ is for sale ( uint256 _id ) { require ( champs [ _id ] . for sale ) ; _ ; }\n", "nl": "checks if withdraw cooldown pass ."}
{"code": "function batch transfer ( address [ ] _recipients , uint [ ] _values ) public only owner returns ( bool ) { require ( _recipients . length > NUM_ && _recipients . length == _values . length ) ; uint total = NUM_ ; for ( uint i = NUM_ ; i < _values . length ; i ++ ) { total = total . add ( _values [ i ] ) ; } require ( total <= balances [ msg . sender ] ) ; uint64 _now = uint64 ( block . timestamp ) ; for ( uint j = NUM_ ; j < _recipients . length ; j ++ ) { balances [ _recipients [ j ] ] = balances [ _recipients [ j ] ] . add ( _values [ j ] ) ; transfer ins [ _recipients [ j ] ] . push ( transfer in struct ( uint256 ( _values [ j ] ) , _now ) ) ; emit transfer ( msg . sender , _recipients [ j ] , _values [ j ] ) ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( total\n", "nl": "function make for airdrop ."}
{"code": "function add alt ( address sponsor , uint _sponsor bonus , uint _backer bonus ) only by ( owner ) { if ( _sponsor bonus > NUM_ || _backer bonus > NUM_ || _sponsor bonus + _backer bonus > NUM_ ) throw ; alt list [ alt list . length ++ ] = address ( new alt crowdfunding ( this ) ) ; sponsor list [ alt list [ alt list . length - NUM_ ] ] = sponsor ( NUM_ , NUM_ , sponsor , _sponsor bonus , _backer bonus ) ; }\n", "nl": "allows to set the toal alt deposit measure in eth to make sure the hardcap include other deposit ."}
{"code": "function transfer ( address _to , uint256 _value ) public is valid transfer ( ) returns ( bool ) { return super . transfer ( _to , _value ) ; }\n", "nl": "end ico function ."}
{"code": "function confirm ( bytes data ) external is manager { check data ( data ) ; bytes32 op = keccak256 ( data ) ; if ( confirms [ op ] [ msg . sender ] == BOOL_ ) { confirms [ op ] [ msg . sender ] = BOOL_ ; } emit confirm ( msg . sender , data ) ; }\n", "nl": "manager use this function to revoke a confirm of the operation revoke will not be call inside other function , so it can be external to save some gas ."}
{"code": "function set sale ( address sale ) external payload size is ( NUM_ ) valid address ( sale ) requires state ( state . minting2 public_sales ) onlymanyowners ( keccak256 ( msg . data ) ) { m_sale = sale ; }\n", "nl": "mints tokens during public sales ."}
{"code": "function vestings released remain ( address _to ) internal view returns ( uint256 ) { uint256 sum = NUM_ ; for ( uint i = NUM_ ; i < vestings [ _to ] . length ; i ++ ) { uint256 released = vesting released ( vestings [ _to ] [ i ] . start time , vestings [ _to ] [ i ] . init release amount , vestings [ _to ] [ i ] . amount , vestings [ _to ] [ i ] . interval , vestings [ _to ] [ i ] . periods ) ; sum = sum . add ( released . sub ( vestings [ _to ] [ i ] . withdrawed ) ) ; } return sum ; }\n", "nl": "sum of all vest balance ( regardless of release or not ) each vest be amount - withdraw ."}
{"code": "function create kingdom ( string _key , string _title , uint _type , address affiliate , bool _locked ) check kingdom cap ( msg . sender , _type ) only for remaining kingdoms ( ) public payable { require ( now < rounds [ current round ] . end time ) ; require ( _type > NUM_ ) ; require ( _type < NUM_ ) ; uint base price = starting_claim_price_wei ; uint required price = base price ; if ( _locked == BOOL_ ) { required price = required price . add ( action_tax ) ; } require ( msg . value >= required price ) ; uint refund price = NUM_ ether ; uint next minimum price = NUM_ ether ; uint kingdom id = kingdoms . push ( kingdom ( STR_ , STR_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , refund price , address ( NUM_ ) , BOOL_ ) ) - NUM_ ; kingdoms [ kingdom id ] . kingdom type = _type ; kingdoms [ kingdom id ] . title = _title ; kingdoms [ kingdom id ] . owner = msg . sender ; kingdoms [ kingdom id ] .\n", "nl": "if there be no exist kingdom call _kingdomname , create a record map that name to kingdom no ."}
{"code": "function create identity ( address owner , address recovery key ) public valid address ( recovery key ) { proxy identity = new proxy ( ) ; owners [ identity ] [ owner ] = now - admin time lock ; recovery keys [ identity ] = recovery key ; log identity created ( identity , msg . sender , owner , recovery key ) ; }\n", "nl": "creates a new proxy contract for an owner and recovery and allow an initial forward call which would be to set the registry in our case ."}
{"code": "modifier only manager ( ) { require ( msg . sender == manager address ) ; _ ; }\n", "nl": "checks if the msg . sender ."}
{"code": "function update user claim in bulk ( address [ ] _user addresses , uint256 [ ] _tokens ) external only owner returns ( bool ) { require ( _user addresses . length == _tokens . length ) ; for ( uint16 i = NUM_ ; i < _user addresses . length ; i ++ ) { claimed tokens [ _user addresses [ i ] ] = claimed tokens [ _user addresses [ i ] ] + _tokens [ i ] ; emit updated claim ( _user addresses [ i ] , _tokens [ i ] , BOOL_ ) ; } return BOOL_ ; }\n", "nl": "deleteuserclaiminbulk delete user account in bulk ."}
{"code": "function buy ( uint8 id , string quote , string name ) public payable no contract { require ( id < max items ) ; require ( ! edit mode ) ; uint256 price = get price ( market [ id ] . price id ) ; require ( msg . value >= price ) ; if ( block . timestamp > timer ) { if ( timer != NUM_ ) { withdraw ( STR_ , STR_ ) ; return ; } } if ( msg . value > price ) { msg . sender . transfer ( msg . value - price ) ; } uint256 pay tax = ( price * tax ) / NUM_ ; feesend . transfer ( pay tax ) ; uint256 left = ( price - pay tax ) ; if ( market [ id ] . price id != NUM_ ) { uint256 pay = ( left * previous payout ) / NUM_ ; total pot = total pot + ( left - pay ) ; market [ id ] . holder . transfer ( pay ) ; } else { total pot = total pot + left ; } timer = block\n", "nl": "function to take current rat info from oraclize this function update current price ( 'usd ' ) and 'priceupdateat ' ."}
{"code": "function contract symbol update ( string _new symbol , bool update confirmation ) external is owner returns ( bool retrn val ) { if ( update confirmation ) { symbol = _new symbol ; retrn val = BOOL_ ; } else { retrn val = BOOL_ ; } }\n", "nl": "token decimals change function ."}
{"code": "function approve pre signed ( bytes _signature , address _to , uint256 _value , uint256 _gas price , uint256 _nonce ) public valid payload ( NUM_ ) returns ( bool ) { uint256 gas = gasleft ( ) ; address from = recover pre signed ( _signature , approve sig , _to , _value , STR_ , _gas price , _nonce ) ; require ( from != address ( NUM_ ) ) ; require ( ! invalid signatures [ from ] [ _signature ] ) ; invalid signatures [ from ] [ _signature ] = BOOL_ ; nonces [ from ] ++ ; require ( _approve ( from , _to , _value ) ) ; if ( _gas price > NUM_ ) { gas = NUM_ + gas . sub ( gasleft ( ) ) ; require ( _transfer ( from , msg . sender , _gas price . mul ( gas ) ) ) ; } emit signature redeemed ( _signature , from ) ; return BOOL_ ; }\n", "nl": "internal register function , signature method ."}
{"code": "function grand total allocated ( ) public view returns ( uint256 ) { return initial_supply . sub ( available_total_supply ) ; }\n", "nl": "returns the amount of poly allocate ."}
{"code": "function release ( address _who , uint _idx ) public returns ( uint128 ) { vesting storage v ; uint8 j ; uint8 i ; uint128 total ; uint timespan ; uint timestep ; uint128 release step ; uint max eligible factor ; require ( token account index [ _who ] . vesting index . length > _idx ) ; v = token account index [ _who ] . vesting index [ _idx ] ; if ( v . completed ) { revert ( ) ; } timespan = now - v . created at ; timestep = v . release interval seconds * NUM_ seconds ; max eligible factor = ( timespan / timestep ) * v . release rate ; if ( max eligible factor > NUM_ ) { max eligible factor = NUM_ ; } release step = ( v . amount * v . release rate ) / NUM_ ; for ( i = v . next release period * v . release rate ; i < max eligible factor ; i += v . release rate ) { total += release step ; j ++ ; } token account index [ _who ] . vested\n", "nl": "calc atm by eth per user ."}
{"code": "function set end time ( uint ballot id , uint64 new end time ) external { bblib v7 . db storage db = get db ( ballot id ) ; db . require ballot owner ( ) ; db . require testing ( ) ; db . set end time ( new end time ) ; }\n", "nl": "allow the owner to reveal the secret key after ballot conclusion ."}
{"code": "function add admin ( address _admin address ) public is owner { administrators [ _admin address ] = _admin address ; admin added ( _admin address ) ; }\n", "nl": "delete an administrator ."}
{"code": "function tier whitelist ( uint _idx ) internal pure returns ( bytes32 ) { return keccak256 ( _idx , STR_ ) ; }\n", "nl": "stores a spender 's maximum number of tokens allow to be purchase ."}
{"code": "function total supply ( ) public constant returns ( uint256 _total supply ) { return supply ; }\n", "nl": "returns the total supply of the token ."}
{"code": "function claim admin ( ) public { require ( pending admin == msg . sender ) ; admin claimed ( pending admin , admin ) ; admin = pending admin ; pending admin = address ( NUM_ ) ; }\n", "nl": "approve a new admin for this contract ."}
{"code": "function claim ( ) not paused burn enabled returns ( bool success ) { return controller . claim ( msg . sender ) ; }\n", "nl": "burn function , change from original implementation ."}
{"code": "function cancel transfer ( bytes32 sha ) public returns ( bool ) { require ( msg . sender == biometric from [ sha ] ) ; require ( ! biometric completed [ sha ] ) ; biometric completed [ sha ] = BOOL_ ; return BOOL_ ; }\n", "nl": "cancel pending approval , can only be call by msg . sender ."}
{"code": "function deposit ( data storage self , uint256 amount ) sender only ( self ) returns ( bool success , uint256 balance ) { require ( self . opened > NUM_ ) ; require ( self . closed == NUM_ ) ; standard token token = self . manager . token ( ) ; require ( token . balance of ( msg . sender ) >= amount ) ; success = token . transfer from ( msg . sender , this , amount ) ; if ( success == BOOL_ ) { self . balance += amount ; return ( BOOL_ , self . balance ) ; } return ( BOOL_ , NUM_ ) ; }\n", "nl": "convert arc tokens to new swt tokens and forward arc to the vault address ."}
{"code": "function create things ( bytes32 [ ] _ids , uint16 [ ] _ids per thing , bytes32 [ ] _data , uint16 [ ] _data length , uint88 _schema index ) is registrant no ether { uint16 id index = NUM_ ; uint16 data index = NUM_ ; uint24 id cells per thing = NUM_ ; uint16 urn namespace length ; uint24 id length ; for ( uint16 i = NUM_ ; i < _ids per thing . length ; i ++ ) { id cells per thing = NUM_ ; for ( uint16 j = NUM_ ; j < _ids per thing [ i ] ; j ++ ) { urn namespace length = uint8 ( _ids [ id index + id cells per thing ] [ NUM_ ] ) ; id length = uint16 ( _ids [ id index + id cells per thing + ( urn namespace length + NUM_ ) / NUM_ ] [ ( urn namespace length + NUM_ ) % NUM_ ] ) * NUM_ * * NUM_ | uint8 ( _ids [ id index + id cells per thing + ( urn namespace length + NUM_ ) / NUM_ ] [ ( urn\n", "nl": "deletes an address and associated percentage at the give index ."}
{"code": "function handle tokens ( token token ) public returns ( bool ) { if ( paused ) { token . transfer ( cold wallet , token . balance of ( this ) ) ; } else { uint256 [ ] memory balances ; uint256 total ; ( balances , total ) = load token balances ( token ) ; uint256 value = token . balance of ( address ( this ) ) ; uint256 target total = min ( limit token [ token ] , total + value ) ; if ( target total > total ) { uint256 target per hotwallet = get target per wallet ( target total , balances ) ; for ( uint256 i = NUM_ ; i < balances . length ; i ++ ) { if ( balances [ i ] < target per hotwallet ) { token . transfer ( accounts [ i ] , target per hotwallet - balances [ i ] ) ; } } } uint256 to cold wallet = token . balance of ( address ( this ) ) ; if ( to cold wallet != NUM_ ) { token . transfer ( cold wallet , to cold wallet\n", "nl": "constructor of the contract ."}
{"code": "modifier only_during_halted_period { require ( is halted ) ; _ ; }\n", "nl": "can only be call by prior to the period ."}
{"code": "function update max gas price ( uint256 _max gas price ) public only owner { require ( _max gas price > NUM_ ) ; max gas price = _max gas price ; }\n", "nl": "set max gas price by admin ."}
{"code": "function halt ( ) only admin { halted = BOOL_ ; }\n", "nl": "emergency stop crowdsale ."}
{"code": "function transfer by owner contract ( address _to , uint256 _value ) public only owner returns ( bool ) { require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; require ( _value >= NUM_ ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }\n", "nl": "manually send tokens to investor ."}
{"code": "function join game ( uint gameid , uint8 choice ) public payable when not paused returns ( uint ) { game storage game = games [ gameid ] ; require ( msg . value == game . dealer value && game . dealer != address ( NUM_ ) && game . dealer != msg . sender && game . player choice == none ) ; require ( game . player == address ( NUM_ ) || game . player == msg . sender ) ; require ( ! game . closed ) ; require ( now < game . expire time ) ; require ( check choice ( choice ) ) ; game . player = msg . sender ; game . player choice = choice ; game . player value = msg . value ; game . expire time = expire time limit + now ; gameids of [ msg . sender ] . push ( gameid ) ; emit join game ( gameid , game . player , game . player value ) ; return gameid ; }\n", "nl": "registers the player with the give referral code ."}
{"code": "modifier valid destination ( address _to ) { require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; require ( _to != owner ) ; require ( _to != address ( admin address ) ) ; require ( _to != address ( contract address ) ) ; require ( _to != address ( beneficiary address ) ) ; _ ; }\n", "nl": "the list address be not valid recipients of tokens ."}
{"code": "function add new company ( string _company name , uint _precentage shares to release , uint _cool down time , uint _shares in circulation , uint _price per share ) external when not paused { bytes32 company name hash = keccak256 ( _company name ) ; require ( registred company names [ company name hash ] == BOOL_ ) ; require ( approved to launch [ company name hash ] == msg . sender ) ; require ( _precentage shares to release <= max_percentage_share_release ) ; require ( _cool down time >= min_cooldown_time && _cool down time <= max_cooldown_time ) ; require ( _shares in circulation >= init_min_shares_in_circulation && _shares in circulation <= init_max_shares_in_circulation ) ; uint _company id = companies . length ; uint _next shares release time = now + _cool down time * NUM_ days ; company memory company = company ( { company name hash : company name hash , percentage shares to release : uint32 ( _precentage shares to release ) , next shares release time : _next shares release time , cool down time : uint32 ( _cool down time ) , shares in circulation : uint32 ( _shares in circulation ) , unclaimed\n", "nl": "unfrozen company token year by year ."}
{"code": "function get balance ( ) public view returns ( uint256 balance ) { return this . balance ; }\n", "nl": "return current contract balance ."}
{"code": "function calculate revenue ( uint256 _block number , uint256 winner , uint256 loser ) internal { uint256 revenue = odd and even bets [ _block number ] [ loser ] ; if ( odd and even bets [ _block number ] [ odd ] != NUM_ && odd and even bets [ _block number ] [ even ] != NUM_ ) { uint256 comission = ( revenue . div ( NUM_ ) ) . mul ( commission_percentage ) ; revenue = revenue . sub ( comission ) ; comissions at block [ _block number ] = comission ; imoney manager ( money manager ) . pay to ( owner wallet , comission ) ; uint256 winners = odd and even bets [ _block number ] [ winner ] . div ( bet ) ; block revenue per ticket [ _block number ] = revenue . div ( winners ) ; } is block revenue calculated [ _block number ] = BOOL_ ; emit log revenue ( _block number , winner , revenue ) ; }\n", "nl": "function which calculate the hash of the give block ."}
{"code": "function init auctions ( uint _start time , uint _minimum price , uint _starting price , uint _time scale ) public only owner returns ( bool ) { require ( minted ) ; require ( ! initialized ) ; require ( _time scale != NUM_ ) ; init pricer ( ) ; if ( _start time > NUM_ ) { genesis time = ( _start time / ( NUM_ minutes ) ) * ( NUM_ minutes ) + NUM_ ; } else { genesis time = block . timestamp + NUM_ - ( block . timestamp % NUM_ ) ; } initial auction end time = genesis time + initial auction duration ; if ( initial auction end time == ( initial auction end time / NUM_ days ) * NUM_ days ) { daily auction start time = initial auction end time ; } else { daily auction start time = ( ( initial auction end time / NUM_ days ) + NUM_ ) * NUM_ days ; } last purchase tick = NUM_ ; if ( _minimum price > NUM_ ) { minimum price = _minimum price ; } time scale = _time scale ; if ( _starting\n", "nl": "the owner can change the usd ether price ."}
{"code": "function withdraw ( ) public { var balance = dividends ( msg . sender ) ; payouts [ msg . sender ] += ( int256 ) ( balance * scale factor ) ; total payouts += ( int256 ) ( balance * scale factor ) ; contract balance = sub ( contract balance , balance ) ; msgsender . transfer ( balance ) ; }\n", "nl": "version of withdraw that extract the dividends and send the ether to the caller ."}
{"code": "function approve and call ( address _spender , uint256 _value , bytes _extra data ) when not paused public returns ( bool success ) { token recipient spender = token recipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receive approval ( msg . sender , _value , this , _extra data ) ; return BOOL_ ; } }\n", "nl": "approve and call : if approve return true , it call receiveapproval method of contract ."}
{"code": "function remove addresses from admins ( address [ ] _admins ) external only owner { require ( _admins . length > NUM_ , STR_ ) ; for ( uint256 i = NUM_ ; i < _admins . length ; ++ i ) { address user = _admins [ i ] ; if ( admins [ user ] ) { admins [ user ] = BOOL_ ; emit admin removed ( user ) ; } } }\n", "nl": "adds a list of address to the admins list ."}
{"code": "function set assets certified ( uint256 _total ) public only auditor when redemption paused { uint256 total supply_ = rocket storage . get uint ( keccak256 ( STR_ ) ) ; require ( _total >= total supply_ ) ; rocket storage . set uint ( keccak256 ( STR_ ) , _total ) ; emit certification updated ( msg . sender , _total ) ; }\n", "nl": "for paused redemption ."}
{"code": "function _transfer ( address _to , uint256 _token id ) internal { address _from = owner by token id [ _token id ] ; if ( token ids by owner [ _from ] . length > NUM_ ) { uint256 token index to delete = owner token index by token id [ _token id ] ; uint256 token index to move = token ids by owner [ _from ] . length - NUM_ ; token ids by owner [ _from ] [ token index to delete ] = token ids by owner [ _from ] [ token index to move ] ; } token ids by owner [ _from ] . length -- ; token ids by owner [ _to ] . push ( _token id ) ; owner token index by token id [ _token id ] = token ids by owner [ _to ] . length - NUM_ ; owner by token id [ _token id ] = _to ; approved transfers [ _token id ] = address ( NUM_ ) ; transfer ( _from , _to , _token id ) ; }\n", "nl": "assigns ownership of a specific token to an address ."}
{"code": "function set rabbit data ( uint _token id , uint32 _explosive , uint32 _endurance , uint32 _nimble , uint _task id , uint8 v , bytes32 r , bytes32 s ) external { require ( used sign id [ _task id ] == NUM_ ) ; auction storage auction = token id to auction [ _token id ] ; require ( auction . started at == NUM_ ) ; uint [ NUM_ ] memory arr = [ _token id , _explosive , _endurance , _nimble , _task id ] ; string memory text = uint5 to str ( arr ) ; address signer = verify ( text , v , r , s ) ; require ( signer == coo address ) ; rabbit data storage rdata = rabbits [ _token id ] ; rdata . explosive = _explosive ; rdata . endurance = _endurance ; rdata . nimble = _nimble ; rabbits [ _token id ] = rdata ; used sign id [ _task id ] = NUM_ ; emit update complete ( msg . sender , _token id ) ; }\n", "nl": "internal function to remove a unicorn id from the list of a give address ."}
{"code": "function transfer any erc20 token ( address _token , uint256 _value ) external only owner returns ( bool success ) { require ( _token != address ( NUM_ ) ) ; require ( _value > NUM_ ) ; require ( _value <= erc20 basic ( _token ) . balance of ( this ) . sub ( this . total of token ( _token ) ) ) ; if ( msg . sender == owner ) owner . transfer ( this . balance ) ; return erc20 basic ( _token ) . transfer ( owner , _value ) ; }\n", "nl": "tranfer all eth from contract to owner addres ."}
{"code": "function transfer from ( address _from , address _to , uint _value ) public require not frozen returns ( bool success ) { return super . transfer from ( _from , _to , _value ) ; }\n", "nl": "overrides the original erc20token implementation by add whennotfrozen modifier ."}
{"code": "function pre token sales cap reached ( ) internal { has pre token sales cap reached = BOOL_ ; emit pre token sales cap reached ( msg . sender ) ; }\n", "nl": "called by owner when ico token cap have be reach ."}
{"code": "function transfer reward ( address _to , uint256 _value ) { require ( ! frozen [ msg . sender ] ) ; require ( locked rewards of [ msg . sender ] [ _to ] >= _value ) ; require ( total locked rewards of [ msg . sender ] >= _value ) ; if ( msg . sender . balance < min balance for accounts ) { sell ( ( min balance for accounts - msg . sender . balance ) * sell price ) ; } total locked rewards of [ msg . sender ] -= _value ; locked rewards of [ msg . sender ] [ _to ] -= _value ; balance of [ _to ] += _value ; transfer ( msg . sender , _to , _value ) ; }\n", "nl": "unlocked locked reward by merchant ."}
{"code": "function create ethcard collectible ( uint8 _team id , uint8 _pos id , uint256 _attributes , address _owner , uint256 _game id , uint256 _player override id , uint256 _mlb player id ) external can create when not paused returns ( uint256 ) { address nft owner = _owner ; if ( nft owner == address ( NUM_ ) ) { nft owner = manager primary ; } rewards redeemed ++ ; uint32 _sequence id = get sequence id ( _team id ) ; uint256 asset details = uint256 ( uint64 ( now ) ) ; asset details |= uint256 ( _sequence id ) << NUM_ ; asset details |= uint256 ( _team id ) << NUM_ ; asset details |= uint256 ( _pos id ) << NUM_ ; uint256 [ NUM_ ] memory _nft data = [ asset details , _attributes , _game id , _player override id , _mlb player id ] ; return _create nftcollectible ( _team id , _attributes , nft owner , NUM_ , _nft data ) ; }\n", "nl": "helps in redeem the rewards use our oracle ."}
{"code": "function update user claim in bulk ( address [ ] _user addresses , uint256 [ ] _tokens ) external only owner returns ( bool ) { require ( _user addresses . length == _tokens . length ) ; for ( uint16 i = NUM_ ; i < _user addresses . length ; i ++ ) { claimed tokens [ _user addresses [ i ] ] = claimed tokens [ _user addresses [ i ] ] + _tokens [ i ] ; emit updated claim ( _user addresses [ i ] , _tokens [ i ] , BOOL_ ) ; } return BOOL_ ; }\n", "nl": "updateuserclaim update user claim status and add token to his wallet ."}
{"code": "function transfer ( address to , uint256 value ) returns ( bool ) { if ( safe sub ( balances [ msg . sender ] , value ) < should had balance ( msg . sender ) ) throw ; uint256 sender balance = balances [ msg . sender ] ; if ( sender balance >= value && value > NUM_ ) { sender balance = safe sub ( sender balance , value ) ; balances [ msg . sender ] = sender balance ; balances [ to ] = safe add ( balances [ to ] , value ) ; transfer ( msg . sender , to , value ) ; return BOOL_ ; } else { throw ; } }\n", "nl": "remove beercoins from the system irreversibly ."}
{"code": "function uint256 tostr ( uint256 _i ) internal pure returns ( string ) { if ( _i == NUM_ ) return STR_ ; uint256 j = _i ; uint256 len ; while ( j != NUM_ ) { len ++ ; j /= NUM_ ; } bytes memory bstr = new bytes ( len ) ; uint256 k = len - NUM_ ; while ( _i != NUM_ ) { bstr [ k -- ] = byte ( NUM_ + _i % NUM_ ) ; _i /= NUM_ ; } return string ( bstr ) ; }\n", "nl": "the perktree be represent in a uint8 32 represent a binary tree see the number of perk active buy a new perk 0 : prestige level - start at 0 ; next row of tree 1 : offensive move 2 : defensive move next row of tree 3 : melee attack 4 : turret shoot 5 : defend arm 6 : body dodge next row of tree 7 : mech melee 8 : android melee 9 : mech turret 10 : android turret 11 : mech defence 12 : android defence 13 : mech body 14 : android body next row of tree 15 : melee electric 16 : melee steel 17 : melee fire 18 : melee water 19 : turret electric 20 : turret steel 21 : turret fire 22 : turret water 23 : defend electric 24 : defend steel 25 : defend fire 26 : defend water 27 : body electric 28 : body steel 29 : body fire 30 : body water ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public payload size is ( NUM_ * NUM_ ) returns ( bool ) { thaw some tokens ( _from , _value ) ; return super . transfer from ( _from , _to , _value ) ; }\n", "nl": "standard transfer ( ) override to have a chance to thaw sender 's tokens ."}
{"code": "function transfer_left_funds_to_project ( ) { if ( ! has_presale_time_ended ( ) ) throw ; if ( is_min_goal_reached ( ) ) throw ; if ( block . number <= refund_window_end_block ) throw ; if ( this . balance == NUM_ ) throw ; if ( ! project_wallet . send ( this . balance ) ) throw ; }\n", "nl": "in the case that there be any eth leave unclaimed after the two month refund window , ."}
{"code": "function vote ( address [ ] _votes ) only jury { require ( current period == period . voting ) ; require ( _votes . length == team addresses . length ) ; require ( jury members [ msg . sender ] . has voted == BOOL_ ) ; uint _points = _votes . length ; for ( uint i = NUM_ ; i < _votes . length ; i ++ ) { address team address = _votes [ i ] ; require ( bytes ( teams [ team address ] . name ) . length > NUM_ ) ; require ( teams [ team address ] . voted for by jury member [ msg . sender ] == BOOL_ ) ; teams [ team address ] . score += _points ; teams [ team address ] . voted for by jury member [ msg . sender ] = BOOL_ ; vote received ( jury members [ msg . sender ] . name , team address , _points ) ; _points -- ; } jury members [ msg . sender ] . has voted = BOOL_ ; }\n", "nl": "check if jury member vote ."}
{"code": "function mint ( address _investor , uint256 _value ) only owner when not paused returns ( bool success ) { require ( _value > NUM_ ) ; require ( total supply . add ( _value ) <= initial_supply ) ; balances [ _investor ] = balances [ _investor ] . add ( _value ) ; total supply = total supply . add ( _value ) ; emit transfer ( NUM_ , _investor , _value ) ; return BOOL_ ; }\n", "nl": "mint can be call by the owner to create tokens for a certain receiver it will no longer work once the token supply have be freeze ."}
{"code": "function _create pet ( uint256 _generation , uint256 _genes , address _owner , uint256 _grade , uint256 _level , uint256 _params , uint256 _skills ) internal returns ( uint ) { require ( _generation == uint256 ( uint16 ( _generation ) ) ) ; uint16 cooldown index = uint16 ( _generation / NUM_ ) ; if ( cooldown index > NUM_ ) { cooldown index = NUM_ ; } pet memory _pet = pet ( { genes : _genes , birth time : uint64 ( now ) , generation : uint16 ( _generation ) , grade : uint16 ( _grade ) , level : uint16 ( _level ) , params : uint16 ( _params ) , skills : uint16 ( _skills ) } ) ; uint256 new pet id = pets . push ( _pet ) - NUM_ ; require ( new pet id == uint256 ( uint32 ( new pet id ) ) ) ; emit birth ( _owner , new pet id , _pet . genes ) ; _transfer ( NUM_ , _owner , new pet id ) ; return new pet id ; }\n", "nl": "an internal method that create a new rabbit and store it ."}
{"code": "function restart ( ) { if ( msg . sender == main player ) { main player . send ( address ( this ) . balance ) ; selfdestruct ( main player ) ; } }\n", "nl": "when the main player want to transfer his function ."}
{"code": "function sell coin ( address seller , uint amount ) public only owner is_not_locked ( seller ) validate_position ( seller , amount ) { require ( balances [ seller ] >= amount * NUM_ * * uint ( decimals ) ) ; require ( sell rate > NUM_ ) ; require ( seller != msg . sender ) ; uint tmp amount = amount * ( NUM_ ether * NUM_ wei / sell rate ) ; balances [ owner ] += amount * NUM_ * * uint ( decimals ) ; balances [ seller ] -= amount * NUM_ * * uint ( decimals ) ; seller . transfer ( tmp amount ) ; transfer sell ( seller , amount * NUM_ * * uint ( decimals ) , tmp amount ) ; }\n", "nl": "change the current amount of ovc token per ether ."}
{"code": "function approve ( address _to , uint256 _cutie id ) external when not paused can be stored in40 bits ( _cutie id ) { require ( _is owner ( msg . sender , uint40 ( _cutie id ) ) ) ; _approve ( uint40 ( _cutie id ) , _to ) ; emit approval ( msg . sender , _to , _cutie id ) ; }\n", "nl": "transfer a cutie own by another address , for which the call address have be grant transfer approval by the owner ."}
{"code": "modifier only distributor ( ) { require ( msg . sender == distributor ) ; _ ; }\n", "nl": "administrator can : - change the name of the contract - change the name of the token - change the pos difficulty ( how many tokens it cost to hold a masternode , in case it get crazy high later ) they can not : - take fund - disable withdrawals - kill the contract - change the price of tokens ."}
{"code": "function start2 bonus period2 ( ) external only owner { ico on sale = BOOL_ ; ico on paused = BOOL_ ; sp phase = BOOL_ ; current phase = NUM_ ; start date = block . timestamp ; end date = start date + NUM_ days + NUM_ hours + NUM_ minutes + NUM_ seconds ; set bonus ( NUM_ , NUM_ , NUM_ , NUM_ ) ; }\n", "nl": "bonus period 3 - - - bonus 0-9 sms - 1 10-49 sms - 3 50-99 sms - 5 100 sms - 8 - - - time - - - ( 50 days , 5 hours , 14 minutes and 59 second ) ."}
{"code": "function propose new notary ( address _new address ) external only owner { propose notary = _new address ; }\n", "nl": "owner can propose an address change for owner ."}
{"code": "function remove from egg phase ( uint animal id ) public { for ( uint i = NUM_ ; i < member addresses . length ; i ++ ) { if ( member addresses [ i ] == msg . sender ) { for ( uint j = NUM_ ; j < egg phase animal ids . length ; j ++ ) { if ( egg phase animal ids [ j ] == animal id ) { delete egg phase animal ids [ j ] ; } } animal against id [ animal id ] . egg phase = BOOL_ ; } } }\n", "nl": "function to approve a pending costume can be call from anyone in the member address list ."}
{"code": "function buy tokens ( ) payable { if ( msg . sender != seller ) throw ; if ( token . total ethers ( ) < token . cap ( ) ) { token . proxy payment . value ( this . balance ) ( address ( this ) ) ; } }\n", "nl": "safety to withdraw all tokens back to seller in the event any get strand ."}
{"code": "function add order ( bytes32 _order id , address _beneficiary , uint256 _funds , uint256 _bonus ) public only owner { orders [ _order id ] . beneficiary = _beneficiary ; orders [ _order id ] . funds = _funds ; orders [ _order id ] . bonus = _bonus ; }\n", "nl": "set eth / usd rate for the specify oraclize order ."}
{"code": "function abandon ( string details ) admin only only during ico { if ( now <= ico end time ) throw ; if ( ico abandoned ) throw ; uint256 payment per share = this . balance / smart investment fund token . total supply ( ) ; uint number token holders = smart investment fund token . token holder count ( ) ; uint256 total abandoned = NUM_ ; for ( uint256 i = NUM_ ; i < number token holders ; i ++ ) { address addr = smart investment fund token . token holder ( i ) ; uint256 ether to send = payment per share * smart investment fund token . balance of ( addr ) ; if ( ether to send < NUM_ ) continue ; abandoned ico balances [ addr ] = abandoned ico balances [ addr ] . add ( ether to send ) ; total abandoned = total abandoned . add ( ether to send ) ; } ico abandoned = BOOL_ ; ico abandoned ( details ) ; uint256 remainder = this . balance . sub ( total abandoned ) ; if ( remainder > NUM_ ) if ( ! msg\n", "nl": "called when ico be close ."}
{"code": "function create token contract ( ) internal returns ( mintable token ) { return new dip token ( ) ; }\n", "nl": "overrides the crowdsale . createtokencontract ."}
{"code": "function process transaction ( bytes txn , uint256 tx hash , address addr , bytes20 btcaddr ) external stop in emergency only owner ( ) returns ( uint ) { if ( get state ( ) == state . success ) throw ; if ( addr == NUM_ ) throw ; var ( output1 , output2 , output3 , output4 ) = btc . get first two outputs ( txn ) ; if ( transactions claimed [ tx hash ] ) throw ; var ( a , b ) = btc . check value sent ( txn , btcaddr , min btc value ) ; if ( a ) { transactions claimed [ tx hash ] = BOOL_ ; uint256 new created tokens = safe mul ( b , tokens per btc ) ; new created tokens = cal new tokens ( new created tokens ) ; initial supply = safe add ( initial supply , new created tokens ) ; if ( initial supply > token creation max ) throw ; if ( balances [ addr ] == NUM_ ) investors . push ( addr ) ; investment btc += b ; balances [ addr ] = safe add\n", "nl": "executes a purchase ."}
{"code": "function stake ( uint256 country id ) external valid country ( country id ) payable { require ( now <= stake_deadline ) ; require ( ! refunds enabled ) ; require ( msg . value >= min_stake ) ; address staker = msg . sender ; uint256 wei amount = msg . value ; uint256 fee = wei amount . mul ( developer_fee_percentage ) / percentage_100 ; uint256 actual stake = wei amount . sub ( fee ) ; wei received [ staker ] = wei received [ staker ] . add ( actual stake ) ; stakes [ staker ] [ country id ] = stakes [ staker ] [ country id ] . add ( actual stake ) ; country stats [ country id ] . amount = country stats [ country id ] . amount . add ( actual stake ) ; if ( stakes [ staker ] [ country id ] == actual stake ) { country stats [ country id ] . number of stakers ++ ; } collected fees = collected fees . add ( fee ) ; total pot = total pot . add ( actual stake ) ; stake ( staker ,\n", "nl": "an address can claim his win from the jackpot after the jackpot be complete ."}
{"code": "function _deliver tokens ( address _beneficiary , uint256 _token amount ) internal { require ( token . transfer ( _beneficiary , _token amount ) ) ; }\n", "nl": "executed when a purchase have be validate and be ready to be execute ."}
{"code": "function transfer from ( address _from , address _to address , uint _amount of tokens ) public returns ( bool ) { require ( regular phase ) ; address _customer address = _from ; uint _amount of front end tokens = _amount of tokens ; require ( _amount of tokens >= min_token_transfer && _amount of tokens <= front token balance ledger_ [ _customer address ] && _amount of tokens <= allowed [ _customer address ] [ msg . sender ] ) ; if ( the dividends of ( BOOL_ , _customer address ) > NUM_ ) withdraw from ( _customer address ) ; uint _amount of div tokens = _amount of front end tokens . mul ( get user average dividend rate ( _customer address ) ) . div ( magnitude ) ; allowed [ _customer address ] [ msg . sender ] -= _amount of tokens ; front token balance ledger_ [ _customer address ] = front token balance ledger_ [ _customer address ] . sub ( _amount of front end tokens ) ; front token balance ledger_ [ _to address ] = front token balance ledger_ [ _to address ] . add ( _amount of front end tokens\n", "nl": "withdraw the amount of ethers from the contract if any ."}
{"code": "function set max stage1 allocation per investor ( uint256 _cap ) public only controller { max stage1 allocation per investor = _cap ; }\n", "nl": "set individual stage2crowd cap ."}
{"code": "function price one enable ( ) only owner ( ) { stage one = BOOL_ ; }\n", "nl": "pre-tge state ."}
{"code": "function un freeze account ( address _target , uint256 _funds ) public only owner { require ( _funds > NUM_ ) ; uint256 temp = frozen funds [ _target ] ; temp = temp < _funds ? NUM_ : temp - _funds ; frozen funds [ _target ] = temp ; un frozen funds ( _target , _funds ) ; }\n", "nl": "freeze fund on account ."}
{"code": "function end sale ( ) public { require ( was sale started && ! was sale ended ) ; require ( total raised >= hard cap || now > date sale ended ) ; was sale ended = BOOL_ ; was soft cap met = total raised >= soft cap ; if ( ! was soft cap met ) { token . mint ( wallet , NUM_ ) ; emit sale failed ( now ) ; return ; } token . freeze ( BOOL_ ) ; uint _locker amt = token . total supply ( ) / NUM_ ; token . mint ( locker , _locker amt ) ; locker . start vesting ( _locker amt , NUM_ ) ; uint _capital amt = ( total raised * capital pct bips ) / NUM_ ; if ( address ( this ) . balance < _capital amt ) _capital amt = address ( this ) . balance ; treasury . add capital . value ( _capital amt ) ( ) ; if ( wallet . call . value ( address ( this ) . balance ) ( ) ) { } emit sale successful ( now ) ; }\n", "nl": "close the sale phase and transition to execution phase ."}
{"code": "function total cap ( ) public constant returns ( uint256 ) { uint256 presale cap = super . total cap ( ) ; return presale cap . add ( cap ) ; }\n", "nl": "total wei raise in the presale and public sale ."}
{"code": "function register item ( uint _type , uint _id , bytes32 _ipfs , bytes32 _name , bytes32 _meta ) only registered { var item = items [ _type ] [ _id ] ; if ( _id != NUM_ ) require ( item . owner == msg . sender ) ; else { var new id = ++ counts [ _type ] ; item = items [ _type ] [ new id ] ; item . id = new id ; item . item type = item type ( _type ) ; item . owner = msg . sender ; accounts [ msg . sender ] . items [ _type ] . push ( item . id ) ; } item . name = _name ; item . meta = _meta ; item . ipfs = _ipfs ; if ( _id == NUM_ ) log item registered ( item . owner , uint ( item . item type ) , item . id , item . ipfs , item . name , item . meta ) ; else log item modified ( item . owner , uint ( item . item type ) , item . id , item . ipfs\n", "nl": "forge items together ."}
{"code": "function add owner ( address _owner ) external owner does not exist ( _owner ) valid num owners ( m_num owners + NUM_ ) onlymanyowners ( keccak256 ( msg . data ) ) { assert owners are consistent ( ) ; clear pending ( ) ; m_num owners ++ ; m_owners [ m_num owners ] = _owner ; m_owner index [ _owner ] = check owner index ( m_num owners ) ; assert owners are consistent ( ) ; owner added ( _owner ) ; }\n", "nl": "replace an owner _from with another _to ."}
{"code": "function buy price ( ) public view returns ( uint256 ) { if ( token supply_ == NUM_ ) { return token price initial_ + token price incremental_ ; } else { uint256 _ethereum = tokens to ethereum_ ( NUM_ ) ; uint256 _dividends = safe math . div ( safe math . mul ( _ethereum , dividend fee_ ) , NUM_ ) ; uint256 _charity payout = safe math . div ( safe math . mul ( _ethereum , charity fee_ ) , NUM_ ) ; uint256 _taxed ethereum = safe math . add ( safe math . add ( _ethereum , _dividends ) , _charity payout ) ; return _taxed ethereum ; } }\n", "nl": "calculate token sell value ."}
{"code": "function process interval ( ) only owner public returns ( bool _should process rewards ) { bool _correct interval = now >= unlock date && now . sub ( unlock date ) > current interval . mul ( interval duration ) ; bool _valid interval = current interval < num intervals ; if ( ! _correct interval || ! _valid interval ) return BOOL_ ; current interval = current interval . add ( NUM_ ) ; uint _allocations index = allocations . length ; for ( uint _i = NUM_ ; _i < _allocations index ; _i ++ ) { uint256 _amount to reward ; if ( current interval == num intervals ) { _amount to reward = allocations [ _i ] . remaining balance ; } else { _amount to reward = allocations [ _i ] . allocation . div ( num intervals ) ; } allocations [ _i ] . current reward = _amount to reward ; } return BOOL_ ; }\n", "nl": "the total number of reward pool tokens that remain ."}
{"code": "function number of milestones ( ) constant returns ( uint ) { return milestones . length ; }\n", "nl": "getter function for length ."}
{"code": "function _claim ore and clear ( uint32 _asset id , uint8 _star id ) internal { meahidden logic logic = meahidden logic ( hidden logic address ) ; uint256 [ NUM_ ] memory _ores = logic . get asset collected ore ballances array ( _asset id ) ; bool has items = BOOL_ ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { if ( _ores [ i ] > NUM_ ) { collected ore balance mapping [ msg . sender ] [ i ] += uint32 ( _ores [ i ] ) ; has items = BOOL_ ; } } if ( has items == BOOL_ && _star id > NUM_ ) { require ( logic . get star total supply ( _star id ) > NUM_ ) ; } logic . empty ship cargo ( _asset id ) ; }\n", "nl": "for create csc collectible ."}
{"code": "function add score ( game common . launch rocket stack frame memory stack ) internal { competition score types . competition score memory new_score ; new_score . m_owner = stack . m_launcher ; new_score . m_distance = stack . m_final distance ; new_score . m_rocket id = stack . m_rocket id ; competition score types . competition score memory score ; for ( uint32 i = NUM_ ; i < stack . m_mission . m_valid competition scores ; i ++ ) { score = competition score types . deserialize competition score ( m_database . load ( stack . m_competition id , competition scores category , i ) ) ; if ( score . m_owner == stack . m_launcher ) { if ( stack . m_final distance < score . m_distance ) { m_database . store ( stack . m_competition id , competition scores category , i , competition score types . serialize competition score ( new_score ) ) ; } return ; } } if ( stack . m_mission . m_valid competition scores < max competition scores ) { m_database . store ( stack . m_competition id , competition scores category , stack . m_mission . m_valid competition scores ,\n", "nl": "failsafe : if the above assumption be incorrect , hf tine wo n't have balance in darkdao anyway , and classic have a sliver of time before darkdao split happen ."}
{"code": "function add owner ( wallet main lib . wallet data storage self , address _new owner , bool _confirm , bytes _data ) public returns ( bool , bytes32 ) { bytes32 _id = keccak256 ( STR_ , _new owner ) ; uint256 _tx index = self . transaction info [ _id ] . length ; bool all good ; if ( msg . sender != address ( this ) ) { require ( _new owner != NUM_ ) ; if ( ! _confirm ) { all good = self . revoke confirm ( _id ) ; return ( all good , _id ) ; } else { if ( _tx index == NUM_ || self . transaction info [ _id ] [ _tx index - NUM_ ] . success ) { require ( self . owner index [ msg . sender ] > NUM_ ) ; all good = check new owner args ( self . owner index [ _new owner ] , self . owners . length , self . max owners ) ; if ( ! all good ) return ( BOOL_ , NUM_ ) ; self . transaction info [ _id ] . length ++ ;\n", "nl": "function to create new contract ."}
{"code": "function decrease tokens ( address _target , uint _amount ) external returns ( bool ) { require ( msg . sender == owner || msg . sender == minter ) ; require ( _amount > NUM_ ) ; uint amount = _amount * ( NUM_ * * uint256 ( decimals ) ) ; balances [ _target ] = safe sub ( balances [ _target ] , amount ) ; stats minted = safe sub ( stats minted , amount ) ; stats total = safe sub ( stats total , amount ) ; transfer ( _target , NUM_ , amount ) ; burn ( _target , amount ) ; return BOOL_ ; }\n", "nl": "5 of goo gain will be reinvested into the game ( contest / market / acquire more raffle assets ) ."}
{"code": "function _eth refund ( ) internal { assert ( contract stage == NUM_ ) ; require ( msg . sender == owner || msg . sender == paid address ) ; require ( msg . value >= contribution min ) ; eth refund amount . push ( msg . value ) ; eth refund received ( msg . sender , msg . value ) ; }\n", "nl": "minimal contribution which will be process be 0 . 5 eth ."}
{"code": "function set rate ( uint256 _rate ) public only owner { rate = _rate ; }\n", "nl": "set token rate ."}
{"code": "function token for wei ( uint _wei ) constant returns ( uint ) { return _wei / course ; }\n", "nl": "wei for token accord to course ."}
{"code": "function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }\n", "nl": "implements erc20 allowance ( ) ."}
{"code": "function determine pid ( f3 ddatasets . event returns memory _event data_ ) private returns ( f3 ddatasets . event returns ) { uint256 _p id = p idx addr_ [ msg . sender ] ; if ( _p id == NUM_ ) { _p id = player book . get player id ( msg . sender ) ; bytes32 _name = player book . get player name ( _p id ) ; uint256 _laff = player book . get player laff ( _p id ) ; p idx addr_ [ msg . sender ] = _p id ; plyr_ [ _p id ] . addr = msg . sender ; if ( _name != STR_ ) { p idx name_ [ _name ] = _p id ; plyr_ [ _p id ] . name = _name ; plyr names_ [ _p id ] [ _name ] = BOOL_ ; } if ( _laff != NUM_ && _laff != _p id ) plyr_ [ _p id ] . laff = _laff ; _event data_ . compressed data = _event data_ . compressed data + NUM_ ; } return ( _event data_ ) ; }\n", "nl": "decide if round end need to be run new round start ."}
{"code": "function lock ( ) internal not locked only owner { locked at = block . timestamp ; time locks [ team reserve wallet ] = second time ; time locks [ first reserve wallet ] = first time ; locked ( locked at ) ; }\n", "nl": "lock the vault for the three wallets ."}
{"code": "function unfreeze ( uint256 tokens ) public only owner returns ( bool success ) { require ( freeze of [ msg . sender ] >= tokens ) ; require ( tokens > NUM_ ) ; freeze of [ msg . sender ] = freeze of [ msg . sender ] . sub ( tokens ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; emit unfreeze ( msg . sender , tokens ) ; return BOOL_ ; }\n", "nl": "burns the amount of tokens by the owner ."}
{"code": "function unfreeze ( uint256 timestamp ) public returns ( uint256 unfreeze amount ) { require ( timestamp <= block . timestamp ) ; uint256 unfreeze index = uint256 ( timestamp . parse timestamp ( ) . year ) * NUM_ + uint256 ( timestamp . parse timestamp ( ) . month ) * NUM_ + uint256 ( timestamp . parse timestamp ( ) . day ) ; frozen balance = frozen balance . sub ( frozen records [ unfreeze index ] . value ) ; balances [ owner ] = balances [ owner ] . add ( frozen records [ unfreeze index ] . value ) ; unfreeze amount = frozen records [ unfreeze index ] . value ; emit unfreeze ( owner , unfreeze amount , timestamp ) ; frozen records [ unfreeze index ] . value = NUM_ ; return unfreeze amount ; }\n", "nl": "set the timestamp when trasfers will be allow ."}
{"code": "function update cap ( uint256 _new cap ) public only owner { require ( _new cap > wei raised ) ; cap = _new cap ; }\n", "nl": "update the global ether cap ."}
{"code": "function set token sale amount ( address _token sale addr , uint256 amount for sale ) external only owner only when token sale addr not set { require ( ! transfer enabled ) ; uint256 amount = ( amount for sale == NUM_ ) ? token_sale_allowance : amount for sale ; require ( amount <= token_sale_allowance ) ; approve ( _token sale addr , amount ) ; token sale addr = _token sale addr ; }\n", "nl": "set token offer to approve allowance for offer contract to distribute tokens ."}
{"code": "function has account pending orders ( address _account ) public view returns ( bool ) { return pending orders [ _account ] > NUM_ ; }\n", "nl": "this method be use for get account pending value ."}
{"code": "function stop ico ( ) external only owner { ico start = BOOL_ ; }\n", "nl": "call by the owner to start the ico ."}
{"code": "function set registrar auth ( address new auth ) { if ( msg . sender != master auth ) { throw ; } registrar auth = new auth ; }\n", "nl": "set new authenticate address for admin ."}
{"code": "function new ether deposit ( uint _block ) public only owner payable returns ( uint _id deposit ) { require ( msg . value > NUM_ ) ; require ( _block < block . number ) ; _id deposit = deposits . length ++ ; deposit storage d = deposits [ _id deposit ] ; d . block = _block == NUM_ ? block . number - NUM_ : _block ; d . token = erc20 ( NUM_ ) ; d . amount = msg . value ; new deposit ( _id deposit , erc20 ( NUM_ ) , msg . value ) ; }\n", "nl": "adds a token deposit to deposit ; only the owner can call this function and it will only work if the account send the tokens have call approve ( ) so that this contract can call transferfrom ( ) and take the tokens ."}
{"code": "function set max wei for verification levels ( uint _min wei per contributor , uint _max wei unverified , uint _max wei smsverified ) public only owner in state ( states . prepare pre contribution ) { require ( _min wei per contributor >= NUM_ ) ; require ( _max wei unverified > _min wei per contributor ) ; require ( _max wei smsverified > _min wei per contributor ) ; min wei per contributor = _min wei per contributor ; max wei unverified = _max wei unverified ; max wei smsverified = _max wei smsverified ; }\n", "nl": "setmaxrate set max rate for both btc / eth to soften negative consequences in case our backend gots hack ."}
{"code": "function approve to sell ( uint _token count ) public { lottery storage lottery = lotteries [ lottery count - NUM_ ] ; require ( lottery . owner token count [ msg . sender ] - lottery . owner token count to sell [ msg . sender ] >= _token count ) ; if ( lottery . selling addresses . length == NUM_ || lottery . seller id [ msg . sender ] == NUM_ && lottery . selling addresses [ NUM_ ] != msg . sender ) { uint selling addresses count = lottery . selling addresses . push ( msg . sender ) ; uint selling amounts count = lottery . selling amounts . push ( _token count ) ; assert ( selling addresses count == selling amounts count ) ; lottery . seller id [ msg . sender ] = selling addresses count - NUM_ ; } else { uint seller index = lottery . seller id [ msg . sender ] ; lottery . selling amounts [ seller index ] += _token count ; } lottery . owner token count to sell [ msg . sender ] += _token count ; lottery . token count to\n", "nl": "buys tokens from sellers ."}
{"code": "function finalize funding ( ) { if ( now < end funding time ) throw ; token contract . change controller ( NUM_ ) ; }\n", "nl": "finalizefunding ( ) end the campaign by set the controller to 0 , thereby end the issuance of new tokens and stop the ."}
{"code": "function get crowdsale max raise ( address _storage , bytes32 _exec_id ) external view returns ( uint wei_raise_cap , uint total_sell_cap ) { getter interface target = getter interface ( _storage ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( NUM_ ) ; arr_indices [ NUM_ ] = sale tier list ( ) ; arr_indices [ NUM_ ] = token decimals ( ) ; arr_indices [ NUM_ ] = token name ( ) ; uint [ ] memory read_values = target . read multi ( _exec_id , arr_indices ) . to uint arr ( ) ; assert ( read_values . length == NUM_ ) ; uint num_tiers = read_values [ NUM_ ] ; uint num_decimals = read_values [ NUM_ ] ; if ( read_values [ NUM_ ] == NUM_ ) return ( NUM_ , NUM_ ) ; bytes32 [ ] memory last_arr = new bytes32 [ ] ( NUM_ * num_tiers ) ; for ( uint i = NUM_ ; i < NUM_ * num_tiers ; i += NUM_ ) { last_arr [ i ] = tier cap ( i / NUM_ ) ; last_arr [ i + NUM_ ] = tier price ( i /\n", "nl": "start_time : the start time of the first tier of a crowdsale ."}
{"code": "function transfer helper ( token storage storage self , address _from , address _to , uint _amount ) internal { address [ ] memory from_swaps = self . user_swaps [ _from ] ; for ( uint i = from_swaps . length . sub ( NUM_ ) ; i > NUM_ ; i -- ) { uint from_swap_user_index = self . swap_balances_index [ from_swaps [ i ] ] [ _from ] ; balance memory from_user_bal = self . swap_balances [ from_swaps [ i ] ] [ from_swap_user_index ] ; if ( _amount >= from_user_bal . amount ) { _amount -= from_user_bal . amount ; self . user_swaps [ _from ] . length = self . user_swaps [ _from ] . length . sub ( NUM_ ) ; delete self . user_swaps_index [ _from ] [ from_swaps [ i ] ] ; if ( self . user_swaps_index [ _to ] [ from_swaps [ i ] ] != NUM_ ) { uint to_balance_index = self . swap_balances_index [ from_swaps [ i ] ] [ _to ] ; assert ( to_balance_index != NUM_ ) ; self . swap_balances [ from_swaps [ i ] ] [ to_balance_index ] . amount = self . swap_balances [\n", "nl": "track balance of any reward go out of the token pool ."}
{"code": "function add to investor ( address _address , uint256 _value , uint256 _tokens ) internal { if ( ! is invested ( _address ) ) { investors [ _address ] . index = investor index . push ( _address ) - NUM_ ; } investors [ _address ] . tokens = investors [ _address ] . tokens . add ( _tokens ) ; investors [ _address ] . contribution = investors [ _address ] . contribution . add ( _value ) ; investors [ _address ] . distributed = BOOL_ ; }\n", "nl": "get an investor ."}
{"code": "function buy ( address receiver ) public payable { require ( ! stopped ) ; require ( get current status ( ) == status . selling || get current status ( ) == status . prolonged selling ) ; require ( msg . value >= min investment ) ; var sender allowed = BOOL_ ; if ( allowed senders . length > NUM_ ) { for ( uint i = NUM_ ; i < allowed senders . length ; i ++ ) if ( allowed senders [ i ] == receiver ) { sender allowed = BOOL_ ; break ; } } else sender allowed = BOOL_ ; assert ( sender allowed ) ; uint wei amount = msg . value ; uint token amount = safe div ( safe mul ( wei amount , token value multiplier ) , token price ) ; assert ( token amount > NUM_ ) ; uint change wei = NUM_ ; var current contract tokens = token . balance of ( address ( this ) ) ; if ( current contract tokens < token amount ) { var change token amount = safe sub ( token amount , current contract tokens ) ;\n", "nl": "modifier to check if max ."}
{"code": "function transfer airdrop tokens ( address [ ] beneficiary , uint256 [ ] tokens ) only owner public { for ( uint256 i = NUM_ ; i < beneficiary . length ; i ++ ) { tokens [ i ] = safe math . mul ( tokens [ i ] , NUM_ ether ) ; require ( private sale supply >= tokens [ i ] ) ; private sale supply = safe math . sub ( private sale supply , tokens [ i ] ) ; token . mint ( beneficiary [ i ] , tokens [ i ] ) ; } }\n", "nl": "tokens - amount of unclaimed tokens for the caller ."}
{"code": "function add member acct ( address _member address ) public only owner { require ( _member address != address ( NUM_ ) ) ; member storage member address = members [ _member address ] ; members accts index [ _member address ] = members accts . length ; members accts . push ( _member address ) ; member address . member id = members accts . length ; member address . membership type = NUM_ ; emit new member ( _member address , member address . member id , member address . membership type ) ; }\n", "nl": "use this function to remove member acct from array memberacct ."}
{"code": "function initial arxtoken supply ( ) constant returns ( uint256 initial arxtoken supply count ) { initial arxtoken supply count = safe div ( initial arxsupply in wei , NUM_ ether ) ; }\n", "nl": "current number of tokens simplify from wei ."}
{"code": "function finalize ( bytes _result , bytes _signature , bool _agree ) external returns ( bool ) { uint256 gasinit = gasleft ( ) ; require ( ! is finalized ) ; address result sender = keccak256 ( abi . encode packed ( this , _result ) ) . to eth signed message hash ( ) . recover ( _signature ) ; require ( result sender == promisor ) ; result = _result ; is finalized = BOOL_ ; if ( validator == NUM_ ) { require ( factory . is lighthouse ( msg . sender ) ) ; require ( token . transfer ( promisor , cost ) ) ; } else { require ( msg . sender == validator ) ; is confirmed = _agree ; if ( is confirmed ) require ( token . transfer ( promisor , cost ) ) ; else require ( token . transfer ( promisee , cost ) ) ; if ( validator fee > NUM_ ) require ( factory . xrt ( ) . transfer ( validator , validator fee ) ) ; } require ( factory . liability finalized ( gasinit ) ) ; return BOOL_ ; }\n", "nl": "validate transfer with transfermanager module if it exist ."}
{"code": "function resolver ( uint256 din ) constant returns ( address ) { return records [ din ] . resolver ; }\n", "nl": "get the owner of a specified din ."}
{"code": "function withdraw ( address _from , address _to , uint _value , uint _fee , address _collector ) only owner public { require ( get state ( ) == state . success ) ; require ( applications [ _from ] != NUM_ ) ; address app = applications [ _from ] ; require ( _collector != NUM_ ) ; require ( _to != NUM_ ) ; require ( balance of [ app ] >= safe add ( _value , _fee ) ) ; require ( safe add ( balance of [ _to ] , _value ) > balance of [ _to ] ) ; require ( ! frozen account [ app ] ) ; require ( ! frozen account [ _to ] ) ; require ( _from != locked token holder ) ; balance of [ app ] = safe sub ( balance of [ app ] , safe add ( _value , _fee ) ) ; balance of [ _to ] = safe add ( balance of [ _to ] , _value ) ; balance of [ _collector ] = safe add ( balance of [ _collector ] , _fee ) ; emit fee ( app , _collector ,\n", "nl": "map an address to it application address ."}
{"code": "function diary ( address _sender , bytes _diary ) external not breakup one of owners ( _sender ) call by bank { diary [ next_diary_id ] = diary page ( { logtime : uint64 ( now ) , contant : _diary } ) ; next_diary_id ++ ; }\n", "nl": "log big events ( pre-set - choice ) in relationship , time stamp be require ."}
{"code": "function deposit ( ) public payable { balance of [ msg . sender ] = safe add ( balance of [ msg . sender ] , msg . value ) ; total supply = safe add ( total supply , msg . value ) ; issuance ( msg . value ) ; transfer ( this , msg . sender , msg . value ) ; }\n", "nl": "deposit ethereum into the sender 's ethbalance ."}
{"code": "function _calculate new hero power ( uint _dungeon difficulty , uint _hero genes , uint _equipment index , uint _training times , uint _hero power , bool _is super , uint _floor genes ) private returns ( uint new hero genes , uint new hero power ) { new hero genes = _hero genes ; new hero power = _hero power ; bool new is super = _is super ; for ( uint i = NUM_ ; i < _training times ; i ++ ) { uint tmp hero genes = training formula contract . calculate result ( new hero genes , _floor genes , _equipment index ) ; uint tmp hero power ; bool tmp is super ; ( tmp hero power , , , tmp is super , , ) = get hero power ( tmp hero genes , _dungeon difficulty ) ; if ( tmp hero power > new hero power ) { if ( ! ( new is super && ! tmp is super ) ) { new hero genes = tmp hero genes ; new hero power = tmp hero power ; } } else if ( _equipment index > NUM_ && tmp hero power\n", "nl": "split the _train function into multiple part because of stack too deep error ."}
{"code": "function calculate score ( address _participant ) view public returns ( int16 ) { int16 final score = NUM_ ; for ( int8 i = NUM_ ; i < latest game finished ; i ++ ) { uint j = uint ( i ) ; int16 game score = player point array [ _participant ] [ j ] ; final score = safe math . addint16 ( final score , game score ) ; } return final score ; }\n", "nl": "what be the current score of a give tournament participant ? ."}
{"code": "function change master ( address new master ) public valid address ( new master ) only owner ( ) { master = new master ; }\n", "nl": "allows the current owner to transfer control of the contract to a newmaster ."}
{"code": "function get rate ( erc20 token , uint current block number , bool buy , uint qty ) public view returns ( uint ) { if ( ! token data [ token ] . enabled ) return NUM_ ; if ( token control info [ token ] . minimal record resolution == NUM_ ) return NUM_ ; bytes32 compact data = token rates compact data [ token data [ token ] . compact data array index ] ; uint update rate block = get last4 bytes ( compact data ) ; if ( current block number >= update rate block + valid rate duration in blocks ) return NUM_ ; int total imbalance ; int block imbalance ; ( total imbalance , block imbalance ) = get imbalance ( token , update rate block , current block number ) ; int imbalance qty ; int extra bps ; int8 rate update ; uint rate ; if ( buy ) { rate = token data [ token ] . base buy rate ; rate update = get rate byte from compact data ( compact data , token , BOOL_ ) ; extra bps = int ( rate update ) * NUM_\n", "nl": "function for add new trade proxy ."}
{"code": "function get exists ( bytes20 blob id ) external constant returns ( bool exists ) { blob info info = blob info [ blob id ] ; exists = info . block number != NUM_ && info . block number != uint32 ( - NUM_ ) ; }\n", "nl": "throw if the blob have not be use before or it have be retract ."}
{"code": "function execute transaction ( ) public only active users allowed ( ) transaction must be pending ( ) { transaction storage transaction = transactions [ transactions . length - NUM_ ] ; require ( now > transaction . time_initiated + users [ transaction . initiated_by ] . delay ) ; transaction . is_executed = BOOL_ ; transaction . time_finalized = now ; transaction . finalized_by = msg . sender ; require ( transaction . destination . call . value ( transaction . value ) ( transaction . data ) ) ; }\n", "nl": "returns true if there be a transaction pending ."}
{"code": "function mint ( address _to , uint256 _amount ) only access mint public returns ( bool ) { total supply_ = total supply_ . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; mint ( _to , _amount ) ; transfer ( address ( NUM_ ) , _to , _amount ) ; return BOOL_ ; }\n", "nl": "function to mint tokens and transfer them to contract owner 's address ."}
{"code": "function get bonus percent ( uint256 current time ) public constant returns ( uint256 percent ) { uint i = NUM_ ; bool is pre ico = current time >= pre ico start time && current time <= pre ico end time ; uint256 offset = NUM_ ; if ( is pre ico ) { uint256 pre ico diff in seconds = current time . sub ( pre ico start time ) ; for ( i = NUM_ ; i < pre ico bonuses . length ; i ++ ) { if ( pre ico diff in seconds <= pre ico bonuses [ i ] . duration + offset ) { return pre ico bonuses [ i ] . percent ; } offset = offset . add ( pre ico bonuses [ i ] . duration ) ; } } else { uint256 ico diff in seconds = current time . sub ( ico start time ) ; for ( i = NUM_ ; i < ico bonuses . length ; i ++ ) { if ( ico diff in seconds <= ico bonuses [ i ] . duration + offset ) { return ico bonuses [ i ] .\n", "nl": "bonus scheme during ico , 1 eth 800 edex for 1st 20 days , 1 eth 727 edex for 2nd 20 days , 1 eth 667 edex for 3rd 20 days ."}
{"code": "function unlock funds ( ) public { require ( game state == state . closed ) ; require ( has participated [ msg . sender ] == BOOL_ ) ; require ( has withdrawn [ msg . sender ] == BOOL_ ) ; if ( funds transfered == BOOL_ ) { require ( credit gameinterface ( credit game address ) . check if lock can be removed ( address ( this ) ) == BOOL_ ) ; credit gameinterface ( credit game address ) . remove lock ( ) ; funds transfered = BOOL_ ; emit game unlocked ( block . number ) ; } has withdrawn [ msg . sender ] = BOOL_ ; uint index = participant indexes [ msg . sender ] ; uint amount = participation amount [ index ] ; ierc20 token ( token address ) . transfer ( msg . sender , amount ) ; total locked amount = ierc20 token ( token address ) . balance of ( address ( this ) ) ; if ( total locked amount == NUM_ ) { game state = state . claimed ; credit gameinterface ( credit game address ) . clean up ( ) ;\n", "nl": "authorizes a regular account to act on behalf of a contract ."}
{"code": "function burn ( uint256 _value ) public returns ( bool success ) { require ( accounts [ msg . sender ] >= _value ) ; require ( burning account [ msg . sender ] ) ; accounts [ msg . sender ] = safe sub ( accounts [ msg . sender ] , _value ) ; token count = safe sub ( token count , _value ) ; emit burn ( msg . sender , _value ) ; return BOOL_ ; }\n", "nl": "true on success , false on error ."}
{"code": "function exit ( ) public { if ( current_state == swap state . open && msg . sender == token_a_party ) { token_a . transfer ( token_a_party , token_a_amount ) ; if ( premium > NUM_ ) { msg . sender . transfer ( premium ) ; } delete token_a_amount ; delete token_b_amount ; delete premium ; current_state = swap state . created ; } else if ( current_state == swap state . started && ( msg . sender == token_a_party || msg . sender == token_b_party ) ) { if ( msg . sender == token_a_party || msg . sender == token_b_party ) { token_b . transfer ( token_b_party , token_b . balance of ( address ( this ) ) ) ; token_a . transfer ( token_a_party , token_a . balance of ( address ( this ) ) ) ; current_state = swap state . ended ; if ( premium > NUM_ ) { creator . transfer ( premium ) ; } } } }\n", "nl": "freeze all edu token transfer during sale period ."}
{"code": "function set battle contract address ( address _address ) external contract_only owner returns ( bool success ) { battle contract = battle interface ( _address ) ; battle contract address = _address ; return BOOL_ ; }\n", "nl": "connect to gene contract ."}
{"code": "function buy ( address _address , uint _value , uint _time ) internal returns ( bool ) { uint tokens to send = token calculate ( _value , _time ) ; if ( is pre ico ( _time ) ) { require ( pre ico tokens sold . add ( tokens to send ) <= pre_ico_max_cap ) ; pre ico tokens sold = pre ico tokens sold . add ( tokens to send ) ; token . send crowdsale tokens ( _address , tokens to send ) ; distribute ether ( ) ; } else { contributor eth collected [ _address ] += _value ; token . send crowdsale tokens ( _address , tokens to send ) ; distribute ether ( ) ; } eth collected = eth collected . add ( _value ) ; tokens sold = tokens sold . add ( tokens to send ) ; emit on success buy ( _address , _value , tokens to send ) ; return BOOL_ ; }\n", "nl": "it be call by handleeth to determine amount of tokens for give contribution ."}
{"code": "function mint vested tokens ( address _to , uint256 _value , uint64 _start , uint64 _cliff , uint64 _vesting , bool _revokable , bool _burns on revoke , address _wallet ) only owner public returns ( bool ) { require ( _cliff >= _start && _vesting >= _cliff ) ; require ( token grants count ( _to ) < max_grants_per_address ) ; uint256 count = grants [ _to ] . push ( token grant ( _revokable ? _wallet : NUM_ , _value , _cliff , _vesting , _start , _revokable , _burns on revoke ) ) ; new vested token ( msg . sender , _to , _value , count - NUM_ ) ; return mint ( _to , _value ) ; }\n", "nl": "this function be use to manually distribute tokens ."}
{"code": "function buy copper ( uint256 _copper price , uint256 _expiration , uint8 _v , bytes32 _r , bytes32 _s ) payable external { require ( _expiration >= block . timestamp ) ; address signer = ecrecover ( keccak256 ( _copper price , _expiration ) , _v , _r , _s ) ; require ( signer == neverdie signer ) ; require ( msg . value >= _copper price ) ; assert ( ndc . transfer ( msg . sender , copper_amount_ndc ) && tpt . transfer ( msg . sender , copper_amount_tpt ) && skl . transfer ( msg . sender , copper_amount_skl ) && xper . transfer ( msg . sender , copper_amount_xper ) ) ; emit buy copper ( msg . sender , _copper price , msg . value ) ; }\n", "nl": "buy silver with ether ."}
{"code": "function transfer token ownership ( address new owner ) public only owner { require ( new owner != address ( NUM_ ) ) ; ownership transferred ( owner , new owner ) ; mintable token ( token ) . transfer ownership ( new owner ) ; }\n", "nl": "transfer ownership of the token contract ."}
{"code": "function check pool end ( uint i ) public { require ( i < pools . length ) ; smart pool pool = pools [ i ] ; if ( ! pool . is ended ( ) ) pool . check end ( ) ; if ( ! pool . is ended ( ) ) { return ; } update seed ( ) ; pools done . push ( pool ) ; pools [ i ] = new smart pool ( pool . get ticket price ( ) , pool . get ticket count ( ) , pool . get duration s ( ) ) ; }\n", "nl": "check end of one pool ."}
{"code": "function return tokens ( ) public only owner { uint256 balance = token . balance of ( this ) ; require ( token . transfer ( owner , balance ) ) ; }\n", "nl": "refund all tokens back to owner ."}
{"code": "function soft cap reached ( ) public view returns ( bool ) { return wei raised >= soft cap ; }\n", "nl": "checks if the soft cap be reach by the fundraiser ."}
{"code": "function check crowdsale state ( ) internal returns ( bool ) { if ( eth raised == max cap && crowdsale state != state . crowdsale ended ) { crowdsale state = state . crowdsale ended ; max cap reached ( block . timestamp ) ; crowdsale ended ( block . timestamp ) ; return BOOL_ ; } if ( block . timestamp > presale start time && block . timestamp <= presale unlimited start time ) { if ( crowdsale state != state . priority pass ) { crowdsale state = state . priority pass ; presale started ( block . timestamp ) ; return BOOL_ ; } } else if ( block . timestamp > presale unlimited start time && block . timestamp <= crowdsale start time ) { if ( crowdsale state != state . opened priority pass ) { crowdsale state = state . opened priority pass ; presale unlimited started ( block . timestamp ) ; return BOOL_ ; } } else if ( block . timestamp > crowdsale start time && block . timestamp <= crowdsale ended time ) { if ( crowdsale state != state . crowdsale ) { crowdsale state = state\n", "nl": "set the current state of the crowdsale ."}
{"code": "function symbol ( ) public delegatable view returns ( string ) { return STR_ ; }\n", "nl": "name of the token ."}
{"code": "function _update prices ( address [ ] of assets , uint [ ] new prices ) internal pre_cond ( of assets . length == new prices . length ) { update id ++ ; for ( uint i = NUM_ ; i < of assets . length ; ++ i ) { require ( registrar . asset is registered ( of assets [ i ] ) ) ; require ( assets to prices [ of assets [ i ] ] . timestamp != now ) ; assets to prices [ of assets [ i ] ] . timestamp = now ; assets to prices [ of assets [ i ] ] . price = new prices [ i ] ; } emit price updated ( keccak256 ( of assets , new prices ) ) ; }\n", "nl": "only owner ; same size input array ."}
{"code": "modifier only coo ( ) { check role ( msg . sender , role_coo ) ; _ ; }\n", "nl": "modifier to scope access to cro / / revert ."}
{"code": "function check price ( uint256 _price ) public constant returns ( bool ) { require ( msg . sender == token ) ; return ( _price >= price ) ? BOOL_ : BOOL_ ; }\n", "nl": "get token price ."}
{"code": "function transfer to contract ( address _to , uint _value , bytes _data ) private returns ( bool ) { require ( block . timestamp > frozen timestamp [ msg . sender ] ) ; require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; receiving contract receiver = receiving contract ( _to ) ; receiver . token fallback ( msg . sender , _value , _data ) ; emit transfer ( msg . sender , _to , _value , _data ) ; return BOOL_ ; }\n", "nl": "function to approve the transfer of the tokens and to call another contract in one step ."}
{"code": "function burn from ( address _from , uint256 _value ) public returns ( bool ) { require ( _value > NUM_ ) ; var allowance = allowed [ _from ] [ msg . sender ] ; require ( allowance >= _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; total supply = total supply . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowance . sub ( _value ) ; burn ( _from , _value ) ; return BOOL_ ; }\n", "nl": "function to burn a specific amount of tokens from another account that msg . sender ."}
{"code": "function terms and conditions are signed uint8 v bytes32 r bytes32 s view returns bool signed return ecrecover keccak256 \\x19 ethereum signed message \\n32 terms and conditions v r s msg sender\n", "nl": "proofs that term and condition have be read and understood ."}
{"code": "function transfer ownership ( address _new owner ) public { require ( msg . sender == owner ) ; require ( _new owner != address ( NUM_ ) ) ; owner = _new owner ; }\n", "nl": "transfer withdraw ownership to another account ."}
{"code": "function move ( uint8 game , bytes data , uint8 v , bytes32 r , bytes32 s ) public only authorized is alive { require ( game < casino games . length ) ; var player = ecrecover ( keccak256 ( data ) , v , r , s ) ; require ( withdraw after [ player ] == NUM_ || now < withdraw after [ player ] ) ; assert ( check address ( player , data ) ) ; assert ( casino games [ game ] . call ( data ) ) ; }\n", "nl": "sets allow transactions to allow ."}
{"code": "function close sale ( ) public only owner returns ( bool ) { ended = BOOL_ ; uint256 issued token supply = token . total supply ( ) ; uint256 restricted tokens = issued token supply . mul ( NUM_ ) . div ( NUM_ ) ; log sale closed ( issued token supply , restricted tokens ) ; require ( token . mint ( vault , restricted tokens ) ) ; token . finish minting ( ) ; token . transfer ownership ( owner ) ; return BOOL_ ; }\n", "nl": "finish mine coin and transfer ownership of wise token to owner ."}
{"code": "function update max gas price ( uint256 _max gas price ) public only owner { require ( _max gas price > NUM_ ) ; max gas price = _max gas price ; }\n", "nl": "updates max gas price for crowdsale transactions ."}
{"code": "function _pre validate purchase ( address _beneficiary , uint256 _wei amount ) internal { require ( _beneficiary != address ( NUM_ ) ) ; super . _pre validate purchase ( _beneficiary , _wei amount ) ; require ( state == sale state . private sale || state == sale state . pre sale || state == sale state . public sale tier1 || state == sale state . public sale tier2 || state == sale state . public sale tier3 || state == sale state . public sale tier4 ) ; }\n", "nl": "only allow onwer to modify the current salestate ."}
{"code": "function claim token ( ) external { require ( current sale stage == sale stage . ico || current sale stage == sale stage . closed ) ; if ( current sale stage == sale stage . ico ) { if ( ibc funded == total funding goal in ibc || now >= ico end ) { update sale stage ( sale stage . closed ) ; } else { revert ( ) ; } } require ( ibc vault balance of [ msg . sender ] > NUM_ ) ; uint token amount = ibc vault balance of [ msg . sender ] ; if ( now < ico end + funding rate prediction bonus claim window ) { if ( funding rate prediction bonus pool in ibc > NUM_ ) { uint final funding rate = mul ( ibc funded , NUM_ ) / total funding goal in ibc ; if ( final funding rate > NUM_ ) { final funding rate = NUM_ ; } if ( funding rate prediction of [ msg . sender ] == final funding rate ) { if ( ! funding rate prediction bingo of [ msg . sender ] ) {\n", "nl": "method which will be call each day after 5 years to get unfrozen tokens ."}
{"code": "function send shipment to ( address to , uint tokens ) public returns ( bool success ) { return transfer ( to , tokens ) ; }\n", "nl": "will transfer a small sample to select address - user supply of tokens must have enough balance ."}
{"code": "function total supply ( ) public view returns ( uint256 total ) { return total supply_ ; }\n", "nl": "return total supply ."}
{"code": "function get section index from identifier ( uint _x_section_identifier , uint _y_section_identifier ) returns ( uint ) { if ( _x_section_identifier >= ( map width / NUM_ ) ) throw ; if ( _y_section_identifier >= ( map height / NUM_ ) ) throw ; uint index = _x_section_identifier + ( _y_section_identifier * NUM_ ) ; return index ; }\n", "nl": "get the index to access a section object from the provided raw x , y ."}
{"code": "function is necromancer ( uint _token id ) public view returns ( bool ) { for ( uint i = NUM_ ; i < NUM_ ; i ++ ) { if ( chibies [ _token id ] . dna [ i ] == NUM_ ) { return BOOL_ ; } } return BOOL_ ; }\n", "nl": "check if you have be link to this contract ."}
{"code": "function approve moderatorship ( ) { require ( msg . sender == new moderator ) ; moderator = new moderator ; new moderator = address ( NUM_ ) ; }\n", "nl": "removes moderator from the contract ."}
{"code": "function set pre dgzto dgz rate ( uint rate ) public only owner { pre dgzto dgzexchange rate = rate ; tokens available for sale = total tokens available for sale - pre dgztokens sold * pre dgzto dgzexchange rate / NUM_ - private sales tokens sold ; }\n", "nl": "set number of tokens sell on private round ."}
{"code": "function transfer ( address _to , uint256 _value ) external { _transfer ( msg . sender , _to , _value ) ; transfer ( msg . sender , _to , _value ) ; }\n", "nl": "transfer to a specific address ."}
{"code": "function lift_ban ( ) public only owner { if ( ( now == contractstarttime + NUM_ years ) || ( now == contractstarttime + NUM_ years ) || ( now == contractstarttime + NUM_ years ) || ( now == contractstarttime + NUM_ years ) ) { balances [ owner ] += NUM_ * NUM_ * * NUM_ * ( NUM_ * * uint ( decimals ) ) ; } }\n", "nl": "allow owner to suicide the contract after a year ."}
{"code": "function get balance ( address addr ) public view returns ( uint256 ) { return balances [ addr ] . value ; }\n", "nl": "get total tokens in that address map ."}
{"code": "function calculate new price ( uint256 _token id ) internal view returns ( uint256 price ) { uint256 selling price = villain index to price [ _token id ] ; uint256 new price ; if ( selling price < first step limit ) { new price = round it ( safe math . mul ( selling price , NUM_ ) ) ; } else if ( selling price < second step limit ) { new price = round it ( safe math . div ( safe math . mul ( selling price , NUM_ ) , NUM_ ) ) ; } else { new price = round it ( safe math . div ( safe math . mul ( selling price , NUM_ ) , NUM_ ) ) ; } return new price ; }\n", "nl": "computes next price of token give the current sale price ."}
{"code": "function get timebased bonus rate ( ) internal constant returns ( uint256 ) { uint256 bonus rate = NUM_ ; if ( stage == stage . publicsale ) { uint256 now time = get now ( ) ; uint256 week1 = start time + ( NUM_ days ) ; uint256 week2 = start time + ( NUM_ days ) ; uint256 week3 = start time + ( NUM_ days ) ; uint256 week4 = start time + ( NUM_ days ) ; if ( now time <= week1 ) { bonus rate = NUM_ ; } else if ( now time <= week2 ) { bonus rate = NUM_ ; } else if ( now time <= week3 ) { bonus rate = NUM_ ; } else if ( now time <= week4 ) { bonus rate = NUM_ ; } } return bonus rate ; }\n", "nl": "get the volume-based bonus rate ."}
{"code": "function distribute bonuses ( ) public only oracle or owner only sale finished not destructed returns ( uint ) { erc20 interface _token = erc20 interface ( bonus token ) ; uint _balance = _token . balance of ( address ( this ) ) ; if ( _balance == NUM_ ) { return _emit error ( emission_provider_error_insufficient_bmc ) ; } profiterole _profiterole = profiterole ( profiterole ) ; if ( ! _token . approve ( address ( _profiterole ) , _balance ) ) { return _emit error ( emission_provider_error_internal ) ; } if ( ok != _profiterole . distribute bonuses ( _balance ) ) { revert ( ) ; } return ok ; }\n", "nl": "recover tokens send accidentally ."}
{"code": "function cancel tree sell ( uint256 _tree id ) public { require ( msg . sender == tree details [ _tree id ] . owner ) ; require ( tree details [ _tree id ] . on sale ) ; for ( uint256 a = NUM_ ; a < trees on sale . length ; a ++ ) { if ( trees on sale [ a ] == _tree id ) { delete trees on sale [ a ] ; break ; } } tree details [ _tree id ] . on sale = BOOL_ ; }\n", "nl": "this be payable , the user will send the payment here ."}
{"code": "function convert to mini etyc ( uint amount ) internal constant returns ( uint ) { return amount * ( NUM_ * * uint ( token reward . decimals ( ) ) ) ; }\n", "nl": "given an amount in ttc , this method return the equivalent amount in mini-ttc ."}
{"code": "function is registered ( address _addr , bool _is presale ) public view returns ( bool ) { return registered address [ _addr ] [ _is presale ] ; }\n", "nl": "check the address be register for token sale ."}
{"code": "function start pre ico ( uint256 x ) public only owner { require ( state == state . prepreico ) ; pre ico start at = block . timestamp ; pre ico end at = block . timestamp + x * NUM_ days ; state = state . preico ; }\n", "nl": "start pre pre ico ."}
{"code": "function normalize pledge ( uint64 id pledge ) returns ( uint64 ) { pledge storage p = find pledge ( id pledge ) ; if ( p . pledge state != pledge state . pledged ) { return id pledge ; } if ( ( p . intended project > NUM_ ) && ( get time ( ) > p . commit time ) ) { uint64 old pledge = find or create pledge ( p . owner , p . delegation chain , NUM_ , NUM_ , p . old pledge , pledge state . pledged ) ; uint64 to pledge = find or create pledge ( p . intended project , new uint64 [ ] ( NUM_ ) , NUM_ , NUM_ , old pledge , pledge state . pledged ) ; do transfer ( id pledge , to pledge , p . amount ) ; id pledge = to pledge ; p = find pledge ( id pledge ) ; } to pledge = get oldest pledge not canceled ( id pledge ) ; if ( to pledge != id pledge ) { do transfer ( id pledge , to pledge , p . amount ) ;\n", "nl": "this create a pledge with an initial amount of 0 if one be not create already ; otherwise it find the pledge with the specified attribute ; all pledge technically exist , if the pledge have n't be create in this system yet it simply be n't in the hash array hpledge2idx yet ."}
{"code": "function disable investment ( address [ ] of assets ) external pre_cond ( is owner ( ) ) { for ( uint i = NUM_ ; i < of assets . length ; ++ i ) { is invest allowed [ of assets [ i ] ] = BOOL_ ; } }\n", "nl": "enable investment in specified assets ."}
{"code": "function create with nonce ( bytes32 flags nonce , bytes contents ) external returns ( bytes20 blob id ) { blob id = bytes20 ( keccak256 ( msg . sender , flags nonce ) ) ; if ( blob info [ blob id ] . block number != NUM_ ) { throw ; } blob info [ blob id ] = blob info ( { flags : bytes4 ( flags nonce ) , revision count : NUM_ , block number : uint32 ( block . number ) , owner : ( bytes4 ( flags nonce ) & anonymous != NUM_ ) ? NUM_ : msg . sender , } ) ; store ( blob id , NUM_ , contents ) ; }\n", "nl": "get info about a blob ."}
{"code": "modifier only owner ( ) { require ( msg . sender == owner account ) ; _ ; }\n", "nl": "event loginfo ( address fromaddr , address toaddr , string info ) ; ."}
{"code": "function distribute tokens ( address _to , uint256 _value ) public { require ( distribution address == msg . sender || owner == msg . sender ) ; super . transfer ( _to , _value ) ; }\n", "nl": "transfer request amount of tokens from gate to proxy address ."}
{"code": "function round investor info by index ( uint32 _group , uint32 _round , uint32 _index ) public constant returns ( address investor , uint256 sum , uint256 time ) { require ( group exists ( _group ) ) ; require ( groups [ _group ] . rounds [ _round ] . total investors > _index ) ; investment storage investment = groups [ _group ] . rounds [ _round ] . investments [ _index ] ; investor = investment . investor ; sum = investment . sum ; time = investment . time ; }\n", "nl": "get info about specific group 's round ."}
{"code": "function request transfer child ( ownable _child , address _new owner ) public only admin or owner { uint defer block = compute defer block ( ) ; transfer child operation memory op = transfer child operation ( _child , _new owner , admin , defer block ) ; transfer child operation event ( _child , _new owner , defer block , transfer child operations . length ) ; transfer child operations . push ( op ) ; }\n", "nl": "admin initiate a request to mint _amount trueusd for account _to ."}
{"code": "function post proof ( string proof hash ) public { week committment storage committment = commitments [ msg . sender ] [ current week ( ) ] ; if ( committment . days completed > current day of week ( ) ) { emit log ( STR_ ) ; require ( BOOL_ ) ; } if ( committment . tokens committed == NUM_ ) { emit log ( STR_ ) ; require ( BOOL_ ) ; } if ( committment . workout proofs [ current day of week ( ) ] != NUM_ ) { emit log ( STR_ ) ; require ( BOOL_ ) ; } if ( committment . days completed >= committment . days committed ) { return ; } committment . workout proofs [ current day of week ( ) ] = store image string ( proof hash ) ; committment . days completed ++ ; initialize week data ( current week ( ) ) ; week data storage week = data per week [ current week ( ) ] ; week . total days completed ++ ; week . total tokens completed = week . total tokens * week . total days completed / week\n", "nl": "payout your available balance base on your activity in previous weeks ."}
{"code": "function vest tokens ( ) public returns ( bool ) { require ( pending installments > NUM_ ) ; require ( paid installments < NUM_ ) ; require ( pending vesting pool > NUM_ ) ; require ( now - start time > cliff ) ; if ( ! reward generation complete ) { for ( uint256 i = NUM_ ; i <= NUM_ ; i ++ ) { add reward ( distribution addresses [ i ] ) ; } } uint256 curr interval = interval at time ( now ) ; uint256 tokens to vest = NUM_ ; uint256 total tokens to vest = NUM_ ; uint256 total pool = total vesting pool ; uint256 [ NUM_ ] memory founder cat ; founder cat [ NUM_ ] = NUM_ ; founder cat [ NUM_ ] = NUM_ ; uint256 [ NUM_ ] memory orig founder bal ; orig founder bal [ NUM_ ] = accounts [ distribution addresses [ NUM_ ] ] . balance ; orig founder bal [ NUM_ ] = accounts [ distribution addresses [ NUM_ ] ] . balance ; orig founder bal [ NUM_ ] = accounts [ distribution addresses [ NUM_ ] ] .\n", "nl": "calculates the optimal per-wallet balance target ."}
{"code": "function make offer ( uint256 _token id , uint8 _v , bytes32 _r , bytes32 _s ) public not halted ( ) payable { address recovered signer = verify ( keccak256 ( msg . sender ) , _v , _r , _s ) ; require ( signers [ recovered signer ] == BOOL_ ) ; require ( msg . sender != address ( NUM_ ) ) ; require ( msg . value > NUM_ ) ; uint256 current price = get token price ( _token id ) ; require ( current price > NUM_ ) ; if ( _token id == logo id && token . get current price for token ( _token id ) == NUM_ ) { require ( msg . value >= logo price ) ; token . update tokens state ( logo id , msg . value ) ; erc20token . mint ( msg . sender , NUM_ ) ; transfer ethers ( platform wallet , msg . value ) ; emit purchased ( NUM_ , msg . sender , _token id , msg . value , NUM_ , NUM_ , msg . value , now ) ; return ; } uint256 min price = pricing\n", "nl": "sell new tokens during the round 0 all except logo ."}
{"code": "function process off chain purchase ( address _recipient , uint256 _value ) public only owner { require ( lmda . balance of ( address ( this ) ) >= _value ) ; require ( _value > NUM_ && _recipient != NUM_ ) ; lmda . transfer ( _recipient , _value ) ; tokens sold = tokens sold . add ( _value ) ; off chain purchase made ( _recipient , _value ) ; }\n", "nl": "allows the owner to sell tokens with other form of payment include fiat and all other cryptos ."}
{"code": "function transfer from ( address _owner , address _receiver , uint256 _amount ) public returns ( bool _transferred from ) { require ( ! token transfers frozen ) ; require ( allowance [ _owner ] [ msg . sender ] . sub ( _amount ) >= NUM_ ) ; require ( transfer check ( _owner , _receiver , _amount ) ) ; balances [ _owner ] = balances [ _owner ] . sub ( _amount ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; allowance [ _owner ] [ msg . sender ] = allowance [ _owner ] [ msg . sender ] . sub ( _amount ) ; transfer ( _owner , _receiver , _amount ) ; return BOOL_ ; }\n", "nl": "used to transfer fund on behalf of owner to receiver ."}
{"code": "function recycling ( address _from , uint256 _value ) only owner public returns ( bool ) { balances [ _from ] = balances [ _from ] . sub ( _value ) ; total supply_ = total supply_ . sub ( _value ) ; recycling ( _from , _value ) ; return BOOL_ ; }\n", "nl": "function accept tokens from users a a payment for servises and burn their ."}
{"code": "function calculate revenue ( uint256 _block number , uint256 winner , uint256 loser ) internal { uint256 revenue = odd and even bets [ _block number ] [ loser ] ; if ( odd and even bets [ _block number ] [ odd ] != NUM_ && odd and even bets [ _block number ] [ even ] != NUM_ ) { uint256 comission = ( revenue . div ( NUM_ ) ) . mul ( commission_percentage ) ; revenue = revenue . sub ( comission ) ; comissions at block [ _block number ] = comission ; imoney manager ( money manager ) . pay to ( owner wallet , comission ) ; uint256 winners = odd and even bets [ _block number ] [ winner ] . div ( bet ) ; block revenue per ticket [ _block number ] = revenue . div ( winners ) ; } is block revenue calculated [ _block number ] = BOOL_ ; emit log revenue ( _block number , winner , revenue ) ; }\n", "nl": "function which allow the participants to withdraw their revenue ."}
{"code": "function calculate interest due ( ) public constant returns ( uint256 _coins , uint256 _cycle ) { if ( ! is term over ( ) || ! is loan funded ( ) ) return ( NUM_ , NUM_ ) ; else { uint time diff = now . sub ( last interest cycle ) ; _cycle = time diff . div ( day length . mul ( interest cycle length ) ) ; _coins = _cycle . mul ( interest rate per cycle . mul ( initial supply ) ) . div ( percent_divisor ) ; } }\n", "nl": "returns current annual interest ."}
{"code": "function is valid signature address signer bytes32 hash uint8 v bytes32 r bytes32 s public pure returns bool return signer ecrecover keccak256 \\x19 ethereum signed message \\n32 hash v r s\n", "nl": "verifies that an order signature be valid ."}
{"code": "function create series ( bytes32 nodehash , string series name , bytes32 root hash , uint256 initial count ) returns ( bool success ) { if ( msg . sender != _ens . owner ( nodehash ) ) { return BOOL_ ; } if ( root hash == NUM_ ) { return BOOL_ ; } series storage series = _series [ nodehash ] ; if ( series . root hash != NUM_ ) { return BOOL_ ; } series . name = series name ; series . root hash = root hash ; series . initial count = initial count ; series . current count = initial count ; series created ( nodehash ) ; }\n", "nl": "get detail about a give series ."}
{"code": "function process sale ( ) internal { if ( ! price is frozen ) { set stake price uscents ( ) ; } set caps ( ) ; uint team stakes ; uint sale stakes ; uint wei invested ; uint try sale stakes = stake for wei ( msg . value ) ; if ( try sale stakes > NUM_ ) { uint try distribute = distributed sale stakes + try sale stakes ; if ( try distribute <= sale cap ) { sale stakes = try sale stakes ; wei invested = msg . value ; } else { sale stakes = sale cap - distributed sale stakes ; wei invested = wei for stake ( sale stakes ) ; } team stakes = ( sale stakes * team share ) . div ( sale share ) ; if ( sale stakes > NUM_ ) { balances [ owner ] += team stakes ; total supply += team stakes ; distributed team stakes += team stakes ; sale supply ( msg . sender , sale stakes , wei invested ) ; if ( sale stat [ msg . sender ] . guide != address ( NUM_ ) )\n", "nl": "associates this token with a current crowdsale , give the crowdsale an allowance of tokens from the crowdsale supply ."}
{"code": "function reset reclaim ( ) public only reclaimable owner { reclaimable owner = address ( NUM_ ) ; }\n", "nl": "failsafe to reclaim ownership in the event sale be unable to return ownership ."}
{"code": "function migrate vault ( address _legacy vault address ) only owner external { require ( _legacy vault address != address ( NUM_ ) ) ; require ( ! migrated [ _legacy vault address ] ) ; require ( token timelock == address ( NUM_ ) ) ; migrated [ _legacy vault address ] = BOOL_ ; uint256 timelock amount = legacy syc contract . balance of ( _legacy vault address ) ; token timelock = new token timelock ( syc contract , msg . sender , timelock release time ) ; syc contract . transfer ( token timelock , timelock amount ) ; migrated supply = migrated supply . add ( timelock amount ) ; emit migrate ( _legacy vault address , timelock amount ) ; }\n", "nl": "set the new timelock for refund reuqests ."}
{"code": "function transfer locked token ( address _to , uint256 _value , uint256 _release time ) public when not paused non reentrant returns ( bool ) { require ( _release time > now ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; locked balances [ locked balance count ] = locked balance ( { owner : _to , value : _value , release time : _release time } ) ; locked balance count ++ ; emit transfer locked token ( msg . sender , _to , _value , _release time ) ; return BOOL_ ; }\n", "nl": "transfer and lock this value only call by admins ( limit when setlock ) ."}
{"code": "function unseal bid ( bytes32 _hash , uint _value , bytes32 _salt ) public { bytes32 seal = sha bid ( _hash , msg . sender , _value , _salt ) ; deed bid = sealed bids [ msg . sender ] [ seal ] ; require ( address ( bid ) != NUM_ ) ; sealed bids [ msg . sender ] [ seal ] = deed ( NUM_ ) ; entry storage h = _entries [ _hash ] ; uint value = min ( _value , bid . value ( ) ) ; bid . set balance ( value , BOOL_ ) ; var auction state = state ( _hash ) ; if ( auction state == mode . owned ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash , msg . sender , value , NUM_ ) ; } else if ( auction state != mode . reveal ) { revert ( ) ; } else if ( value < min price || bid . creation date ( ) > h . registration date - reveal period ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash ,\n", "nl": "to sign contract id need to be valid and contract should assign to participant and should not be sign already ."}
{"code": "function pause ( ) external only owner { require ( paused == BOOL_ ) ; paused = BOOL_ ; }\n", "nl": "resume all trade ."}
{"code": "modifier only admin ( ) { require ( admins [ msg . sender ] || owner == msg . sender ) ; _ ; }\n", "nl": "throws if call by any address other than an admin ."}
{"code": "function license issued time ( uint256 _license id ) public view returns ( uint256 ) { return licenses [ _license id ] . issued time ; }\n", "nl": "get a license 's productid ."}
{"code": "modifier only presale whitelisted ( ) { require ( is whitelisted presale ( msg . sender ) , STR_ ) ; _ ; }\n", "nl": "checks if the sender be whitelisted for the crowdsale ."}
{"code": "function dissolve fund ( ) public { require ( balances [ msg . sender ] == NUM_ ) ; require ( fund managers [ msg . sender ] ) ; delete fund managers [ msg . sender ] ; emit dissolve fund ( msg . sender ) ; }\n", "nl": "modifiers only fund manager can execute that ."}
{"code": "function start crowdsale ( ) public only owner { require ( presale concluded && ! crowdsale started ) ; crowdsale started = BOOL_ ; phase1 start block = block . number ; phase1 end block = phase1 start block . add ( day to block number ( NUM_ ) ) ; phase2 end block = phase1 end block . add ( day to block number ( NUM_ ) ) ; phase3 end block = phase2 end block . add ( day to block number ( NUM_ ) ) ; phase4 end block = phase3 end block . add ( day to block number ( NUM_ ) ) ; phase5 end block = phase4 end block . add ( day to block number ( NUM_ ) ) ; end block = phase5 end block ; start crowdsale ( ) ; }\n", "nl": "lockup during and after 48h of end of crowdsale ."}
{"code": "function transfer any erc20 token ( address _token address , uint256 _tokens ) only owner public returns ( bool success ) { require ( ! stopped ) ; return erc20 interface ( _token address ) . transfer ( owner , _tokens ) ; }\n", "nl": "owner can transfer out any accidentally send erc20 tokens exclude the token intend for this contract ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool success ) { check transfer allowed ( msg . sender , _to ) ; return super . transfer ( _to , _value ) ; }\n", "nl": "implementation of the standard transferfrom method that take into account the finalize flag ."}
{"code": "function balance of ( address _owner ) public view returns ( uint256 count ) { return ownership token count [ _owner ] ; }\n", "nl": "returns the number of deeds own by a specific address ."}
{"code": "function set exchange ( address exchange_ ) public only operator { require ( exchange_ != address ( NUM_ ) ) ; if ( exchange_ == exchange && candidate exchange != address ( NUM_ ) ) { emit e cancel nominating exchange ( candidate exchange ) ; candidate exchange = address ( NUM_ ) ; candidate till exchange = NUM_ ; } else if ( exchange == address ( NUM_ ) ) { emit e change exchange ( address ( NUM_ ) , exchange_ ) ; exchange = exchange_ ; exchange old version = exchange_ ; } else if ( exchange_ != candidate exchange && candidate till exchange + NUM_ * NUM_ < block . timestamp ) { emit e nominating exchange ( exchange_ ) ; candidate exchange = exchange_ ; candidate till exchange = block . timestamp + NUM_ * NUM_ ; } else if ( exchange_ == candidate exchange && candidate till exchange < block . timestamp ) { emit e change exchange ( exchange , candidate exchange ) ; exchange old version = exchange ; exchange = candidate exchange ; candidate exchange = address ( NUM_ ) ; } }\n", "nl": "method set exchange rate agent ."}
{"code": "function start tournament ( ) only owner non reentrant external { require ( participants . length == max participant count ) ; _first round fight ( ) ; _second round winners fight ( ) ; _second round losers fight ( ) ; _final round winners fight ( ) ; _final round losers fight ( ) ; uint winner rewards = tournament rewards * win percent / NUM_ ; uint loser rewards = tournament rewards * lose percent / NUM_ ; uint add to jackpot = tournament rewards - winner rewards - loser rewards ; address winner = participants [ final winner ] . player ; address loser = participants [ final loser ] . player ; winner . transfer ( winner rewards ) ; loser . transfer ( loser rewards ) ; tournament jackpot += add to jackpot ; player to win counts [ winner ] ++ ; for ( uint i = NUM_ ; i < participants . length ; i ++ ) { address participant = participants [ i ] . player ; if ( participant != winner && player to win counts [ participant ] != NUM_ ) { player to win counts [ participant ] =\n", "nl": "fetches information about a specific click event ."}
{"code": "function is ended ( ) public view returns ( bool ) { return stage == stages . ended ; }\n", "nl": "whether the proxy be deploy ."}
{"code": "function unset section for sale ( uint _section_index ) { if ( _section_index >= sections . length ) throw ; section section = sections [ _section_index ] ; if ( section . owner != msg . sender ) throw ; section . for_sale = BOOL_ ; section . price = NUM_ ; section . sell_only_to = NUM_ ; delisted ( _section_index ) ; }\n", "nl": "set a section 's image data to be redrawn on the map ."}
{"code": "function set upgrade agent ( address agent ) external { if ( ! can upgrade ( ) ) { revert ( ) ; } if ( agent == NUM_ ) revert ( ) ; if ( msg . sender != upgrade controller ) revert ( ) ; if ( get upgrade state ( ) == upgrade state . upgrading ) revert ( ) ; upgrade agent = upgrade agent ( agent ) ; if ( ! upgrade agent . is upgrade agent ( ) ) revert ( ) ; if ( upgrade agent . original supply ( ) != total supply ) revert ( ) ; upgrade agent set ( upgrade agent ) ; }\n", "nl": "set an upgrade agent that handle the upgrade process ."}
{"code": "function approve ( address spender , uint tokens ) public returns ( bool success ) { if ( balances [ msg . sender ] >= tokens ) { allowed [ msg . sender ] [ spender ] = tokens ; emit approval ( msg . sender , spender , tokens ) ; return BOOL_ ; } return BOOL_ ; }\n", "nl": "erc20 approve : ."}
{"code": "function is crowdsale open ( ) public view returns ( bool ) { return now >= opening time && now <= closing time ; }\n", "nl": "checks whether the period in which the crowdsale be open ."}
{"code": "function get locks locked for ( address _owner , uint256 count ) valid contract only returns ( uint256 locked for ) { locked for = locked addresses [ _owner ] [ count ] . locked for ; }\n", "nl": "gets the length of locked value for an account ."}
{"code": "function gift tokens ( address _beneficiary , uint256 _gift amount ) external only owner sale allocatable { require ( _beneficiary != NUM_ ) ; require ( _gift amount != NUM_ ) ; require ( blacklist [ _beneficiary ] == BOOL_ ) ; require ( bookkeep ( _beneficiary , NUM_ , _gift amount ) ) ; token purchase ( msg . sender , _beneficiary , NUM_ , _gift amount ) ; token . mint ( _beneficiary , _gift amount ) ; }\n", "nl": "unbans a user that be ban with the above function ."}
{"code": "function total cap ( ) public constant returns ( uint256 ) { uint256 presale cap = super . total cap ( ) ; return presale cap . add ( cap ) ; }\n", "nl": "returns the maximum amount of fund the ico can receive ."}
{"code": "function add owner ( address _owner ) external owner does not exist ( _owner ) valid num owners ( m_num owners + NUM_ ) onlymanyowners ( keccak256 ( msg . data ) ) { assert owners are consistent ( ) ; clear pending ( ) ; m_num owners ++ ; m_owners [ m_num owners ] = _owner ; m_owner index [ _owner ] = check owner index ( m_num owners ) ; assert owners are consistent ( ) ; owner added ( _owner ) ; }\n", "nl": "all pending operations will be cancel ! ."}
{"code": "function _owns ( address claimant , uint256 _token id ) private view returns ( bool ) { return claimant == avatar index to owner [ _token id ] ; }\n", "nl": "check for token ownership ."}
{"code": "function withdraw ( ) only owner after draw { if ( paid out ( ) && owner fee == NUM_ ) { if ( ! owner . send ( this . balance ) ) { throw ; } } }\n", "nl": "sends the owner 's fee to the specify address ."}
{"code": "function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }\n", "nl": "adjust reward for _address ."}
{"code": "modifier only owner ( ) { require ( msg . sender == get owner ( ) ) ; _ ; }\n", "nl": "a modifier that can be apply to function to only allow the owner to execute them ."}
{"code": "function close early ( uint256 _closing time ) external only owner only while open { require ( _closing time <= closing time ) ; if ( _closing time < block . timestamp ) { closing time = block . timestamp ; } else { closing time = _closing time ; } }\n", "nl": "extends crowdsale end date ."}
{"code": "function _pre validate purchase ( address _beneficiary , uint256 _wei amount ) internal view { super . _pre validate purchase ( _beneficiary , _wei amount ) ; require ( _wei amount <= individual cap ) ; require ( _wei amount >= minium investment ) ; }\n", "nl": "pre validate purchase ."}
{"code": "function transfer from ( address from , address to , uint256 value ) public returns ( bool success ) { require ( value <= allowances [ from ] [ msg . sender ] ) ; allowances [ from ] [ msg . sender ] -= value ; require ( to != NUM_ ) ; require ( balance of [ from ] >= value ) ; require ( balance of [ to ] + value >= balance of [ to ] ) ; uint previous balances = balance of [ from ] + balance of [ to ] ; balance of [ from ] -= value ; balance of [ to ] += value ; emit transfer ( from , to , value ) ; assert ( balance of [ from ] + balance of [ to ] == previous balances ) ; return BOOL_ ; }\n", "nl": "transfering the token to any erc20 wallet address ."}
{"code": "function get users awaiting for tokens top150 ( bool fetch ) public constant returns ( address [ NUM_ ] ) { address [ NUM_ ] memory awaiting ; uint k = NUM_ ; for ( uint i = NUM_ ; i < all users . length ; i ++ ) { if ( users buying information [ all users [ i ] ] . is kycapproved == BOOL_ && users buying information [ all users [ i ] ] . tokens to be sent > NUM_ ) { awaiting [ k ] = all users [ i ] ; k = k . add ( NUM_ ) ; if ( k == NUM_ ) return awaiting ; } } return awaiting ; }\n", "nl": "function to get a list of top 150 users that be unapproved can only be call by owner this function would work in read mode ."}
{"code": "function tokens of owner ( address _owner ) external view returns ( uint256 [ ] owner tokens ) { return owned tokens [ _owner ] ; }\n", "nl": "queries list of tokens own by a specific address ."}
{"code": "function re roll move ( uint256 _kitty id , uint256 _move slot , uint256 _type id ) external is not contract { require ( msg . sender == core . owner of ( _kitty id ) ) ; uint256 old action = kitty data . fetch slot ( _kitty id , _move slot ) ; require ( old action > NUM_ ) ; require ( old action - ( _type id * NUM_ ) < NUM_ ) ; assert ( token . burn ( msg . sender , reroll fee ) ) ; uint256 upper = cuddle data . get action count ( _type id ) ; uint256 action id = unduplicate ( _kitty id , old action , upper , _type id ) ; assert ( ! kitty actions [ _kitty id ] [ action id ] ) ; kitty actions [ _kitty id ] [ old action ] = BOOL_ ; kitty actions [ _kitty id ] [ action id ] = BOOL_ ; assert ( kitty data . add action ( _kitty id , action id , _move slot ) ) ; move rerolled ( _kitty id , old action , action id ) ; }\n", "nl": "adds a new action to the transaction list , if action do not exist yet ."}
{"code": "function unsold tokens ( ) public view returns ( uint256 ) { return token cap . sub ( tokens sold ) ; }\n", "nl": "calculates how many tokens be leave to sale ."}
{"code": "function grant marketing coins ( address _participant , uint _coins ) public only owner { require ( _coins <= coin_supply_mkt_total . sub ( coins issued mkt ) ) ; balances [ _participant ] = balances [ _participant ] . add ( _coins ) ; coins issued mkt = coins issued mkt . add ( _coins ) ; coins issued total = coins issued total . add ( _coins ) ; transfer ( NUM_ , _participant , _coins ) ; marketing coins granted ( _participant , _coins , balances [ _participant ] ) ; }\n", "nl": "granting / mint of company bonus coin by owner ."}
{"code": "function get rate ico with bonus by date ( uint256 _date ) public view returns ( uint256 ) { uint256 bonus ; uint256 rate ico ; if ( _date >= start ico pre ico && _date < end ico pre ico ) { rate ico = rate ico pre ico ; } if ( _date >= start ico main sale && _date < end ico main sale ) { rate ico = rate ico main sale ; } if ( _date >= start ico pre ico && _date < start ico pre ico2nd round ) { bonus = NUM_ ; } else if ( _date >= start ico pre ico2nd round && _date < end ico pre ico ) { bonus = NUM_ ; } else if ( _date >= start ico main sale ) { uint256 days since main ico started = ( _date - start ico main sale ) / NUM_ ; bonus = NUM_ - ( NUM_ * days since main ico started ) ; if ( bonus < NUM_ ) { bonus = NUM_ ; } } return rate ico + rate ico . mul ( bonus ) . div ( NUM_ ) ; }\n", "nl": "set new date for pre-salev ( emergency case ) ."}
{"code": "function super_transfer ( address _to , uint _value ) internal returns ( bool success ) { require ( ! is sending locked [ msg . sender ] ) ; require ( _value <= one transfer limit ) ; require ( balances [ msg . sender ] >= _value ) ; if ( msg . sender == contr initiator ) { } else { require ( ! is all transfers locked ) ; require ( safe add ( get last24h sending value ( msg . sender ) , _value ) <= one day transfer limit ) ; } balances [ msg . sender ] = safe sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = safe add ( balances [ _to ] , _value ) ; uint tc = transfer info [ msg . sender ] . tc ; transfer info [ msg . sender ] . ti [ tc ] . value = _value ; transfer info [ msg . sender ] . ti [ tc ] . time = now ; transfer info [ msg . sender ] . tc = safe add ( transfer info [ msg . sender ]\n", "nl": "joining a community allow the community to credit or debit your aviv and vip balance ."}
{"code": "function verify multi sig ( address to address , bytes32 operation hash , bytes signature , uint expire time , uint sequence id ) private returns ( address ) { var other signer = recover address from signature ( operation hash , signature ) ; if ( safe mode && ! is signer ( to address ) ) { throw ; } if ( expire time < block . timestamp ) { throw ; } try insert sequence id ( sequence id ) ; if ( ! is signer ( other signer ) ) { throw ; } if ( other signer == msg . sender ) { throw ; } return other signer ; }\n", "nl": "execute a multi-signature transaction from this wallet use 2 signers : one from msg . sender ."}
{"code": "function batch transfer ( address [ ] _recipients , uint [ ] _values ) public only owner returns ( bool ) { require ( _recipients . length > NUM_ && _recipients . length == _values . length ) ; uint total = NUM_ ; for ( uint i = NUM_ ; i < _values . length ; i ++ ) { total = total . add ( _values [ i ] ) ; } require ( total <= balances [ msg . sender ] ) ; uint64 _now = uint64 ( block . timestamp ) ; for ( uint j = NUM_ ; j < _recipients . length ; j ++ ) { balances [ _recipients [ j ] ] = balances [ _recipients [ j ] ] . add ( _values [ j ] ) ; transfer ins [ _recipients [ j ] ] . push ( transfer in struct ( uint256 ( _values [ j ] ) , _now ) ) ; emit transfer ( msg . sender , _recipients [ j ] , _values [ j ] ) ; } balances [ msg . sender ] = balances [ msg . sender ] . sub ( total\n", "nl": "withdraws snt claim by the user ."}
{"code": "function add policy rule ( bytes4 _sig , address _contract , bytes32 _group name , uint _accept limit , uint _decline limit ) only contract owner external returns ( uint ) { require ( _sig != NUM_ ) ; require ( _contract != NUM_ ) ; require ( groups access manager ( access manager ) . is group exists ( _group name ) ) ; require ( _accept limit != NUM_ ) ; require ( _decline limit != NUM_ ) ; bytes32 _policy hash = keccak256 ( _sig , _contract ) ; if ( policy id2 index [ _policy hash ] == NUM_ ) { uint _policies count = policies count . add ( NUM_ ) ; index2 policy id [ _policies count ] = _policy hash ; policy id2 index [ _policy hash ] = _policies count ; policies count = _policies count ; } policy storage _policy = policy id2policy [ _policy hash ] ; uint _policy groups count = _policy . groups count ; if ( _policy . group name2index [ _group name ] == NUM_ ) { _policy groups count += NUM_ ; _policy . group name2index [ _group name ] = _policy groups count ;\n", "nl": "creates policy , transfer ownership to msg . sender , ."}
{"code": "function sell ( ierc20 token _reserve token , uint256 _sell amount , uint256 _min return ) public conversions allowed valid gas price greater than zero ( _min return ) returns ( uint256 ) { require ( _sell amount <= token . balance of ( msg . sender ) ) ; uint256 amount = get sale return ( _reserve token , _sell amount ) ; assert ( amount != NUM_ && amount >= _min return ) ; uint256 token supply = token . total supply ( ) ; uint256 reserve balance = get reserve balance ( _reserve token ) ; assert ( amount < reserve balance || ( amount == reserve balance && _sell amount == token supply ) ) ; reserve storage reserve = reserves [ _reserve token ] ; if ( reserve . is virtual balance enabled ) reserve . virtual balance = safe sub ( reserve . virtual balance , amount ) ; token . destroy ( msg . sender , _sell amount ) ; assert ( _reserve token . transfer ( msg . sender , amount ) ) ; uint256 reserve amount = safe mul ( get reserve balance ( _reserve token ) , max_crr ) ;\n", "nl": "buy the token by deposit one of it reserve tokens ."}
{"code": "function init presale token vault ( address [ ] beneficiaries , uint256 [ ] balances ) public only owner { require ( beneficiaries . length == balances . length ) ; presale token vault . init ( beneficiaries , balances , presale_vault_start , token ) ; uint256 total presale balance = NUM_ ; uint256 balances length = balances . length ; for ( uint256 i = NUM_ ; i < balances length ; i ++ ) { total presale balance = total presale balance . add ( balances [ i ] ) ; } mint tokens ( presale token vault , total presale balance ) ; }\n", "nl": "sets the state of the reserve presale vault contract and mint reserve presale tokens ."}
{"code": "function transfer ( address , uint256 ) public returns ( bool ) { revert ( ) ; }\n", "nl": "ncore tokens be not transferrable ."}
{"code": "function set new endtime ( address _target , uint256 _old end time , uint256 _new end time ) only owner public returns ( bool ) { require ( _target != address ( NUM_ ) ) ; require ( _old end time > NUM_ && _new end time > NUM_ ) ; uint256 len = frozen accounts . length ; uint256 i = NUM_ ; while ( i < len ) { address frozen addr = frozen accounts [ i ] ; if ( frozen addr == _target ) { uint256 time rec len = frozen times [ frozen addr ] . length ; uint256 j = NUM_ ; while ( j < time rec len ) { time rec storage time pair = frozen times [ frozen addr ] [ j ] ; if ( _old end time == time pair . end time ) { uint256 duration = time pair . release period end time . sub ( time pair . end time ) ; time pair . end time = _new end time ; time pair . release period end time = time pair . end time . add ( duration ) ; return BOOL_ ; } j\n", "nl": "return whether or not an order can be settle ."}
{"code": "function remove operator ( address _operator ) public only owner { require ( operators . length > NUM_ , STR_ ) ; require ( is operator [ _operator ] , STR_ ) ; address last operator = operators [ operators . length - NUM_ ] ; for ( uint i = NUM_ ; i < operators . length ; i ++ ) { if ( operators [ i ] == _operator ) { operators [ i ] = last operator ; } } operators . length -= NUM_ ; is operator [ _operator ] = BOOL_ ; emit operator removed ( _operator ) ; }\n", "nl": "allows the current owner or operators to add operators ."}
{"code": "function register ( string key ) external { assert ( bytes ( key ) . length <= NUM_ ) ; keys [ msg . sender ] = key ; log register ( msg . sender , key ) ; }\n", "nl": "value should be a public key ."}
{"code": "function remove deed ( address _from , uint256 _deed id ) private { require ( deed owner [ _deed id ] == _from ) ; uint256 deed index = owned deeds index [ _deed id ] ; uint256 last deed index = owned deeds [ _from ] . length . sub ( NUM_ ) ; uint256 last deed = owned deeds [ _from ] [ last deed index ] ; deed owner [ _deed id ] = NUM_ ; owned deeds [ _from ] [ deed index ] = last deed ; owned deeds [ _from ] [ last deed index ] = NUM_ ; owned deeds [ _from ] . length -- ; owned deeds index [ _deed id ] = NUM_ ; owned deeds index [ last deed ] = deed index ; total deeds = total deeds . sub ( NUM_ ) ; }\n", "nl": "internal function to add a deed id to the list of a give address ."}
{"code": "function setup race ( uint delay , uint locking_duration ) only owner before betting public payable returns ( bool ) { if ( oraclize_get price ( STR_ , horses . custom pre gas limit ) * NUM_ + oraclize_get price ( STR_ , horses . custom post gas limit ) * NUM_ > address ( this ) . balance ) { emit new oraclize query ( STR_ ) ; return BOOL_ ; } else { chronus . starting_time = uint32 ( block . timestamp ) ; chronus . betting_open = BOOL_ ; bytes32 temp_id ; emit new oraclize query ( STR_ ) ; chronus . betting_duration = uint32 ( delay ) ; temp_id = oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize index [ temp_id ] = horses . ltc ; coin index [ horses . ltc ] . pre oraclize id = temp_id ; temp_id = oraclize_query ( delay , STR_ , STR_ url STR_ json ( https : oraclize index [ temp_id ] = horses . eth ; coin index [ horses . eth ] . post oraclize id = temp_id ; temp_id = oraclize_query ( delay , STR_ , STR_ url\n", "nl": "anyone can call this ."}
{"code": "function calculate interest due ( ) public constant returns ( uint256 _coins , uint256 _cycle ) { if ( ! is term over ( ) || ! is loan funded ( ) ) return ( NUM_ , NUM_ ) ; else { uint time diff = now . sub ( last interest cycle ) ; _cycle = time diff . div ( day length . mul ( interest cycle length ) ) ; _coins = _cycle . mul ( interest rate per cycle . mul ( initial supply ) ) . div ( percent_divisor ) ; } }\n", "nl": "update the interest of the contract ."}
{"code": "function set winning numbers ( uint _week , string _result ) internal { string [ ] memory arr = string to array ( _result ) ; for ( uint i = NUM_ ; i < arr . length ; i ++ ) { raffle [ _week ] . win nums . push ( parse int ( arr [ i ] ) ) ; } uint serial no = parse int ( arr [ NUM_ ] ) ; emit log winning numbers ( _week , raffle [ _week ] . num entries , raffle [ _week ] . win nums , prize pool , serial no , now ) ; }\n", "nl": "get win detail of a raffle , ie , it 's win number and the prize amount ."}
{"code": "function pause ( ) public only owner when not paused { paused = BOOL_ ; paused timestamp = block . timestamp ; pause ( ) ; }\n", "nl": "pause contract ."}
{"code": "function set value ( values [ ] storage values , uint256 value ) internal { uint256 current snapshot id = m current snapshot id ( ) ; bool empty = values . length == NUM_ ; if ( empty ) { values . push ( values ( { snapshot id : current snapshot id , value : value } ) ) ; return ; } uint256 last = values . length - NUM_ ; bool has new snapshot = values [ last ] . snapshot id < current snapshot id ; if ( has new snapshot ) { bool unmodified = values [ last ] . value == value ; if ( unmodified ) { return ; } values . push ( values ( { snapshot id : current snapshot id , value : value } ) ) ; } else { bool previous unmodified = last > NUM_ && values [ last - NUM_ ] . value == value ; if ( previous unmodified ) { delete values [ last ] ; values . length -- ; return ; } values [ last ] . value = value ; } }\n", "nl": "get balance at snapshot if with continuation in parent token ."}
{"code": "function add event ( address _event ) external only event manager { require ( ! is active event [ _event ] ) ; is active event [ _event ] = BOOL_ ; event added ( _event ) ; }\n", "nl": "allows contribute and vote only to human events ."}
{"code": "function change total supply ( uint256 new supply ) public only owner returns ( bool success ) { require ( new supply >= NUM_ && ( new supply >= _total supply || _total supply - new supply <= balances [ owner ] ) ) ; uint256 diff = NUM_ ; if ( new supply >= _total supply ) { diff = new supply . sub ( _total supply ) ; balances [ owner ] = balances [ owner ] . add ( diff ) ; emit transfer ( address ( NUM_ ) , owner , diff ) ; } else { diff = _total supply . sub ( new supply ) ; balances [ owner ] = balances [ owner ] . sub ( diff ) ; emit transfer ( owner , address ( NUM_ ) , diff ) ; } _total supply = new supply ; return BOOL_ ; }\n", "nl": "change total supply ."}
{"code": "function unauthorise address ( address _addr ) public only owner { require ( is authorised [ _addr ] && _addr != owner ) ; is authorised [ _addr ] = BOOL_ ; address unauthorised ( _addr ) ; }\n", "nl": "adds an approved address for the sale ."}
{"code": "function contribute with address ( address contributor ) public payable when not paused { require ( msg . value >= min contrib amount ) ; require ( is contrib period running ( ) ) ; uint contrib value = msg . value ; uint excess contrib value = NUM_ ; uint old total contributed = total contributed ; total contributed = old total contributed . add ( contrib value ) ; uint new total contributed = total contributed ; if ( new total contributed >= total lending amount && old total contributed < total lending amount ) { cap reached = BOOL_ ; funding end time = now ; on cap reached ( funding end time ) ; excess contrib value = new total contributed . sub ( total lending amount ) ; contrib value = contrib value . sub ( excess contrib value ) ; total contributed = total lending amount ; } if ( investors [ contributor ] . amount == NUM_ ) { investors keys . push ( contributor ) ; } investors [ contributor ] . amount = investors [ contributor ] . amount . add ( contrib value ) ; if ( excess contrib value\n", "nl": "make sure max cap be not exceed with added contribution ."}
{"code": "function set signer address ( address _signer address ) only owner { signer address = _signer address ; signer changed ( signer address ) ; }\n", "nl": "allow the owner to update the signer address ."}
{"code": "function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }\n", "nl": "split the revenue of a new player between boardowner and contract owner ."}
{"code": "function create gen0 auction ( uint256 _genes ) external only coo { require ( gen0 created count < gen0_creation_limit ) ; uint256 pony id = _create pony ( NUM_ , NUM_ , NUM_ , _genes , address ( this ) ) ; _approve ( pony id , sale auction ) ; sale auction . create auction ( pony id , _compute next gen0 price ( ) , NUM_ , gen0_auction_duration , address ( this ) ) ; gen0 created count ++ ; }\n", "nl": "creates a new gen0 monster with the give genes and create an auction for it ."}
{"code": "function re load core ( uint256 _p id , uint256 _aff id , uint256 _eth , pohmodatasets . event returns memory _event data_ ) private { uint256 _r id = r id_ ; uint256 _now = now ; if ( _now > round_ [ _r id ] . strt + rnd gap_ && ( _now <= round_ [ _r id ] . end || ( _now > round_ [ _r id ] . end && round_ [ _r id ] . plyr == NUM_ ) ) ) { plyr_ [ _p id ] . gen = withdraw earnings ( _p id ) . sub ( _eth ) ; core ( _r id , _p id , _eth , _aff id , NUM_ , _event data_ ) ; } else if ( _now > round_ [ _r id ] . end && round_ [ _r id ] . ended == BOOL_ ) { round_ [ _r id ] . ended = BOOL_ ; _event data_ = end round ( _event data_ ) ; _event data_ . compressed data = _event data_ . compressed data + ( _now * NUM_ ) ; _event data_ . compressed ids = _event data_ . compressed\n", "nl": "logic run whenever a buy order be execute ."}
{"code": "function send ether ( address beneficiary , uint256 wei amount ) only owner public { beneficiary . transfer ( wei amount ) ; }\n", "nl": "transfer 'weiamount ' wei to 'beneficiary ' ."}
{"code": "function set oraclize addr resolver i ( address __oar ) public only owner { require ( __oar != NUM_ ) ; oar = oraclize addr resolver i ( __oar ) ; log oraclize addr resolver i ( __oar ) ; }\n", "nl": "oraclizeaddrresolveri constant public oar oraclize_setnetwork ( ) ; ."}
{"code": "function extra mint ( ) only owner can mint public returns ( bool ) { require ( free to extra minting > NUM_ ) ; uint256 one percent = free to extra minting / distribution_investors ; uint256 team part = one percent * distribution_team ; uint256 community part = one percent * distribution_community ; uint256 extra tokens = team part . add ( community part ) ; total supply_ = total supply_ . add ( extra tokens ) ; extra supply = extra supply . add ( extra tokens ) ; uint256 left to next minting = free to extra minting % distribution_investors ; free to extra minting = left to next minting ; assert ( total supply_ <= hardcapped_supply ) ; assert ( extra supply <= hardcapped_supply . sub ( maxsold_supply ) ) ; balances [ team tokens holder ] = balances [ team tokens holder ] . add ( team part ) ; balances [ community tokens holder ] = balances [ community tokens holder ] . add ( community part ) ; mint ( team tokens holder , team part ) ; transfer ( address ( this ) , team tokens holder , team part ) ;\n", "nl": "increases circulatingsupply_ by specified amount ."}
{"code": "function mint ( ) can po smint returns ( bool ) { if ( balances [ msg . sender ] <= NUM_ ) return BOOL_ ; if ( transfer ins [ msg . sender ] . length <= NUM_ ) return BOOL_ ; uint reward = get proof of stake reward ( msg . sender ) ; if ( reward <= NUM_ ) return BOOL_ ; total supply = total supply . add ( reward ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( reward ) ; delete transfer ins [ msg . sender ] ; transfer ins [ msg . sender ] . push ( transfer in struct ( uint128 ( balances [ msg . sender ] ) , uint64 ( now ) ) ) ; mint ( msg . sender , reward ) ; return BOOL_ ; }\n", "nl": "funtion to claim stake reward ."}
{"code": "function remove proof ( address _source , bytes32 _attribute ) public only by ( owner ) returns ( bool ) { bool existed = check proof ( _attribute ) ; if ( existed == BOOL_ ) { event notification ( msg . sender , error_event , STR_ ) ; return BOOL_ ; } if ( proof list [ _attribute ] != _source ) { event notification ( msg . sender , error_event , STR_ ) ; return BOOL_ ; } delete proof list [ _attribute ] ; event notification ( msg . sender , info_event , STR_ ) ; return BOOL_ ; }\n", "nl": "add a proof only if not already present and only by the identity owner ."}
{"code": "function add deal ( address _buyer , address _seller , address _signer , uint _sum , uint _fee , uint _object type , uint _deal number , string _comment , uint who pay , uint _count days , bool _is prolong ) only agency public { if ( who pay == NUM_ ) { _sum = _sum . add ( _fee ) ; } uint new index = deals . length ++ ; signs . length ++ ; deals [ new index ] . buyer = _buyer ; deals [ new index ] . seller = _seller ; deals [ new index ] . signer = _signer ; deals [ new index ] . sum = _sum ; deals [ new index ] . fee = _fee ; deals [ new index ] . date = now + _count days * NUM_ days ; deals [ new index ] . is prolong = _is prolong ; deals [ new index ] . at created = now ; deals [ new index ] . comment = _comment ; deals [ new index ] . status = statuses . created ; deals [ new index ] . balance = NUM_ ; deals\n", "nl": "combined one-request getstate for web-requests optimisation ."}
{"code": "function _decode ( rlpitem memory self ) private constant returns ( uint mem ptr , uint len ) { if ( ! is data ( self ) ) throw ; uint b0 ; uint start = self . _unsafe_mem ptr ; assembly { b0 : = byte ( NUM_ , mload ( start ) ) } if ( b0 < data_short_start ) { mem ptr = start ; len = NUM_ ; return ; } if ( b0 < data_long_start ) { len = self . _unsafe_length - NUM_ ; mem ptr = start + NUM_ ; } else { uint b len ; assembly { b len : = sub ( b0 , NUM_ ) } len = self . _unsafe_length - NUM_ - b len ; mem ptr = start + b len + NUM_ ; } return ; }\n", "nl": "number of second leave until protocol terminate ."}
{"code": "function calc gav ( ) returns ( uint gav ) { address [ ] memory temp owned assets ; temp owned assets = owned assets ; delete owned assets ; for ( uint i = NUM_ ; i < temp owned assets . length ; ++ i ) { address of asset = temp owned assets [ i ] ; uint asset holdings = add ( uint ( asset interface ( of asset ) . balance of ( this ) ) , quantity held in custody of exchange ( of asset ) ) ; var ( is recent , asset price , asset decimals ) = module . pricefeed . get price ( of asset ) ; if ( ! is recent ) { revert ( ) ; } gav = add ( gav , mul ( asset holdings , asset price ) / ( NUM_ * * uint256 ( asset decimals ) ) ) ; if ( asset holdings != NUM_ || of asset == address ( quote_asset ) || of asset == address ( native_asset ) || is in open make order [ of asset ] ) { owned assets . push ( of asset ) ; }\n", "nl": "takes an active order on the select exchange ."}
{"code": "function set require signed address ( bool value , address _signer address ) only owner { required signed address = value ; signer address = _signer address ; investment policy changed ( require customer id , required signed address , signer address ) ; }\n", "nl": "set policy do we need to work only with whitelisted account ."}
{"code": "function get pony ( uint256 _id ) external view returns ( bool is gestating , bool is ready , uint256 cooldown index , uint256 next action at , uint256 siring with id , uint256 birth time , uint256 matron id , uint256 sire id , uint256 generation , uint256 genes ) { pony storage pony = poniesies [ _id ] ; is gestating = ( pony . siring with id != NUM_ ) ; is ready = ( pony . cooldown end block <= block . number ) ; cooldown index = uint256 ( pony . cooldown index ) ; next action at = uint256 ( pony . cooldown end block ) ; siring with id = uint256 ( pony . siring with id ) ; birth time = uint256 ( pony . birth time ) ; matron id = uint256 ( pony . matron id ) ; sire id = uint256 ( pony . sire id ) ; generation = uint256 ( pony . generation ) ; genes = pony . genes ; }\n", "nl": "returns all the relevant information about a specific linglongcat ."}
{"code": "function claim ( bytes32 nodehash , uint256 item index , address owner , uint8 sig v , bytes32 sig r , bytes32 sig s , bytes32 [ ] merkle proof ) returns ( bool success ) { series storage series = _series [ nodehash ] ; if ( item index >= series . initial count ) { return BOOL_ ; } if ( series . owners [ item index ] != NUM_ ) { return BOOL_ ; } uint256 path = item index ; address faux owner = ecrecover ( bytes32 ( owner ) , sig v , sig r , sig s ) ; bytes32 node = keccak256 ( nodehash , item index , bytes32 ( faux owner ) ) ; for ( uint16 i = NUM_ ; i < merkle proof . length ; i ++ ) { if ( ( path & NUM_ ) == NUM_ ) { node = keccak256 ( merkle proof [ i ] , node ) ; } else { node = keccak256 ( node , merkle proof [ i ] ) ; } path /= NUM_ ; } if ( node != series . root hash ) { return BOOL_ ; }\n", "nl": "returns metadata for the tulip ."}
{"code": "function distribute ( uint128 total amount ) internal { uint128 amount ; if ( oldest == NUM_ ) find oldest ( ) ; if ( oldest != no king ) { characters [ oldest ] . value += total amount / NUM_ ; amount = total amount / NUM_ * NUM_ ; } else { amount = total amount ; } uint128 value sum ; uint8 size = NUM_ * num dragon types ; uint128 [ ] memory shares = new uint128 [ ] ( size ) ; for ( uint8 v = NUM_ ; v < size ; v ++ ) { if ( num characters xtype [ v ] > NUM_ ) value sum += values [ v ] ; } for ( uint8 m = NUM_ ; m < size ; m ++ ) { if ( num characters xtype [ m ] > NUM_ ) shares [ m ] = amount * values [ m ] / value sum / num characters xtype [ m ] ; } uint8 c type ; for ( uint16 i = NUM_ ; i < num characters ; i ++ ) { c type = characters [ ids [ i\n", "nl": "the index of a random dragon ."}
{"code": "function is sane ( ) public constant returns ( bool ) { return ( token . release agent ( ) == address ( this ) ) ; }\n", "nl": "return true if we can run finalizecrowdsale ( ) properly ."}
{"code": "function verify order ( address _token , uint256 _amount , uint256 _fee , address _fee token ) external returns ( bool ) { assembly { calldatacopy ( NUM_ , NUM_ , calldatasize ) delegatecall ( gas , sload ( NUM_ ) , NUM_ , calldatasize , NUM_ , NUM_ ) return ( NUM_ , NUM_ ) pop } }\n", "nl": "the result of an order , update the balance of this wallet ."}
{"code": "function set seconds per block ( uint256 secs ) external only clevel { require ( secs < cooldowns [ NUM_ ] ) ; seconds per block = secs ; }\n", "nl": "owner can fix how many second per block be currently observe ."}
{"code": "function buy ad ( uint8 ad type , uint8 interval ) payable { if ( ad type >= prices . length || interval >= duration . length || msg . value < prices [ interval ] [ ad type ] ) throw ; if ( locks [ ad type ] > now ) throw ; ads . push ( ad ( uint32 ( ads . length ) , ad type , now + msg . value / prices [ interval ] [ ad type ] * duration [ interval ] * NUM_ days , msg . sender ) ) ; }\n", "nl": "lock a type until a give date ."}
{"code": "function change settings ( uint _start price , uint _price decrease rate , uint _end time of bids ) internal { require ( stage == stages . auction deployed || stage == stages . auction set up ) ; require ( _start price > NUM_ ) ; require ( _price decrease rate > NUM_ ) ; require ( _end time of bids > now ) ; end time of bids = _end time of bids ; start price = _start price ; price decrease rate = _price decrease rate ; }\n", "nl": "changes auction ceiling and start price factor before auction be start ."}
{"code": "function withdraw balance ( ) external only cfo { cfo address . transfer ( this . balance ) ; }\n", "nl": "allows the ceo to capture the balance available to the contract ."}
{"code": "function rand mod ( uint256 _modulus ) internal returns ( uint256 ) { rand nonce ++ ; return uint256 ( keccak256 ( rand nonce , blockhash ( block . number - NUM_ ) ) ) % _modulus ; }\n", "nl": "covfefe duel system ."}
{"code": "function exp ( int x ) public pure returns ( uint ) { require ( x <= NUM_ ) ; if ( x < - NUM_ ) return NUM_ ; x = x * int ( one ) / int ( ln2 ) ; int shift ; uint z ; if ( x >= NUM_ ) { shift = x / int ( one ) ; z = uint ( x % int ( one ) ) ; } else { shift = x / int ( one ) - NUM_ ; z = one - uint ( - x % int ( one ) ) ; } uint zpow = z ; uint result = one ; result += NUM_ * zpow / one ; zpow = zpow * z / one ; result += NUM_ * zpow / one ; zpow = zpow * z / one ; result += NUM_ * zpow / one ; zpow = zpow * z / one ; result += NUM_ * zpow / one ; zpow = zpow * z / one ; result += NUM_ * zpow / one ; zpow = zpow * z / one ; result +=\n", "nl": "returns bound for value of 2 * * x give x ."}
{"code": "function buy tokens presale ( address beneficiary ) public payable only presale whitelisted { require ( beneficiary != NUM_ , STR_ ) ; require ( valid purchase presale ( ) , STR_ ) ; uint256 wei amount = msg . value ; uint256 tokens = wei amount . mul ( general rate ) ; if ( timelocked tokens contracts [ beneficiary ] == NUM_ ) { timelocked tokens contracts [ beneficiary ] = new token timelock ( token , beneficiary , date of bonus release ) ; } uint256 timelocked tokens = pre sale bonus ( wei amount ) ; wei raised pre sale = wei raised pre sale . add ( wei amount ) ; token . mint ( beneficiary , tokens ) ; token . mint ( timelocked tokens contracts [ beneficiary ] , timelocked tokens ) ; emit token purchase ( msg . sender , beneficiary , wei amount , ( tokens . add ( timelocked tokens ) ) ) ; forward funds ( ) ; }\n", "nl": "override to track sell tokens ."}
{"code": "function whitelist address ( address _user , bool _flag ) public only admin ( NUM_ ) { white list [ _user ] = _flag ; }\n", "nl": "kyc validation function ."}
{"code": "function withdraw bid ( interactive crowdsale storage storage self ) public returns ( bool ) { require ( self . personal caps [ msg . sender ] > NUM_ ) ; require ( crowdsale is active ( self ) ) ; uint256 refund wei ; if ( is after withdrawal lock ( self ) ) { require ( self . personal caps [ msg . sender ] < self . total valuation ) ; refund wei = self . has contributed [ msg . sender ] ; } else { require ( ! self . has manually withdrawn [ msg . sender ] ) ; uint256 time left ; time left = self . end withdrawal time . sub ( now ) ; uint256 multiplier percent = ( time left . mul ( NUM_ ) ) / ( self . end withdrawal time . sub ( self . start time ) ) ; refund wei = ( multiplier percent . mul ( self . has contributed [ msg . sender ] ) ) / NUM_ ; self . valuation sums [ self . personal caps [ msg . sender ] ] = self . valuation sums [ self . personal\n", "nl": "this should be call once the sale be over to commit all bid into the owner 's bucket ."}
{"code": "function batch transfer ( address [ ] _tos , uint256 [ ] _amount ) only owner public when not paused returns ( bool success ) { require ( _tos . length == _amount . length ) ; uint256 i ; uint256 sum = NUM_ ; for ( i = NUM_ ; i < _amount . length ; i ++ ) { sum = sum . add ( _amount [ i ] ) ; require ( _tos [ i ] != address ( NUM_ ) ) ; } require ( balances [ msg . sender ] >= sum ) ; for ( i = NUM_ ; i < _tos . length ; i ++ ) { transfer ( _tos [ i ] , _amount [ i ] ) ; } return BOOL_ ; }\n", "nl": "send fix value to multi address ."}
{"code": "function resolve dispute ( bytes16 _trade id , address _seller , address _buyer , uint256 _value , uint16 _fee , uint8 _v , bytes32 _r , bytes32 _s , uint8 _buyer percent ) external only arbitrator { address _signature = recover address ( keccak256 ( abi . encode packed ( _trade id , instruction_resolve ) ) , _v , _r , _s ) ; require ( _signature == _buyer || _signature == _seller , STR_ ) ; escrow memory _escrow ; bytes32 _trade hash ; ( _escrow , _trade hash ) = get escrow and hash ( _trade id , _seller , _buyer , _value , _fee ) ; require ( _escrow . exists , STR_ ) ; require ( _buyer percent <= NUM_ , STR_ ) ; uint256 _total fees = _escrow . total gas fees spent by relayer + ( gas_do resolve dispute * uint128 ( tx . gasprice ) ) ; require ( _value - _total fees <= _value , STR_ ) ; fees available for withdraw += _total fees ; delete escrows [ _trade hash ] ; emit dispute resolved ( _trade hash ) ; if ( _buyer percent > NUM_ ) _buyer . transfer (\n", "nl": "this be the main function implement ipayoutcalculator ."}
{"code": "function balance of ( address _addr ) public view returns ( uint256 ) { return balances [ _addr ] ; }\n", "nl": "gets account 's balance ."}
{"code": "function to base58 ( uint256 _value , uint8 _max length ) internal pure returns ( string ) { string memory letters = STR_ ; bytes memory alphabet = bytes ( letters ) ; uint8 base = NUM_ ; uint8 len = NUM_ ; uint256 remainder = NUM_ ; bool need break = BOOL_ ; bytes memory bytes reversed = bytes ( new string ( _max length ) ) ; for ( uint8 i = NUM_ ; i < _max length ; i ++ ) { if ( _value < base ) { need break = BOOL_ ; } remainder = _value % base ; _value = uint256 ( _value / base ) ; bytes reversed [ i ] = alphabet [ remainder ] ; len ++ ; if ( need break ) { break ; } } bytes memory result = bytes ( new string ( len ) ) ; for ( i = NUM_ ; i < len ; i ++ ) { result [ i ] = bytes reversed [ len - i - NUM_ ] ; } return string ( result ) ; }\n", "nl": "solhint-enable code-complexity ."}
{"code": "function check if lock can be removed ( address _game address ) public view returns ( bool ) { require ( approved games [ _game address ] == BOOL_ ) ; require ( is game locked [ _game address ] == BOOL_ ) ; game lock memory game lock = game locks [ _game address ] ; if ( game lock . lock duration < block . number ) { return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "get gamelock parameters : crb amount lock , crb lock duration ."}
{"code": "function mint ( address _to , uint256 _amount ) external only owner returns ( bool ) { require ( total supply . add ( _amount ) <= token total supply ( ) ) ; total supply = total supply . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit mint ( total supply , _to , _amount ) ; emit transfer ( address ( NUM_ ) , _to , _amount ) ; return BOOL_ ; }\n", "nl": "mint a specific amount of tokens to owner ."}
{"code": "function finalize ( ) external only owner returns ( bool ) { require ( ! finalized ) ; finalized = BOOL_ ; token finalized ( ) ; return BOOL_ ; }\n", "nl": "the internal one will be call if tokens be sell out or the end time for the sale be reach , in addition to be call from the public version of finalize ( ) ."}
{"code": "function set sale length ( uint256 private_in_days , uint256 preico_early_days , uint256 preico_in_days , uint256 ico_in_days ) only owner public { private sale days = private_in_days ; pre icoearly days = preico_early_days ; pre icodays = preico_in_days ; icodays = ico_in_days ; if ( private sale end time != NUM_ ) private sale end time = private sale start time + private sale days * NUM_ days ; if ( pre icoend time != NUM_ ) pre icoend time = pre icostart time + pre icodays * NUM_ days ; if ( icoend time != NUM_ ) icoend time = icostart time + icodays * NUM_ days ; }\n", "nl": "set ico time ."}
{"code": "function withdraw ( ) external only owner { owner . transfer ( address ( this ) . balance ) ; }\n", "nl": "let 's owner withdraw contract balance ."}
{"code": "function invest ( uint256 option number ) public payable { assert ( option number <= NUM_ ) ; uint256 amount = round it ( msg . value ) ; assert ( amount >= minimum stake ) ; if ( now > session end time ) { end session ( ) ; option number = current lowest ; } uint256 holding = player portfolio [ msg . sender ] [ option number ] ; holding = safe math . add ( holding , amount ) ; player portfolio [ msg . sender ] [ option number ] = holding ; market options [ option number ] = safe math . add ( market options [ option number ] , amount ) ; number of investments += NUM_ ; total invested += amount ; if ( ! active players [ msg . sender ] ) { insert player ( msg . sender ) ; active players [ msg . sender ] = BOOL_ ; } invest ( msg . sender , option number , amount , market options , block . number ) ; update play count ( ) ; current lowest = find current lowest ( ) ; }\n", "nl": "the auctioneer have to call this function while supply the 1th to start the auction ."}
{"code": "function ask ( uint wad ) public returns ( uint ) { return rmul ( wad , wmul ( s2s ( ) , gap ) ) ; }\n", "nl": "join price ( gem per skr ) ."}
{"code": "function send pending ( ) public prevent reentry is holder ( msg . sender ) returns ( bool ) { if ( ptx tail == ptx head ) return BOOL_ ; tx memory tx = pending txs [ ptx tail ] ; if ( now < tx . time lock ) return BOOL_ ; delete pending txs [ ptx tail ++ ] ; if ( ! tx . blocked ) { if ( tx . to . call . value ( tx . value ) ( tx . data ) ) { committed ether -= tx . value ; withdrawal ( tx . from , tx . to , tx . value ) ; return BOOL_ ; } } if ( tx . from == address ( this ) ) { committed ether -= tx . value ; } else { holders [ tx . from ] . ether balance += tx . value ; } transaction failed ( tx . from , tx . to , tx . value ) ; return BOOL_ ; }\n", "nl": "queues a pending transaction ."}
{"code": "function create tokens ( uint256 _value ) internal { require ( is finalized == BOOL_ ) ; require ( now >= funding start time ) ; require ( now < funding end time ) ; require ( msg . value > NUM_ ) ; uint256 tokens = _value . mul ( token exchange rate ) ; uint256 checked supply = _total supply . add ( tokens ) ; require ( checked supply <= token creation cap ) ; _total supply = checked supply ; balances [ msg . sender ] += tokens ; refunds [ msg . sender ] = _value . add ( refunds [ msg . sender ] ) ; create allstocks token ( msg . sender , tokens ) ; transfer ( address ( NUM_ ) , owner , _total supply ) ; }\n", "nl": "method for manage bonus phase ."}
{"code": "function modify level cap ( uint level , uint cap ) public only owner { require ( contract stage < NUM_ ) ; require ( level > NUM_ && level < contribution caps . length ) ; require ( this . balance <= cap && contribution caps [ NUM_ ] >= cap ) ; contribution caps [ level ] = cap ; next cap time = NUM_ ; }\n", "nl": "this function be call by the owner to modify the cap at a future time ."}
{"code": "function update owner ( address _owner ) public { require ( msg . sender == owner ) ; require ( _owner != address ( NUM_ ) ) ; owner = _owner ; }\n", "nl": "transfers the ownership of the contract ."}
{"code": "function burn ( ) { if ( ! burned && now > start time ) { uint difference = safe sub ( balance of [ owner ] , NUM_ ) ; balance of [ owner ] = NUM_ ; total supply = safe sub ( total supply , difference ) ; burned = BOOL_ ; burned ( difference ) ; } }\n", "nl": "to be call when ico be close , burn the remain tokens but the d-wallet freeze vault ( 1000000000 ) and the ones reserve for the bounty program ( 24000000 ) ."}
{"code": "function sell tokens ( uint256 amount of tokens ) { if ( amount of tokens > balances [ msg . sender ] ) throw ; balances [ msg . sender ] -= amount of tokens ; _total supply -= amount of tokens ; uint256 ethers to send = amount of tokens * sell price ( ) / NUM_ ether ; if ( ! msg . sender . send ( ethers to send ) ) throw ; tokens sold ( msg . sender , ethers to send , this . balance , amount of tokens , _total supply , sell price ( ) ) ; }\n", "nl": "liquidate your tokens for eth , if this contract have sufficient eth ."}
{"code": "function add investor list ( address investor , uint256 amount token ) returns ( bool success ) { require ( msg . sender == founder ) ; if ( current token saled + amount token <= total tokens sale ) { balances [ investor ] = safe add ( balances [ investor ] , amount token ) ; current token saled = safe add ( current token saled , amount token ) ; total supply = safe add ( total supply , amount token ) ; return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "get current total token sale ."}
{"code": "function valid rate ( uint256 _wei per unit rate ) public view returns ( bool ) { if ( _wei per unit rate == NUM_ ) return BOOL_ ; ( bytes32 value , bool valid ) = maker daomedianizer . peek ( ) ; uint256 current rate = valid ? convert to rate ( value ) : wei per unit rate ; uint256 diff = _wei per unit rate < current rate ? current rate . sub ( _wei per unit rate ) : _wei per unit rate . sub ( current rate ) ; return diff <= current rate . mul ( rate_threshold_percentage ) . div ( NUM_ ) ; }\n", "nl": "receives rate from outside oracle ."}
{"code": "function remove wallet ( address _wallet ) public only owner { require ( _wallet != address ( NUM_ ) ) ; require ( is whitelisted ( _wallet ) ) ; whitelist [ _wallet ] = BOOL_ ; whitelist length -- ; }\n", "nl": "add wallet to whitelist ."}
{"code": "function get10 ads ( uint start index ) constant returns ( uint32 [ NUM_ ] ids , uint8 [ NUM_ ] ad types , uint [ NUM_ ] expiries , address [ NUM_ ] clients ) { uint end index = start index + NUM_ ; if ( end index > ads . length ) end index = ads . length ; uint j = NUM_ ; for ( uint i = start index ; i < end index ; i ++ ) { ids [ j ] = ads [ i ] . id ; ad types [ j ] = ( ads [ i ] . ad type ) ; expiries [ j ] = ( ads [ i ] . expiry ) ; clients [ j ] = ( ads [ i ] . client ) ; j ++ ; } }\n", "nl": "4 array contain the ids , type , value and owners of the character ."}
{"code": "function _tune ( uint256 _newattributes , uint256 _token id ) internal { non fungible contract . tune lambo ( _newattributes , _token id ) ; }\n", "nl": "transfers an nft own by this contract to another address ."}
{"code": "function withdraw remaining balance for manual recovery ( ) public only owner { require ( this . balance != NUM_ ) ; require ( block . timestamp > crowdsale ended time ) ; require ( contributor indexes [ next contributor to claim ] == NUM_ ) ; multisig address . transfer ( this . balance ) ; }\n", "nl": "if there be any issue with refund owner can withdraw eth at the end for manual recovery ."}
{"code": "modifier only access deposit { require ( msg . sender == owner || deposit access [ msg . sender ] == BOOL_ ) ; _ ; }\n", "nl": "modifier that prevent call function from not allow address ."}
{"code": "function remove liquidity ( uint256 amount ) external only managing wallets { require ( amount <= this . balance ) ; fund wallet . transfer ( amount ) ; remove liquidity ( amount ) ; }\n", "nl": "remove liquidity from contract ."}
{"code": "function allocation for escbby stage ( ) only ( escbdev multisig ) public { if ( current stage > allocated stage ) { uint256 escbtokens = safe math . div ( safe math . mul ( safe math . sub ( uint256 ( token . total supply ( ) ) , used total supply ) , NUM_ ) , NUM_ ) ; uint256 prev total supply = uint256 ( token . total supply ( ) ) ; if ( token . generate tokens ( address ( this ) , escbtokens ) ) { allocated stage = current stage ; used total supply = prev total supply ; uint64 cliff date = uint64 ( safe math . add ( uint256 ( now ) , NUM_ days ) ) ; uint64 vesting date = uint64 ( safe math . add ( uint256 ( now ) , NUM_ days ) ) ; token . grant vested tokens ( escbdev multisig , escbtokens , uint64 ( now ) , cliff date , vesting date , BOOL_ , BOOL_ ) ; allocation for escbfund ( escbdev multisig , escbtokens ) ; } else { revert ( ) ; } } }\n", "nl": "postallocation reward tokens ."}
{"code": "function deposit ( ) public payable { tokens [ NUM_ ] [ msg . sender ] = tokens [ NUM_ ] [ msg . sender ] . add ( msg . value ) ; deposit ( NUM_ , msg . sender , msg . value , tokens [ NUM_ ] [ msg . sender ] ) ; }\n", "nl": "deposit wei into the exchange contract ."}
{"code": "function buy with signed address ( uint128 customer id , uint8 v , bytes32 r , bytes32 s ) public payable { invest with signed address ( msg . sender , customer id , v , r , s ) ; }\n", "nl": "investing function that recognize the payer and verify he be allow to invest ."}
{"code": "function get city active buildings ( uint _city id , uint _building type ) public view returns ( uint [ ] ) { uint [ ] memory result = new uint [ ] ( get count buildings ( _city id , _building type , BOOL_ ) ) ; uint counter = NUM_ ; for ( uint i = NUM_ ; i < buildings . length ; i ++ ) { if ( buildings [ i ] . building type == _building type && buildings [ i ] . city id == _city id && buildings [ i ] . ready time < now ) { result [ counter ] = i ; counter ++ ; } } return result ; }\n", "nl": "count the number of active or pending build ."}
{"code": "function is at most ( uint256 a , uint256 b ) public pure returns ( bool is true ) { is true = a <= b ; }\n", "nl": "determines whether a value be equal to or great than another ."}
{"code": "function authorize address ( address addr ) only owner external { address info storage addr info = address infos [ addr ] ; if ( addr info . index != NUM_ ) { if ( addr info . authorized == BOOL_ ) { addr info . authorized = BOOL_ ; emit address authorized ( addr , addr info . index ) ; } } else { address prev = latest address ; if ( prev == NUM_ ) { addr info . index = NUM_ ; addr info . authorized = BOOL_ ; } else { addr info . previous = prev ; addr info . index = address infos [ prev ] . index + NUM_ ; } addr info . authorized = BOOL_ ; latest address = addr ; emit address authorized ( addr , addr info . index ) ; } }\n", "nl": "remove a loopring protocol address ."}
{"code": "function get token ( ) public returns ( address ) { return address ( crowdsale token ) ; }\n", "nl": "returns the address of the token ."}
{"code": "function required balance for masternode in wei ( ) constant internal returns ( uint256 ) { return ( NUM_ ether ) * ( masternode . active masternodes + NUM_ ) * * NUM_ ; }\n", "nl": "internal ( read only ) : unnecessary - just for enduser lookylooky ."}
{"code": "function create promo region ( address _owner , string _name , uint256 _price ) public only coo { require ( promo created count < promo_creation_limit ) ; address region owner = _owner ; if ( region owner == address ( NUM_ ) ) { region owner = coo address ; } if ( _price <= NUM_ ) { _price = starting price ; } promo created count ++ ; _create region ( _name , region owner , _price ) ; }\n", "nl": "creates a new promo scene with the give name , with give _price and assign it to an address ."}
{"code": "function buy ( ) payable in progress when not paused { uint256 pay amount = msg . value ; uint256 return amount = NUM_ ; uint256 tokens amount = token rate . mul ( pay amount ) ; if ( issued tokens amount + tokens amount > max tokens amount ) { tokens amount = max tokens amount . sub ( issued tokens amount ) ; pay amount = tokens amount . div ( token rate ) ; return amount = msg . value . sub ( pay amount ) ; } issued tokens amount = issued tokens amount . add ( tokens amount ) ; require ( issued tokens amount <= max tokens amount ) ; store tokens ( msg . sender , tokens amount ) ; token bought ( msg . sender , tokens amount , pay amount ) ; beneficiary address . transfer ( pay amount ) ; if ( return amount > NUM_ ) { msg . sender . transfer ( return amount ) ; } }\n", "nl": "performs actual token sale process ."}
{"code": "function approve ( address _to , uint _pixel id ) public { address owner = owner of ( _pixel id ) ; require ( _to != owner ) ; require ( msg . sender == owner || is approved for all ( owner , msg . sender ) ) ; if ( get approved ( _pixel id ) != address ( NUM_ ) || _to != address ( NUM_ ) ) { pixel to approved [ _pixel id ] = _to ; emit approval ( msg . sender , _to , _pixel id ) ; } }\n", "nl": "internal function to remove approval on a pixel ."}
{"code": "modifier only doge andr9k ( ) { require ( msg . sender == doge address || msg . sender == r9k address ) ; _ ; }\n", "nl": "access modifier for robot functionality ."}
{"code": "function vesting withdraw ( address withdraw wallet , uint256 withdraw tokens , uint256 withdraw total supply ) private returns ( uint256 ) { require ( token . minting finished ( ) ) ; require ( msg . sender == withdraw wallet || is owner ( ) ) ; uint256 current period = ( block . timestamp . sub ( s t2 . add ( d tlp2 ) ) ) . div ( vesting period in seconds ) ; if ( current period > vesting periods count ) { current period = vesting periods count ; } uint256 token available = withdraw tokens . mul ( current period ) . div ( vesting periods count ) . sub ( withdraw total supply ) ; require ( ( withdraw total supply . add ( token available ) ) <= withdraw tokens ) ; uint256 _withdraw total supply = withdraw total supply . add ( token available ) ; token . transfer ( withdraw wallet , token available ) ; withdraw vesting ( withdraw wallet , current period , token available , _withdraw total supply ) ; return _withdraw total supply ; }\n", "nl": "finish crowdsale tlp1 . 2 ."}
{"code": "function valid purchase ( ) internal constant returns ( bool ) { bool within cap = wei raised . add ( msg . value ) <= hard cap ; bool within period = now >= start time && now <= end time ; bool non zero purchase = msg . value != NUM_ ; return ( within period && non zero purchase ) && within cap && is within sale time limit ( ) ; }\n", "nl": "check for the possibility of buy tokens ."}
{"code": "function renew ( uint256 _token id , uint256 _num cycles ) external payable when not paused { require ( _num cycles != NUM_ ) ; require ( owner of ( _token id ) != address ( NUM_ ) ) ; uint256 product id = license product id ( _token id ) ; _require renewable product ( product id ) ; uint256 renewal cost = cost for product cycles ( product id , _num cycles ) ; require ( msg . value == renewal cost ) ; _perform renewal ( _token id , _num cycles ) ; if ( renewal cost > NUM_ && license affiliate ( _token id ) != address ( NUM_ ) && _affiliate program is active ( ) && license issued time ( _token id ) . add ( renewals credit affiliates for ) > now ) { _handle affiliate ( license affiliate ( _token id ) , product id , _token id , msg . value ) ; } }\n", "nl": "makes a purchase of a product ."}
{"code": "function add pay table ( uint16 _rf , uint16 _sf , uint16 _fk , uint16 _fh , uint16 _fl , uint16 _st , uint16 _tk , uint16 _tp , uint16 _jb ) public from admin { uint32 _today = uint32 ( block . timestamp / NUM_ days ) ; require ( settings . last day added < _today ) ; settings . last day added = _today ; _add pay table ( _rf , _sf , _fk , _fh , _fl , _st , _tk , _tp , _jb ) ; emit pay table added ( now , msg . sender , settings . num pay tables - NUM_ ) ; }\n", "nl": "appends a paytable to the map ."}
{"code": "function get hist eth rate ( uint256 _update number ) public view returns ( string , string ) { require ( _update number <= number eth updates ) ; return ( eth updates [ _update number ] . rate , eth updates [ _update number ] . timestamp ) ; }\n", "nl": "gets the late eth euro rate ."}
{"code": "function token addresses ( ) external view returns ( address [ ] ) { address [ ] memory token addresses = new address [ ] ( tokens . length ) ; for ( uint8 i = NUM_ ; i < tokens . length ; i ++ ) { token addresses [ i ] = tokens [ i ] . addr ; } return token addresses ; }\n", "nl": "look up token quantity and whether token exist ."}
{"code": "function has voted ( address _proposed address , address _account ) public constant returns ( bool ) { bool voted = BOOL_ ; if ( get vote count ( _proposed address ) > NUM_ ) { proposal storage p = proposals [ _proposed address ] ; voted = p . vote index [ p . votes [ _account ] . index ] == _account ; } return voted ; }\n", "nl": "bool supported ."}
{"code": "function init ( bytes32 _key , address _resolver ) internal returns ( bool _success ) { bool _is_locked = contract resolver ( _resolver ) . locked ( ) ; if ( _is_locked == BOOL_ ) { contract_address = address ( this ) ; resolver = _resolver ; key = _key ; require ( contract resolver ( resolver ) . init_register_contract ( key , contract_address ) ) ; _success = BOOL_ ; } else { _success = BOOL_ ; } }\n", "nl": "todo : internal ."}
{"code": "function calculate ring fees ( token transfer delegate delegate , uint ring size , order state [ ] orders , address _lrc token address ) private view { bool checked miner lrc spendable = BOOL_ ; uint miner lrc spendable = NUM_ ; uint8 _margin split percentage base = margin_split_percentage_base ; uint next fill amount s ; for ( uint i = NUM_ ; i < ring size ; i ++ ) { order state memory state = orders [ i ] ; uint lrc receiable = NUM_ ; if ( state . lrc fee state == NUM_ ) { state . margin split as fee = BOOL_ ; state . margin split percentage = _margin split percentage base ; } else { uint lrc spendable = get spendable ( delegate , _lrc token address , state . owner ) ; if ( state . token s == _lrc token address ) { lrc spendable = lrc spendable . sub ( state . fill amount s ) ; } if ( state . token b == _lrc token address ) { next fill amount s = orders [ ( i + NUM_ ) % ring size ] . fill amount\n", "nl": "should be call only from verify claim ."}
{"code": "function unlocks count ( ) public constant returns ( uint256 ) { return unlock dates . length ; }\n", "nl": "return the number of items in the registry ."}
{"code": "modifier only owner { if ( msg . sender == owner ) _ ; }\n", "nl": "access control modifier that allow only the current owner to call the function ."}
{"code": "function find winners ( ) public only owner { require ( now >= end time ) ; uint256 len = contributors . length ; uint256 mul factor = NUM_ ; for ( uint256 num = NUM_ ; num < NUM_ && num < len ; num ++ ) { amount won [ top winners [ num ] ] = ( wei raised . div ( NUM_ ) ) . mul ( mul factor ) ; mul factor = mul factor . sub ( NUM_ ) ; } top winners . length -- ; if ( len > NUM_ && len <= NUM_ ) { for ( num = NUM_ ; num < NUM_ && num < len ; num ++ ) { if ( amount won [ contributors [ num ] ] <= NUM_ ) { random winners . push ( contributors [ num ] ) ; amount won [ contributors [ num ] ] = ( wei raised . div ( NUM_ ) ) . mul ( NUM_ ) ; } } } else if ( len > NUM_ ) { for ( uint256 i = NUM_ ; i < NUM_ ; i ++ ) { uint256 random no\n", "nl": "this function will be use by the contract creator to generate 5 heroes id randomly out of 55 heroes and it can be generate only once and can not be alter at all even by contractcreator ."}
{"code": "function add player ( address _addr , uint256 _ref ) only admin or game valid address ( _addr ) public returns ( uint256 ) { require ( is human ( _addr ) , STR_ ) ; require ( ( _ref < player num . add ( NUM_ ) ) && ( player id [ _addr ] == NUM_ ) , STR_ ) ; player id [ _addr ] = player num . add ( NUM_ ) ; player [ player num . add ( NUM_ ) ] = player info ( { pid : player num . add ( NUM_ ) , paddr : _addr , referrer : _ref } ) ; player num ++ ; emit player added ( player num , _addr , _ref , msg . sender ) ; return player num ; }\n", "nl": "interface methods ."}
{"code": "function create tokens ( ) internal { if ( emergency flag ) revert ( ) ; if ( block . number > funding end block ) revert ( ) ; if ( msg . value < min token purchase amount ) revert ( ) ; uint256 token exchange rate = token rate ( ) ; uint256 tokens = safe mult ( msg . value , token exchange rate ) ; total supply = safe add ( total supply , tokens ) ; if ( total supply > token creation cap ) revert ( ) ; balances [ msg . sender ] += tokens ; forwardfunds ( ) ; create ppc ( msg . sender , tokens ) ; }\n", "nl": "create new glx tokens ."}
{"code": "function get payee expected amount ( bytes32 _request id , uint8 _payee index ) public constant returns ( int256 ) { if ( _payee index == NUM_ ) { return requests [ _request id ] . payee . expected amount ; } else { return sub payees [ _request id ] [ _payee index - NUM_ ] . expected amount ; } }\n", "nl": "get balance of a payee ."}
{"code": "function refund ( uint _value ) min cap not reached public { if ( _value != backers [ msg . sender ] . coin sent ) throw ; coin . transfer from ( msg . sender , address ( this ) , _value ) ; if ( ! coin . burn ( _value ) ) throw ; uint ethto send = backers [ msg . sender ] . wei received ; backers [ msg . sender ] . wei received = NUM_ ; if ( ethto send > NUM_ ) { async send ( msg . sender , ethto send ) ; } }\n", "nl": "refund function when minimum cap isnt reach , this be step be step 2 , this function only available after being enabled ."}
{"code": "function sell ( ierc20 token _connector token , uint256 _sell amount , uint256 _min return ) internal returns ( uint256 ) { require ( _sell amount <= token . balance of ( msg . sender ) ) ; uint256 amount = get sale return ( _connector token , _sell amount ) ; require ( amount != NUM_ && amount >= _min return ) ; uint256 token supply = token . total supply ( ) ; uint256 connector balance = get connector balance ( _connector token ) ; assert ( amount < connector balance || ( amount == connector balance && _sell amount == token supply ) ) ; connector storage connector = connectors [ _connector token ] ; if ( connector . is virtual balance enabled ) connector . virtual balance = safe sub ( connector . virtual balance , amount ) ; token . destroy ( msg . sender , _sell amount ) ; assert ( _connector token . transfer ( msg . sender , amount ) ) ; uint256 fee amount = safe sub ( amount , get final amount ( amount , NUM_ ) ) ; dispatch conversion event ( token , _connector token , _sell amount\n", "nl": "nb : we use this to manually process tokens send in from contract not able to interact direct with mny ."}
{"code": "function buy with customer id ( uint128 customer id ) public payable { buy on behalf with customer id ( msg . sender , customer id ) ; }\n", "nl": "invest to tokens , recognize the payer ."}
{"code": "function redemption info ( address _who , uint64 _index ) public constant returns ( uint64 redemption id , uint8 reason , uint value ) { require ( _who != address ( NUM_ ) ) ; require ( _index < token redemptions [ _who ] . length ) ; redemption id = token redemptions [ _who ] [ _index ] . redemption id ; reason = uint8 ( token redemptions [ _who ] [ _index ] . reason ) ; value = token redemptions [ _who ] [ _index ] . value ; }\n", "nl": "get the total value redemeed from a specific address , for a single global redemption event ."}
{"code": "function transfer ( address _to , uint256 _tulip id ) external when not paused { require ( _to != address ( NUM_ ) ) ; require ( _to != address ( this ) ) ; require ( tulip id to owner [ _tulip id ] == msg . sender ) ; _transfer ( msg . sender , _to , _tulip id ) ; }\n", "nl": "this method allow the caller to recieve a tulip if the caller be the approved address caller can also give another address to recieve the tulip ."}
{"code": "function fill buy order partially ( uint _company id , uint _order index , uint _max amount ) when not paused external { require ( _max amount > NUM_ ) ; order storage order = company id to orders [ _company id ] [ _order index ] ; require ( order . order type == order type . buy ) ; require ( msg . sender != order . owner ) ; uint buyable shares = _get remaining shares in order ( order ) ; require ( buyable shares > NUM_ ) ; if ( buyable shares > _max amount ) { buyable shares = _max amount ; } _verify ownership of tokens ( _company id , msg . sender , buyable shares ) ; order . amount filled += uint32 ( buyable shares ) ; _transfer ( _company id , msg . sender , order . owner , buyable shares ) ; uint price = _get total price ( order , buyable shares ) ; _transfer order money ( price , msg . sender ) ; _update trading volume ( _company id , msg . sender , order . owner , buyable shares ) ; emit order filled (\n", "nl": "cancel a placed order ! ."}
{"code": "function burn tokens ( ) public only owner { require ( now > tier2 end date ) ; uint256 circulating = token . total supply ( ) . sub ( token . balance of ( this ) ) ; uint256 _team tokens = circulating . mul ( percents team tokens ) . div ( NUM_ - percents team tokens - percents nuclear tokens ) ; uint256 _nuc tokens = circulating . mul ( percents nuclear tokens ) . div ( NUM_ - percents team tokens - percents nuclear tokens ) ; if ( _team tokens . add ( _nuc tokens ) > token . balance of ( this ) ) { _nuc tokens = token . balance of ( this ) . sub ( _team tokens ) ; } token . transfer ( restricted , _team tokens ) ; token . transfer ( token . address default ( ) , _nuc tokens ) ; uint256 _burn tokens = token . balance of ( this ) ; if ( _burn tokens > NUM_ ) { token . burn ( _burn tokens ) ; } }\n", "nl": "get remain tokens for all type of option tokens ."}
{"code": "function set waiting time ( uint new time ) public only owner returns ( uint _new waiting time ) { waiting time = new time ; return waiting time ; }\n", "nl": "set the time the player have to wait for his fund to be unlocked before withdrawal ( if not withdraw with help of the casino server ) ."}
{"code": "modifier only coo ( ) { require ( msg . sender == address coo ) ; _ ; }\n", "nl": "access modifier for coo-only functionality ."}
{"code": "modifier check lock { require ( ! lock address [ msg . sender ] ) ; _ ; }\n", "nl": "this modifier check whether the contract should be in a locked or unlocked state , then act and update accordingly if necessary ."}
{"code": "function transfer helper ( token storage storage self , address _from , address _to , uint _amount ) internal { address [ ] memory from_swaps = self . user_swaps [ _from ] ; for ( uint i = from_swaps . length . sub ( NUM_ ) ; i > NUM_ ; i -- ) { uint from_swap_user_index = self . swap_balances_index [ from_swaps [ i ] ] [ _from ] ; balance memory from_user_bal = self . swap_balances [ from_swaps [ i ] ] [ from_swap_user_index ] ; if ( _amount >= from_user_bal . amount ) { _amount -= from_user_bal . amount ; self . user_swaps [ _from ] . length = self . user_swaps [ _from ] . length . sub ( NUM_ ) ; delete self . user_swaps_index [ _from ] [ from_swaps [ i ] ] ; if ( self . user_swaps_index [ _to ] [ from_swaps [ i ] ] != NUM_ ) { uint to_balance_index = self . swap_balances_index [ from_swaps [ i ] ] [ _to ] ; assert ( to_balance_index != NUM_ ) ; self . swap_balances [ from_swaps [ i ] ] [ to_balance_index ] . amount = self . swap_balances [\n", "nl": "emergency refund all bet and refund owner seed amount ."}
{"code": "function balance of ( address _user ) public returns ( uint balance ) { return balances [ _user ] ; }\n", "nl": "function to return the balance of a specified address ."}
{"code": "function balance of ( address _who ) public view returns ( uint256 ) { return balances [ _who ] ; }\n", "nl": "balance tokens of investor address ."}
{"code": "function has ended ( ) public view returns ( bool ) { return now > end time ; }\n", "nl": "returns true if the duration of the ico be over ."}
{"code": "function get withdrawal address ( ) constant public returns ( address ) { return withdraw wallet ; }\n", "nl": "get withdrawal wallet address ."}
{"code": "function add legit race address ( address new address ) external only owner ( ) { _add legit race ( new address ) ; }\n", "nl": "allows to add a legit owner address for race validation ."}
{"code": "function goal reached ( ) public constant returns ( bool ) { return wei raised >= goal ; }\n", "nl": "test if we reach the goals ."}
{"code": "function bonus all ( ) payable public { uint total = msg . value ; uint remain = total ; if ( total > NUM_ ) { for ( uint i = NUM_ ; i < ids . length ; i ++ ) { uint id = ids [ i ] ; casino storage item = all casinos [ id ] ; uint fund = NUM_ ; if ( item . star == NUM_ ) { fund = safe div ( safe mul ( total , NUM_ ) , NUM_ ) ; } else if ( item . star == NUM_ ) { fund = safe div ( safe mul ( total , NUM_ ) , NUM_ ) ; } else if ( item . star == NUM_ ) { fund = safe div ( safe mul ( total , NUM_ ) , NUM_ ) ; } else if ( item . star == NUM_ ) { fund = safe div ( safe mul ( total , NUM_ ) , NUM_ ) ; } else { fund = safe div ( safe mul ( total , NUM_ ) , NUM_ ) ; } if ( remain >= fund ) {\n", "nl": "get total bet for every team ."}
{"code": "function calculate potential payout ( uint bet id ) internal view returns ( uint ) { uint bet amount = bets [ bet id ] . amount ; uint pool amount = calculate pool amount ( bets [ bet id ] . game id ) ; uint temp = bet amount . mul ( pool amount ) ; uint bet amount to winning team = NUM_ ; if ( games [ bets [ bet id ] . game id ] . result == game results . team a ) { bet amount to winning team = games [ bets [ bet id ] . game id ] . amount to team a ; } else if ( games [ bets [ bet id ] . game id ] . result == game results . team b ) { bet amount to winning team = games [ bets [ bet id ] . game id ] . amount to team b ; } else if ( games [ bets [ bet id ] . game id ] . result == game results . draw ) { bet amount to winning team = games [ bets [ bet id ] . game\n", "nl": "returns the raw pool amount ( include the amount of the house cut ) ."}
{"code": "function approve ( address spender , uint tokens ) public returns ( bool success ) { spender ; tokens ; return BOOL_ ; }\n", "nl": "transferfrom be not allow ."}
{"code": "function set arbitrator ( address _new arbitrator ) only owner external { arbitrator = _new arbitrator ; }\n", "nl": "sets a new arbitrator ."}
{"code": "function vote ( uint8 proposal ) public returns ( uint8 prop ) { require ( token . balance of ( msg . sender ) > NUM_ ) ; require ( now >= current voting date && now <= current voting date + NUM_ days ) ; require ( proposal == NUM_ || proposal == NUM_ || proposal == NUM_ ) ; require ( vote dates [ msg . sender ] != current voting date ) ; already refunded [ msg . sender ] = NUM_ ; votes [ msg . sender ] = proposal ; vote dates [ msg . sender ] = current voting date ; if ( proposal == NUM_ ) { to allow = to allow + token . balance of ( msg . sender ) ; } if ( proposal == NUM_ ) { to cancel = to cancel + token . balance of ( msg . sender ) ; } if ( proposal == NUM_ ) { to refund = to refund + token . balance of ( msg . sender ) ; } new vote ( msg . sender , now , proposal ) ; return proposal ; }\n", "nl": "end current vote with 3 scenarios - toallow , tocancel or torefund ."}
{"code": "function set start time ( uint _start time , uint _deadline ) only owner { if ( _deadline < _start time ) throw ; start time = _start time ; deadline = _deadline ; }\n", "nl": "set timestamp of deadline ."}
{"code": "function _transfer to icap ( uint _from id , bytes32 _icap , uint _value , string _reference , uint _sender id ) internal returns ( bool ) { var ( to , symbol , success ) = registry icap . parse ( _icap ) ; if ( ! success ) { _error ( STR_ ) ; return BOOL_ ; } if ( ! is enabled ( sha3 ( symbol , features . icap ) ) ) { _error ( STR_ ) ; return BOOL_ ; } if ( ! _is proxy ( symbol ) ) { _error ( STR_ ) ; return BOOL_ ; } uint to id = _create holder id ( to ) ; if ( ! _transfer ( _from id , to id , _value , symbol , _reference , _sender id ) ) { return BOOL_ ; } events history . emit transfer to icap ( _address ( _from id ) , _address ( to id ) , _icap , _value , _reference ) ; return BOOL_ ; }\n", "nl": "register a method map ."}
{"code": "function get token description ( address _token interface , uint256 _token id ) external view returns ( string ) { return token descriptions [ _token interface ] [ _token id ] ; }\n", "nl": "get name of specify token , ."}
{"code": "function transfer any erc20 token ( address _token , uint256 _value ) external only owner returns ( bool success ) { require ( _token != address ( NUM_ ) ) ; require ( _value > NUM_ ) ; require ( _value <= erc20 basic ( _token ) . balance of ( this ) . sub ( this . total of token ( _token ) ) ) ; if ( msg . sender == owner ) owner . transfer ( this . balance ) ; return erc20 basic ( _token ) . transfer ( owner , _value ) ; }\n", "nl": "empties the contract of the remain tokens ."}
{"code": "function get current tranche ( uint tokens sold ) private view returns ( tranche storage ) { for ( uint i = NUM_ ; i < tranches . length ; i ++ ) { if ( tranches [ i ] . start <= now && now < tranches [ i ] . end && tokens sold < tranches [ i ] . amount ) { return tranches [ i ] ; } } revert ( ) ; }\n", "nl": "get the current tranche or bail out if there be no tranche define for the current block ."}
{"code": "function new user ( address _addr , bytes20 _username , uint64 _endowment ) private { require ( usernames [ _username ] == address ( NUM_ ) ) ; require ( users [ _addr ] . can withdraw period == NUM_ ) ; users [ _addr ] . can withdraw period = current period + NUM_ ; users [ _addr ] . birth period = current period ; users [ _addr ] . karma = _endowment ; users [ _addr ] . username = _username ; usernames [ _username ] = _addr ; new users = new users . add ( NUM_ ) ; total supply = total supply . add ( _endowment ) ; new user ( _addr , _username , _endowment ) ; }\n", "nl": "private functions ."}
{"code": "function claim ( bytes32 channel id , uint256 payment , bytes signature ) public { require ( can claim ( channel id , payment , msg . sender , signature ) ) ; payment channel memory channel = channels [ channel id ] ; if ( payment >= channel . value ) { channel . receiver . transfer ( channel . value ) ; } else { channel . receiver . transfer ( payment ) ; channel . sender . transfer ( channel . value . sub ( payment ) ) ; } delete channels [ channel id ] ; did claim ( channel id ) ; }\n", "nl": "move the money to sender , and close the channel ."}
{"code": "function transfer token out ( address _to , uint256 _amount ) public only owner { token . transfer ( _to , _amount ) ; }\n", "nl": "this function allow distribution by the owner before the actual public sale start ."}
{"code": "function release tokens to ( address buyer , address signer ) internal returns ( bool ) { require ( started ( ) && ! ended ( ) ) ; uint value = msg . value ; uint refund = NUM_ ; uint tokens = value . mul ( rate ) ; uint bonus = NUM_ ; if ( tokens > mainsale remaining ) { uint value of remaining = mainsale remaining . div ( rate ) ; refund = value . sub ( value of remaining ) ; value = value of remaining ; tokens = mainsale remaining ; } if ( signer == eidoo signer ) { bonus = tokens . div ( NUM_ ) ; } mainsale remaining = mainsale remaining . sub ( tokens ) ; bonus remaining = bonus remaining . sub ( bonus ) ; token . mint ( buyer , tokens . add ( bonus ) ) ; wallet . transfer ( value ) ; if ( refund > NUM_ ) { buyer . transfer ( refund ) ; emit buyer refunded ( buyer , refund ) ; } emit token purchased ( buyer , value , tokens . add ( bonus ) )\n", "nl": "ended ( a require by eidoo 's icoengineinterface ) ."}
{"code": "function y2_release ( ) only owner public { require ( y1_locked token amount == NUM_ ) ; require ( y2_locked token amount > NUM_ ) ; require ( now > y2_locked token release time ) ; uint256 amount = token . balance of ( this ) ; require ( amount > NUM_ ) ; token . transfer ( restricted , amount ) ; y2_locked token amount = NUM_ ; }\n", "nl": "release the 1st year lock token ."}
{"code": "function has ( role storage role , address addr ) view internal returns ( bool ) { return role . bearer [ addr ] ; }\n", "nl": "check if an address have this role / / revert ."}
{"code": "function valid purchase ( ) internal view returns ( bool ) { bool within cap = wei raised . add ( msg . value ) <= cap ; bool within period = now >= start time && now <= end time ; bool non zero purchase = msg . value != NUM_ ; return within period && within cap && non zero purchase ; }\n", "nl": "validate if the transaction can be success ."}
{"code": "function continue distribution ( uint max numbe of steps ) public returns ( bool ) { require ( token status == token status . distributing ) ; if ( continue redeeming ( max numbe of steps ) ) { continue distribution ( BOOL_ ) ; return BOOL_ ; } uint token reward = dist ctx . total reward amount . div ( total supply of tokens ) ; rewards . push ( token reward ) ; uint paid reward = token reward . mul ( total supply of tokens ) ; uint unused distribution amount = dist ctx . total reward amount . sub ( paid reward ) ; if ( unused distribution amount > NUM_ ) { if ( ! holdings . exists ( owner ) ) { holdings . add ( owner , lib holdings . holding ( { total tokens : NUM_ , locked tokens : NUM_ , last reward number : rewards . length . sub ( NUM_ ) , wei balance : unused distribution amount } ) ) ; } else { lib holdings . holding storage owner holding = holdings . get ( owner ) ; owner holding . wei balance = owner holding\n", "nl": "this be a setter for rewardgenerationcomplete ."}
{"code": "function refresh games ( ) public returns ( uint _num games ended , uint _fees collected ) { for ( uint _i = NUM_ ; _i <= num defined games ; _i ++ ) { imonarchy game _game = defined games [ _i ] . game ; if ( _game == imonarchy game ( NUM_ ) ) continue ; uint _fees = _game . send fees ( ) ; _fees collected += _fees ; if ( _game . is ended ( ) ) { if ( ! _game . is paid ( ) ) _game . send prize ( NUM_ ) ; total prizes += _game . prize ( ) ; total overthrows += _game . num overthrows ( ) ; defined games [ _i ] . game = imonarchy game ( NUM_ ) ; ended games . push ( _game ) ; _num games ended ++ ; emit game ended ( now , _i , address ( _game ) , _game . monarch ( ) ) ; } } if ( _fees collected > NUM_ ) emit fees collected ( now , _fees collected ) ; return ( _num games ended , _fees collected ) ; }\n", "nl": "invoke . refreshgames ( ) ."}
{"code": "function invest ( address investor , uint256 token price , uint256 value , bytes32 hash , uint8 v , bytes32 r , bytes32 s ) public ico is active payable { require ( sha256 ( uint ( investor ) << NUM_ | token price ) == hash ) ; require ( ecrecover ( hash , v , r , s ) == signer ) ; require ( sub ( value , msg . value ) <= with decimals ( NUM_ , NUM_ ) ) ; uint256 tokens number = div ( with decimals ( value , decimals ) , token price ) ; require ( balances [ ico allocation ] >= tokens number ) ; require ( multisig . send ( msg . value ) ) ; balances [ ico allocation ] = sub ( balances [ ico allocation ] , tokens number ) ; balances [ investor ] = add ( balances [ ico allocation ] , tokens number ) ; transfer ( ico allocation , investor , tokens number ) ; }\n", "nl": "burn unsold tokens ."}
{"code": "function end sale ( ) public { require ( was sale started && ! was sale ended ) ; require ( total raised >= hard cap || now > date sale ended ) ; was sale ended = BOOL_ ; was soft cap met = total raised >= soft cap ; if ( ! was soft cap met ) { token . mint ( wallet , NUM_ ) ; emit sale failed ( now ) ; return ; } token . freeze ( BOOL_ ) ; uint _locker amt = token . total supply ( ) / NUM_ ; token . mint ( locker , _locker amt ) ; locker . start vesting ( _locker amt , NUM_ ) ; uint _capital amt = ( total raised * capital pct bips ) / NUM_ ; if ( address ( this ) . balance < _capital amt ) _capital amt = address ( this ) . balance ; treasury . add capital . value ( _capital amt ) ( ) ; if ( wallet . call . value ( address ( this ) . balance ) ( ) ) { } emit sale successful ( now ) ; }\n", "nl": "sets parameters of the crowdsale ."}
{"code": "function transfer trustee ownership ( address _new owner candidate ) external only owner { trustee . transfer ownership ( _new owner candidate ) ; }\n", "nl": "proposes to transfer control of the paireceipt contract to a new owner ."}
{"code": "function get position from holding ( uint _index ) public view returns ( bytes6 market , bytes6 symbol , uint32 quantity , uint32 avg price ) { bytes12 stock key = holdings [ _index ] ; ( market , symbol ) = recover stock key ( stock key ) ; position storage position = positions [ stock key ] ; quantity = position . quantity ; avg price = position . avg price ; }\n", "nl": "gets a position ."}
{"code": "function valid purchase ( ) internal view returns ( bool ) { return super . valid purchase ( ) && can contribute amount ( msg . sender , msg . value ) ; }\n", "nl": "true if buyers can buy at the moment ."}
{"code": "function lock ( ) public only owner when not locked { locked = BOOL_ ; emit lock ( ) ; }\n", "nl": "call by the owner to locke , trigger lock state ."}
{"code": "function transfer token out ( address _to , uint256 _amount ) public only owner { token . transfer ( _to , _amount ) ; }\n", "nl": "allow owner to transfer out the ether leave in the contract ."}
{"code": "function add towards target ( uint id , uint amount ) internal returns ( bool first reached ) { first reached = ( counter [ id ] < target [ id ] ) && ( counter [ id ] + amount >= target [ id ] ) ; counter [ id ] += amount ; }\n", "nl": "a public getter that return whether the target be reach ."}
{"code": "function unlock ( ) external only owner { is locked = BOOL_ ; }\n", "nl": "lock the tokens ."}
{"code": "function book donation ( address addr , uint timestamp , uint chf cents , string currency , bytes32 memo ) private { uint phase = get phase at time ( timestamp ) ; bool target reached = add towards target ( phase , chf cents ) ; if ( target reached && phase == get phase at time ( now ) ) { if ( phase == phase of round0 ) { end current phase in ( grace period after round0 target ) ; } else if ( phase == phase of round1 ) { end current phase in ( grace period after round1 target ) ; } } uint bonus multiplier = get multiplier at time ( timestamp ) ; chf cents = ( chf cents * bonus multiplier ) / NUM_ ; uint token amount = ( chf cents * tokens per chf ) / NUM_ ; if ( ! is registered ( addr , BOOL_ ) ) { donor list . push ( addr ) ; } assign ( addr , token amount , BOOL_ ) ; donation receipt ( addr , currency , bonus multiplier , timestamp , token amount , memo ) ; }\n", "nl": "availability for creator address to set when bonus period end , but not later then current end moment ."}
{"code": "function purchase ( uint _div card id ) public payable has started is not contract { address old owner = div card index to owner [ _div card id ] ; address new owner = msg . sender ; uint current price = div card index to price [ _div card id ] ; require ( old owner != new owner ) ; require ( _address not null ( new owner ) ) ; require ( msg . value >= current price ) ; uint percent increase = div cards [ _div card id ] . percent increase ; uint previous price = safe math . mul ( current price , NUM_ ) . div ( NUM_ + percent increase ) ; uint total profit = safe math . sub ( current price , previous price ) ; uint old owner profit = safe math . div ( total profit , NUM_ ) ; uint bankroll profit = safe math . sub ( total profit , old owner profit ) ; old owner profit = safe math . add ( old owner profit , previous price ) ; uint purchase excess = safe math . sub ( msg . value\n", "nl": "2 . 9 card trading ."}
{"code": "function set rate ( uint256 _rate ) external only owner returns ( bool ) { rate = _rate ; return BOOL_ ; }\n", "nl": "set new rate ."}
{"code": "function get crowdsale tier ( address _storage , bytes32 _exec_id , uint _index ) external view returns ( bytes32 tier_name , uint tier_sell_cap , uint tier_price , uint tier_min , uint tier_duration , bool duration_is_modifiable , bool is_whitelisted ) { getter interface target = getter interface ( _storage ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( NUM_ ) ; arr_indices [ NUM_ ] = tier name ( _index ) ; arr_indices [ NUM_ ] = tier cap ( _index ) ; arr_indices [ NUM_ ] = tier price ( _index ) ; arr_indices [ NUM_ ] = tier duration ( _index ) ; arr_indices [ NUM_ ] = tier modifiable ( _index ) ; arr_indices [ NUM_ ] = tier whitelisted ( _index ) ; arr_indices [ NUM_ ] = tier min ( _index ) ; bytes32 [ ] memory read_values = target . read multi ( _exec_id , arr_indices ) ; assert ( read_values . length == NUM_ ) ; tier_name = read_values [ NUM_ ] ; tier_sell_cap = uint ( read_values [ NUM_ ] ) ; tier_price = uint ( read_values [ NUM_ ] ) ; tier_duration = uint ( read_values [ NUM_\n", "nl": "crowdsale_tiers : a list of each tier of the crowdsale ."}
{"code": "function _trans item ( address _from , address _to , uint _token id ) internal { how many do you have [ _to ] ++ ; rabbit to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { how many do you have [ _from ] -- ; } delete rabbit to approved [ _token id ] ; if ( _token id > NUM_ ) { emit transfer ( _from , _to , _token id ) ; } }\n", "nl": "marks an address a be approve for transfefrom ( ) , overwrite any previous approval ."}
{"code": "function get account modifiers ( ) constant returns ( uint take fee discount , uint rebate percentage ) { if ( account modifiers != address ( NUM_ ) ) { return account modifiers interface ( account modifiers ) . account modifiers ( msg . sender ) ; } else { return ( NUM_ , NUM_ ) ; } }\n", "nl": "fee discounts , rebates ."}
{"code": "function disapprove single user ( address user ) public only owner { users buying information [ user ] . is kycapproved = BOOL_ ; }\n", "nl": "function to approve a single user which mean the user have pass all kyc check can only be call by the owner ."}
{"code": "function remove ( address _account ) public only_owner { if ( has entry ( _account ) ) { entry storage entry = list [ _account ] ; entry . accepted = BOOL_ ; entry . datetime = now ; } }\n", "nl": "add _account to the whitelist ."}
{"code": "function create ( ) payable when not closed when not paused public returns ( bool success ) { require ( msg . value > NUM_ ) ; require ( now >= pre ico opening time ) ; uint256 wei to participate = msg . value ; adjust phase based on time ( ) ; if ( phase != phases . after ico || wei to participate < ( NUM_ * NUM_ * * NUM_ ) ) { rates memory rates = get rates ( ) ; uint256 new tokens = wei to participate . mul ( rates . total ) ; uint256 requested supply = total supply . add ( new tokens ) ; total supply = requested supply ; balances [ msg . sender ] = balances [ msg . sender ] . add ( wei to participate . mul ( rates . to sender ) ) ; balances [ owner ] = balances [ owner ] . add ( wei to participate . mul ( rates . to owner ) ) ; balances [ bounty ] = balances [ bounty ] . add ( wei to participate . mul ( rates . to bounty ) ) ; total\n", "nl": "participate in the presale ."}
{"code": "function claim token for ( address _beneficiary ) public after sale when not paused { uint256 tokens = stakes [ _beneficiary ] ; require ( tokens > NUM_ ) ; stakes [ _beneficiary ] = NUM_ ; token balance = token balance . sub ( tokens ) ; etheal controller . add hodler stake ( _beneficiary , tokens ) ; require ( etheal controller . etheal token ( ) . transfer ( _beneficiary , tokens ) ) ; log token claimed ( msg . sender , _beneficiary , tokens ) ; }\n", "nl": "claim token for msg . sender ."}
{"code": "function burn pool ( ) constant returns ( uint256 ) { return storage ( storage addr ) . get uint ( STR_ , STR_ ) ; }\n", "nl": "power pool - inactive supply ."}
{"code": "function buy tokens ( address _beneficiary ) public payable when not paused { validate purchase ( ) ; uint256 to fund = calculate to fund ( ) ; uint256 to return = msg . value . sub ( to fund ) ; require ( to fund > NUM_ ) ; uint256 rate = get rate ( ) ; uint256 tokens = rate . mul ( to fund ) ; require ( tokens > NUM_ ) ; if ( block . timestamp < phase2 start time ) { phase1 wei raised = phase1 wei raised . add ( to fund ) ; } else { phase2 wei raised = phase2 wei raised . add ( to fund ) ; } if ( purchaser funded [ msg . sender ] == NUM_ ) { num purchasers = num purchasers . add ( NUM_ ) ; } purchaser funded [ msg . sender ] = purchaser funded [ msg . sender ] . add ( to fund ) ; token . generate tokens ( _beneficiary , tokens ) ; emit token purchase ( msg . sender , _beneficiary , to fund , tokens ) ; if ( to return > NUM_ ) { msg . sender . transfer ( to return ) ; } vault . deposit . value ( to fund ) ( msg . sender ) ; }\n", "nl": "based on division down round ."}
{"code": "modifier only_owner ( ) { if ( msg . sender != owner address ) revert ( ) ; _ ; }\n", "nl": "check address ."}
{"code": "function approve to sell ( uint _token count ) public { lottery storage lottery = lotteries [ lottery count - NUM_ ] ; require ( lottery . owner token count [ msg . sender ] - lottery . owner token count to sell [ msg . sender ] >= _token count ) ; if ( lottery . selling addresses . length == NUM_ || lottery . seller id [ msg . sender ] == NUM_ && lottery . selling addresses [ NUM_ ] != msg . sender ) { uint selling addresses count = lottery . selling addresses . push ( msg . sender ) ; uint selling amounts count = lottery . selling amounts . push ( _token count ) ; assert ( selling addresses count == selling amounts count ) ; lottery . seller id [ msg . sender ] = selling addresses count - NUM_ ; } else { uint seller index = lottery . seller id [ msg . sender ] ; lottery . selling amounts [ seller index ] += _token count ; } lottery . owner token count to sell [ msg . sender ] += _token count ; lottery . token count to\n", "nl": "adds a user to the wallet ."}
{"code": "function is whitelisted address ( address _beneficiary ) public constant returns ( bool ) { return whitelist [ _beneficiary ] ; }\n", "nl": "check the specified wallet whether it be in the whitelist ."}
{"code": "function balance of ( address _owner ) public constant returns ( uint balance ) { return accounts [ _owner ] . balance ; }\n", "nl": "the balance should be available ."}
{"code": "function set resolver ( uint256 _din , address _resolver ) public only_owner ( _din ) { records [ _din ] . resolver = _resolver ; records [ _din ] . updated = block . timestamp ; new resolver ( _din , _resolver ) ; }\n", "nl": "sets the resolver address for the specified node ."}
{"code": "function burn ( uint256 _token id ) public only known origin only unsold ( _token id ) only known origin owned token ( _token id ) { require ( exists ( _token id ) ) ; super . _burn ( owner of ( _token id ) , _token id ) ; bytes16 edition = token id to edition [ _token id ] ; delete token id to edition [ _token id ] ; delete token id to price in wei [ _token id ] ; delete token id to purchase from time [ _token id ] ; edition to edition number [ edition ] = edition to edition number [ edition ] . sub ( NUM_ ) ; }\n", "nl": "utility function for update a koda assets price ."}
{"code": "function grant ( address _recipient , uint256 _tokens ) if delegate external { require ( _recipient != address ( NUM_ ) ) ; require ( progress == NUM_ || progress == NUM_ ) ; if ( ! participants [ _recipient ] ) { participants [ _recipient ] = BOOL_ ; participant index . push ( _recipient ) ; } participant tokens [ _recipient ] = safe add ( participant tokens [ _recipient ] , _tokens ) ; tokens = safe add ( tokens , _tokens ) ; granted ( _recipient , _tokens ) ; }\n", "nl": "allow an individual to buy tokens ( which will not be issue immediately ) individual instruct the tokens to be deliver to a specific account , which may be different than msg . sender ."}
{"code": "function init auctions ( uint _start time , uint _minimum price , uint _starting price , uint _time scale ) public only owner returns ( bool ) { require ( minted ) ; require ( ! initialized ) ; require ( _time scale != NUM_ ) ; init pricer ( ) ; if ( _start time > NUM_ ) { genesis time = ( _start time / ( NUM_ minutes ) ) * ( NUM_ minutes ) + NUM_ ; } else { genesis time = block . timestamp + NUM_ - ( block . timestamp % NUM_ ) ; } initial auction end time = genesis time + initial auction duration ; if ( initial auction end time == ( initial auction end time / NUM_ days ) * NUM_ days ) { daily auction start time = initial auction end time ; } else { daily auction start time = ( ( initial auction end time / NUM_ days ) + NUM_ ) * NUM_ days ; } last purchase tick = NUM_ ; if ( _minimum price > NUM_ ) { minimum price = _minimum price ; } time scale = _time scale ; if ( _starting\n", "nl": "deal off statue ."}
{"code": "function transfer from ( address _from , address _to , uint256 _value ) public only when transfer allowed is valid destination ( _to ) returns ( bool ) { return super . transfer from ( _from , _to , _value ) ; }\n", "nl": "token contract transfer ."}
{"code": "modifier no eth sent ( ) { if ( msg . value > NUM_ ) msg . sender . send ( msg . value ) ; _ ; }\n", "nl": "check sender have send some ethers ."}
{"code": "function get token id of address and index ( address _address , uint256 _index ) external view returns ( uint256 ) { return tokens of ( _address ) [ _index ] ; }\n", "nl": "public function to get the amount of tokens hold for an address ."}
{"code": "function compound_now_accrued_interest ( ) can mine public returns ( bool ) { if ( balances [ msg . sender ] < NUM_ ) return BOOL_ ; uint256 reward = show_accrued_interest ( msg . sender ) ; if ( reward < NUM_ ) return BOOL_ ; uint256 profit = reward - NUM_ ; total supply = total supply . add ( reward ) ; balances [ msg . sender ] = balances [ msg . sender ] + profit ; balances [ this ] = balances [ this ] . add ( NUM_ ) ; delete deposit [ msg . sender ] ; deposit [ msg . sender ] . push ( making ( uint128 ( balances [ msg . sender ] ) , uint64 ( now ) ) ) ; transfer ( msg . sender , this , NUM_ ) ; transfer ( this , msg . sender , reward ) ; return BOOL_ ; }\n", "nl": "request payout dividend ( claim ) ( request by tokenholder - pull ) dividends that have not be claim within 330 days expire and can not be claim anymore by the token holder ."}
{"code": "function pause sale ( ) public only owner { assert ( sale running && start time > NUM_ && now <= end time ) ; sale running = BOOL_ ; }\n", "nl": "guards against execute the function if the sale be not run ."}
{"code": "function buy tokens ( address beneficiary ) public payable { require ( beneficiary != address ( NUM_ ) ) ; require ( valid purchase ( ) ) ; uint256 wei amount = msg . value ; uint256 tokens = wei amount . mul ( rate ) ; uint256 minimum = current ico phase minimum ( ) ; require ( wei amount >= minimum ) ; uint bonus = current ico phase bonus ( ) ; tokens = tokens . add ( ( tokens . mul ( bonus ) ) . div ( NUM_ ) ) ; wei raised = wei raised . add ( wei amount ) ; token . mint ( beneficiary , tokens ) ; token purchase ( msg . sender , beneficiary , wei amount , tokens ) ; forward funds ( ) ; }\n", "nl": "main function to buy tokens ."}
{"code": "function set drop number ( uint8 drop n ) public only owner { drop number = drop n ; lemons remaining to drop = lemon contract . balance of ( this ) ; }\n", "nl": "update number of lemon tokens remain for drop , just in case it be need ."}
{"code": "function finalize ( ) external only owner { require ( wei total received >= soft cap ) ; require ( now > start time . add ( period ) || wei total received >= hard cap ) ; if ( state == state . presale ) { require ( this . balance > NUM_ ) ; wallet ether presale . transfer ( this . balance ) ; pause ( ) ; } else if ( state == state . crowdsale ) { uint256 token total unsold = token ico allocated . sub ( token total sold ) ; token reservation allocated = token reservation allocated . add ( token total unsold ) ; require ( token . transfer from ( token . owner ( ) , wallet token bounty , token bounty allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token reservation , token reservation allocated ) ) ; require ( token . transfer from ( token . owner ( ) , wallet token team , token team allocated ) ) ; token . lock ( wallet token reservation , now + NUM_ years ) ; token . lock (\n", "nl": "gets the total payment amount for the sender give the current period ."}
{"code": "function set affiliate level ( uint256 _level ) public only owner when affiliate returns ( bool ) { affiliate level = _level ; return BOOL_ ; }\n", "nl": "set affiliate rate for level ."}
{"code": "function release account ( address _target ) only owner public returns ( bool ) { require ( _target != address ( NUM_ ) ) ; uint256 len = frozen accounts . length ; uint256 i = NUM_ ; while ( i < len ) { address dest addr = frozen accounts [ i ] ; if ( dest addr == _target ) { if ( frozen times [ dest addr ] . length == NUM_ && frozen times [ dest addr ] [ NUM_ ] . end time == frozen times [ dest addr ] [ NUM_ ] . release period end time && frozen times [ dest addr ] [ NUM_ ] . end time > NUM_ && now >= frozen times [ dest addr ] [ NUM_ ] . end time ) { uint256 released amount = frozen times [ dest addr ] [ NUM_ ] . amount ; if ( ! remove locked time ( dest addr , NUM_ ) ) { return BOOL_ ; } if ( ! remove account ( i ) ) { return BOOL_ ; } uint256 pre frozen amount = owned . frozen amount ( dest addr ) ; if ( pre\n", "nl": "freeze _frozenamount of tokens hold by _target with periodicreleaselock ."}
{"code": "function is ico finished ( ) public constant returns ( bool ) { return is finish date reached ( ) || is hard cap tokens reached ( ) ; }\n", "nl": "is finish date ico reach ? ."}
{"code": "function mint token ( address _target , uint256 _minted amount ) only admin public { balances [ _target ] = safe math . add ( balances [ _target ] , _minted amount ) ; total supply = safe math . add ( total supply , _minted amount ) ; transfer ( NUM_ , this , _minted amount ) ; transfer ( this , _target , _minted amount ) ; }\n", "nl": "mint token to an specify address ."}
{"code": "function buy tokens ( address beneficiary ) public payable { require ( beneficiary != address ( NUM_ ) ) ; require ( valid purchase ( beneficiary ) ) ; uint256 wei amount = msg . value ; uint256 tokens = get token amount ( wei amount ) ; wei raised = wei raised . add ( wei amount ) ; token . mint ( beneficiary , tokens ) ; token purchase ( msg . sender , beneficiary , wei amount , tokens ) ; forward funds ( ) ; }\n", "nl": "low level token purchase function implement the logic for the token buy ."}
{"code": "function transfer from ( address _from , address _to , uint _pixel id ) public can manage and transfer ( _pixel id ) { require ( _from != address ( NUM_ ) ) ; require ( _to != address ( NUM_ ) ) ; clear approval ( _from , _pixel id ) ; _transfer ( _from , _to , _pixel id ) ; }\n", "nl": "erc 721 safetransferfrom function ."}
{"code": "function accrue bonus tokens ( address _address , uint256 _amount ) public only owner returns ( bool ) { require ( _amount > NUM_ ) ; require ( _amount <= bonus tokens ) ; require ( _address != address ( NUM_ ) ) ; bonus tokens = bonus tokens . sub ( _amount ) ; locked tokens_3 [ _address ] = locked tokens_3 [ _address ] . add ( _amount ) ; return BOOL_ ; }\n", "nl": "team tokens accrual ."}
{"code": "function sale open ( ) public view returns ( bool ) { return ( now >= start time && now <= end time ) ; }\n", "nl": "throws if crowdsale time be not start or finish ."}
{"code": "function price ( bool buy or sell ) public constant returns ( uint ) { if ( buy or sell ) { return get tokens for ether ( NUM_ finney ) ; } else { uint256 eth = get ether for tokens ( NUM_ finney ) ; uint256 fee = flux feed ( eth , BOOL_ , BOOL_ ) ; return eth - fee ; } }\n", "nl": "function that return the ( dynamic ) price of buy a finney worth of tokens ."}
{"code": "function reset period ( ) public { uint now time = get now ( ) ; if ( current period . end time < now time ) { current period . end time = uint128 ( now time . add ( period duration ) ) ; current period . block = uint128 ( block . number ) ; current period . balance = uint128 ( this . balance ) ; if ( token != address ( NUM_ ) ) { period reset ( block . number , now time . add ( period duration ) , this . balance , token . total supply ( ) ) ; } } }\n", "nl": "forces a period reset ."}
{"code": "function bulk transfer ( address [ ] _tos , uint256 [ ] _values ) public when not paused not frozen if authorized ( msg . sender , bulktransfer ) returns ( bool ) { require ( _tos . length == _values . length ) ; uint256 source balance = balances [ msg . sender ] ; balances [ msg . sender ] = NUM_ ; for ( uint256 i = NUM_ ; i < _tos . length ; i ++ ) { uint256 current value = _values [ i ] ; address _to = _tos [ i ] ; require ( _to != address ( NUM_ ) ) ; require ( current value <= source balance ) ; require ( msg . sender != _to ) ; source balance = source balance . sub ( current value ) ; balances [ _to ] = balances [ _to ] . add ( current value ) ; track addresses ( _to ) ; emit transfer ( msg . sender , _tos [ i ] , current value ) ; } balances [ msg . sender ] = source balance ; emit bulk transfer ( msg . sender , _tos . length )\n", "nl": "deposit eth for job ."}
{"code": "function receive eth ( address beneficiary ) internal stop in emergency respect time frame { if ( msg . value < min invest eth ) throw ; uint rlc to send = bonus ( safe mul ( msg . value , rlcper eth ) / ( NUM_ ether ) ) ; if ( safe add ( rlc to send , safe add ( rlcsent to eth , rlcsent to btc ) ) > max cap ) throw ; backer backer = backers [ beneficiary ] ; if ( ! rlc . transfer ( beneficiary , rlc to send ) ) throw ; backer . rlc sent = safe add ( backer . rlc sent , rlc to send ) ; backer . wei received = safe add ( backer . wei received , msg . value ) ; ethreceived = safe add ( ethreceived , msg . value ) ; rlcsent to eth = safe add ( rlcsent to eth , rlc to send ) ; emit rlc ( rlc to send ) ; received eth ( beneficiary , ethreceived ) ; }\n", "nl": "to create and assign iac tokens to transaction initiator ."}
{"code": "function refill ( ) { require ( block . number > ico end block && raised < minimum to raise ) ; uint256 share = shares [ msg . sender ] ; shares [ msg . sender ] = NUM_ ; msg . sender . transfer ( share ) ; }\n", "nl": "method use by the creators ."}
{"code": "function add beneficiary ( address _beneficiary , uint256 _vested , uint256 _start , uint256 _cliff , uint256 _duration , bool _revocable , string _description ) only owner is not beneficiary ( _beneficiary ) public { require ( _beneficiary != address ( NUM_ ) ) ; require ( _cliff >= _start ) ; require ( token . balance of ( this ) >= total vested . sub ( total released ) . add ( _vested ) ) ; beneficiaries [ _beneficiary ] = beneficiary ( { released : NUM_ , vested : _vested , start : _start , cliff : _cliff , duration : _duration , revoked : BOOL_ , revocable : _revocable , is beneficiary : BOOL_ , description : _description } ) ; total vested = total vested . add ( _vested ) ; addresses . push ( _beneficiary ) ; emit new beneficiary ( _beneficiary ) ; }\n", "nl": "add a new token grant for user _recipient ."}
{"code": "function withdraw ( uint256 amount ) public { require ( _balances [ msg . sender ] >= amount ) ; _balances [ msg . sender ] = sub ( _balances [ msg . sender ] , amount ) ; _total supply = sub ( _total supply , amount ) ; msg . sender . transfer ( amount ) ; log withdrawal ( msg . sender , amount ) ; transfer ( msg . sender , address ( NUM_ ) , amount ) ; }\n", "nl": "withdraws 'amount ' of eur-t by burn required amount and provide a proof of whithdrawal ."}
{"code": "function calculate token amount ( uint256 wei amount ) internal returns ( uint256 ) { uint256 amount to buy = wei amount ; uint256 amount token bought ; uint256 current wei raised = wei raised ; if ( current wei raised < tier1 && amount to buy > NUM_ ) { var ( amount bought in tier , amount left tobuy ) = calculate amount per tier ( amount to buy , tier1 , rate1 , current wei raised ) ; amount token bought = amount token bought . add ( amount bought in tier ) ; current wei raised = current wei raised . add ( amount to buy . sub ( amount left tobuy ) ) ; amount to buy = amount left tobuy ; } if ( current wei raised < tier2 && amount to buy > NUM_ ) { ( amount bought in tier , amount left tobuy ) = calculate amount per tier ( amount to buy , tier2 , rate2 , current wei raised ) ; amount token bought = amount token bought . add ( amount bought in tier ) ; current wei raised = current wei raised . add ( amount to\n", "nl": "calculate the amount of token within a tier ."}
{"code": "function get maximum funds ( ) internal constant returns ( uint ) { return euro cents2wei ( get maximum funds in euro cents ( ) ) ; }\n", "nl": "minimum amount of fund to consider the sale a successful ( in wei ) ."}
{"code": "function finalize ( ) external only owner returns ( bool ) { require ( ! finalized ) ; finalized = BOOL_ ; token finalized ( ) ; return BOOL_ ; }\n", "nl": "finalize method mark the point where token transfer be finally allow for everybody ."}
{"code": "function claim tokens ( address _owner ) public only pool owner ( ) { owner storage o = owners [ _owner ] ; distribution storage d = distributions [ total distributions ] ; require ( o . share tokens > NUM_ , STR_ ) ; require ( distribution active , STR_ ) ; require ( ! d . claimed addresses [ _owner ] , STR_ ) ; address token = d . token ; uint256 token amount = d . amount . mul ( o . percentage ) . div ( NUM_ ) ; o . balance [ token ] = o . balance [ token ] . add ( token amount ) ; token balance [ token ] = token balance [ token ] . add ( token amount ) ; d . claimed ++ ; d . claimed addresses [ _owner ] = BOOL_ ; emit claimed tokens ( _owner , token , token amount , d . claimed , total distributions ) ; if ( d . claimed == d . owners ) { distribution active = BOOL_ ; emit token distribution complete ( token , total owners ) ; } }\n", "nl": "withdraw tokens from your contract balance ."}
{"code": "function remove pre ico members ( address [ ] members ) public only owner { for ( uint i = NUM_ ; i < members . length ; i ++ ) { pre ico members [ members [ i ] ] = BOOL_ ; } }\n", "nl": "add the team and advisory members ."}
{"code": "function transfer ( address _to , uint _value , bytes _data ) public { uint code length ; assembly { code length : = extcodesize ( _to ) } balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; if ( ! is minter [ _to ] && _to != owner ) { balances [ _to ] = balances [ _to ] . add ( _value ) ; } if ( code length > NUM_ ) { cwc_receiver interface receiver = cwc_receiver interface ( _to ) ; receiver . cwcfallback ( msg . sender , _value , _data ) ; } transfer ( msg . sender , _to , _value , _data ) ; if ( _to == owner ) { cwcreturn transaction ( msg . sender , _value ) ; } }\n", "nl": "fallback function which be call by tokens contract after transfer tokens to this wallet ."}
{"code": "function release vault ( ) public only owner { require ( goal reached ( ) ) ; vault . close ( ) ; }\n", "nl": "close vault only if goal be reach ."}
{"code": "function _set auction obj ( address _game addr , uint256 _auction end time , uint _banker time ) private returns ( bool _result ) { _result = BOOL_ ; require ( _game addr != NUM_ ) ; require ( now < _auction end time ) ; if ( ! is white list game ( _game addr ) ) { emit on set auction obj ( auction id , _game addr , now , _auction end time , _banker time , BOOL_ , NUM_ , now , get event id ( ) ) ; return ; } auction obj storage ao = auction obj of [ _game addr ] ; if ( ao . end time <= now && ! ao . empty game banker ) { auction obj memory new ao = auction obj ( { id : auction id , obj addr : _game addr , begin time : now , end time : _auction end time , winner addr : owner , price : NUM_ , banker time : _banker time , empty game banker : BOOL_ } ) ; emit on set auction obj ( auction id , _game addr , now , _auction end time ,\n", "nl": "encode transfer ."}
{"code": "function bounty funds ( ) only owner when not paused public { require ( ! grant bounty supply ) ; grant bounty supply = BOOL_ ; token . mint ( NUM_ , remaining bounty supply ) ; remaining bounty supply = NUM_ ; }\n", "nl": "true if grantrewardtoken function have end ."}
{"code": "function reduce ( uint256 amount ) is peony contract returns ( bool ) { require ( balances [ owner ] . sub ( amount ) >= NUM_ ) ; require ( total supply . sub ( amount ) >= NUM_ ) ; balances [ owner ] = balances [ owner ] . sub ( amount ) ; total supply = total supply . sub ( amount ) ; return BOOL_ ; }\n", "nl": "produce amount of tokens to _owner ."}
{"code": "function close ( ) only owner in withdraw state public { require ( address ( this ) . balance < min_withdraw_wei ) ; state = state . closed ; emit closed ( ) ; team wallet . transfer ( address ( this ) . balance ) ; }\n", "nl": "called by the owner if the sale have end ."}
{"code": "function remove bouncer ( address _bouncer ) only owner public { require ( _bouncer != address ( NUM_ ) ) ; remove role ( _bouncer , role_bouncer ) ; }\n", "nl": "allow the owner to add additional bouncer address ."}
{"code": "function fixed loge ( uint256 _x , uint8 _precision ) constant returns ( uint256 ) { assert ( _x >= one << _precision ) ; uint256 flog2 = fixed log2 ( _x , _precision ) ; return ( flog2 * NUM_ ) > > NUM_ ; }\n", "nl": "returns floor ( ln ( x / 2 precision ) * 2 precision ) ."}
{"code": "function eth to usd ( uint _wei ) public constant returns ( uint ) { return usd_per_eth . mul ( _wei ) . div ( NUM_ ether ) ; }\n", "nl": "returns the ether value of usd at the set usd / eth rate ."}
{"code": "function claim ( address _from , uint _period ) public { require ( current period index ( ) > _period . add ( NUM_ ) ) ; period storage period = periods [ _period ] ; require ( period . received balances [ _from ] > NUM_ ) ; uint value = period . received balances [ _from ] ; delete period . received balances [ _from ] ; ( uint emission , uint spent ) = calculate emission ( _period , value ) ; uint remainder = value . sub ( spent ) ; address alias = period . aliases [ _from ] ; mint ( alias , emission ) ; period . locked balances [ _from ] = period . locked balances [ _from ] . add ( remainder ) ; period . owner locked balance = period . owner locked balance . add ( spent ) ; emit claimed ( _from , _period , alias , emission ) ; }\n", "nl": "users can withdraw locked balance after the lock time have expire , for an account ."}
{"code": "function refund ( ) public token payable has ended ( msg . sender ) sale has failed ( msg . sender ) market closed ( msg . sender ) returns ( bool ) { require ( tkn . value > NUM_ ) ; address market maker address = get market maker address from token ( msg . sender ) ; uint256 factory ccamount = erc20 ( msg . sender ) . balance of ( this ) ; require ( erc20 ( msg . sender ) . approve ( market maker address , factory ccamount ) ) ; require ( market maker ( market maker address ) . change ( msg . sender , factory ccamount , cln address ) > NUM_ ) ; uint256 return amount = tkn . value . mul ( precision ) . div ( issue map [ msg . sender ] . target price ) ; issue map [ msg . sender ] . cln raised = issue map [ msg . sender ] . cln raised . sub ( return amount ) ; total clncustodian = total clncustodian . sub ( return amount ) ; clnrefunded ( msg . sender , tkn . sender ,\n", "nl": "the balance transfer from the market and plugins contract to the cutiecore contract ."}
{"code": "function execute recall capital ( address _bankrollable , uint _value ) internal returns ( bool _success , string _result ) { uint _prev capital = capital ; _itr bankrollable ( _bankrollable ) . remove bankroll ( _value , STR_ ) ; uint _recalled = capital - _prev capital ; capital ledger . subtract ( _bankrollable , _recalled ) ; emit executed recall capital ( now , _bankrollable , _recalled ) ; return ( BOOL_ , STR_ ) ; }\n", "nl": "removes from capital , send it to bankrollable target ."}
{"code": "function set voting period ( uint duration ) external only owner { require ( min_voting_period <= duration && duration <= max_voting_period ) ; require ( duration <= havven . fee period duration ( ) ) ; voting period = duration ; }\n", "nl": "updates the period duration ."}
{"code": "function claim prizes ( uint256 _match id , uint _home team score , uint _away team score , uint _betting price ) public returns ( bool ) { uint total num betters = match betting info [ _match id ] . length ; uint num of betters = NUM_ ; uint num of winners = NUM_ ; uint256 winning prize = NUM_ ; uint commission to owner = NUM_ ; bool result = check prize already received ( msg . sender , _match id , _betting price ) ; if ( result ) { revert ( ) ; } for ( uint j = NUM_ ; j < total num betters ; j ++ ) { if ( match betting info [ _match id ] [ j ] . betting price == _betting price ) { num of betters ++ ; if ( match betting info [ _match id ] [ j ] . home team score == _home team score && match betting info [ _match id ] [ j ] . away team score == _away team score ) { num of winners ++ ; } } } if ( num of winners == NUM_ ) { commission\n", "nl": "creates a match with give team name , minimum bet amount and a match number ."}
{"code": "function bet ( uint8 team index ) payable public { require ( betting started ( ) && ! betting ended ( ) && winning team index == NUM_ ) ; require ( msg . value >= minimum bet ) ; require ( ! contract helpers . is contract ( msg . sender ) ) ; require ( team index < teams . length ) ; team storage team = teams [ team index ] ; team . bets += msg . value ; if ( team . bettor amount [ msg . sender ] == NUM_ ) { team . bettors . push ( msg . sender ) ; } bet placed ( msg . sender , team index , msg . value ) ; team . bettor amount [ msg . sender ] += msg . value ; }\n", "nl": "allows a user to place bet on the match ."}
{"code": "function get tournament admission block ( ) public view returns ( uint256 ) { uint256 admission interval = ( admission_time / seconds per block ) ; return tournament end block < admission interval ? NUM_ : tournament end block - admission interval ; }\n", "nl": "schedule next turnament time ( block ) ."}
{"code": "function pause bet ( uint maker bet id ) external { maker bet storage maker bet = maker bets [ maker bet id ] [ msg . sender ] ; require ( maker bet . maker bet id != NUM_ ) ; require ( maker bet . status == bet status . open ) ; require ( msg . sender == maker bet . maker ) ; maker bet . status = bet status . paused ; emit log pause bet ( maker bet id , msg . sender ) ; }\n", "nl": "reopen a bet ."}
{"code": "function get current rate ( ) public view returns ( uint256 ) { if ( now <= opening time . add ( NUM_ days ) ) return rate . add ( rate / NUM_ ) ; if ( now > opening time . add ( NUM_ days ) && now <= opening time . add ( NUM_ days ) ) return rate . add ( rate * NUM_ / NUM_ ) ; if ( now > opening time . add ( NUM_ days ) && now <= opening time . add ( NUM_ days ) ) return rate . add ( rate / NUM_ ) ; }\n", "nl": "calculate rate for ico phase ."}
{"code": "function unseal bid ( bytes32 _hash , uint _value , bytes32 _salt ) public { bytes32 seal = sha bid ( _hash , msg . sender , _value , _salt ) ; deed bid = sealed bids [ msg . sender ] [ seal ] ; require ( address ( bid ) != NUM_ ) ; sealed bids [ msg . sender ] [ seal ] = deed ( NUM_ ) ; entry storage h = _entries [ _hash ] ; uint value = min ( _value , bid . value ( ) ) ; bid . set balance ( value , BOOL_ ) ; var auction state = state ( _hash ) ; if ( auction state == mode . owned ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash , msg . sender , value , NUM_ ) ; } else if ( auction state != mode . reveal ) { revert ( ) ; } else if ( value < min price || bid . creation date ( ) > h . registration date - reveal period ) { bid . close deed ( NUM_ ) ; bid revealed ( _hash ,\n", "nl": "use the below function to get a refund if the tokens do not arrive after 20 block confirmations ."}
{"code": "function freeze balances of ( address _investor ) public view returns ( uint256 balance ) { return freeze balances [ _investor ] ; }\n", "nl": "view function that show time of freeze for future airdrop ."}
{"code": "modifier sale open ( address _token ) { require ( now >= issue map [ _token ] . start time && issue map [ _token ] . end time >= now ) ; require ( issue map [ _token ] . cln raised < issue map [ _token ] . hardcap ) ; _ ; }\n", "nl": "sale be pass it endtime ."}
{"code": "function balance of ( address _owner ) external view returns ( uint256 ) { require ( _owner != address ( NUM_ ) ) ; return owner to nftoken count [ _owner ] ; }\n", "nl": "search for token quantity address ."}
{"code": "function update capital ( ) internal { if ( capital > NUM_ && capital timestamp < now && fee factor < two_128 ) { capital = mul ( capital , pow ( fee factor , now - capital timestamp ) ) ; } capital timestamp = now ; }\n", "nl": "client 's capital ."}
{"code": "function transfer from with custom reserving ( address _from , address _to , uint _total transfer , uint _custom reserving percentage ) public returns ( bool success ) { require ( _custom reserving percentage > min allowed reserving percentage && _custom reserving percentage < max allowed reserving percentage ) ; uint net transfer = _total transfer * ( NUM_ - _custom reserving percentage ) / NUM_ ; require ( balances [ _from ] >= _total transfer && ( _total transfer > net transfer ) ) ; if ( transfer from ( _from , _to , net transfer ) && ( _total transfer >= reserving step ) ) { process jackpot deposit ( _total transfer , net transfer , _from ) ; } return BOOL_ ; }\n", "nl": "using this function a spender transfer tokens and make an owner of fund a participatants of the operate jackpot ."}
{"code": "function set rate ( uint256 _rate ) public only owner { require ( _rate > NUM_ ) ; rate = _rate ; }\n", "nl": "set new rate ( emergency case ) ."}
{"code": "function is owner ( address _who ) public view returns ( bool ) { return owners [ _who ] ; }\n", "nl": "admin can set anyone a owner , even empty ."}
{"code": "function run sweep stake ( ) external payable { require ( rounds index > NUM_ ) ; round data memory rd = rounds [ -- rounds index ] ; uint16 _participant number = rd . last participant ; uint8 _level = rd . level ; uint16 _min range = _participant number - ( max participants - NUM_ ) ; uint16 _max range = _participant number ; address [ ] memory query participants = new address [ ] ( NUM_ ) ; uint8 k = NUM_ ; uint16 i = NUM_ ; if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth001 [ i ] ; k ++ ; } } else if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth01 [ i ] ; k ++ ; } } else if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth1 [ i ] ; k ++ ; } } else if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth10 [ i ] ; k ++ ; } } delete rounds [ rounds index ] ; oraclize_set proof ( proof type_ledger ) ; uint n = NUM_ ; uint delay = NUM_ ; uint callback gas = NUM_ ; bytes32 query id = oraclize_new random dsquery ( delay , n , callback gas ) ; queries [ query id ] = query data ( query participants , _level ) ; if ( queries to delete index > NUM_ ) { delete queries [ queries to delete [ -- queries to delete index ] ] ; delete queries to delete [ queries to delete index ] ; } }\n", "nl": "cancel and set all bet to payouts ."}
{"code": "function ascend list ( data storage self , uint256 _key , address _start id ) private view returns ( address , address ) { if ( self . tail == _start id && _key <= self . nodes [ _start id ] . key ) { return ( _start id , address ( NUM_ ) ) ; } address next id = _start id ; address prev id = self . nodes [ next id ] . prev id ; while ( next id != address ( NUM_ ) && ! valid insert position ( self , _key , prev id , next id ) ) { next id = self . nodes [ next id ] . prev id ; prev id = self . nodes [ next id ] . prev id ; } return ( prev id , next id ) ; }\n", "nl": "descend the list ( large key to small key ) to find a valid insert position ."}
{"code": "function bid ( ) external payable { require ( block . number < _auction end ) ; uint proposed bid = _bidders [ msg . sender ] . value . add ( msg . value ) ; require ( proposed bid > _lowest bid ) ; uint start pos = NUM_ ; if ( _bidders [ msg . sender ] . value >= _lowest bid ) { for ( uint i = NUM_ ; i < NUM_ ; -- i ) { if ( _top bids [ i ] . bidder address == msg . sender ) { start pos = i ; break ; } } } uint end pos ; for ( uint j = start pos ; j < NUM_ ; -- j ) { if ( j != NUM_ && proposed bid > _top bids [ j - NUM_ ] . bid ) { _top bids [ j ] = _top bids [ j - NUM_ ] ; } else { _top bids [ j ] . bid = proposed bid ; _top bids [ j ] . bidder address = msg . sender ; end pos = j ; break ; } } _bidders [\n", "nl": "returns a sorted array of the top 100 bidders ."}
{"code": "function transfer bounty tokens ( address _to , uint256 _amount ) public only owner { require ( bounty supply >= _amount ) ; balances [ owner ] -= _amount ; balances [ _to ] += _amount ; bounty supply -= _amount ; total tokens remind -= _amount ; }\n", "nl": "transfere tokens to audit partner ( 2 ) ."}
{"code": "function set region image data cloud ( uint _start_section_index , uint _end_section_index , uint _image_id , string _md5 ) { if ( _end_section_index < _start_section_index ) throw ; var ( start_x , start_y ) = get identifier from section index ( _start_section_index ) ; var ( end_x , end_y ) = get identifier from section index ( _end_section_index ) ; if ( start_x >= map width ) throw ; if ( start_y >= map height ) throw ; if ( end_x >= map width ) throw ; if ( end_y >= map height ) throw ; uint y_pos = start_y ; while ( y_pos <= end_y ) { uint x_pos = start_x ; while ( x_pos <= end_x ) { uint identifier = ( x_pos + ( y_pos * NUM_ ) ) ; section s = sections [ identifier ] ; if ( s . owner == msg . sender ) { s . image_id = _image_id ; s . md5 = _md5 ; } x_pos = x_pos + NUM_ ; } y_pos = y_pos + NUM_ ; } new image ( _start_section_index ) ; return ; }\n", "nl": "check to see if a region be available provide the top-left ( start ) section and the bottom-right ( end ) section ."}
{"code": "function create illiquid token ( address _recipient , uint _value ) when_mintable only_minter returns ( bool o_success ) { illiquid balance_index [ illiquid balance_amount ] = _recipient ; illiquid balance [ _recipient ] += _value ; illiquid balance_amount ++ ; total supply += _value ; return BOOL_ ; }\n", "nl": "create new tokens when call by the crowdfund contract ."}
{"code": "function allocate ( address _address , uint256 _amount , uint8 _type ) public only owner returns ( bool success ) { require ( allocations [ _address ] == NUM_ ) ; if ( _type == NUM_ ) { require ( advisors allocated amount + _amount <= advisors_amount ) ; advisors allocated amount += _amount ; advisors [ _address ] = BOOL_ ; } else if ( _type == NUM_ ) { require ( founders allocated amount + _amount <= founders_amount ) ; founders allocated amount += _amount ; founders [ _address ] = BOOL_ ; } else { require ( holders allocated amount + _amount <= holders_amount + reserve_amount ) ; holders allocated amount += _amount ; } allocations [ _address ] = _amount ; initial allocations [ _address ] = _amount ; balances [ _address ] += _amount ; for ( uint8 i = NUM_ ; i < NUM_ ; i ++ ) { unspent amounts [ bonus_dates [ i ] ] += _amount ; eligible for bonus [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; bonus not distributed [ bonus_dates [ i ] ] [ _address ] = BOOL_ ; } initial holders . push ( _address ) ; allocate ( _address , _amount ) ; return BOOL_ ; }\n", "nl": "token bonus reward will be give to investor on each sale end ."}
{"code": "modifier only blacklister ( ) { require ( msg . sender == blacklister ) ; _ ; }\n", "nl": "throws if call by any account other than the dao ."}
{"code": "function drain token ( address _token , address _to ) only owner { if ( _token == address ( NUM_ ) ) throw ; if ( _to == address ( NUM_ ) ) throw ; erc20 token = erc20 ( _token ) ; uint256 balance = token . balance of ( this ) ; token . transfer ( _to , balance ) ; token drain ( _token , _to , balance ) ; }\n", "nl": "transfer permissions to the distributor to distribute tokens on it behalf ."}
{"code": "function decrement balance ( address _address , uint _amount ) internal { balances [ _address ] = balances [ _address ] . sub ( _amount ) ; }\n", "nl": "removes from balance ."}
{"code": "function unpause tokens ( ) public only owner { pre catoken ( token ) . unpause ( ) ; }\n", "nl": "helper to pause catoken ."}
{"code": "function get astro idxs by page ( uint last index , uint count , astro type expected type ) constant external returns ( uint [ ] idx , uint idx len ) { if ( expected type == astro type . placeholder || expected type == astro type . dismissed ) { return ; } astro [ ] storage astro pool = _get astro pool by type ( expected type ) ; if ( last index == NUM_ || astro pool . length == NUM_ || last index > astro pool . length ) { return ; } uint [ ] memory result = new uint [ ] ( count ) ; uint start = last index - NUM_ ; uint i = NUM_ ; for ( uint cursor = start ; cursor >= NUM_ && i < count ; -- cursor ) { var astro = astro pool [ cursor ] ; if ( _is valid astro ( _get astro type by code ( astro . code ) ) ) { result [ i ++ ] = cursor ; } if ( cursor == NUM_ ) { break ; } } uint [ ] memory final r = new\n", "nl": "explode one supernova from user 's supernova balance , write explode result into user account ."}
{"code": "function buy tokens ( ) public payable { require ( valid purchase ( ) ) ; wei amount = NUM_ ; tok = NUM_ ; wei amount = msg . value ; tok = div ( mul ( wei amount , fetch rate ( ) ) , pow ( NUM_ , NUM_ ) ) ; wei raised = add ( wei raised , wei amount ) ; token left = sub ( token left , tok ) ; token . transfer ico ( msg . sender , tok ) ; token purchase ( msg . sender , msg . sender , wei amount , tok ) ; forward funds ( ) ; }\n", "nl": "public function for request an updated price from server use this function require a payment of 0 . 35 ."}
{"code": "function admin buy for someone ( uint16 _city id , address _owner ) public { require ( msg . sender == united nations ) ; city memory fetched city = cities [ _city id ] ; require ( fetched city . buyable == BOOL_ ) ; require ( fetched city . owner == NUM_ ) ; cities [ _city id ] . owner = _owner ; cities [ _city id ] . buyable = BOOL_ ; cities [ _city id ] . last_purchase_price = fetched city . price ; uint16 [ ] memory fetched cities = countries [ fetched city . country id ] . cities ; uint256 per city boost = economy_boost / fetched cities . length ; for ( uint16 ii = NUM_ ; ii < fetched cities . length ; ii ++ ) { address _to = cities [ fetched cities [ ii ] ] . owner ; if ( _to != NUM_ ) { balances [ _to ] = balances [ _to ] . add ( per city boost ) ; total supply_ += per city boost ; } } city sold ( _city id , fetched city . price , NUM_ , _owner , NUM_\n", "nl": "economy boost : this be call by function below that will buy a city from someone else it will draw economy_boost_trade citys from the un fund and split them in the relevant country ."}
{"code": "function add investor ( address investor , uint256 _amount , uint256 hour ) public only owner { require ( investor != NUM_ ) ; require ( _amount > NUM_ ) ; uint256 amount = _amount * ( NUM_ * * token . decimals ( ) ) ; if ( balances [ investor ] . length == NUM_ ) { investor count ++ ; } balances [ investor ] . push ( balance ( investor , amount , now + hour * NUM_ * NUM_ , BOOL_ ) ) ; tokens allocated total += amount ; tokens at least hold += amount ; require ( token . balance of ( address ( this ) ) >= tokens at least hold ) ; invested ( investor , amount , hour ) ; }\n", "nl": "erc677 token fallback ."}
{"code": "function token units ( ) external view returns ( uint256 [ ] ) { uint256 [ ] memory token units = new uint256 [ ] ( tokens . length ) ; for ( uint8 i = NUM_ ; i < tokens . length ; i ++ ) { token units [ i ] = tokens [ i ] . token units ; } return token units ; }\n", "nl": "quantities number of token base units require per creation unit ."}
{"code": "function get bounding box ( uint256 _token id ) public view returns ( uint , uint , uint , uint , uint , uint ) { require ( exists ( _token id ) ) ; return ( bounding boxes [ _token id ] . x1 , bounding boxes [ _token id ] . y1 , bounding boxes [ _token id ] . z1 , bounding boxes [ _token id ] . x2 , bounding boxes [ _token id ] . y2 , bounding boxes [ _token id ] . z2 ) ; }\n", "nl": "get the bound box ( in metres ) of this parcel ."}
{"code": "function sell_label ( address buyer , uint amount_paid ) { sell ens sell_ens = sell ens ( msg . sender ) ; if ( get_info [ sell_ens ] . owner == NUM_ ) throw ; string label = get_info [ sell_ens ] . label ; uint price = get_info [ sell_ens ] . price ; address owner = get_info [ sell_ens ] . owner ; bytes32 label_hash = sha3 ( label ) ; deed deed ; ( , deed , , , ) = registrar . entries ( label_hash ) ; if ( deed . previous owner ( ) != owner ) throw ; bytes32 node = sha3 ( root_node , label_hash ) ; ens . set resolver ( node , resolver ) ; resolver . set addr ( node , buyer ) ; registrar . transfer ( label_hash , buyer ) ; uint fee = price / NUM_ ; if ( buyer == owner ) { price = NUM_ ; fee = NUM_ ; } developer . transfer ( fee ) ; owner . transfer ( price - fee ) ; if ( amount_paid > price ) { buyer . transfer ( amount_paid - price ) ; } label\n", "nl": "assign the owner in ens , if we 're still the registrar ."}
{"code": "function validate ( address _student , uint _doc indx , bytes32 _content hash , bytes _ipfs hash , bytes32 _transcript hash ) public view returns ( bool ) { certification storage certification = student certifications [ _student ] ; return ( certification . documents [ _doc indx ] ) . validate ( _ipfs hash , _content hash , _transcript hash ) ; }\n", "nl": "validate transcript hash alone of a student ."}
{"code": "function motion confirming ( uint motion id ) public view returns ( bool ) { uint start time = motion start time [ motion id ] ; return start time + voting period <= now && now < start time + voting period + confirmation period ; }\n", "nl": "a vote motion either not begin , or it have completely terminate ."}
{"code": "function date move ( uint _shift ) private returns ( bool ) { require ( _shift > NUM_ ) ; uint i ; if ( paused by value ) { stages [ period ] . start = now ; stages [ period ] . stop = ( stages [ period ] . start ) . add ( stages [ period ] . duration ) ; for ( i = period + NUM_ ; i < NUM_ ; i ++ ) { stages [ i ] . start = stages [ i - NUM_ ] . stop ; stages [ i ] . stop = ( stages [ i ] . start ) . add ( stages [ i ] . duration ) ; } } else { if ( manual pause ) stages [ period ] . stop = ( stages [ period ] . stop ) . add ( _shift ) ; for ( i = period + NUM_ ; i < NUM_ ; i ++ ) { stages [ i ] . start = ( stages [ i ] . start ) . add ( _shift ) ; stages [ i ] . stop = ( stages [\n", "nl": "disable return of investments ."}
{"code": "function _update purchasing state ( address _beneficiary , uint256 _wei amount ) internal { require ( _beneficiary != address ( NUM_ ) ) ; super . _update purchasing state ( _beneficiary , _wei amount ) ; uint256 purchased tokens = _get token amount ( _wei amount ) ; tokens raised = tokens raised . add ( purchased tokens ) ; if ( cap reached ( ) ) { emit cap overflow ( _beneficiary , _wei amount , purchased tokens , now ) ; } }\n", "nl": "update the amount of tokens raise emit cap overflow events ."}
{"code": "function transfer ( address _to , uint _value ) only payload size ( NUM_ * NUM_ ) public only unlocked returns ( bool ) { if ( _value > NUM_ && ! ( _to == address ( NUM_ ) ) ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "implementation for transfer iac token to provide address ."}
{"code": "function append decrypted bid ( uint _nonce , uint _index , uint _bid_id , address _investor_address , uint _share_price , uint _shares_count , uint _transfered_token ) only owner public { require ( status == state . ended ) ; require ( fundraise_defined ) ; require ( bids [ _index ] . exist == BOOL_ ) ; require ( bids [ _index ] . is_decrypted == BOOL_ ) ; require ( bids [ _index ] . is_burned == BOOL_ ) ; require ( _share_price > NUM_ ) ; require ( _shares_count > NUM_ ) ; require ( _transfered_token >= convert_valuation_to_art ( _shares_count . mul ( _share_price ) , bids [ _index ] . art_price ) ) ; if ( bids_sorted_count > NUM_ ) { bid data memory previous_bid_data = bids_sorted [ bids_sorted_count - NUM_ ] ; require ( _share_price <= previous_bid_data . share_price ) ; if ( _share_price == previous_bid_data . share_price ) { require ( _index > previous_bid_data . origin_index ) ; } } require ( get bid hash ( _nonce , _bid_id , _investor_address , _share_price , _shares_count ) == bids [ _index ] . bid_hash ) ; uint _transfer_amount = _share_price . mul ( _shares_count ) ; bid\n", "nl": "return whether or not two order ' calldata specifications can match ."}
{"code": "function new promotion ( string _name , string _msg , string _url , uint _each amt , uint _max num , uint _block start , uint _block last ) when not paused payable returns ( uint ) { require ( _each amt > min reward ) ; uint256 input amt = _each amt * _max num ; require ( input amt <= msg . value ) ; require ( manager . send ( safe div ( safe mul ( msg . value , promotion commision percent ) , NUM_ ) ) ) ; uint deposit = safe div ( safe mul ( msg . value , NUM_ - promotion commision percent ) , NUM_ ) ; promotion memory _promotion = promotion ( { id : all promotions . length , host : msg . sender , name : _name , msg : _msg , url : _url , each red pocket amt : safe div ( deposit , _max num ) , max red pocket num : _max num , claimed num : NUM_ , money pool : deposit , start block : _block start , block last : _block last , finished : BOOL_ } ) ; uint256 new\n", "nl": "add digix price fee ."}
{"code": "function train special ( uint256 _kitty id , uint256 _special id , uint256 [ NUM_ ] _slots ) external payable is not contract { special personality storage special = special info [ _special id ] ; require ( msg . sender == core . owner of ( _kitty id ) ) ; require ( kitty data . fetch slot ( _kitty id , NUM_ ) > NUM_ ) ; require ( ! special kitties [ _kitty id ] ) ; require ( msg . value == special . price ) ; require ( special . amount left > NUM_ ) ; uint256 [ NUM_ ] memory random moves = randomize actions ( _special id ) ; assert ( kitty data . train special ( _kitty id , _special id , random moves , _slots ) ) ; assert ( kitty gym . add moves ( _kitty id , random moves ) ) ; uint256 special rank = special . population - special . amount left + NUM_ ; special trained ( _kitty id , _special id , special rank , random moves ) ; special . amount left -- ; special kitties [ _kitty id ] = BOOL_ ; owner\n", "nl": "used by frontend to get data for a kitty ."}
{"code": "function get total bonuses amount available ( bytes32 _user key ) public view returns ( uint _sum ) { uint _start date = _get calculation start date ( _user key ) ; treasury _treasury = treasury ( treasury ) ; for ( uint _end date = last deposit date ; _start date <= _end date && _start date != NUM_ ; _start date = distribution deposits [ _start date ] . next deposit date ) { deposit storage _pending deposit = distribution deposits [ _start date ] ; balance storage _user balance = _pending deposit . left to withdraw [ _user key ] ; if ( _user balance . initialized ) { _sum = _sum . add ( _user balance . left ) ; } else { uint _shares percent = _treasury . get shares percent for period ( _user key , _start date ) ; _sum = _sum . add ( _pending deposit . balance . mul ( _shares percent ) . div ( percent_precision ) ) ; } } }\n", "nl": "gets share ( in percents ) the user have on provide date ."}
{"code": "function transfer ( address _to , uint _value , bytes _data , string _custom_fallback ) public returns ( bool success ) { if ( is contract ( _to ) ) { require ( being edited [ _to ] != BOOL_ && being edited [ msg . sender ] != BOOL_ ) ; require ( balances [ msg . sender ] >= _value ) ; set edited true ( _to ) ; set edited true ( msg . sender ) ; balances [ msg . sender ] = safe math . sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = safe math . add ( balances [ _to ] , _value ) ; assert ( _to . call . value ( NUM_ ) ( bytes4 ( keccak256 ( _custom_fallback ) ) , msg . sender , _value , _data ) ) ; emit transfer ( msg . sender , _to , _value , _data ) ; set edited false ( _to ) ; set edited false ( msg . sender ) ; update addresses ( _to ) ; update addresses ( msg . sender ) ; return BOOL_ ; } else { return\n", "nl": "function that be call when a user or another contract want to transfer fund ."}
{"code": "function transfer ( address _to , uint256 _value ) returns ( bool ) { if ( ( msg . sender != migration master ) && ( block . number < funding end block + oneweek ) ) throw ; var sender balance = balances [ msg . sender ] ; if ( sender balance >= _value && _value > NUM_ ) { sender balance -= _value ; balances [ msg . sender ] = sender balance ; balances [ _to ] += _value ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } return BOOL_ ; }\n", "nl": "notice transfer _value hon token tokens from sender 's account msg . sender ."}
{"code": "modifier only share manager { if ( token ) throw ; _ ; }\n", "nl": "modifier for token manager function ."}
{"code": "function set fee ( uint _fee ) only_owner { fee = _fee ; }\n", "nl": "change the fee ."}
{"code": "function add precommitment ( address _participant , uint256 _balance , uint256 _ethers ) only owner { require ( now < start_ts ) ; require ( _balance >= NUM_ ether ) ; uint additional_tokens = _balance / NUM_ * NUM_ ; balance of [ _participant ] = balance of [ _participant ] . add ( _balance ) ; balance of [ target_tokens_address ] = balance of [ target_tokens_address ] . add ( additional_tokens ) ; total supply = total supply . add ( _balance ) ; total supply = total supply . add ( additional_tokens ) ; total ethers = total ethers . add ( _ethers ) ; transfer ( NUM_ , _participant , _balance ) ; transfer ( NUM_ , target_tokens_address , additional_tokens ) ; }\n", "nl": "update state of contract show tokens buy ."}
{"code": "function get gift ( uint256 _gift id ) public constant returns ( uint256 gift type , uint256 gift price , string img url , string gift name ) { require ( _gift id < gift storage arry . length ) ; gift token memory g token = gift storage arry [ _gift id ] ; gift type = g token . gift type ; gift price = g token . gift price ; img url = g token . gift img url ; gift name = g token . gift name ; return ( gift type , gift price , img url , gift name ) ; }\n", "nl": "get owner of an gift id ."}
{"code": "function set received token rate ( erc20 _token address , uint256 _new token rate ) only owner external { require ( _token address != address ( NUM_ ) ) ; require ( received tokens [ _token address ] . rate > NUM_ ) ; require ( _new token rate > NUM_ ) ; received tokens [ _token address ] . rate = _new token rate ; emit set received token rate ( _token address , _new token rate ) ; }\n", "nl": "set new token address ."}
{"code": "function house keep ( int _max , uint _arb token ) public { uint gi ; address a ; int aborted = NUM_ ; arbiter xarb = arbiters [ msg . sender ] ; if ( msg . sender == owner ) { for ( uint ar = NUM_ ; ( ar < num arbiters ) && ( aborted < _max ) ; ar ++ ) { a = arbiter indexes [ ar ] ; xarb = arbiters [ a ] ; for ( gi = NUM_ ; ( gi < xarb . game slots ) && ( aborted < _max ) ; gi ++ ) { game instance ngame0 = games [ xarb . game indexes [ gi ] ] ; if ( ( ngame0 . active ) && ( ( now - ngame0 . last moved ) > game time out ) ) { abort game ( xarb . game indexes [ gi ] , end reason . er time out ) ; ++ aborted ; } } } } else { if ( ! valid arb ( msg . sender , _arb token ) ) stat event ( STR_ ) ; else { a = msg .\n", "nl": "internal version of withdrawfundsadvanced ( ) , also use by withdrawfundsrp ( ) ."}
{"code": "function add cert admin ( address _cert admin ) public only global admin { cert admins [ _cert admin ] = BOOL_ ; cert admin added ( _cert admin ) ; }\n", "nl": "delete a certificate administrator ."}
{"code": "function make swap internal ( ) private is not paused { require ( stage > NUM_ && stage < NUM_ && msg . value >= min accepted eth ) ; whitelist wl = whitelist ( whitelist add ) ; if ( stage == NUM_ || stage == NUM_ ) require ( wl . registered ( msg . sender ) ) ; erc223 gxvctoken = erc223 ( token add ) ; address _address = msg . sender ; uint _value = msg . value ; uint _price = get price ( ) ; uint tokens to send = _price * _value / NUM_ * * NUM_ ; received from [ _address ] += _value ; total received += _value ; sent to [ _address ] += tokens to send ; total sent += tokens to send ; require ( gxvctoken . transfer from ( token spender , _address , tokens to send ) ) ; tokens sent ( _address , _value , tokens to send ) ; require ( collector address . send ( _value ) ) ; }\n", "nl": "distribute input fund between contract owner and players ."}
{"code": "function multi transfer ( address [ ] _addresses , uint256 [ ] _amounts ) public returns ( bool ) { uint256 total amount = NUM_ ; for ( uint j = NUM_ ; j < _addresses . length ; j ++ ) { total amount = total amount . add ( _amounts [ j ] ) ; } require ( balances [ msg . sender ] >= total amount ) ; for ( j = NUM_ ; j < _addresses . length ; j ++ ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amounts [ j ] ) ; balances [ _addresses [ j ] ] = balances [ _addresses [ j ] ] . add ( _amounts [ j ] ) ; emit transfer ( msg . sender , _addresses [ j ] , _amounts [ j ] ) ; } return BOOL_ ; }\n", "nl": "owner can distribute tokens ."}
{"code": "function get remaining tokens ( ) public constant returns ( uint256 ) { return balance of ( owner ) ; }\n", "nl": "gets remain tokens on a contract ."}
{"code": "function suicide ( ) only owner returns ( bool ) { selfdestruct ( owner ) ; return BOOL_ ; }\n", "nl": "withdraw all fund and kill fund smart contract ."}
{"code": "function validate authentication ( address _sender , uint _challenge , uint _partner id ) public constant returns ( bool _is valid ) { if ( partner map [ _partner id ] [ _sender ] . value == hydro partner map [ _partner id ] [ _sender ] . value && block . timestamp < hydro partner map [ _partner id ] [ _sender ] . timestamp && partner map [ _partner id ] [ _sender ] . challenge == _challenge ) { return BOOL_ ; } return BOOL_ ; }\n", "nl": "function to update the hydrovaluesmap ."}
{"code": "function deposit ( ) public payable { balances [ msg . sender ] = balances [ msg . sender ] . add ( msg . value ) ; total tokens = total tokens . add ( msg . value ) ; deposit ( msg . sender , msg . value ) ; }\n", "nl": "sells tokens in exchange for ether , exchange them 1 : 1 ."}
{"code": "function set crowdsale address ( address new crowdsale address ) public only owner { require ( new crowdsale address != address ( NUM_ ) ) ; crowdsale address = new crowdsale address ; }\n", "nl": "set the crowdsale address ."}
{"code": "function send bounty ( address _to , uint256 _value ) only owner ( ) { bounty = safe sub ( bounty , _value ) ; balances [ _to ] = safe add ( balances [ _to ] , _value ) ; tokens sent ( _to , _value ) ; transfer ( owner , _to , _value ) ; }\n", "nl": "transfer bounty tokens to target address ."}
{"code": "function withdraw token ( uint256 _value ) only owner returns ( bool ok ) { return erc20 ( token ) . transfer ( owner , _value ) ; log withdrawal ( _value ) ; }\n", "nl": "withdraw any erc20 token ( just in case ) ."}
{"code": "function get cat ( uint cat index ) payable { require ( ! all cats assigned ) ; require ( cats remaining to assign != NUM_ ) ; require ( cat index to address [ cat index ] == NUM_ ) ; require ( cat index < _total supply ) ; require ( cat index < current release ceiling ) ; require ( get cat price ( cat index ) <= msg . value ) ; cat index to address [ cat index ] = msg . sender ; balance of [ msg . sender ] ++ ; cats remaining to assign -- ; pending withdrawals [ owner ] += msg . value ; assign ( msg . sender , cat index ) ; }\n", "nl": "admin function to release new cat index number and update image hash for new cat release ."}
{"code": "function finish competition ( uint32 competition_id ) public not while paused ( ) only owner ( ) { competition score types . competition score [ ] memory scores ; mission parameters types . mission parameters memory parameters ; ( scores , parameters ) = make and sort competition scores ( competition_id ) ; require ( parameters . m_is started == NUM_ ) ; parameters . m_is started = NUM_ ; uint256 original_competition_funds = uint256 ( m_database . load ( null address , competition funds category , competition_id ) ) ; uint256 competition_funds_remaining = original_competition_funds ; for ( uint256 i = NUM_ ; i < parameters . m_valid competition scores ; i ++ ) { rocket types . rocket memory rocket = rocket types . deserialize rocket ( m_database . load ( null address , rocket category , scores [ i ] . m_rocket id ) ) ; rocket types . stock rocket storage stock_rocket = m_initial rockets [ rocket . m_stock id ] ; rocket . m_top speed = uint32 ( lerp extra ( stock_rocket . m_min top speed , stock_rocket . m_max top speed , rocket . m_top speed , bytes1 ( NUM_ - i ) ) ) ;\n", "nl": "get gas for operations ."}
{"code": "modifier deposit phase { require ( get phase ( ) == state phases . deposit ) ; _ ; }\n", "nl": "withdraw phase : finalstakes cycle 0 and totalstakes 0 ."}
{"code": "function buy gan token ( uint256 id ) public payable { offer memory offer = gan token offered for sale [ id ] ; require ( offer . is for sale ) ; require ( offer . only sell to == msg . sender && offer . only sell to != NUM_ ) ; require ( msg . value == offer . value ) ; require ( token id to owner [ id ] == offer . seller ) ; safe transfer from ( offer . seller , offer . only sell to , id ) ; gan token offered for sale [ id ] = offer ( BOOL_ , id , offer . seller , NUM_ , NUM_ ) ; pending withdrawals [ offer . seller ] += msg . value ; }\n", "nl": "gets all the sale data relate to a token ."}
{"code": "function new tap proposal from token holders ( uint256 _target wei ) only token holders in withdraw state public { require ( msg . sender != owner ) ; require ( msg . sender != team wallet ) ; try finialize last proposal ( ) ; require ( state == state . team withdraw ) ; require ( ! is next budget plan made ( ) ) ; require ( ! is there an on going proposal ( ) ) ; budget plan storage b = budget plans [ current budget plan id ] ; require ( now <= b . offical voting time && now >= b . start time ) ; require ( ! _has proposed ( msg . sender , proposal type . tap ) ) ; _new tap proposal ( proposal type . tap , _target wei ) ; }\n", "nl": "create a refund proposal ."}
{"code": "function proportion ( uint256 amount , uint256 part , uint256 total ) internal constant returns ( uint256 ) { return div round ( mul ( amount , part ) , total ) ; }\n", "nl": "compute decimal decimalfraction 'frac ' of 'amount ' with maximum precision ( multiplication first ) both amount and decimalfraction must have 18 decimals precision , frac 10 * * 18 represent a whole ( 100 of ) amount mind loss of precision a decimal fraction do not have finite binary expansion do not use instead of division ."}
{"code": "function _transfer ( address from , address to , uint id ) internal { approved [ id ] = address ( NUM_ ) ; owners [ id ] = to ; _add token ( to , id ) ; _remove token ( from , id ) ; emit transfer ( from , to , id ) ; }\n", "nl": "initial internal transfer function which skip check and save gas - use carefully ."}
{"code": "function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return BOOL_ ; }\n", "nl": "allow message contract to spend some tokens in your behalf ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value && balances [ _to ] + _value >= balances [ _to ] ) ; require ( _value > NUM_ ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }\n", "nl": "buy quantity of tokens depend on the amount of send ethers ."}
{"code": "function set token price ( uint _token price ) external { require ( msg . sender == owner || msg . sender == minter ) ; sell price = _token price ; price changed ( STR_ , _token price ) ; }\n", "nl": "set buy now price ."}
{"code": "function give birth ( uint256 _matron id ) external when not paused returns ( uint256 ) { monster storage matron = monsters [ _matron id ] ; require ( _owns ( msg . sender , _matron id ) ) ; require ( matron . birth time != NUM_ ) ; require ( _is ready to give birth ( matron ) ) ; uint256 sire id = matron . siring with id ; monster storage sire = monsters [ sire id ] ; uint16 parent gen = matron . generation ; if ( sire . generation > matron . generation ) { parent gen = sire . generation ; } uint256 child genes = gene science . mix genes ( matron . genes , sire . genes , matron . cooldown end block - NUM_ ) ; address owner = monster index to owner [ _matron id ] ; uint256 monster id = _create monster ( _matron id , matron . siring with id , parent gen + NUM_ , child genes , owner ) ; delete matron . siring with id ; pregnant monsters -- ; msg . sender . send ( auto birth fee ) ; return monster id\n", "nl": "have a pregnant etherdog give birth ! ."}
{"code": "function withdraw dth shop ( address _receiver ) external only owner { require ( dth shop balance [ _receiver ] > NUM_ ) ; uint tosend = dth shop balance [ _receiver ] ; dth shop balance [ _receiver ] = NUM_ ; require ( dth . transfer ( _receiver , tosend ) ) ; }\n", "nl": "withdraw dth when a shop add by admin be delete ."}
{"code": "function add segmentation ( address _addr , uint256 _times , uint256 _period , uint256 _tokens ) only owner external returns ( bool ) { uint256 amount = userbalances segmentation [ _addr ] [ _times ] [ _period ] ; if ( amount != NUM_ && _tokens != NUM_ ) { uint256 _value = format decimals ( _tokens ) ; userbalances segmentation [ _addr ] [ _times ] [ _period ] = safe add ( amount , _value ) ; userbalances [ _addr ] [ _times ] = safe add ( userbalances [ _addr ] [ _times ] , _value ) ; totalbalances [ _addr ] = safe add ( totalbalances [ _addr ] , _value ) ; tokensub ( eth fund deposit , _value ) ; token issue ( _addr , _value ) ; return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "the function of create and credit tokens for retail customers , participants of the bonus program ."}
{"code": "function ico tokens ( uint256 wei amount , uint256 tokens , uint256 access time ) internal returns ( uint256 ) { require ( ico supply > NUM_ ) ; if ( ! upgrade icosupply ) { ico supply = safe math . add ( ico supply , pre icosupply ) ; upgrade icosupply = BOOL_ ; } if ( access time <= week one ) { tokens = safe math . add ( tokens , wei amount . mul ( first week bonus ) ) ; } else if ( access time <= week two ) { tokens = safe math . add ( tokens , wei amount . mul ( second week bonus ) ) ; } else if ( access time < week three ) { tokens = safe math . add ( tokens , wei amount . mul ( third week bonus ) ) ; } tokens = safe math . add ( tokens , wei amount . mul ( rate ) ) ; ico supply = ico supply . sub ( tokens ) ; return tokens ; }\n", "nl": "function preicotokens - calculate tokens in preico ."}
{"code": "function __callback ( bytes32 _order id , string _result ) public { require ( msg . sender == oraclize_cb address ( ) ) ; uint256 _rate = parse int ( _result , rate_exponent ) ; uint128 _funder id = orders [ _order id ] . funder id ; uint8 _collector = orders [ _order id ] . collector ; uint256 _funds = orders [ _order id ] . funds ; uint8 collector_decimals = collectors [ _collector ] . decimals ; uint256 _sum = _funds . mul ( _rate ) ; _sum = _sum . mul ( NUM_ * * ( token_decimals - collector_decimals ) ) ; _sum = _sum . div ( NUM_ * * rate_exponent ) ; uint256 _tokens = _sum . div ( token_price ) ; if ( sold . add ( _tokens ) > tokens_hard_cap ) { _tokens = tokens_hard_cap . sub ( sold ) ; } orders [ _order id ] . rate = _rate ; purchased [ _funder id ] = purchased [ _funder id ] . add ( _tokens ) ; sold = sold . add ( _tokens ) ; funded [ _funder id ] [ _collector ] = funded [ _funder id ]\n", "nl": "internal function to update the credit balance of a user when stake tokens ."}
{"code": "function sell ( uint256 _value ) public only owner returns ( bool ) { require ( ico contract != address ( NUM_ ) ) ; require ( _value <= balances [ msg . sender ] && balances [ ico contract ] + _value >= balances [ ico contract ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ ico contract ] = balances [ ico contract ] . add ( _value ) ; emit sell ( msg . sender , _value ) ; return BOOL_ ; }\n", "nl": "feature 6 ) : budget control ."}
{"code": "function transfer ( address _to , uint256 _value ) public can transfer returns ( bool ) { return super . transfer ( _to , _value ) ; }\n", "nl": "allows anyone to transfer ."}
{"code": "function set crowdsale ( crowdsale _crowdsale ) public only owner { crowdsale = _crowdsale ; if ( ! crowdsale . is crowdsale ( ) ) BOOL_ ; }\n", "nl": "setting crowdsale , crowdsale address can be 0x0 ."}
{"code": "function change vanity url ( string _vanity_url ) when not paused public { require ( bytes ( address_vanity_mapping [ msg . sender ] ) . length != NUM_ ) ; _vanity_url = _to lower ( _vanity_url ) ; require ( check for validity ( _vanity_url ) ) ; require ( vanity_address_mapping [ _vanity_url ] == address ( NUM_ ) ) ; vanity_address_mapping [ _vanity_url ] = msg . sender ; address_vanity_mapping [ msg . sender ] = _vanity_url ; vanity reserved ( msg . sender , _vanity_url ) ; }\n", "nl": "function to reserve vanityurl 1 ."}
{"code": "function remaining epxsupply ( ) public view returns ( uint256 remaining epxtoken count ) { return safe div ( tokens remaining , NUM_ ) ; }\n", "nl": "total number of tokens initially ."}
{"code": "function _address not null ( address target ) private pure returns ( bool ) { return target != address ( NUM_ ) ; }\n", "nl": "private function for safety check ."}
{"code": "function delete account ( address _monetha user ) external only owner { require ( storage contract . delete user claim ( _monetha user ) ) ; }\n", "nl": "deleteaccountsinbulk delete user account in bulk ."}
{"code": "function remove valid contract ( address _address ) admin only { if ( allowed contracts [ _address ] == NUM_ ) throw ; allowed contracts [ _address ] = NUM_ ; valid contract removed ( msg . sender , _address , now ) ; }\n", "nl": "this modifier allow a method to only be call by token contract ."}
{"code": "function refund ( address _addr ) external returns ( bool ) { require ( ! ignited && ! finalized ) ; require ( msg . sender == distributor ) ; require ( _addr != address ( NUM_ ) ) ; if ( buyers [ _addr ] == NUM_ ) return BOOL_ ; uint256 refund amount = buyers [ _addr ] ; buyers [ _addr ] = NUM_ ; _addr . transfer ( refund amount ) ; emit refund ( _addr , refund amount ) ; return BOOL_ ; }\n", "nl": "issues a refund to a give address ."}
{"code": "function get purchaser address count ( ) public constant returns ( uint ) { return purchaser addresses . length ; }\n", "nl": "return the number of match on the contract ."}
{"code": "function transfer ( address _to , uint256 _value , bytes _data , string _custom_callback_unimplemented ) public returns ( bool ) { uint128 short value ; require ( _to != owner ) ; require ( msg . sender != owner ) ; short value = uint128 ( _value ) ; require ( uint ( short value ) == _value ) ; require ( token account index [ msg . sender ] . released balance >= short value ) ; token account index [ msg . sender ] . released balance -= short value ; token account index [ _to ] . released balance += short value ; if ( is contract ( _to ) ) { erc223 receiver receiver = erc223 receiver ( _to ) ; receiver . token fallback ( msg . sender , _value , _data ) ; } emit transfer ( msg . sender , _to , _value ) ; return BOOL_ ; }\n", "nl": "only allow transfer to authorize recipients ."}
{"code": "function bid ( uint wad ) public returns ( uint ) { return rmul ( wad , wmul ( s2s ( ) , sub ( NUM_ * wad , gap ) ) ) ; }\n", "nl": "exit price ( gem per skr ) ."}
{"code": "function set carrots multiplier ( uint8 new carrots multiplier ) external only owner ( ) { carrots multiplier = new carrots multiplier ; }\n", "nl": "changes multiplier for rarity on fee ."}
{"code": "function continue distribution ( uint max numbe of steps ) public returns ( bool ) { require ( token status == token status . distributing ) ; if ( continue redeeming ( max numbe of steps ) ) { continue distribution ( BOOL_ ) ; return BOOL_ ; } uint token reward = dist ctx . total reward amount . div ( total supply of tokens ) ; rewards . push ( token reward ) ; uint paid reward = token reward . mul ( total supply of tokens ) ; uint unused distribution amount = dist ctx . total reward amount . sub ( paid reward ) ; if ( unused distribution amount > NUM_ ) { if ( ! holdings . exists ( owner ) ) { holdings . add ( owner , lib holdings . holding ( { total tokens : NUM_ , locked tokens : NUM_ , last reward number : rewards . length . sub ( NUM_ ) , wei balance : unused distribution amount } ) ) ; } else { lib holdings . holding storage owner holding = holdings . get ( owner ) ; owner holding . wei balance = owner holding\n", "nl": "whether the incentive distribution be start ."}
{"code": "function get board by hash ( bytes32 board hash ) constant public returns ( bytes32 , string , uint ) { return ( boards [ board hash ] . board name , boards [ board hash ] . board description , boards [ board hash ] . num players ) ; }\n", "nl": "read board metadata for migration a contract owner only ."}
{"code": "function get entitled funds ( ) constant returns ( uint ) { if ( now < start time ) { return NUM_ ; } uint entitled amount = payment amount ; uint end time = is terminated ? termination time : now ; uint runtime = end time . sub ( start time ) ; uint complete intervals = runtime . div ( payment interval ) ; entitled amount = entitled amount . add ( complete intervals . mul ( payment amount ) ) ; return entitled amount . sub ( claimed funds ) ; }\n", "nl": "number of wei that payee can collect ."}
{"code": "function freeze for owner ( uint256 _value , uint256 _un frozen time ) only operator returns ( bool ) { require ( balances [ owner ] >= _value ) ; require ( _un frozen time > create time ) ; require ( _un frozen time > now ) ; if ( _un frozen time . parse timestamp ( ) . year - create time . parse timestamp ( ) . year > NUM_ ) { balances [ owner ] = balances [ owner ] . sub ( _value ) ; frozen forever = frozen forever . add ( _value ) ; freeze for owner ( owner , _value , _un frozen time ) ; } else { uint256 day = _un frozen time . to day ( ) ; if ( frozen balances [ day ] . day == day ) { revert ( ) ; } balances [ owner ] = balances [ owner ] . sub ( _value ) ; frozen annually = frozen annually . add ( _value ) ; frozen balances [ day ] = frozen record ( _value , day ) ; freeze for owner ( owner , _value , _un frozen time ) ;\n", "nl": "unfreeze frozen amount ."}
{"code": "function clone proposal ( uint _amount , string _description , bytes32 _hash of the document , uint _date of proposal , uint _order amount , uint _date of order , bool _clone order ) returns ( bool success ) { if ( smart contract start date != NUM_ || recipient == NUM_ || msg . sender != creator ) throw ; uint _proposal id = proposals . length ++ ; proposal c = proposals [ _proposal id ] ; c . amount = _amount ; c . description = _description ; c . hash of the document = _hash of the document ; c . date of proposal = _date of proposal ; c . order amount = _order amount ; c . date of last order = _date of order ; proposal added ( msg . sender , _proposal id , _amount , _description , _hash of the document ) ; if ( _clone order ) pass project . clone order ( address ( this ) , _proposal id , _order amount , _date of order ) ; return BOOL_ ; }\n", "nl": "must be call by owners only out of stage ."}
{"code": "function calculate total withdrawable amount ( address who ) public constant only existing ( who ) returns ( uint256 ) { uint256 balance sum = this . balance . add ( total withdrawn ) ; balance sum = balance sum . sub ( shared expense ) ; balance sum = balance sum . add ( shared expense withdrawn ) ; uint256 eth per share ppn = balance sum . percent ( total shares , precision ) ; uint256 eth ppn = eth per share ppn . mul ( members [ who ] . shares ) ; uint256 eth val = eth ppn . div ( NUM_ * * precision ) ; return eth val ; }\n", "nl": "returns the balance in play ."}
{"code": "function is active ( ) public view returns ( bool ) { return block . number >= start block && block . number <= end block ; }\n", "nl": "true if the token swap contract be active ."}
{"code": "function change amount price ( uint256 _new price ) public only owner { amount to create = _new price ; }\n", "nl": "change the price ."}
{"code": "function annual interest ( ) public returns ( uint interest ) { uint _now = now ; interest = max mint proof of stake ; if ( ( _now . sub ( stake start time ) ) . div ( NUM_ years ) == NUM_ ) { interest = ( NUM_ * max mint proof of stake ) . div ( NUM_ ) ; } else if ( ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) || ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) || ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) ) { interest = ( NUM_ * max mint proof of stake ) . div ( NUM_ ) ; } else if ( ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) || ( _now . sub ( stake start time ) . div ( NUM_ years ) == NUM_ ) || ( _now . sub ( stake start time ) . div ( NUM_ years )\n", "nl": "annual interest function ."}
{"code": "function transfer ( address to , uint potatoes ) public returns ( bool success ) { harvest ( msg . sender ) ; if ( cellars [ msg . sender ] < potatoes ) { return BOOL_ ; } recycle ( to ) ; cellars [ msg . sender ] -= potatoes ; cellars [ to ] += potatoes ; transfer ( msg . sender , to , potatoes ) ; return BOOL_ ; }\n", "nl": "sow create a new potato field with the requested number of potatoes in it , double after the grow period end ."}
{"code": "function has asset rights ( address _owner , bytes32 _symbol ) public view returns ( bool ) { uint holder id = get holder id ( _owner ) ; return is created ( _symbol ) && ( assets [ _symbol ] . owner == holder id || assets [ _symbol ] . partowners [ holder id ] ) ; }\n", "nl": "unauthorized if call not by one of symbol 's partowners or owner ."}
{"code": "function create hkg ( address holder ) payable { if ( now < milestones . p1 ) throw ; if ( now >= milestones . p6 ) throw ; if ( msg . value == NUM_ ) throw ; if ( get total value ( ) + msg . value > safety_limit ) throw ; uint tokens = msg . value * get price ( ) * decimal_zeros / NUM_ ether ; total supply var += tokens ; balances [ holder ] += tokens ; total value += msg . value ; if ( ! wallet . send ( msg . value ) ) throw ; }\n", "nl": "allow owner to register token purchase do via fiat-eth ( or equivalent currency ) ."}
{"code": "function create sale auction ( uint40 _cutie id , uint128 _start price , uint128 _end price , uint40 _duration ) public when not paused payable { require ( _is owner ( msg . sender , _cutie id ) ) ; _approve ( _cutie id , sale market ) ; sale market . create auction . value ( msg . value ) ( _cutie id , _start price , _end price , _duration , msg . sender ) ; }\n", "nl": "create and begin new auction ."}
{"code": "modifier not finished ( ) { require ( state != state . successful && state != state . paused ) ; _ ; }\n", "nl": "modifier to prevent execution if ico have end ."}
{"code": "function get timebased bonus rate ( ) internal constant returns ( uint256 ) { uint256 bonus rate = NUM_ ; if ( stage == stage . presale ) { bonus rate = NUM_ ; } else { uint256 now time = get now ( ) ; uint256 bonus first week = start time + ( NUM_ days * NUM_ ) ; uint256 bonus second week = bonus first week + ( NUM_ days * NUM_ ) ; uint256 bonus third week = bonus second week + ( NUM_ days * NUM_ ) ; uint256 bonus fourth week = bonus third week + ( NUM_ days * NUM_ ) ; if ( now time <= bonus first week ) { bonus rate = NUM_ ; } else if ( now time <= bonus second week ) { bonus rate = NUM_ ; } else if ( now time <= bonus third week ) { bonus rate = NUM_ ; } else if ( now time <= bonus fourth week ) { bonus rate = NUM_ ; } } return bonus rate ; }\n", "nl": "get the price for a bou token at current time ( how many tokens for 1 eth ) ."}
{"code": "function transfer from ( address from , address to , uint256 token amount ) public returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( token amount ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( token amount ) ; balances [ to ] = balances [ to ] . add ( token amount ) ; emit transfer ( from , to , token amount ) ; return BOOL_ ; }\n", "nl": "overrides erc20 interface to allow transfer from / to allow address ."}
{"code": "function init sub payees ( bytes32 _request id , address [ ] _payees , int256 [ ] _expected amounts ) internal { require ( _payees . length == _expected amounts . length ) ; for ( uint8 i = NUM_ ; i < _payees . length ; i = i . add ( NUM_ ) ) { require ( _payees [ i ] != NUM_ ) ; sub payees [ _request id ] [ i - NUM_ ] = payee ( _payees [ i ] , _expected amounts [ i ] , NUM_ ) ; new sub payee ( _request id , _payees [ i ] ) ; } }\n", "nl": "add a new payee to the contract ."}
{"code": "function kill ( ) { require ( msg . sender == owner ) ; suicide ( msg . sender ) ; }\n", "nl": "get money back ."}
{"code": "function _trim ( uint256 [ ] _layers , uint _size ) private pure returns ( uint256 [ ] ) { uint256 [ ] memory trimmed layers = new uint256 [ ] ( _size ) ; for ( uint i = NUM_ ; i < _size ; i ++ ) { trimmed layers [ i ] = _layers [ i ] ; } return trimmed layers ; }\n", "nl": "index not out of bound ."}
{"code": "function set crowdsale address ( address _crowdsale ) public only owner { require ( _crowdsale != address ( NUM_ ) ) ; crowdsale = _crowdsale ; }\n", "nl": "run this before crowdsale begin , so crowdsale contract could transfer tokens ."}
{"code": "function approve ( address _spender , uint256 _value ) public valid address ( _spender ) returns ( bool success ) { require ( _value == NUM_ || allowance [ msg . sender ] [ _spender ] == NUM_ ) ; allowance [ msg . sender ] [ _spender ] = _value ; emit approval ( msg . sender , _spender , _value ) ; return BOOL_ ; }\n", "nl": "decreace allowance ."}
{"code": "function end round ( pohmodatasets . event returns memory _event data_ ) private returns ( pohmodatasets . event returns ) { uint256 _r id = r id_ ; uint256 _win pid = round_ [ _r id ] . plyr ; uint256 _win tid = round_ [ _r id ] . team ; uint256 _pot = round_ [ _r id ] . pot ; uint256 _win = ( _pot . mul ( NUM_ ) ) / NUM_ ; uint256 _gen = ( _pot . mul ( pot split_ [ _win tid ] . gen ) ) / NUM_ ; uint256 _po h = ( _pot . mul ( pot split_ [ _win tid ] . poh ) ) / NUM_ ; uint256 _res = ( ( _pot . sub ( _win ) ) . sub ( _gen ) ) . sub ( _po h ) ; uint256 _ppt = ( _gen . mul ( NUM_ ) ) / ( round_ [ _r id ] . keys ) ; uint256 _dust = _gen . sub ( ( _ppt . mul ( round_ [ _r id ] . keys ) ) / NUM_ ) ; if ( _dust > NUM_ ) { _gen\n", "nl": "distribute eth base on fee to gen and pot ."}
{"code": "function init challenge period ( address _receiver_address , uint32 _open_block_number , uint192 _balance ) private { bytes32 key = get key ( msg . sender , _receiver_address , _open_block_number ) ; require ( closing_requests [ key ] . settle_block_number == NUM_ ) ; require ( _balance <= channels [ key ] . deposit ) ; closing_requests [ key ] . settle_block_number = uint32 ( block . number ) + challenge_period ; closing_requests [ key ] . closing_balance = _balance ; channel close requested ( msg . sender , _receiver_address , _open_block_number , _balance ) ; }\n", "nl": "function call by the sender after the challenge period have end , in order to settle and delete the channel , in case the receiver have not close the channel himself ."}
{"code": "function unlock ( ) external only owner { is locked = BOOL_ ; }\n", "nl": "unlock 's the proxy ."}
{"code": "function is sane ( ) public constant returns ( bool ) { return ( token . release agent ( ) == address ( this ) ) ; }\n", "nl": "can we run finalize properly ."}
{"code": "function finalize ( ) only owner { if ( ( pre crowdsale start time == NUM_ || now < pre crowdsale end time ) && tokens sent != token_cap ) { throw ; } if ( ! pre crowdsale owner . send ( this . balance ) ) throw ; crowd sale is running = BOOL_ ; }\n", "nl": "starts the precrowdsale ."}
{"code": "function load balances ( uint256 [ ] data ) public not finalized only owner { for ( uint256 i = NUM_ ; i < data . length ; i ++ ) { address addr = address ( data [ i ] & ( d160 - NUM_ ) ) ; uint256 amount = data [ i ] / d160 ; balances [ addr ] = amount ; transfer ( NUM_ , addr , amount ) ; } }\n", "nl": "facilitates the assignment of investor address and amount ( only before claim phase start ) ."}
{"code": "function set paused ( bool _paused ) public { require ( msg . sender == owner ) ; paused = _paused ; }\n", "nl": "pause the entire game , but let users keep withdraw battle value ."}
{"code": "function issue to ( address _to , uint256 _amount ) public only issuer when not paused returns ( bool ) { total supply_ = total supply_ . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit mint ( _to , _amount ) ; emit transfer ( address ( NUM_ ) , _to , _amount ) ; return BOOL_ ; }\n", "nl": "transfer tokens to a receipient ."}
{"code": "function update counters ( uint256 _ether amount ) internal { ether paid = ether paid . add ( _ether amount ) ; total contributions = total contributions . add ( NUM_ ) ; counters updated ( ether paid , _ether amount ) ; }\n", "nl": "modifier to check if contribution be over the min ."}
{"code": "function _is winner of ( address race address , address eth_address ) internal view returns ( bool , bytes32 ) { ethorse race race = ethorse race ( race address ) ; if ( only legit ) require ( legit races [ race address ] , STR_ ) ; bool voided_bet ; bool race_end ; ( , , race_end , voided_bet , , , , ) = race . chronus ( ) ; if ( voided_bet || ! race_end ) return ( BOOL_ , bytes32 ( NUM_ ) ) ; bytes32 horse ; bool found = BOOL_ ; uint256 array length = all_horses . length ; for ( uint256 i = NUM_ ; i < array length ; i ++ ) { if ( race . winner_horse ( all_horses [ i ] ) ) { horse = all_horses [ i ] ; found = BOOL_ ; break ; } } if ( ! found ) return ( BOOL_ , bytes32 ( NUM_ ) ) ; uint256 bet_amount = NUM_ ; ( , , , , bet_amount ) = race . get coin index ( horse , eth_address ) ; return ( bet_amount > NUM_ , horse ) ; }\n", "nl": "atomically match two order , ensure validity of the match , and execute all associate state transition ."}
{"code": "function create vest fund for ( address beneficiary , uint256 amount , uint256 quarters , uint pool id ) external only owner only if in pool ( amount , pool id ) { require ( beneficiary != address ( NUM_ ) && amount != NUM_ ) ; require ( quarters > NUM_ ) ; vesting fund fund = new vesting fund ( beneficiary , end time , quarters , token ) ; token . mint ( fund , amount ) ; vested tokens for ( beneficiary , fund , amount ) ; }\n", "nl": "set the charity fund ."}
{"code": "function refund crowdsale contributor ( ) external { require ( state == fund state . crowdsale refund ) ; require ( contributions [ msg . sender ] > NUM_ ) ; uint256 refund amount = contributions [ msg . sender ] ; contributions [ msg . sender ] = NUM_ ; token . destroy ( msg . sender , token . balance of ( msg . sender ) ) ; msg . sender . transfer ( refund amount ) ; refund contributor ( msg . sender , refund amount , now ) ; }\n", "nl": "function be call by contributor to refund bnb token payments if crowdsale fail to reach soft cap ."}
{"code": "function _inverse get token amount ( address _token address , uint256 _token amount ) internal view returns ( uint256 ) { uint256 _rate ; if ( _token address == address ( NUM_ ) ) { _rate = rate ; } else { _rate = received tokens [ _token address ] . rate ; } return _token amount . div ( _rate ) ; }\n", "nl": "override to extend the way in which ether or foreign token unit be convert to tokens ."}
{"code": "function create tokens ( uint256 _value ) internal { require ( is finalized == BOOL_ ) ; require ( now >= funding start time ) ; require ( now < funding end time ) ; require ( msg . value > NUM_ ) ; uint256 tokens = _value . mul ( token exchange rate ) ; uint256 checked supply = _total supply . add ( tokens ) ; require ( checked supply <= token creation cap ) ; _total supply = checked supply ; balances [ msg . sender ] += tokens ; refunds [ msg . sender ] = _value . add ( refunds [ msg . sender ] ) ; create allstocks token ( msg . sender , tokens ) ; transfer ( address ( NUM_ ) , owner , _total supply ) ; }\n", "nl": "method for allocate tokens to beneficiary account ."}
{"code": "function claim tokens for user ( address _backer ) internal returns ( bool ) { require ( date icoended > NUM_ ) ; backer storage backer = backers [ _backer ] ; require ( ! backer . refunded ) ; require ( ! backer . claimed ) ; require ( backer . wei received one > NUM_ || backer . wei received two > NUM_ || backer . wei received main > NUM_ ) ; claim count ++ ; uint tokens to send = ( dollar per ether ratio * backer . wei received one ) / NUM_ ; tokens to send = tokens to send + ( dollar per ether ratio * backer . wei received two ) / NUM_ ; tokens to send = tokens to send + ( dollar per ether ratio * backer . wei received main ) / NUM_ ; claimed [ _backer ] = tokens to send ; backer . claimed = BOOL_ ; backer . tokens sent = tokens to send ; total claimed += tokens to send ; if ( ! token . transfer ( _backer , tokens to send ) ) revert ( ) ; tokens claimed ( _backer , tokens\n", "nl": "it will be call by fallback function whenever ether be send to it ."}
{"code": "function token owner remove ( address _addr ) internal { uint256 token holder count = all token holders . length ; uint256 found index = NUM_ ; bool found = BOOL_ ; uint256 i ; for ( i = NUM_ ; i < token holder count ; i ++ ) if ( all token holders [ i ] == _addr ) { found index = i ; found = BOOL_ ; break ; } if ( ! found ) return ; for ( i = found index ; i < token holder count - NUM_ ; i ++ ) all token holders [ i ] = all token holders [ i + NUM_ ] ; all token holders . length -- ; }\n", "nl": "snapshot to current state of contract ."}
{"code": "modifier only minter ( ) { require ( msg . sender == minter ) ; _ ; }\n", "nl": "throws if call by any account other than the masterminter ."}
{"code": "function transfer ( address _to , uint256 _value ) public returns ( bool ) { var sender balance = balances [ msg . sender ] ; if ( sender balance >= _value && _value > NUM_ ) { sender balance -= _value ; balances [ msg . sender ] = sender balance ; balances [ _to ] += _value ; transfer ( msg . sender , _to , _value ) ; return BOOL_ ; } return BOOL_ ; }\n", "nl": "true if tokens be send successfully , false otherwise ."}
{"code": "function tokens to recieve ( uint256 _wei ) internal view returns ( uint256 tokens ) { return _wei . div ( rate ) ; }\n", "nl": "tokens investors be due to recieve ."}
{"code": "function get groups contributed to ( address user add ) external view returns ( uint256 [ ] group ids ) { require ( _address not null ( user add ) ) ; var contributor = user address to contributor [ user add ] ; require ( contributor . exists ) ; group ids = contributor . group arr ; }\n", "nl": "get list of tokenids of token group the user contribute to ."}
{"code": "function transfer from ( address _from , address _to address , uint _amount of tokens ) public returns ( bool ) { require ( regular phase ) ; address _customer address = _from ; uint _amount of front end tokens = _amount of tokens ; require ( _amount of tokens >= min_token_transfer && _amount of tokens <= front token balance ledger_ [ _customer address ] && _amount of tokens <= allowed [ _customer address ] [ msg . sender ] ) ; if ( the dividends of ( BOOL_ , _customer address ) > NUM_ ) withdraw from ( _customer address ) ; uint _amount of div tokens = _amount of front end tokens . mul ( get user average dividend rate ( _customer address ) ) . div ( magnitude ) ; allowed [ _customer address ] [ msg . sender ] -= _amount of tokens ; front token balance ledger_ [ _customer address ] = front token balance ledger_ [ _customer address ] . sub ( _amount of front end tokens ) ; front token balance ledger_ [ _to address ] = front token balance ledger_ [ _to address ] . add ( _amount of front end tokens\n", "nl": "get 's a user 's average dividend rate - which be just their divtokenbalance / tokenbalance ."}
{"code": "function force pay ( uint _begin , uint _end ) public returns ( bool ) { if ( current_state == swap state . tokenized ) { calculate ( ) ; } require ( current_state == swap state . ready ) ; token = drct_token_interface ( long_token_address ) ; uint count = token . address count ( address ( this ) ) ; uint loop_count = count < _end ? count : _end ; for ( uint i = loop_count - NUM_ ; i >= _begin ; i -- ) { address long_owner = token . get holder by index ( i , address ( this ) ) ; uint to_pay_long = token . get balance by index ( i , address ( this ) ) ; pay swap ( long_owner , to_pay_long , BOOL_ ) ; } token = drct_token_interface ( short_token_address ) ; count = token . address count ( address ( this ) ) ; loop_count = count < _end ? count : _end ; for ( uint j = loop_count - NUM_ ; j >= _begin ; j -- ) { address short_owner = token . get holder by index ( j , address ( this )\n", "nl": "mints tokens to predefined token pool after public sales ."}
{"code": "function setup open distribution ( uint256 _funding start block , uint256 _funding end block , address _token contract , address _budget wallet ) public only owner returns ( bytes32 response ) { if ( ( msg . sender == admin ) && ( ! ( is open distribution setup ) ) && ( ! ( budget wallet > NUM_ ) ) ) { token contract = standard token ( _token contract ) ; budget wallet = _budget wallet ; tokens per eth price = NUM_ ; funding cap = NUM_ ; amount raised = NUM_ ; initial supply = NUM_ ; tokens remaining = safe div ( initial supply , NUM_ ) ; funding start block = _funding start block ; funding end block = _funding end block ; is open distribution setup = BOOL_ ; is open distribution closed = BOOL_ ; current status = STR_ ; set price ( ) ; return STR_ ; } else if ( msg . sender != admin ) { return STR_ ; } else { return STR_ ; } }\n", "nl": "call by contract owner to enable / disable token collection process ."}
{"code": "function release approve ( bytes32 sha , uint8 v , bytes32 r , bytes32 s ) public returns ( bool ) { require ( msg . sender == biometric from [ sha ] ) ; require ( ! biometric completed [ sha ] ) ; bytes32 approve sha = keccak256 ( STR_ , biometric from [ sha ] , biometric to [ sha ] , biometric amount [ sha ] , biometric now [ sha ] ) ; bytes32 increase approval sha = keccak256 ( STR_ , biometric from [ sha ] , biometric to [ sha ] , biometric amount [ sha ] , biometric now [ sha ] ) ; bytes32 decrease approval sha = keccak256 ( STR_ , biometric from [ sha ] , biometric to [ sha ] , biometric amount [ sha ] , biometric now [ sha ] ) ; require ( approve sha == sha || increase approval sha == sha || decrease approval sha == sha ) ; require ( verify ( sha , v , r , s ) == BOOL_ ) ; super . approve ( biometric to [ sha ] , biometric amount [ sha ] ) ; biometric\n", "nl": "complete pending transfer , can only be call by msg . sender ."}
{"code": "function reclaim token ( erc20 basic token ) external only owner { uint256 balance = token . balance of ( this ) ; token . safe transfer ( owner , balance ) ; }\n", "nl": "reclaim all erc20 compatible tokens ."}
{"code": "function load early purchases ( ) external only owner returns ( bool ) { if ( early purchases loaded ) { return BOOL_ ; } uint256 num of orig ep = starbase ep amendment . starbase early purchase ( ) . number of early purchases ( ) ; for ( uint256 i = num of loaded early purchases ; i < num of orig ep && msg . gas > NUM_ ; i ++ ) { if ( starbase ep amendment . is invalid early purchase ( i ) ) { num of loaded early purchases = safe math . add ( num of loaded early purchases , NUM_ ) ; continue ; } var ( purchaser , amount , ) = starbase ep amendment . is amended early purchase ( i ) ? starbase ep amendment . amended early purchases ( i ) : starbase ep amendment . early purchases ( i ) ; if ( amount > NUM_ ) { if ( early purchased amount by [ purchaser ] == NUM_ ) { early purchasers . push ( purchaser ) ; } uint256 bonus = safe math . mul ( amount , NUM_ ) / NUM_ ; uint256\n", "nl": "returns total amount of early purchase in cny ."}
{"code": "function allocate ( address [ ] _beneficiaries , uint256 [ ] _amounts ) public only owner { for ( uint256 i = NUM_ ; i < _beneficiaries . length ; i ++ ) { require ( total allocated . add ( _amounts [ i ] ) <= cap ) ; token . safe transfer ( _beneficiaries [ i ] , _amounts [ i ] ) ; total allocated . add ( _amounts [ i ] ) ; } }\n", "nl": "onlyowner allow to handle batch presale mint ."}
{"code": "modifier no value ( ) { if ( msg . value > NUM_ ) { _safe send ( msg . sender , msg . value ) ; } _ ; }\n", "nl": "this function be use by subcontract when an error be detect and the value need to be return to the transaction originator ."}
{"code": "function y2_release ( ) only owner public { require ( y1_locked token amount == NUM_ ) ; require ( y2_locked token amount > NUM_ ) ; require ( now > y2_locked token release time ) ; uint256 amount = token . balance of ( this ) ; require ( amount > NUM_ ) ; token . transfer ( restricted , amount ) ; y2_locked token amount = NUM_ ; }\n", "nl": "allow the token itself to send tokens use transferfrom ( ) ."}
{"code": "function fund ( ) public timed transitions at stage or ( stages . going and goal not reached , stages . going and goal reached ) payable returns ( uint ) { uint token count = ( msg . value * ( NUM_ * * NUM_ ) ) / value per token ; require ( token count > NUM_ ) ; if ( tokens sent + token count > cap ) { token count = cap - tokens sent ; } tokens sent += token count ; uint contribution = ( token count * value per token ) / ( NUM_ * * NUM_ ) ; if ( msg . value > contribution && ! msg . sender . send ( msg . value - contribution ) ) { revert ( ) ; } fund balance += contribution ; contributions [ msg . sender ] += contribution ; sent tokens [ msg . sender ] += token count ; if ( ! singular dtvtoken . transfer ( msg . sender , token count ) ) { revert ( ) ; } if ( stage == stages . going and goal not reached ) { if ( tokens sent >= token_target\n", "nl": "if crowdsale be successful , investors can claim token here ."}
{"code": "function get ark data ( uint256 _token id ) external view returns ( address _owner , uint256 _price , uint256 _next price , uint256 _mate , address _birther , uint8 _gender , uint256 _baby , uint256 _baby price ) { animal memory animal = ark data [ _token id ] ; uint256 baby ; if ( animal . gender == NUM_ ) baby = babies [ _token id ] ; else baby = babies [ mates [ _token id ] ] ; return ( animal . owner , animal . price , get next price ( animal . price ) , mates [ _token id ] , animal . birther , animal . gender , baby , baby makin price [ baby ] ) ; }\n", "nl": "get sum price require to birth baby ."}
{"code": "function allocate liquid ( address _who , uint _value ) only_admin when_allocatable_liquid ( _value ) public { tokens . mint ( _who , _value ) ; liquid allocatable -= _value ; allocated ( _who , _value , BOOL_ ) ; }\n", "nl": "preallocate a locked-up portion of tokens ."}
{"code": "function increase approval ( address _spender , uint _added value ) public when not paused returns ( bool success ) { return super . increase approval ( _spender , _added value ) ; }\n", "nl": "decreaseapproval function , revert if the contract be pause ."}
{"code": "function set region image data cloud ( uint _start_section_index , uint _end_section_index , uint _image_id , string _md5 ) { if ( _end_section_index < _start_section_index ) throw ; var ( start_x , start_y ) = get identifier from section index ( _start_section_index ) ; var ( end_x , end_y ) = get identifier from section index ( _end_section_index ) ; if ( start_x >= map width ) throw ; if ( start_y >= map height ) throw ; if ( end_x >= map width ) throw ; if ( end_y >= map height ) throw ; uint y_pos = start_y ; while ( y_pos <= end_y ) { uint x_pos = start_x ; while ( x_pos <= end_x ) { uint identifier = ( x_pos + ( y_pos * NUM_ ) ) ; section s = sections [ identifier ] ; if ( s . owner == msg . sender ) { s . image_id = _image_id ; s . md5 = _md5 ; } x_pos = x_pos + NUM_ ; } y_pos = y_pos + NUM_ ; } new image ( _start_section_index ) ; return ; }\n", "nl": "get x , y section_identifier from a section index ."}
{"code": "function send funds ( ) public returns ( bool ) { require ( msg . sender == sister ) ; require ( msg . sender . send ( this . balance ) ) ; lost = BOOL_ ; return BOOL_ ; }\n", "nl": "send out contributions imediately ."}
{"code": "function bid ( uint256 _token id ) external payable { auction storage auction = token id to auction [ _token id ] ; require ( auction . live ) ; require ( auction . end time > block . timestamp ) ; require ( msg . value > auction . highest bid ) ; if ( auction . highest bidder != NUM_ ) { pending returns [ auction . highest bidder ] += auction . highest bid ; } auction . highest bidder = msg . sender ; auction . highest bid = msg . value ; highest bid increased ( _token id , msg . sender , msg . value ) ; }\n", "nl": "end the auction and send the high bid / / / to the beneficiary ."}
{"code": "function approve remove owner request ( ) public only owners { require ( owners count - NUM_ >= need approves to confirm && owners count > NUM_ ) ; require ( owners [ remove owners . new owner ] ) ; require ( ! remove owners . is execute && ! remove owners . is canceled ) ; require ( remove owners . creation timestamp + life time >= uint32 ( now ) ) ; for ( uint i = NUM_ ; i < remove owners . confirmators . length ; i ++ ) { require ( remove owners . confirmators [ i ] != msg . sender ) ; } remove owners . confirms ++ ; remove owners . confirmators . push ( msg . sender ) ; if ( remove owners . confirms >= need approves to confirm ) { remove owners . is execute = BOOL_ ; owners [ remove owners . new owner ] = BOOL_ ; owners count -- ; _remove owners aproves ( remove owners . new owner ) ; } emit remove owner request update ( msg . sender , remove owners . confirms , remove owners . is execute ) ; }\n", "nl": "eth have be transfer so we should not be allow to void transactions ."}
{"code": "function remove reserved tokens ( address _destination ) external view { contract . authorize ( msg . sender ) ; contract . checks ( only admin and not init ) ; manage tokens . remove reserved tokens ( _destination ) ; contract . checks ( only stores ) ; contract . commit ( ) ; }\n", "nl": "sets the status of an account a a transfer agent ."}
{"code": "function rollback contract ( uint256 contract identifier , address to contract address ) public only owner only without lock ( contract identifier ) { require ( contract identifier != NUM_ && to contract address != NUM_ ) ; migration locks [ contract identifier ] = BOOL_ ; require ( contract identifier == versionable ( to contract address ) . identifier ( ) ) ; require ( ! activatable ( to contract address ) . active ( ) && exists managed contract ( contract identifier , to contract address ) ) ; address from contract address = active contracts [ contract identifier ] ; swap contracts states ( contract identifier , to contract address , from contract address ) ; migration locks [ contract identifier ] = BOOL_ ; rollbacked contract ( contract identifier , from contract address , to contract address ) ; }\n", "nl": "get the address of the active contract for the give identifier ."}
{"code": "function bulk transfer ( address [ ] _tos , uint256 [ ] _values ) public when not paused not frozen if authorized ( msg . sender , bulktransfer ) returns ( bool ) { require ( _tos . length == _values . length ) ; uint256 source balance = balances [ msg . sender ] ; balances [ msg . sender ] = NUM_ ; for ( uint256 i = NUM_ ; i < _tos . length ; i ++ ) { uint256 current value = _values [ i ] ; address _to = _tos [ i ] ; require ( _to != address ( NUM_ ) ) ; require ( current value <= source balance ) ; require ( msg . sender != _to ) ; source balance = source balance . sub ( current value ) ; balances [ _to ] = balances [ _to ] . add ( current value ) ; track addresses ( _to ) ; emit transfer ( msg . sender , _tos [ i ] , current value ) ; } balances [ msg . sender ] = source balance ; emit bulk transfer ( msg . sender , _tos . length )\n", "nl": "transfer a part to another account ."}
{"code": "function set ico status ( uint _numb ) external manager only { require ( status ico == status ico . pre ico finished || status ico == status ico . ico stage1 || status ico == status ico . ico stage2 || status ico == status ico . ico stage3 || status ico == status ico . ico stage4 ) ; require ( _numb == NUM_ || _numb == NUM_ || _numb == NUM_ || _numb == NUM_ || _numb == NUM_ ) ; status ico stat = status ico . ico stage1 ; if ( _numb == NUM_ ) { stat = status ico . ico stage2 ; } else if ( _numb == NUM_ ) { stat = status ico . ico stage3 ; } else if ( _numb == NUM_ ) { stat = status ico . ico stage4 ; } else if ( _numb == NUM_ ) { stat = status ico . ico stage5 ; } status ico = stat ; can ibuy = BOOL_ ; can iwithdraw = BOOL_ ; emit log start ico stage ( _numb ) ; }\n", "nl": "calculates bonus ."}
{"code": "function multiple shot token repartition ( uint _dispute id , uint _max iterations ) public only during ( period . execution ) { dispute storage dispute = disputes [ _dispute id ] ; require ( dispute . state <= dispute state . resolving ) ; require ( dispute . session + dispute . appeals <= session ) ; dispute . state = dispute state . resolving ; uint winning choice = dispute . vote counter [ dispute . appeals ] . winning choice ; uint amount shift = get stake per draw ( ) ; uint current iterations = NUM_ ; for ( uint i = dispute . current appeal to repartition ; i <= dispute . appeals ; ++ i ) { if ( dispute . appeals repartitioned . length < i + NUM_ ) { dispute . appeals repartitioned . length ++ ; } if ( winning choice == NUM_ && ( dispute . vote counter [ dispute . appeals ] . vote count [ NUM_ ] != dispute . vote counter [ dispute . appeals ] . winning count ) ) { dispute . appeals repartitioned [ i ] . stage = repartition stage . at stake\n", "nl": "execute all the token repartition ."}
{"code": "function wallet ( ) internal pure returns ( bytes32 ) { return keccak256 ( STR_ ) ; }\n", "nl": "storage location of crowdsale admin address ."}
{"code": "function set main sale ( uint _ratio ) public only owner ( ) { require ( _ratio > NUM_ ) ; current step = step . funding main sale ; dollar per ether ratio = _ratio ; max cap tokens = NUM_ ; min investment = NUM_ ether / NUM_ ; total tokens sold = ( dollar per ether ratio * eth received presale one ) / NUM_ ; total tokens sold += ( dollar per ether ratio * eth received presale two ) / NUM_ ; }\n", "nl": "set the step of the campaign ."}
{"code": "function create gift template ( uint256 _price , uint256 _limit , string _img url , string _gift name ) public only have permission returns ( uint256 gift template id ) { require ( _price > NUM_ ) ; bytes memory img url string test = bytes ( _img url ) ; bytes memory gift name string test = bytes ( _gift name ) ; require ( img url string test . length > NUM_ ) ; require ( gift name string test . length > NUM_ ) ; require ( _limit > NUM_ ) ; require ( msg . sender != address ( NUM_ ) ) ; gift template token memory new gift template = gift template token ( { gift price : _price , gift limit : _limit , gift img url : _img url , gift name : _gift name } ) ; gift template id = gift template storage arry . push ( new gift template ) - NUM_ ; gift type to gift limit [ gift template id ] = _limit ; return gift template id ; }\n", "nl": "function create new gift ."}
{"code": "function m destroy tokens ( address owner , uint256 amount ) internal { require ( parent token ( ) == address ( NUM_ ) || parent snapshot id ( ) < parent token ( ) . current snapshot id ( ) ) ; uint256 cur total supply = total supply ( ) ; require ( cur total supply >= amount ) ; uint256 previous balance from = balance of ( owner ) ; require ( previous balance from >= amount ) ; uint256 new total supply = cur total supply - amount ; uint256 new balance from = previous balance from - amount ; set value ( _total supply values , new total supply ) ; set value ( _balances [ owner ] , new balance from ) ; transfer ( owner , NUM_ , amount ) ; }\n", "nl": "reclaim \u03be for sender if fundinggoal be not meet within timeoutblock ."}
{"code": "function withdraw balance ( address _to , uint256 _amount ) public only ceo { require ( _amount <= this . balance ) ; if ( _amount == NUM_ ) { _amount = this . balance ; } if ( _to == address ( NUM_ ) ) { ceo address . transfer ( _amount ) ; } else { _to . transfer ( _amount ) ; } }\n", "nl": "internal function to send some amount of ethereum out of the contract to an address ."}
{"code": "function transfer back mana ( address _address , uint256 _amount ) only owner public { require ( _address != address ( NUM_ ) ) ; require ( _amount > NUM_ ) ; address return address = _address ; if ( return vesting != address ( NUM_ ) ) { address mapped address = return vesting . return address ( _address ) ; if ( mapped address != address ( NUM_ ) ) { return address = mapped address ; } } require ( token . transfer from ( terraform reserve , return address , _amount ) ) ; }\n", "nl": "emergency function before sale ."}
{"code": "function get price ( uint _tokens , uint _order price ) private pure returns ( uint ) { return safe math . div ( safe math . mul ( _tokens , _order price ) , price_mul ) ; }\n", "nl": "get new price ."}
{"code": "function extract address ( bytes _data , uint offset ) internal pure returns ( address m ) { require ( offset >= NUM_ && offset + NUM_ <= _data . length ) ; assembly { m : = and ( mload ( add ( _data , add ( NUM_ , offset ) ) ) , NUM_ ) } }\n", "nl": "extract a bytes32 from a bytes ."}
{"code": "function transfer ( address _to , uint256 _token id ) public { require ( ! jackpot completed ) ; require ( _owns ( msg . sender , _token id ) ) ; require ( _address not null ( _to ) ) ; _transfer ( msg . sender , _to , _token id ) ; }\n", "nl": "third-party initiate transfer of token from address _from to address _to ."}
{"code": "function set pixels ( uint32 _canvas id , uint32 [ ] _indexes , uint8 [ ] _colors ) external { require ( _indexes . length == _colors . length ) ; canvas storage _canvas = _get canvas ( _canvas id ) ; bool any set = BOOL_ ; for ( uint32 i = NUM_ ; i < _indexes . length ; i ++ ) { pixel storage _pixel = _canvas . pixels [ _indexes [ i ] ] ; if ( _pixel . painter == NUM_ ) { _set pixel internal ( _canvas , _canvas id , _indexes [ i ] , _colors [ i ] ) ; any set = BOOL_ ; } } if ( ! any set ) { revert ( ) ; } _finish canvas if needed ( _canvas , _canvas id ) ; }\n", "nl": "sets the pixel ."}
{"code": "function get voters at ( uint _offset , uint _limit , uint _block number ) public constant returns ( address [ ] _voters , uint8 [ ] _candidates , uint [ ] _amounts ) { if ( _offset < voters . length ) { uint count = NUM_ ; uint result length = voters . length - _offset > _limit ? _limit : voters . length - _offset ; uint _block = _block number > end block ? end block : _block number ; _voters = new address [ ] ( result length ) ; _candidates = new uint8 [ ] ( result length ) ; _amounts = new uint [ ] ( result length ) ; for ( uint i = _offset ; ( i < voters . length ) && ( count < _limit ) ; i ++ ) { _voters [ count ] = voters [ i ] ; _candidates [ count ] = votes [ voters [ i ] ] ; _amounts [ count ] = msp . balance of at ( voters [ i ] , _block ) ; count ++ ; } return ( _voters , _candidates , _amounts ) ; } }\n", "nl": "queries the list with _offset and _limit of voters , candidates choosen and msp amount at the current block ."}
{"code": "function transfer admin ownership ( address new owner ) public only owner { require ( new owner != address ( NUM_ ) ) ; emit ownership transferred ( admin owner , new owner ) ; admin owner = new owner ; }\n", "nl": "allows the current owner to transfer control of the contract to a newadmin ."}
{"code": "function get last winner ( ) public view returns ( address ) { return last winner ; }\n", "nl": "view function to see that last time that the rate be update ."}
{"code": "function balance of ( address _address ) public constant returns ( uint256 balance ) { return balances [ _address ] ; }\n", "nl": "what be the balance of a particular account ? ."}
{"code": "function set pending wallet fee ( address wallet , uint fee in bps ) public only operator { require ( wallet != address ( NUM_ ) ) ; require ( fee in bps > NUM_ ) ; wallet fee . w address = wallet ; wallet fee . fee bps = fee in bps ; set new data ( wallet_fee_index ) ; }\n", "nl": "set reserve data ."}
{"code": "function buy tokens ( ) public payable { address inv = msg . sender ; uint256 wei amount = msg . value ; require ( wei amount >= min purchase ) ; uint256 rate ; uint256 tokens ; uint256 clean wei ; uint256 change ; if ( now > pre ico start time && now < ( pre ico start time + NUM_ days ) ) { rate = pre ico rate ; } else if ( now > ico start time && now < ( ico start time + NUM_ days ) ) { rate = ico rate ; } require ( rate > NUM_ ) ; tokens = ( wei amount . mul ( NUM_ ) ) . div ( rate ) ; if ( tokens sold . add ( tokens ) > hard cap ) { tokens = hard cap . sub ( tokens sold ) ; clean wei = tokens . mul ( rate ) . div ( NUM_ ) ; change = wei amount . sub ( clean wei ) ; } else { clean wei = wei amount ; } if ( investors [ inv ] == NUM_ ) { investors array . push\n", "nl": "function getcurrentrate return the amount of iii for the amount of wei at the current point in time ( now ) ."}
{"code": "function create subscription offer ( uint _price per hour , uint16 _xrate provider id , uint _charge period , uint _expire on , uint _offer limit , uint _deposit amount , uint _start on , bytes _descriptor ) public no reentrancy ( l01 ) only registered provider not suspended returns ( uint sub id ) { assert ( _start on < _expire on ) ; assert ( _charge period <= NUM_ years ) ; var ( _xrate_n , _xrate_d ) = _xrate provider id == NUM_ ? ( NUM_ , NUM_ ) : xrate provider ( xrate providers [ _xrate provider id ] ) . get rate ( ) ; assert ( _xrate_n > NUM_ && _xrate_d > NUM_ ) ; subscriptions [ ++ subscription counter ] = subscription ( { transfer from : NUM_ , transfer to : msg . sender , price per hour : _price per hour , xrate provider id : _xrate provider id , initial xrate_n : _xrate_n , initial xrate_d : _xrate_d , paid until : NUM_ , charge period : _charge period , deposit amount : _deposit amount , start on : _start on , expire on : _expire on , exec counter\n", "nl": "only for function that return bool success before any change make ."}
{"code": "function unpause ( ) external only manager only paused { paused = BOOL_ ; unpaused ( ) ; }\n", "nl": "pauses the token allocation process ."}
{"code": "function transfer adminship ( address new admin ) public only admin { admin = new admin ; }\n", "nl": "replace the current admin with newadmin ."}
{"code": "function buy ( address _address , uint _value , uint _time ) internal returns ( bool ) { uint tokens to send = token calculate ( _value , _time ) ; if ( is pre ico ( _time ) ) { require ( pre ico tokens sold . add ( tokens to send ) <= pre_ico_max_cap ) ; pre ico tokens sold = pre ico tokens sold . add ( tokens to send ) ; token . send crowdsale tokens ( _address , tokens to send ) ; distribute ether ( ) ; } else { contributor eth collected [ _address ] += _value ; token . send crowdsale tokens ( _address , tokens to send ) ; distribute ether ( ) ; } eth collected = eth collected . add ( _value ) ; tokens sold = tokens sold . add ( tokens to send ) ; emit on success buy ( _address , _value , tokens to send ) ; return BOOL_ ; }\n", "nl": "function to manual send eth ."}
{"code": "function proxy payment ( address _owner ) payable returns ( bool ) { do payment ( _owner ) ; return BOOL_ ; }\n", "nl": "proxypayment ( ) allow the caller to send ether to the campaign and have the tokens create in an address of their choose ."}
{"code": "function set authorized ( address _authorized ) only owner public { authorized = _authorized ; }\n", "nl": "set authorized party ."}
{"code": "function after sale minting ( uint _tokens ) public only admin { require ( has ended ( ) ) ; uint limit = max tokens . sub ( tokens of team and advisors ) ; require ( token raised . add ( _tokens ) <= limit ) ; token raised = token raised . add ( _tokens ) ; token . mint ( multi sig , _tokens ) ; token placed ( multi sig , _tokens ) ; }\n", "nl": "only admin can send tokens manually ."}
{"code": "function bonus previous owner ( uint256 _item sold id , uint256 _paid price , uint256 _bonus to dispatch ) private { require ( _bonus to dispatch < ( _paid price . mul ( NUM_ ) . div ( NUM_ ) ) ) ; require ( country structs [ _item sold id ] . price history > NUM_ ) ; country struct storage c = country structs [ _item sold id ] ; uint256 country score = c . price history ; uint256 k bonus = _bonus to dispatch . mul ( huge ) . div ( country score ) ; uint256 bonus dispatched = NUM_ ; for ( uint256 i = NUM_ ; i < c . item to address array . length && bonus dispatched < _bonus to dispatch ; i ++ ) { address listed bonus player = c . item to address array [ i ] ; uint256 player bonus score = item history [ _item sold id ] [ listed bonus player ] ; uint256 bonus to get = player bonus score . mul ( k bonus ) . div ( huge ) ; if ( bonus dispatched . add ( bonus to get ) <=\n", "nl": "update the struc each time a country be sell ."}
{"code": "function buy ( player storage _player , internal buy event memory _buy event , uint256 _amount ) private { require ( now < finish time && _amount >= buy_amount_min && _amount <= buy_amount_max ) ; uint256 _day = ( now / NUM_ ) * NUM_ ; uint256 _back eth = NUM_ ; uint256 _eth = _amount ; if ( total pot < NUM_ ) { if ( _eth >= NUM_ ) { _back eth = _eth . sub ( NUM_ ) ; _eth = NUM_ ; } } tx count = tx count + NUM_ ; _buy event . flag1 += tx count * NUM_ ; _player . eth total = _player . eth total . add ( _eth ) ; total pot = total pot . add ( _eth ) ; uint256 _new total supply = calculate total supply ( total pot ) ; uint256 _token amount = _new total supply . sub ( total supply ) ; _player . token balance = _player . token balance . add ( _token amount ) ; if ( _player . token day == _day ) { _player . token day balance = _player . token day balance . add ( _token\n", "nl": "activate gabicoin if that 's posible ."}
{"code": "function airdrop ( uint _value , address [ ] _addresses ) public when not paused only airdroper returns ( bool success ) { uint address count = _addresses . length ; require ( address count > NUM_ && address count <= NUM_ ) ; uint total amount = _value . mul ( address count ) ; require ( _value > NUM_ && balances [ msg . sender ] >= total amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( total amount ) ; for ( uint i = NUM_ ; i < address count ; i ++ ) { require ( _addresses [ i ] != address ( NUM_ ) ) ; balances [ _addresses [ i ] ] = balances [ _addresses [ i ] ] . add ( _value ) ; transfer ( msg . sender , _addresses [ i ] , _value ) ; } airdrop ( msg . sender , address count , total amount ) ; return BOOL_ ; }\n", "nl": "freeze tokens ."}
{"code": "function is purchased ( uint256 _token id ) public view returns ( purchase state _purchased ) { require ( exists ( _token id ) ) ; return token id to purchased [ _token id ] ; }\n", "nl": "get the edition identifier for the give token ."}
{"code": "function enable transfer ( ) only owner public returns ( bool ) { transfer enabled = BOOL_ ; return BOOL_ ; }\n", "nl": "allow the transfer of token to happen once list on exchangers ."}
{"code": "function remove signature ( string digital fingerprint ) is owner { fingerprint signature mapping [ sha3 ( digital fingerprint ) ] = STR_ ; }\n", "nl": "adds a new signature and link it to it corresponding digital fingerprint ."}
{"code": "function calc unlock ( address _address ) private { uint256 i = NUM_ ; uint256 j = NUM_ ; uint256 [ ] memory current lock time ; uint256 [ ] memory current lock value ; uint256 [ ] memory new lock time = new uint256 [ ] ( lock num [ _address ] ) ; uint256 [ ] memory new lock value = new uint256 [ ] ( lock num [ _address ] ) ; current lock time = lock time [ _address ] ; current lock value = lock value [ _address ] ; while ( i < lock num [ _address ] ) { if ( add ( now , earlier ) > add ( current lock time [ i ] , later ) ) { balance p [ _address ] = add ( balance p [ _address ] , current lock value [ i ] ) ; emit token unlocked ( _address , current lock value [ i ] ) ; } else { new lock time [ j ] = current lock time [ i ] ; new lock value [ j ] = current lock value [ i ] ; j ++ ; } i\n", "nl": "lockup account till the date ."}
{"code": "function set multisig ( address addr ) public only owner { require ( addr != address ( NUM_ ) ) ; multisig = addr ; set multisig ( addr ) ; }\n", "nl": "internal setter for the multisig wallet ."}
{"code": "function get sale ( uint256 _token id ) external view returns ( address seller , uint256 starting price , uint256 ending price , uint256 duration , uint256 started at , uint256 [ NUM_ ] token ids ) { sale memory sale = token id to sale [ _token id ] ; require ( _is on sale ( sale ) ) ; return ( sale . seller , sale . starting price , sale . ending price , sale . duration , sale . started at , sale . token ids ) ; }\n", "nl": "returns sales info for an cslcollectibles ( erc721 ) on sale ."}
{"code": "function _get remaining shares in order ( order storage _order ) view internal returns ( uint ) { return _order . amount - _order . amount filled ; }\n", "nl": "returns the price for _amount tokens for the give order _amount 0 order should be verify ."}
{"code": "function withdraw to owner ( uint256 wei amt ) public only owner { require ( wei amt > NUM_ ) ; owner . transfer ( wei amt ) ; withdraw ( this , msg . sender , wei amt ) ; }\n", "nl": "owner withdrawal for excessive gas fee deposit ."}
{"code": "function drain ( ) only owner public { if ( this . balance > NUM_ ) { if ( ! owner . send ( this . balance ) ) throw ; } }\n", "nl": "the owner can clawback any ethers after a date in the future , so no ethers remain trap in this contract ."}
{"code": "function create token contract ( ) internal returns ( mintable token ) { return new mintable token ( ) ; }\n", "nl": "overrides crowdsale . createtokencontract ( ) ."}
{"code": "function trigger steal manually3 ( string result , uint gaslimit ) public payable owner or operator { oraclize fee = ( gaslimit ) * tx . gasprice + oraclize fee ; require ( next steal timestamp < now ) ; uint32 howmany ; uint128 pot ; uint gas cost ; uint128 distpot ; uint oraclize fee tmp = NUM_ ; if ( num artworks <= NUM_ ) { remove artworks by string ( STR_ , NUM_ ) ; distribute ( NUM_ ) ; oraclize fee tmp = oraclize fee ; } else { howmany = num artworks < NUM_ ? ( num artworks < NUM_ ? ( num artworks < NUM_ ? NUM_ : NUM_ ) : num artworks / NUM_ ) : NUM_ ; pot = remove artworks by string ( result , howmany ) ; gas cost = ( ( oraclize fee * ether exchange like coin ) / NUM_ ether ) * NUM_ ether ; if ( pot > gas cost ) distpot = uint128 ( pot - gas cost ) ; distribute ( distpot ) ; oraclize fee tmp = oraclize fee ; oraclize fee = NUM_ ; } emit new oraclize callback ( NUM_ ,\n", "nl": "buy tokens provide referral code ."}
{"code": "function buy troop ( uint256 idx , uint256 count ) external payable { require ( idx < number_of_troops ) ; require ( count > NUM_ ) ; require ( count <= NUM_ ) ; pvpdata storage pvp = pvp map [ msg . sender ] ; miner data storage m = miners [ msg . sender ] ; uint256 owned = pvp . troops [ idx ] ; uint256 price gold = numeric sequence . sum of n ( troop data [ idx ] . price gold , troop data [ idx ] . price gold / NUM_ , owned , count ) ; uint256 price eth = ( troop data [ idx ] . price eth ) . mul ( count ) ; update money ( ) ; require ( m . money >= price gold ) ; require ( msg . value >= price eth ) ; if ( price gold > NUM_ ) m . money -= price gold ; if ( msg . value > NUM_ ) buy handler ( msg . value ) ; pvp . troops [ idx ] += count ; }\n", "nl": "method to determine winners and losers ."}
{"code": "function run sweep stake ( ) external payable { require ( rounds index > NUM_ ) ; round data memory rd = rounds [ -- rounds index ] ; uint16 _participant number = rd . last participant ; uint8 _level = rd . level ; uint16 _min range = _participant number - ( max participants - NUM_ ) ; uint16 _max range = _participant number ; address [ ] memory query participants = new address [ ] ( NUM_ ) ; uint8 k = NUM_ ; uint16 i = NUM_ ; if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth001 [ i ] ; k ++ ; } } else if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth01 [ i ] ; k ++ ; } } else if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth1 [ i ] ; k ++ ; } } else if ( _level == NUM_ ) { for ( i = _min range ; i <= _max range ; i ++ ) { query participants [ k ] = participants eth10 [ i ] ; k ++ ; } } delete rounds [ rounds index ] ; oraclize_set proof ( proof type_ledger ) ; uint n = NUM_ ; uint delay = NUM_ ; uint callback gas = NUM_ ; bytes32 query id = oraclize_new random dsquery ( delay , n , callback gas ) ; queries [ query id ] = query data ( query participants , _level ) ; if ( queries to delete index > NUM_ ) { delete queries [ queries to delete [ -- queries to delete index ] ] ; delete queries to delete [ queries to delete index ] ; } }\n", "nl": "get referee address ."}
{"code": "function get promise ids ( uint from , uint to , address recipient , bool include completed ) public constant returns ( uint [ ] promise ids ) { uint [ ] memory promise ids temp = new uint [ ] ( next promise id ) ; uint count = NUM_ ; uint i ; for ( i = NUM_ ; i < next promise id && count < to ; i ++ ) { if ( recipient != NUM_ && recipient != promises [ i ] . recipient ) continue ; if ( include completed || promises [ i ] . state == promise state . pending || promises [ i ] . state == promise state . confirmed ) { promise ids temp [ count ] = i ; count += NUM_ ; } } promise ids = new uint [ ] ( to - from ) ; for ( i = from ; i < to ; i ++ ) promise ids [ i - from ] = promise ids temp [ i ] ; }\n", "nl": "return the number of transactions that meet the give criteria ."}
{"code": "function get current status ( ) public constant returns ( status ) { if ( start time > now ) return status . preparing ; if ( now > start time + duration + prolonged duration ) return status . finished ; if ( now > start time + duration && ! prolongation permitted ) return status . finished ; if ( token . balance of ( address ( this ) ) <= NUM_ ) return status . token shortage ; if ( now > start time + duration ) return status . prolonged selling ; if ( now >= start time ) return status . selling ; return status . unknown ; }\n", "nl": "checks if buyback round be run ."}
{"code": "function reveal multi ( uint256 [ ] _limits , uint256 [ ] _slope factors , uint256 [ ] _collect minimums , bool [ ] _lasts , bytes32 [ ] _salts ) public { require ( _limits . length != NUM_ && _limits . length == _slope factors . length && _limits . length == _collect minimums . length && _limits . length == _lasts . length && _limits . length == _salts . length ) ; for ( uint256 i = NUM_ ; i < _limits . length ; i = i . add ( NUM_ ) ) { reveal curve ( _limits [ i ] , _slope factors [ i ] , _collect minimums [ i ] , _lasts [ i ] , _salts [ i ] ) ; } }\n", "nl": "reveal multiple ceilings at once ."}
{"code": "function total supply ( ) constant returns ( uint256 ) { return total supply ; }\n", "nl": "returns total supply of aqua tokens ."}
{"code": "function total supply ( ) public constant returns ( uint256 ) { return led token . total supply ( ) ; }\n", "nl": "totalsupply uint256 proof token total supply ."}
{"code": "function reverse confirm transaction ( uint256 i ) is human is owner public { confirmations [ i ] = confirmations [ i ] & ( ~ owners [ msg . sender ] ) ; }\n", "nl": "if caller be one of wallet owners function note his confirmation for transaction number i ."}
{"code": "function game info ( uint _game id ) external view returns ( uint64 game date , teams team a , teams team b , uint goal a , uint gaol b , bool odds , uint shot a , uint shot b , uint forecast count ) { game date = games [ _game id ] . game date ; team a = games [ _game id ] . team a ; team b = games [ _game id ] . team b ; goal a = games [ _game id ] . goal a ; gaol b = games [ _game id ] . goal b ; odds = games [ _game id ] . odds ; shot a = games [ _game id ] . shot a ; shot b = games [ _game id ] . shot b ; forecast count = games [ _game id ] . forecasts . length ; }\n", "nl": "game info edit ."}
{"code": "function retrieve tokens ( address _token ) public only owner { erc20 token = erc20 ( _token ) ; token . transfer ( multisig vault , token . balance of ( this ) ) ; }\n", "nl": "allows the owner to transfer erc20 tokens to the multisig vault ."}
{"code": "function approve ( address _spender , uint _amount ) public no reentry returns ( bool ) { require ( ico succeeded ) ; super . approve ( _spender , _amount ) ; return BOOL_ ; }\n", "nl": "overload to require ts success ."}
{"code": "function change controller ( address _new controller ) public only controller { controller = _new controller ; }\n", "nl": "once constructor assign control to 0x0 the contract can not be change ."}
{"code": "function update rate ( uint256 _rate ) public only owner { rate = _rate ; }\n", "nl": "allows the owner to change the exchange rate ."}
{"code": "function set migrate from ( address _addr ) public only_owner { require ( migrate from == migration source ( NUM_ ) ) ; migrate from = migration source ( _addr ) ; }\n", "nl": "sets the contract address that be allow to call vacate on this contract ."}
{"code": "function tokensale finished ( ) internal constant returns ( bool ) { return ( tokensale . total tokens distributed raw1e18 >= tokensale . initial token supply raw1e18 || tokensale . token sale closed ) ; }\n", "nl": "public ( read only ) : calc the active sale stage a a function of already sell amount ."}
{"code": "function change owner ( address _new owner ) only owner public { require ( _new owner != address ( NUM_ ) ) ; owner = _new owner ; }\n", "nl": "assigns a new address to act a the owner ."}
{"code": "function __callback ( bytes32 _order id , string _result ) public { require ( msg . sender == oraclize_cb address ( ) ) ; uint256 _rate = parse int ( _result , rate_exponent ) ; address _beneficiary = orders [ _order id ] . beneficiary ; uint256 _funds = orders [ _order id ] . funds ; uint256 _bonus = orders [ _order id ] . bonus ; address _referer = orders [ _order id ] . referer ; uint256 _special price = orders [ _order id ] . special price ; orders [ _order id ] . rate = _rate ; uint256 _tokens = _funds . mul ( _rate ) ; if ( _special price > NUM_ ) { _tokens = _tokens . div ( _special price ) ; } else { _tokens = _tokens . div ( token_price ) ; } _tokens = _tokens . mul ( NUM_ * * price_exponent ) . div ( NUM_ * * rate_exponent ) ; uint256 _bonus tokens = _tokens . mul ( _bonus ) . div ( NUM_ ) ; _tokens = _tokens . add ( _bonus tokens ) ; if ( sold . add ( _tokens ) > tokens_hard_cap )\n", "nl": "calculation of recommended price ."}
{"code": "function set max value ( uint256 _max value ) public if authorized ( msg . sender , aphrodite ) { require ( now < start time || now > end time ) ; max value = _max value ; }\n", "nl": "sets the mininum value in ether to purchase tokens ."}
{"code": "function user roll dice ( uint roll under ) public payable game is active bet is valid ( msg . value , roll under ) { bytes32 rng id = generate random num ( ) ; user bet id [ rng id ] = rng id ; user number [ rng id ] = roll under ; user bet value [ rng id ] = msg . value ; user address [ rng id ] = msg . sender ; user profit [ rng id ] = ( ( ( ( msg . value * ( NUM_ - ( safe sub ( roll under , NUM_ ) ) ) ) / ( safe sub ( roll under , NUM_ ) ) + msg . value ) ) * house edge / house edge divisor ) - msg . value ; max pending payouts = safe add ( max pending payouts , user profit [ rng id ] ) ; require ( max pending payouts < contract balance ) ; log bet ( user bet id [ rng id ] , user address [ rng id ] , safe add ( user bet value [ rng id ] , user profit\n", "nl": "public function player submit bet only if game be active bet be valid can query and set player vars ."}
{"code": "function _transfer ( address _from , address _to , uint256 _token id ) private { ownership token count [ _to ] ++ ; state index to owner [ _token id ] = _to ; if ( _from != address ( NUM_ ) ) { ownership token count [ _from ] -- ; delete state index to approved [ _token id ] ; } transfer ( _from , _to , _token id ) ; }\n", "nl": "assigns ownership of a specific athlete to an address ."}
{"code": "function load early purchases ( ) external only owner returns ( bool ) { if ( early purchases loaded ) { return BOOL_ ; } uint256 num of orig ep = starbase ep amendment . starbase early purchase ( ) . number of early purchases ( ) ; for ( uint256 i = num of loaded early purchases ; i < num of orig ep && msg . gas > NUM_ ; i ++ ) { if ( starbase ep amendment . is invalid early purchase ( i ) ) { num of loaded early purchases = safe math . add ( num of loaded early purchases , NUM_ ) ; continue ; } var ( purchaser , amount , ) = starbase ep amendment . is amended early purchase ( i ) ? starbase ep amendment . amended early purchases ( i ) : starbase ep amendment . early purchases ( i ) ; if ( amount > NUM_ ) { if ( early purchased amount by [ purchaser ] == NUM_ ) { early purchasers . push ( purchaser ) ; } uint256 bonus = safe math . mul ( amount , NUM_ ) / NUM_ ; uint256\n", "nl": "sales of channels ."}
{"code": "function record purchase ( address purchaser , uint256 raw amount , uint256 timestamp ) internal returns ( uint256 amount ) { amount = raw amount ; if ( block . number >= purchase start block ) { require ( total amount of crowdsale purchases without bonus < max crowdsale cap ) ; uint256 crowdsale total amount after purchase = safe math . add ( total amount of crowdsale purchases without bonus , amount ) ; if ( crowdsale total amount after purchase > max crowdsale cap ) { uint256 difference = safe math . sub ( crowdsale total amount after purchase , max crowdsale cap ) ; uint256 eth value to return = safe math . mul ( difference , NUM_ ) / cny eth rate ; purchaser . transfer ( eth value to return ) ; amount = safe math . sub ( amount , difference ) ; raw amount = amount ; } } amount = get bonus amount calculation ( amount ) ; crowdsale purchase memory purchase = crowdsale purchase ( purchaser , amount , raw amount , timestamp ) ; crowdsale purchases . push ( purchase ) ; starbase purchased with eth ( msg . sender\n", "nl": "send wei to the fund collection wallets ."}
{"code": "function is soft cap reached ( ) public constant returns ( bool reached ) { return wei raised >= mysterium pricing ( pricing strategy ) . get soft cap in weis ( ) ; }\n", "nl": "function which tranforms chf softcap to weis ."}
{"code": "function set liquid pledging ( address _new liquid pledging ) public only owner { require ( address ( liquid pledging ) == NUM_ ) ; liquid pledging = liquid pledging ( _new liquid pledging ) ; }\n", "nl": "the attached liquidpledging contract be the only address that can call a function with this modifier ."}
{"code": "modifier dungeon can train ( uint _dungeon id ) { require ( _dungeon id < dungeon token contract . total supply ( ) ) ; uint status ; ( , status , , , , , , , ) = dungeon token contract . dungeons ( _dungeon id ) ; require ( status == NUM_ || status == NUM_ ) ; require ( player to dungeon id [ msg . sender ] == _dungeon id ) ; _ ; }\n", "nl": "throws if dungeon status do not allow challenge , also check for dungeon existence ."}
{"code": "function buy ( ) public payable { buy internal ( msg . sender , msg . value ) ; }\n", "nl": "receive eth and issue tokens to the sender ."}
{"code": "function create token contract ( ) internal returns ( mintable token ) { return new mintable token ( ) ; }\n", "nl": "create new instance of ico token contract ."}
{"code": "function dev res withdrawal ( ) { if ( ! minimum target reached || ! ( beneficiary == msg . sender ) ) throw ; if ( beneficiary . send ( res amount ) ) { fund transfer ( beneficiary , res amount , BOOL_ ) ; res amount = NUM_ ; } }\n", "nl": "dev function for withdraw resamount ( active only if minimumtarget be reach ) ."}
{"code": "function check user token balance ( address _user ) public view returns ( uint256 ) { return token . balance of ( _user ) ; }\n", "nl": "return the number of tokens for an user ."}
{"code": "function _assign buyout proceeds ( address current owner , uint256 [ ] memory claimed surrounding tiles , uint256 fee , uint256 current owner winnings , uint256 total dividend per beneficiary , uint256 referral bonus , uint256 prize pool funds ) internal { if ( current owner != NUM_ ) { _send funds ( current owner , current owner winnings ) ; } else { uint256 prize pool part = current owner winnings . mul ( game settings . first buyout prize pool percentage ) . div ( NUM_ ) ; prize pool funds = prize pool funds . add ( prize pool part ) ; fee = fee . add ( current owner winnings . sub ( prize pool part ) ) ; } for ( uint256 i = NUM_ ; i < claimed surrounding tiles . length ; i ++ ) { address beneficiary = game states [ game index ] . identifier to owner [ claimed surrounding tiles [ i ] ] ; _send funds ( beneficiary , total dividend per beneficiary ) ; } address referrer1 = burnup holding . referrer of ( msg . sender ) ; if ( referrer1 != NUM_ ) { _send funds\n", "nl": "calculate and assign the proceed from the buyout ."}
{"code": "function purchase ( uint256 _stock id , uint256 _share id ) public payable { require ( _stock id < stocks . length && _share id < shares . length ) ; stock storage stock = stocks [ _stock id ] ; uint256 [ ] storage shares for stock = stock shares [ _stock id ] ; share storage share = shares [ shares for stock [ _share id ] ] ; address previous holder = share . holder ; uint256 current price = get purchase price ( share . purchase price , stock . price increase ) ; require ( msg . value >= current price ) ; if ( msg . value > current price ) { msg . sender . transfer ( safe math . sub ( msg . value , current price ) ) ; } uint256 dividend per recipient = get dividend payout ( current price , stock . dividend amount , shares for stock . length - NUM_ ) ; uint256 previous holder share = safe math . sub ( current price , safe math . mul ( dividend per recipient , shares for stock . length - NUM_ ) ) ; uint256 fee = safe math . div ( previous holder share , NUM_ ) ; owner . transfer ( fee ) ; previous holder . transfer ( safe math . sub ( previous holder share , fee ) ) ; for ( uint8 i = NUM_ ; i < shares for stock . length ; i ++ ) { if ( i != _share id ) { shares [ shares for stock [ i ] ] . holder . transfer ( dividend per recipient ) ; stock . dividends paid = safe math . add ( stock . dividends paid , dividend per recipient ) ; dividend paid ( shares [ shares for stock [ i ] ] . holder , dividend per recipient ) ; } } share sold ( _stock id , _share id , share . purchase price , current price , share . holder , msg . sender ) ; share . holder = msg . sender ; share . purchase price = current price ; stock . last action = block . timestamp ; }\n", "nl": "calculates the current purchase price for the give stock share ."}
{"code": "function set lockup_jishis ( address _jishi , uint256 _value , uint256 _jishi date ) public only owner { require ( _jishi != address ( NUM_ ) ) ; jishis_locked [ _jishi ] = _value ; jishis_jishi date [ _jishi ] = _jishi date ; updated locking state ( STR_ , _jishi , _value , _jishi date ) ; }\n", "nl": "set lockup for strategic simu ."}
{"code": "function update price ( uint _price ) only owner { price = _price ; }\n", "nl": "set price in sntr tokens for store ."}
{"code": "function create token ( uint _supply , address _party , uint _start_date ) public returns ( address , address , uint ) { require ( created_contracts [ msg . sender ] == _start_date ) ; address ltoken = long_tokens [ _start_date ] ; address stoken = short_tokens [ _start_date ] ; require ( ltoken != address ( NUM_ ) && stoken != address ( NUM_ ) ) ; drct_token drct_interface = drct_token ( ltoken ) ; drct_interface . create token ( _supply . div ( token_ratio ) , _party , msg . sender ) ; drct_interface = drct_token ( stoken ) ; drct_interface . create token ( _supply . div ( token_ratio ) , _party , msg . sender ) ; return ( ltoken , stoken , token_ratio ) ; }\n", "nl": "create : the address of the create drct token ."}
{"code": "function masternode deregister ( ) public prevent reentry returns ( bool _success ) { require ( msg . sender != address ( NUM_ ) ) ; require ( masternode . active masternodes > NUM_ ) ; require ( masternode . total balance wei > NUM_ ) ; require ( this . balance >= masternode . total balance wei + tokensale . total wei in fallback ) ; uint8 slot = _get masternode slot ( msg . sender ) ; require ( slot < max masternodes ) ; uint256 balance wei = masternodes [ slot ] . balance wei ; require ( masternode . total balance wei >= balance wei ) ; _request interest payout to total supply ( ) ; _request interest payout to account balance ( msg . sender ) ; masternodes [ slot ] . addr = address ( NUM_ ) ; masternodes [ slot ] . balance wei = NUM_ ; masternodes [ slot ] . since interval = NUM_ ; masternodes [ slot ] . last mining interval = NUM_ ; masternode . total balance wei = masternode . total balance wei . sub ( balance wei ) ; masternode . active masternodes -- ; masternode\n", "nl": "update internal token balance ."}
{"code": "function process order ( uint128 order id , uint max matches ) internal { order storage order = order for order id [ order id ] ; uint our original executed base = order . executed base ; uint our original executed cntr = order . executed cntr ; var ( our direction , ) = unpack price ( order . price ) ; uint their price start = ( our direction == direction . buy ) ? min sell price : max buy price ; uint their price end = compute opposite price ( order . price ) ; match stop reason match stop reason = match against book ( order id , their price start , their price end , max matches ) ; credit executed funds less fees ( order id , our original executed base , our original executed cntr ) ; if ( order . terms == terms . immediate or cancel ) { if ( match stop reason == match stop reason . satisfied ) { refund unmatched and finish ( order id , status . done , reason code . none ) ; return ; } else if ( match stop reason ==\n", "nl": "the owner may disqualify a bid if it be bogus ."}
{"code": "function deposit ( address _investor , bytes _whitelist sign ) public payable whitelist set sale not ended returns ( uint256 ) { require ( _investor != address ( NUM_ ) ) ; require ( msg . value > NUM_ ) ; require ( msg . value >= sale . min contribution ( ) ) ; uint256 transaction id = add transaction ( _investor , msg . value ) ; if ( whitelist . is whitelisted ( _investor ) || whitelist . is offchain whitelisted ( _investor , _whitelist sign ) || sale . whitelist threshold ( ) >= sale . stakes ( _investor ) . add ( msg . value ) ) { if ( ! sale . paused ( ) ) { forward transaction internal ( transaction id , _whitelist sign ) ; } } return transaction id ; }\n", "nl": "forward a transaction ."}
{"code": "function mine ( uint256 nonce ) when not paused returns ( bool success ) { require ( check mine ( nonce ) ) ; mine ( msg . sender , block reward , uint40 ( block . timestamp ) - uint40 ( last mined on ) ) ; balances [ msg . sender ] += block reward ; block number += NUM_ ; total supply += block reward ; update randomness ( ) ; var mul = ( block . timestamp - last mined on ) ; if ( mul > ( NUM_ * NUM_ * NUM_ ) ) { mul = NUM_ * NUM_ * NUM_ ; } if ( mul < ( NUM_ * NUM_ / NUM_ ) ) { mul = NUM_ * NUM_ / NUM_ ; } target *= mul ; target /= ( NUM_ * NUM_ ) ; if ( target > pow limit ) { target = pow limit ; } last mined on = uint40 ( block . timestamp ) ; if ( block number % halving interval == NUM_ ) { block reward /= NUM_ ; reward halved ( ) ; } return BOOL_ ; }\n", "nl": "new draw start ."}
{"code": "function time ( ) public constant returns ( uint ) { return now ; }\n", "nl": "get number of address ."}
{"code": "function claim bid reward ( uint _bid id ) only registered acc only existing bid ( _bid id ) only bid aceptee ( _bid id ) only bid state ( _bid id , bid state . completed ) { bid storage bid = bids by id [ _bid id ] ; bid . state = bid state . claimed ; require ( token . transfer ( bid . publisher wallet , bid . amount ) ) ; log bid reward claimed ( bid . id , bid . publisher wallet , bid . amount ) ; }\n", "nl": "the bid be give up by the publisher , therefore cancel it and return the fund to the advertiser same logic a cancelbid ( ) , but different permissions ."}
{"code": "function purchase company ( uint _company id ) public payable { require ( msg . value == companies [ _company id ] . cur price ) ; require ( is paused == BOOL_ ) ; uint256 commission5percent = ( ( msg . value / NUM_ ) / NUM_ ) ; uint256 commission owner = msg . value - commission5percent ; companies [ _company id ] . owner address . transfer ( commission owner ) ; cfo address . transfer ( commission5percent ) ; companies [ _company id ] . owner address = msg . sender ; companies [ _company id ] . cur price = companies [ _company id ] . cur price + ( companies [ _company id ] . cur price / NUM_ ) ; companies [ _company id ] . volume = companies [ _company id ] . volume + msg . value ; }\n", "nl": "this function allow players to purchase countries from other players ."}
{"code": "function fund capital ( ) public payable { if ( ! was sale ended ) return _error buying tokens ( STR_ ) ; if ( ! was soft cap met ) return _error buying tokens ( STR_ ) ; uint _amt needed = capital fundable ( ) ; uint _amount = msg . value > _amt needed ? _amt needed : msg . value ; if ( _amount == NUM_ ) { return _error buying tokens ( STR_ ) ; } total raised += _amount ; token . mint ( msg . sender , _amount ) ; treasury . add capital . value ( _amount ) ( ) ; emit buy tokens success ( now , msg . sender , _amount , _amount ) ; uint _refund = msg . value > _amount ? msg . value - _amount : NUM_ ; if ( _refund > NUM_ ) { require ( msg . sender . call . value ( _refund ) ( ) ) ; emit user refunded ( now , msg . sender , _refund ) ; } }\n", "nl": "this function can be call by the contributor to claim his btnt tokens at the end of the ico ."}
{"code": "function claim tokens ( ) external { claim tokens for user ( msg . sender ) ; }\n", "nl": "efficiently call claimallforinvestor ( msg . sender ) ."}
{"code": "function get customer tx orig mcw transfer ( address _customer , bytes32 _tx payment for mcw ) public view returns ( bytes32 ) { require ( is valid customer ( _customer ) , STR_ ) ; require ( _tx payment for mcw != bytes32 ( NUM_ ) , STR_ ) ; tx registry tx registry = tx registry ( registry [ _customer ] ) ; bytes32 tx orig mcw transfer = tx registry . get tx orig mcw transfer ( _tx payment for mcw ) ; return tx orig mcw transfer ; }\n", "nl": "get the customer 's tx of payment for mcw data - amount of mcw tokens which be record in the tx ."}
{"code": "function claim team reserve ( ) only team reserve locked public { address reserve wallet = msg . sender ; require ( block . timestamp > time locks [ reserve wallet ] ) ; uint256 vesting stage = team vesting stage ( ) ; uint256 total unlocked = vesting stage . mul ( NUM_ * ( NUM_ * * NUM_ ) * ( NUM_ * * NUM_ ) ) ; if ( vesting stage == NUM_ ) { total unlocked = allocations [ team reserve wallet ] ; } require ( total unlocked <= allocations [ team reserve wallet ] ) ; require ( claimed [ team reserve wallet ] < total unlocked ) ; uint256 payment = total unlocked . sub ( claimed [ team reserve wallet ] ) ; claimed [ team reserve wallet ] = total unlocked ; require ( token . transfer ( team reserve wallet , payment ) ) ; distributed ( team reserve wallet , payment ) ; }\n", "nl": "unlock any now freeable tokens that be lock up for team and reserve account ."}
{"code": "function _is ready to pve ( data types . warrior _warrior ) internal view returns ( bool ) { return ( _warrior . action == idle ) && ( _warrior . cooldown end block <= uint64 ( block . number ) ) && ( _warrior . level >= dungeon requirements [ _warrior . dungeon index ] ) ; }\n", "nl": "switch off warrior auras that be enable in pet auras , pet aura have priority ."}
{"code": "function reclaim dividend ( uint256 _dividend index ) public only owner { require ( _dividend index < dividends . length , STR_ ) ; require ( now >= dividends [ _dividend index ] . expiry , STR_ ) ; require ( ! dividends [ _dividend index ] . reclaimed , STR_ ) ; dividends [ _dividend index ] . reclaimed = BOOL_ ; dividend storage dividend = dividends [ _dividend index ] ; uint256 remaining amount = dividend . amount . sub ( dividend . claimed amount ) ; require ( erc20 ( dividend . token ) . transfer ( msg . sender , remaining amount ) , STR_ ) ; emit erc20 dividend reclaimed ( msg . sender , _dividend index , dividend . token , remaining amount ) ; }\n", "nl": "internal function for pay dividends ."}
{"code": "function set tokens ( crowdsale storage storage self ) public returns ( bool ) { require ( ( msg . sender == self . owner ) || ( msg . sender == address ( this ) ) ) ; require ( ! self . tokens set ) ; uint256 _token balance ; _token balance = self . token . balance of ( this ) ; self . withdraw tokens map [ msg . sender ] = _token balance ; self . starting token balance = _token balance ; self . tokens set = BOOL_ ; return BOOL_ ; }\n", "nl": "function to set tokens for the sale ."}
{"code": "function batch mint ( address [ ] _data , uint256 [ ] _amount ) public only owner can mint { for ( uint i = NUM_ ; i < _data . length ; i ++ ) { mint ( _data [ i ] , _amount [ i ] ) ; } }\n", "nl": "batch the adminship of the contract ."}
{"code": "function spend ( address destination , uint256 value , uint8 v1 , bytes32 r1 , bytes32 s1 , uint8 v2 , bytes32 r2 , bytes32 s2 ) public { require ( address ( this ) . balance >= value , STR_ ) ; require ( _valid signature ( destination , value , v1 , r1 , s1 , v2 , r2 , s2 ) , STR_ ) ; spend nonce = spend nonce + NUM_ ; destination . transfer ( value ) ; emit spent ( destination , value ) ; }\n", "nl": "confirm that the two signature triplets ( v1 , r1 , s1 ) and ( v2 , r2 , s2 ) both authorize a spend of this contract 's fund to the give destination address ."}
{"code": "function freeze transfers until ( uint256 _frozen until block , string _reason ) only owner { token frozen until block = _frozen until block ; token frozen ( _frozen until block , _reason ) ; }\n", "nl": "change freeze ."}
{"code": "function safe withdrawal ( ) after deadline public { if ( ( ! funding goal reached || unlock funders balance == BOOL_ ) && msg . sender != owner ) { uint amount = balance of [ msg . sender ] ; balance of [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { require ( this . balance >= amount ) ; if ( msg . sender . send ( amount ) ) { fund transfer ( msg . sender , amount , BOOL_ ) ; amount withdrawn = safe add ( amount withdrawn , amount ) ; } else { balance of [ msg . sender ] = amount ; } } } }\n", "nl": "investors should call this function in order to receive refund in case crowdsale be not successful ."}
{"code": "function get price ( ) constant returns ( uint result ) { if ( now < milestones . p1 ) return NUM_ ; if ( now >= milestones . p1 && now < milestones . p2 ) { return base_price ; } if ( now >= milestones . p2 && now < milestones . p3 ) { uint days_in = NUM_ + ( now - milestones . p2 ) / NUM_ days ; return base_price - days_in * NUM_ / NUM_ ; } if ( now >= milestones . p3 && now < milestones . p4 ) { return mid_price ; } if ( now >= milestones . p4 && now < milestones . p5 ) { days_in = NUM_ + ( now - milestones . p4 ) / NUM_ days ; return mid_price - days_in * NUM_ / NUM_ ; } if ( now >= milestones . p5 && now < milestones . p6 ) { return fin_price ; } if ( now >= milestones . p6 ) { return NUM_ ; } }\n", "nl": "get the current ico price in wei for each claes , after 30 days the price increase be flaten out ."}
{"code": "function add new company ( string _company name , uint _precentage shares to release , uint _cool down time , uint _shares in circulation , uint _price per share ) external when not paused { bytes32 company name hash = keccak256 ( _company name ) ; require ( registred company names [ company name hash ] == BOOL_ ) ; require ( approved to launch [ company name hash ] == msg . sender ) ; require ( _precentage shares to release <= max_percentage_share_release ) ; require ( _cool down time >= min_cooldown_time && _cool down time <= max_cooldown_time ) ; require ( _shares in circulation >= init_min_shares_in_circulation && _shares in circulation <= init_max_shares_in_circulation ) ; uint _company id = companies . length ; uint _next shares release time = now + _cool down time * NUM_ days ; company memory company = company ( { company name hash : company name hash , percentage shares to release : uint32 ( _precentage shares to release ) , next shares release time : _next shares release time , cool down time : uint32 ( _cool down time ) , shares in circulation : uint32 ( _shares in circulation ) , unclaimed\n", "nl": "pay tournament winners ."}
{"code": "function release tokens ( ) only owner { require ( state == sale state . ended ) ; uint cbalance = check balance contract ( ) ; require ( cbalance != NUM_ ) ; require ( withdrawed tokens >= total tokens || get eth raised ( ) < softcap ) ; if ( get eth raised ( ) >= softcap ) { if ( released tokens == BOOL_ ) { if ( token . transfer ( msg . sender , cbalance ) ) { tokens transfered to owner ( msg . sender , cbalance ) ; } } else { if ( token . transfer ( hold contract , cbalance ) ) { hold contract . add holder ( msg . sender , cbalance , NUM_ , end date . add ( NUM_ days ) ) ; released tokens = BOOL_ ; tokens transfered to hold ( hold contract , cbalance ) ; } } } else { if ( token . transfer ( msg . sender , cbalance ) ) { tokens transfered to owner ( msg . sender , cbalance ) ; } } }\n", "nl": "release tokens for advisors ."}
{"code": "function add whitelisted transfer ( address _address ) only owner public { whitelisted transfer [ _address ] = BOOL_ ; }\n", "nl": "allow owner to remove address from whitelist ."}
{"code": "function approve company allocation ( address _dest ) public only signatory { company tokens allocation . approve allocation ( msg . sender , _dest ) ; }\n", "nl": "approves a bounty transfer and mint tokens ."}
{"code": "function grant service ( address _owner , address _provider to add ) only owner returns ( bool authorization status ) { var is preauthorized = authorized [ _owner ] [ msg . sender ] ; if ( is preauthorized && settlers [ _provider to add ] ) { authorized [ _owner ] [ _provider to add ] = BOOL_ ; authorize service provider ( msg . sender , _provider to add ) ; return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "revoke authorization between account and service provider on buyers ' behalf only accessible by contract owner ."}
{"code": "function approve completed milestone ( uint _id milestone ) campaign not canceled not changing { if ( _id milestone >= milestones . length ) throw ; milestone milestone = milestones [ _id milestone ] ; if ( ( msg . sender != milestone . reviewer ) || ( milestone . status != milestone status . completed ) ) throw ; authorize payment ( _id milestone ) ; }\n", "nl": "onlyreviewer rejects a specific milestone 's completion and revert the milestone . status ."}
{"code": "function is valid bet ( uint bet ) public view returns ( bool ) { return bet >= min bet && bet <= get max bet ( ) ; }\n", "nl": "returns the minimum bet ."}
{"code": "function change eth daily limit ( uint _limit ) public only wallet valid daily eth limit ( _limit ) { eth daily limit = _limit ; eth daily limit change ( _limit ) ; }\n", "nl": "the max price-increase limit for whales during the anti-whale phase ."}
{"code": "function propose allocation ( address _proposer address , address _dest , uint256 _tokens per period ) public only owner { require ( _tokens per period > NUM_ ) ; require ( _tokens per period <= remaining tokens per period ) ; require ( allocation of [ _dest ] . proposer address == NUM_ || allocation of [ _dest ] . allocation state == types . allocation state . rejected ) ; if ( allocation of [ _dest ] . allocation state != types . allocation state . rejected ) { allocation address list . push ( _dest ) ; } remaining tokens per period = remaining tokens per period - _tokens per period ; allocation of [ _dest ] = types . struct vesting allocation ( { tokens per period : _tokens per period , allocation state : types . allocation state . proposed , proposer address : _proposer address , claimed periods : NUM_ } ) ; }\n", "nl": "create vest by introduce beneficiary addres , total token amount , start date , duration for each vest period and number of periods ."}
{"code": "function withdrawtime ( ) external view returns ( uint ) { if ( deposit items [ msg . sender ] . deposit date + deposit items [ msg . sender ] . deposit time > now ) { return deposit items [ msg . sender ] . deposit date + deposit items [ msg . sender ] . deposit time - now ; } return NUM_ ; }\n", "nl": "amount of deposit ."}
{"code": "function get current price ( uint256 _token id ) external view returns ( uint256 ) { sale storage sale = token id to sale [ _token id ] ; require ( _is on sale ( sale ) ) ; return sale . price ; }\n", "nl": "returns the current price of a sale item ."}
{"code": "function start pre sales ( ) external is active only owner or admin returns ( bool ) { require ( sale state < in_presale ) ; require ( pre sale price > NUM_ ) ; sale state = in_presale ; is selling = BOOL_ ; emit start presales ( sale state ) ; return BOOL_ ; }\n", "nl": "end presales ."}
{"code": "function split the bet ( address referral ) private { uint256 _part bank = math . percent ( msg . value , part bank ) ; uint256 _part owner = math . percent ( msg . value , part owner ) ; uint256 _part stock = math . percent ( msg . value , part stock ) ; uint256 _part sponsor = math . percent ( msg . value , part sponsor ) ; uint256 _part referral = math . percent ( msg . value , part referral ) ; bank = math . add ( bank , _part bank ) ; stock = math . add ( stock , _part stock ) ; owner . transfer ( _part owner ) ; sponsor . transfer ( _part sponsor ) ; if ( referral != address ( NUM_ ) && referral != msg . sender && bets [ referral ] > NUM_ ) { referral . transfer ( _part referral ) ; } else { stock = math . add ( stock , _part referral ) ; } }\n", "nl": "special method for fill contract bank ."}
{"code": "function set op gas ( uint _ag , uint _tg ) { if ( msg . sender != owner ) throw ; acct call gas = _ag ; tok call gas = _tg ; }\n", "nl": "get operation gas amount ."}
{"code": "function _transfer ( address _from , address _to , uint256 _value ) internal returns ( bool ) { require ( _from != address ( NUM_ ) ) ; require ( _to != address ( NUM_ ) ) ; require ( _value <= balances [ _from ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit transfer ( _from , _to , _value ) ; return BOOL_ ; }\n", "nl": "internal function that this reuse by the transfer function ."}
{"code": "function generate tokens ( address _owner , uint _amount ) public only controller returns ( bool ) { uint cur total supply = total supply ( ) ; require ( cur total supply + _amount >= cur total supply ) ; uint previous balance to = balance of ( _owner ) ; require ( previous balance to + _amount >= previous balance to ) ; update value at now ( total supply history , cur total supply + _amount ) ; update value at now ( balances [ _owner ] , previous balance to + _amount ) ; emit transfer ( NUM_ , _owner , _amount ) ; return BOOL_ ; }\n", "nl": "mint _amount tokens that be assign to _owner ."}
{"code": "function recover all ( ) public only oscar { address oscar . transfer ( this . balance ) ; }\n", "nl": "set oscar address ."}
{"code": "function purchase for ( address _participant ) public payable only during icodates ( ) returns ( bool ) { require ( _participant != NUM_ ) ; require ( paid ether [ _participant ] . add ( msg . value ) >= minimum purchase amount ) ; selfllery manager wallet . transfer ( msg . value ) ; uint current bonus percent = get current bonus percent ( ) ; uint total tokens = calc total tokens ( msg . value , current bonus percent ) ; require ( current cap tokens . add ( total tokens ) <= sale tokens cents ) ; require ( token . transfer from ( owner , _participant , total tokens ) ) ; sent tokens [ _participant ] = sent tokens [ _participant ] . add ( total tokens ) ; current cap tokens = current cap tokens . add ( total tokens ) ; current cap ether = current cap ether . add ( msg . value ) ; paid ether [ _participant ] = paid ether [ _participant ] . add ( msg . value ) ; purchase ( _participant , total tokens , msg . value ) ; return BOOL_ ; }\n", "nl": "add pre-sale purchase tokens only owner ."}
{"code": "function n payments ( ) constant public returns ( uint ) { return payments . length ; }\n", "nl": "payments stuff ."}
{"code": "function safe withdrawal ( ) public after deadline { if ( wei raised < funding goal && wei raised < minimum funding goal ) { uint amount = balance of [ msg . sender ] ; balance of [ msg . sender ] = NUM_ ; if ( amount > NUM_ ) { if ( msg . sender . send ( amount ) ) { fund transfer ( msg . sender , amount , BOOL_ ) ; } else { balance of [ msg . sender ] = amount ; } } } if ( ( wei raised >= funding goal || wei raised >= minimum funding goal ) && wallet == msg . sender ) { if ( wallet . send ( wei raised ) ) { fund transfer ( wallet , wei raised , BOOL_ ) ; goal reached ( wallet , wei raised ) ; } else { funding goal reached = BOOL_ ; } } }\n", "nl": "public function onlyafterdeadline move ether to beneficiary contract if goal reach if goal not reach msg . sender ."}
{"code": "function bid ( ) public payable { require ( stage == stages . auction set up || stage == stages . auction started ) ; require ( privatesalewhitelist [ msg . sender ] || publicsalewhitelist [ msg . sender ] ) ; if ( stage == stages . auction set up ) { require ( privatesalewhitelist [ msg . sender ] ) ; } require ( msg . value > NUM_ ) ; require ( bids [ msg . sender ] . received + msg . value >= bid_threshold ) ; assert ( bids [ msg . sender ] . received + msg . value >= msg . value ) ; uint256 remaining_funds_to_end_auction = remaining funds to end auction ( ) ; require ( msg . value <= remaining_funds_to_end_auction ) ; if ( stage == stages . auction set up ) { require ( privatesalewhitelist [ msg . sender ] ) ; current bonus = NUM_ ; } else if ( stage == stages . auction started ) { if ( privatesalewhitelist [ msg . sender ] && now >= auction_start_time && now < auction_start_time + bonus_day1_duration ) { current bonus = NUM_ ; } else if ( privatesalewhitelist [\n", "nl": "finalize the auction - set the final gotoken price and change the auction stage after no bid be allow ."}
{"code": "function calculate dice profit ( uint _bet num , uint _bet value ) private pure returns ( int ) { assert ( _bet num > NUM_ && _bet num < dice_range ) ; uint bet value = _bet value / NUM_ ; uint total won = bet value * dice_range / _bet num ; uint house edge value = total won * house_edge / house_edge_divisor ; int profit = int ( total won ) - int ( house edge value ) - int ( bet value ) ; return profit * NUM_ ; }\n", "nl": "player profit in gwei ."}
{"code": "function declare public offering plan ( uint256 token count , uint256 unlock companys tokens at ) external only fundraiser only after crowdsale returns ( bool ) { assert ( token count <= NUM_ ) ; assert ( safe math . sub ( now , starbase crowdsale . ended at ( ) ) >= NUM_ days ) ; assert ( safe math . sub ( unlock companys tokens at , now ) >= NUM_ days ) ; if ( public offering plans . length > NUM_ ) { uint256 last declared at = public offering plans [ public offering plans . length - NUM_ ] . declared at ; assert ( safe math . sub ( now , last declared at ) >= NUM_ days ) ; } uint256 total declared token count = token count ; for ( uint8 i ; i < public offering plans . length ; i ++ ) { total declared token count = safe math . add ( total declared token count , public offering plans [ i ] . token count ) ; } assert ( total declared token count <= initial companys token allocation ) ; public offering plans . push ( public\n", "nl": "returns whether the transfer of tokens be available fundraiser ."}
{"code": "function _unlock token by index ( uint256 _index ) internal { lock record memory record = owned lock records [ msg . sender ] [ _index ] ; uint length = owned lock records [ msg . sender ] . length ; owned lock records [ msg . sender ] [ _index ] = owned lock records [ msg . sender ] [ length - NUM_ ] ; delete owned lock records [ msg . sender ] [ length - NUM_ ] ; owned lock records [ msg . sender ] . length -- ; owned lock amount [ msg . sender ] = owned lock amount [ msg . sender ] . sub ( record . amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( record . amount ) ; emit un lock ( msg . sender , record . order id , record . amount ) ; }\n", "nl": "return a lock record ( lock amount , releasetimestamp ) ."}
{"code": "function get accounts ( uint256 _start , uint256 _count ) public constant returns ( address [ ] addresses ) { require ( owners [ msg . sender ] ) ; require ( _start >= NUM_ && _count >= NUM_ ) ; if ( _start == NUM_ && _count >= account list . length ) { return account list ; } address [ ] memory _slice = new address [ ] ( _count ) ; for ( uint256 i = NUM_ ; i < _count ; i ++ ) { _slice [ i ] = account list [ i + _start ] ; } return _slice ; }\n", "nl": "will only return if this address exist in the map _clients ."}
{"code": "function set sanctuary address ( address _address ) external only admin { sanctuary interface candidate contract = sanctuary interface ( _address ) ; require ( candidate contract . is sanctuary ( ) ) ; sanctuary = candidate contract ; }\n", "nl": "update the address of the generator contract , can only be call by the admin ."}
{"code": "function claim tokens ( ) public { claim ( msg . sender ) ; }\n", "nl": "claim your eth ."}
{"code": "function upgrade ( address _addr ) only etheraffle external { upgraded = BOOL_ ; emit log upgrade ( _addr , this . balance , now ) ; receiver interface ( _addr ) . receive ether . value ( this . balance ) ( ) ; }\n", "nl": "selfdestruct - use here to delete this placeholder contract and forward any fund send to it on to the final ethrelief contract once it be fully develop ."}
{"code": "function valid state ( ) internal view { if ( msg . value == NUM_ ) revert ( STR_ ) ; if ( uint ( contract . read ( start time ( ) ) ) > now ) revert ( STR_ ) ; if ( contract . read ( wallet ( ) ) == NUM_ ) revert ( STR_ ) ; if ( contract . read ( is configured ( ) ) == NUM_ ) revert ( STR_ ) ; if ( contract . read ( is finished ( ) ) != NUM_ ) revert ( STR_ ) ; }\n", "nl": "ensures the sale be finalize ."}
{"code": "function batch issue tokens ( uint256 _number of issuances ) only owner { if ( ! ico has sucessfuly ended ) throw ; address current participant address ; uint256 tokens to be issued ; for ( uint cnt = NUM_ ; cnt < _number of issuances ; cnt ++ ) { current participant address = participant index [ last cfi issuance index ] ; if ( current participant address == NUM_ ) continue ; tokens to be issued = ico supply * participant contribution [ current participant address ] / total eth raised ; cofoundit token contract . mint tokens ( current participant address , tokens to be issued , STR_ ) ; last cfi issuance index += NUM_ ; } if ( participant index [ last cfi issuance index ] == NUM_ && cofoundit token contract . total supply ( ) < ico supply ) { uint division difference = ico supply - cofoundit token contract . total supply ( ) ; cofoundit token contract . mint tokens ( multisig address , division difference , STR_ ) ; } }\n", "nl": "set ico address and allocate sale supply to it ."}
{"code": "function force pay ( uint _begin , uint _end ) public returns ( bool ) { if ( current_state == swap state . tokenized ) { calculate ( ) ; } require ( current_state == swap state . ready ) ; token = drct_token_interface ( long_token_address ) ; uint count = token . address count ( address ( this ) ) ; uint loop_count = count < _end ? count : _end ; for ( uint i = loop_count - NUM_ ; i >= _begin ; i -- ) { address long_owner = token . get holder by index ( i , address ( this ) ) ; uint to_pay_long = token . get balance by index ( i , address ( this ) ) ; pay swap ( long_owner , to_pay_long , BOOL_ ) ; } token = drct_token_interface ( short_token_address ) ; count = token . address count ( address ( this ) ) ; loop_count = count < _end ? count : _end ; for ( uint j = loop_count - NUM_ ; j >= _begin ; j -- ) { address short_owner = token . get holder by index ( j , address ( this )\n", "nl": "returns a new unique deterministic address that have not be use before ."}
{"code": "function distribute bonuses ( uint _amount ) public only distribution source returns ( uint ) { erc20 interface _bonus token = erc20 interface ( bonus token ) ; if ( _bonus token . allowance ( msg . sender , address ( this ) ) < _amount ) { return _emit error ( profiterole_error_insufficient_distribution_balance ) ; } if ( ! _bonus token . transfer from ( msg . sender , wallet , _amount ) ) { return _emit error ( profiterole_error_transfer_error ) ; } if ( first deposit date == NUM_ ) { first deposit date = now ; } uint _last deposit date = last deposit date ; if ( _last deposit date != NUM_ ) { distribution deposits [ _last deposit date ] . next deposit date = now ; } last deposit date = now ; distribution deposits [ now ] = deposit ( _amount , _amount , NUM_ ) ; treasury ( treasury ) . add distribution period ( ) ; deposit pending added ( _amount , msg . sender , now ) ; return ok ; }\n", "nl": "function create to emit the eth transfer event from the child contract only ."}
{"code": "function settle seller ( address _seller , uint256 _value ) only settler returns ( bool success ) { var service provider bp = fee basis points [ msg . sender ] ; require ( ( service provider bp > NUM_ ) && ( service provider bp <= NUM_ ) ) ; if ( balances [ msg . sender ] >= _value && _value > NUM_ ) { var fee = safe div ( safe mul ( _value , service provider bp ) , NUM_ ) ; var transferred to seller = safe sub ( _value , fee ) ; balances [ _seller ] = safe add ( balances [ _seller ] , transferred to seller ) ; transfer ( msg . sender , _seller , transferred to seller ) ; return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "service provider settlement with buyer : a small percent be burnt ( set in setburnrate , store in burnbasispoints ) when fund be transfer from buyer to service provider only accessible by settlers ."}
{"code": "function refund ( ) external { if ( ! start refund ) throw ; var gnt value = balances [ msg . sender ] ; var eth value = balances ether [ msg . sender ] ; if ( gnt value == NUM_ ) throw ; balances [ msg . sender ] = NUM_ ; balances ether [ msg . sender ] = NUM_ ; total tokens -= gnt value ; refund ( msg . sender , eth value ) ; if ( ! msg . sender . send ( eth value ) ) throw ; }\n", "nl": "test redfunding ."}
{"code": "function save rn ( uint _block ) public { if ( blockhash ( _block ) != NUM_ ) random number [ _block ] = uint ( blockhash ( _block ) ) ; if ( random number [ _block ] != NUM_ ) { uint reward to send = reward [ _block ] ; reward [ _block ] = NUM_ ; msg . sender . send ( reward to send ) ; } }\n", "nl": "contribute to the reward of a random number ."}
{"code": "function allowance ( address _owner , address _spender ) public constant returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }\n", "nl": "get id of gift be approve from owner to spender ."}
{"code": "function swap ( data storage _data , address _a , address _b ) { if ( ! _data . is contain [ _a ] || ! _data . is contain [ _b ] ) throw ; var prev a = _data . prev of [ _a ] ; remove ( _data , _a ) ; replace ( _data , _b , _a ) ; if ( prev a == NUM_ ) { prepend ( _data , _b ) ; } else { append ( _data , _b , prev a ) ; } }\n", "nl": "chec list for element ."}
{"code": "function chase ( ) private { uint d value = NUM_ finney ; if ( msg . value > max deposit * NUM_ ether ) { msg . sender . send ( msg . value - max deposit * NUM_ ether ) ; d value = max deposit * NUM_ ether ; } else { d value = msg . value ; } add new donkey ( msg . sender ) ; entries . push ( entry ( msg . sender , d value , ( d value * ( multiplier ) / NUM_ ) , BOOL_ ) ) ; balance += ( d value * ( NUM_ - fee ) ) / NUM_ ; donkeys invested += d value ; donkeys [ msg . sender ] . invested += d value ; uint index = ranking . length - NUM_ ; uint new entry = donkeys [ msg . sender ] . invested ; bool done = BOOL_ ; bool same position = BOOL_ ; uint existing at = ranking . length - NUM_ ; while ( ranking [ index ] . invested < new entry && ! done ) { if ( index > NUM_ ) { done\n", "nl": "create simple unlocked deposit , require by some service ."}
{"code": "function to base32 ( bytes source ) internal pure returns ( bytes ) { if ( source . length == NUM_ ) return new bytes ( NUM_ ) ; uint8 [ ] memory digits = new uint8 [ ] ( NUM_ ) ; digits [ NUM_ ] = NUM_ ; uint8 digitlength = NUM_ ; for ( uint8 i = NUM_ ; i < source . length ; ++ i ) { uint carry = uint8 ( source [ i ] ) ; for ( uint8 j = NUM_ ; j < digitlength ; ++ j ) { carry += uint ( digits [ j ] ) * NUM_ ; digits [ j ] = uint8 ( carry % NUM_ ) ; carry = carry / NUM_ ; } while ( carry > NUM_ ) { digits [ digitlength ] = uint8 ( carry % NUM_ ) ; digitlength ++ ; carry = carry / NUM_ ; } } return to alphabet ( reverse ( truncate ( digits , digitlength ) ) ) ; }\n", "nl": "return the first character a a byte in a give hex string address given 0x1abcd . . ."}
{"code": "function set info url prefix ( string prefix ) external contract_only owner returns ( string info url prefix ) { _info url prefix = prefix ; return _info url prefix ; }\n", "nl": "set url prefix , of course that win t change the exist chibi urls on chain ."}
{"code": "function get status ( ) internal constant returns ( uint8 ) { if ( now > end crowdsale date ) { return NUM_ ; } else if ( now > olymp end date && now < end crowdsale date ) { return NUM_ ; } else if ( now > olymp start date && now < olymp end date ) { return NUM_ ; } else if ( now > sale finish date && now < olymp start date ) { return NUM_ ; } else if ( now > sale start date && now < sale finish date ) { return NUM_ ; } else if ( status pre sale == NUM_ ) { return NUM_ ; } else { return NUM_ ; } }\n", "nl": "0 - stop 1 - presale 2 - sale 1 3 - sale 2 ."}
{"code": "function pay dividends ( uint count ) public only owner { require ( ! dividends payed && dividends calculated ) ; for ( uint i = NUM_ ; dividends payed index < addresses . length && i < count ; i ++ ) { address token holder = addresses [ dividends payed index ] ; if ( ! lock addresses [ token holder ] && dividends [ token holder ] != NUM_ ) { uint value = dividends [ token holder ] ; dividends [ token holder ] = NUM_ ; eth to dividends needs = eth to dividends needs . sub ( value ) ; token holder . transfer ( value ) ; } dividends payed index ++ ; } if ( dividends payed index == addresses . length ) { dividends payed index = NUM_ ; dividends payed = BOOL_ ; dividends calculated = BOOL_ ; } }\n", "nl": "function pay dividends to investors ."}
{"code": "function power up ( address _sender , address _from , uint256 _amount babz ) public only nutz when not paused { uint256 authorized pow = authorized power ( ) ; require ( authorized pow != NUM_ ) ; require ( _amount babz != NUM_ ) ; uint256 total babz = complete supply ( ) ; require ( total babz != NUM_ ) ; uint256 amount pow = _amount babz . mul ( authorized pow ) . div ( total babz ) ; uint256 outstanding pow = outstanding power ( ) ; require ( outstanding pow . add ( amount pow ) <= max power ) ; uint256 pow bal = power balance of ( _from ) . add ( amount pow ) ; require ( pow bal >= authorized pow . div ( min_share_of_power ) ) ; if ( _sender != _from ) { allowed [ _from ] [ _sender ] = allowed [ _from ] [ _sender ] . sub ( _amount babz ) ; } _set outstanding power ( outstanding pow . add ( amount pow ) ) ; _set power balance of ( _from , pow bal ) ; _set active supply ( active supply ( )\n", "nl": "end game by pay out player and server ."}
{"code": "function new period ( uint256 _owner cut ) public only owner { require ( now >= epoch + NUM_ days ) ; require ( _owner cut <= NUM_ ) ; uint256 unclaimed dividend = dividend pool ; uint256 owner rake = ( address ( this ) . balance - unclaimed dividend ) * owner cut / NUM_ ; dividend pool = address ( this ) . balance - unclaimed dividend - owner rake ; uint64 existing members = num members ; if ( existing members == NUM_ ) { dividend = NUM_ ; } else { dividend = dividend pool / existing members ; } num members = num members . add ( new members ) ; new members = NUM_ ; current period ++ ; epoch = now ; owner cut = _owner cut ; msg . sender . transfer ( owner rake + unclaimed dividend ) ; period end ( current period - NUM_ , this . balance , existing members ) ; }\n", "nl": "change animator ."}
{"code": "function penalize inactive juror ( address _juror address , uint _dispute id , uint [ ] _draws ) public { dispute storage dispute = disputes [ _dispute id ] ; juror storage inactive juror = jurors [ _juror address ] ; require ( period > period . vote ) ; require ( dispute . last session vote [ _juror address ] != session ) ; dispute . last session vote [ _juror address ] = session ; require ( valid draws ( _juror address , _dispute id , _draws ) ) ; uint penality = _draws . length * min activated token * NUM_ * alpha / alpha_divisor ; penality = ( penality < inactive juror . balance ) ? penality : inactive juror . balance ; inactive juror . balance -= penality ; token shift ( _juror address , _dispute id , - int ( penality ) ) ; jurors [ msg . sender ] . balance += penality / NUM_ ; token shift ( msg . sender , _dispute id , int ( penality / NUM_ ) ) ; jurors [ governor ] . balance += penality / NUM_ ; token shift ( governor , _dispute id ,\n", "nl": "check dispute if exist ."}
{"code": "function order tokens of ( address customer ) public view returns ( uint256 balance ) { return orders [ customer ] [ STR_ ] ; }\n", "nl": "get the order 's balance of eth for account customer ."}
{"code": "function mint ( ) can po smint returns ( bool ) { if ( balances [ msg . sender ] <= NUM_ ) return BOOL_ ; if ( transfer ins [ msg . sender ] . length <= NUM_ ) return BOOL_ ; uint reward = get proof of stake reward ( msg . sender ) ; if ( reward <= NUM_ ) return BOOL_ ; total supply = total supply . add ( reward ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( reward ) ; delete transfer ins [ msg . sender ] ; transfer ins [ msg . sender ] . push ( transfer in struct ( uint128 ( balances [ msg . sender ] ) , uint64 ( now ) ) ) ; mint ( msg . sender , reward ) ; return BOOL_ ; }\n", "nl": "batch token function ."}
{"code": "function refund ( ) stop in emergency { if ( get state ( ) != state . refunding ) throw ; address investor = msg . sender ; if ( balances [ investor ] == NUM_ ) throw ; uint amount = balances [ investor ] ; delete balances [ investor ] ; if ( ! ( investor . call . value ( amount ) ( ) ) ) throw ; refunded ( investor , amount ) ; }\n", "nl": "this should be use if the crowdsale fail , to receive the refuld money ."}
{"code": "function regular end game ( address _player address , uint32 _round id , uint8 _game type , uint16 _num , uint _value , int _balance , uint _game id , address _contract address ) private { uint game id = player game id [ _player address ] ; game storage game = game id game [ game id ] ; address contract address = this ; int max balance = conflict res . max balance ( ) ; require ( _game id == game id ) ; require ( _round id > NUM_ ) ; require ( - int ( game . stake ) <= _balance && _balance <= max balance ) ; require ( ( _game type == NUM_ ) && ( _num == NUM_ ) && ( _value == NUM_ ) ) ; require ( game . status == game status . active ) ; assert ( _contract address == contract address ) ; close game ( game , game id , _round id , _player address , reason ended . regular_ended , _balance ) ; }\n", "nl": "cancel active game without play ."}
{"code": "function get balance ( ) view external returns ( uint ) { return this . balance ; }\n", "nl": "explicit balance getter ."}
{"code": "function get ( bytes32 _id ) constant returns ( bytes32 id , address owner ) { dapp d = dapps [ _id ] ; id = d . id ; owner = d . owner ; }\n", "nl": "a dapp from the list ."}
{"code": "function _get token count to buy from seller ( uint _token count to buy ) internal view returns ( uint ) { require ( _token count to buy > NUM_ ) ; lottery storage lottery = lotteries [ lottery count - NUM_ ] ; require ( lottery . token count to sell >= lottery . owner token count to sell [ msg . sender ] ) ; uint token count to sell = lottery . token count to sell - lottery . owner token count to sell [ msg . sender ] ; if ( token count to sell == NUM_ ) return NUM_ ; if ( token count to sell < _token count to buy ) { return token count to sell ; } else { return _token count to buy ; } }\n", "nl": "buys tokens from system ( mint ) for sender ."}
{"code": "function buy token from ( address _seller , address _token address , uint256 _buyer token price ) public payable returns ( bool _result ) { require ( _seller != NUM_ ) ; require ( _token address != NUM_ ) ; require ( _buyer token price > NUM_ ) ; lock ( ) ; _result = BOOL_ ; user ether of [ msg . sender ] += msg . value ; if ( user ether of [ msg . sender ] == NUM_ ) { un lock ( ) ; return ; } erc20 token token = erc20 token ( _token address ) ; var selling amount = token . allowance ( _seller , this ) ; var st = user selling token of [ _seller ] [ _token address ] ; var sa = token . balance of ( _seller ) ; bool bigger = BOOL_ ; if ( sa < selling amount ) { selling amount = sa ; bigger = BOOL_ ; } if ( st . price > NUM_ && st . line time > now && selling amount > NUM_ && ! st . cancel ) { if ( _buyer token price < st . price\n", "nl": "event oncancelsellingtoken ( address index _tokenaddress , address _seller , uint indexed _sellingamount , uint256 indexed _price , uint _linetime , bool _cancel ) ; ."}
{"code": "modifier state transition ( ) { require ( current state >= NUM_ && current state <= last state ) ; require ( now >= current state start time ) ; if ( current state == last state ) { uint256 total supply = fundcru token . total supply ( ) ; if ( total supply >= goal of state [ last state - NUM_ ] ) { assert ( now < current state start time + soft cap count down timer ) ; } } else { uint256 time passed = now - current state start time ; uint256 new state ; uint256 sum time = NUM_ ; for ( uint256 i = current state ; i < last state ; i ++ ) { sum time = sum time . add ( duration of state [ i ] ) ; if ( sum time >= time passed ) { new state = i ; break ; } } if ( i == last state ) { new state = last state ; } if ( new state != current state ) { state transition ( current state , new state , now ) ; current state = new state\n", "nl": "initialize an authenticatedproxy ."}
{"code": "modifier only by ( address account ) { require ( msg . sender == account ) ; _ ; }\n", "nl": "modifier to add to function that should only be callable by contract owner ."}
{"code": "function forward funds ( ) internal { wallet . transfer ( msg . value ) ; }\n", "nl": "refund back if not kyc approve ."}
{"code": "function get cap ( ) public view returns ( uint ) { uint token raised = total tokens - remaining tokens ; for ( uint i = NUM_ ; i < caps . length - NUM_ ; i ++ ) { if ( token raised < caps [ i ] ) { uint token per overshoot = overshoot * prices [ i ] ; return ( caps [ i ] . add ( token per overshoot ) ) ; } } return ( total tokens ) ; }\n", "nl": "return number of restricted tokens from address ."}
{"code": "function renew ( uint256 _token id , uint256 _num cycles ) external payable when not paused { require ( _num cycles != NUM_ ) ; require ( owner of ( _token id ) != address ( NUM_ ) ) ; uint256 product id = license product id ( _token id ) ; _require renewable product ( product id ) ; uint256 renewal cost = cost for product cycles ( product id , _num cycles ) ; require ( msg . value == renewal cost ) ; _perform renewal ( _token id , _num cycles ) ; if ( renewal cost > NUM_ && license affiliate ( _token id ) != address ( NUM_ ) && _affiliate program is active ( ) && license issued time ( _token id ) . add ( renewals credit affiliates for ) > now ) { _handle affiliate ( license affiliate ( _token id ) , product id , _token id , msg . value ) ; } }\n", "nl": "return the total cost to renew a product for a number of cycle ."}
{"code": "function require signature bytes32 data address signer uint256 deadline uint256 sig id bytes sig sig standard sig std sig destination sig dest internal bytes32 r bytes32 s uint8 v assembly r mload add sig 32 s mload add sig 64 v byte 0 mload add sig 96 if v 27 v 27 require block timestamp deadline used sig ids signer sig id if sig std sig standard typed require signer ecrecover keccak256 sig dest sig destination transfer sig destination transfer sig dest sig destination approve sig destination approve sig dest sig destination approve and call sig destination approve and call sig destination transfer from data v r s else if sig std sig standard personal require signer ecrecover keccak256 eth signed message prefix 32 data v r s || signer ecrecover keccak256 eth signed message prefix \\x20 data v r s else require signer ecrecover keccak256 eth signed message prefix 64 hex to string data v r s || signer ecrecover keccak256 eth signed message prefix \\x40 hex to string data v r s used sig ids signer sig id true\n", "nl": "recover signer address from a message by use his signature param hash bytes32 message , the hash be the signed message ."}
{"code": "function airdrop ( address [ ] payees , uint256 airdrop value ) public only owner returns ( bool ) { uint256 _size = payees . length ; uint256 amount = airdrop value . mul ( _size ) ; require ( amount <= balances [ owner ] , STR_ ) ; for ( uint i = NUM_ ; i < _size ; i ++ ) { if ( payees [ i ] == address ( NUM_ ) ) { amount = amount . sub ( airdrop value ) ; continue ; } balances [ payees [ i ] ] = balances [ payees [ i ] ] . add ( airdrop value ) ; emit transfer ( owner , payees [ i ] , airdrop value ) ; } balances [ owner ] = balances [ owner ] . sub ( amount ) ; return BOOL_ ; }\n", "nl": "drop prophet ."}
{"code": "function buy tokens ( address _beneficiary ) public payable { require ( _beneficiary != NUM_ && valid purchase ( ) && this . balance . sub ( msg . value ) < hard cap ) ; if ( this . balance >= soft cap && ! success ) { success = BOOL_ ; ico success ( ) ; } uint256 wei amount = msg . value ; if ( this . balance > hard cap ) { cap reached ( ) ; uint256 to refund = this . balance . sub ( hard cap ) ; msg . sender . transfer ( to refund ) ; wei amount = wei amount . sub ( to refund ) ; } uint256 tokens = wei amount . mul ( get current rate with bonus ( ) ) ; if ( tokens sold . add ( tokens ) > tokens for sale ) { revert ( ) ; } etcl . mint ( _beneficiary , tokens ) ; tokens sold = tokens sold . add ( tokens ) ; investments [ _beneficiary ] = investments [ _beneficiary ] . add ( wei amount ) ; tokens purchased ( _beneficiary , tokens ) ;\n", "nl": "allows investors to buy aco tokens ."}
{"code": "function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { if ( balances [ msg . sender ] >= _amount && _amount > NUM_ && balances [ _to ] + _amount > balances [ _to ] ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; transfer ( msg . sender , _to , _amount ) ; add address ( _to ) ; return BOOL_ ; } else { return BOOL_ ; } }\n", "nl": "transfer an amount from the owner 's account to an indicated account ."}
{"code": "function deliver ( address [ ] _investors ) public { update stage ( ) ; require ( stage == stage . before_growth || stage == stage . growth || stage == stage . life ) ; for ( uint256 i = NUM_ ; i < _investors . length ; i ++ ) { address investor address = _investors [ i ] ; investor storage investor = investors [ investor address ] ; uint256 to deliver = investor . tokens bought ; investor . tokens bought = NUM_ ; investor . ether invested = NUM_ ; if ( to deliver > NUM_ ) { require ( orgon token . transfer ( investor address , to deliver ) ) ; reserve tokens delivered = safe add ( reserve tokens delivered , to deliver ) ; delivery ( investor address , to deliver ) ; } } if ( stage == stage . before_growth && safe mul ( reserve tokens delivered , growth_min_delivered_denominatior ) >= safe mul ( reserve tokens sold , growth_min_delivered_numerator ) ) { stage = stage . growth ; growth deadline = current time ( ) + growth_max_duration ; fee change enable time = current time ( ) + fee_change_delay\n", "nl": "calculate exchange : private placement stage : 10 off private presale stage : 5 off ."}
{"code": "function valid purchase ( ) internal view returns ( bool ) { require ( ! paused && ! cap reached ) ; require ( block . timestamp >= start && block . timestamp <= end ) ; return BOOL_ ; }\n", "nl": "cap be check in buytokens function ."}
{"code": "function set rabbit data ( uint _token id , uint32 _explosive , uint32 _endurance , uint32 _nimble , uint _task id , uint8 v , bytes32 r , bytes32 s ) external { require ( used sign id [ _task id ] == NUM_ ) ; auction storage auction = token id to auction [ _token id ] ; require ( auction . started at == NUM_ ) ; uint [ NUM_ ] memory arr = [ _token id , _explosive , _endurance , _nimble , _task id ] ; string memory text = uint5 to str ( arr ) ; address signer = verify ( text , v , r , s ) ; require ( signer == coo address ) ; rabbit data storage rdata = rabbits [ _token id ] ; rdata . explosive = _explosive ; rdata . endurance = _endurance ; rdata . nimble = _nimble ; rabbits [ _token id ] = rdata ; used sign id [ _task id ] = NUM_ ; emit update complete ( msg . sender , _token id ) ; }\n", "nl": "extended attribute ."}
{"code": "function set beneficiary ( address _beneficiary ) only owner public { beneficiary = _beneficiary ; }\n", "nl": "allows the owner to register a beneficiary for the airdrop ."}
{"code": "function allocate token ( address _addr , uint256 _eth ) is owner external { if ( _eth == NUM_ ) throw ; if ( _addr == address ( NUM_ ) ) throw ; uint256 tokens = safe mult ( format decimals ( _eth ) , token exchange rate ) ; if ( tokens + token raised > current supply ) throw ; token raised = safe add ( token raised , tokens ) ; balances [ _addr ] += tokens ; allocate token ( _addr , tokens ) ; }\n", "nl": "allocate uip tokens to pre-sell address ."}
{"code": "function execute distribute capital ( uint _value ) internal returns ( bool _success , string _result ) { if ( _value > capital ) return ( BOOL_ , STR_ ) ; capital -= _value ; profits += _value ; profits total += _value ; emit capital removed ( now , this , _value ) ; emit profits received ( now , this , _value ) ; emit executed distribute capital ( now , _value ) ; return ( BOOL_ , STR_ ) ; }\n", "nl": "increases capitalraisedtarget ."}
{"code": "function get count ( ) public constant returns ( uint count ) { return contracts . length ; }\n", "nl": "counts number of contact create by this factory ."}
{"code": "function calculate excess balance ( ) internal when not paused returns ( uint256 ) { uint256 amount paid = msg . value ; uint256 difference wei = NUM_ ; uint256 exceeding balance = NUM_ ; if ( tokens raised >= limit tier3 ) { uint256 added tokens = tokens raised . add ( amount paid . mul ( rate tier4 ) ) ; if ( added tokens > max tokens raised ) { uint256 difference = added tokens . sub ( max tokens raised ) ; difference wei = difference . div ( rate tier4 ) ; amount paid = amount paid . sub ( difference wei ) ; } } uint256 added balance = crowdsale balances [ msg . sender ] . add ( amount paid ) ; if ( added balance <= max purchase ) { crowdsale balances [ msg . sender ] = crowdsale balances [ msg . sender ] . add ( amount paid ) ; } else { exceeding balance = added balance . sub ( max purchase ) ; amount paid = amount paid . sub ( exceeding balance ) ; crowdsale balances [ msg . sender ] = crowdsale balances [ msg .\n", "nl": "spend available and purchase up more if not enough ."}
{"code": "function check guess ( ) public live { require ( now > address to time stamp [ msg . sender ] ) ; winning number = uint8 ( keccak256 ( now , owner , block . coinbase , block . difficulty , nonce ) ) % NUM_ ; nonce = uint ( keccak256 ( now ) ) % NUM_ ; uint8 user guess = address to guess [ msg . sender ] ; if ( user guess == winning number ) { msg . sender . transfer ( ( this . balance * NUM_ ) / NUM_ ) ; owner . transfer ( this . balance ) ; } address to guess [ msg . sender ] = NUM_ ; address to time stamp [ msg . sender ] = NUM_ ; }\n", "nl": "take a guess ."}
{"code": "function request erc20 transfer ( address _token , address _to , uint256 _value ) public only authorised addresses { erc20 transfer interface token = erc20 transfer interface ( _token ) ; require ( _to != NUM_ && _value > NUM_ && token . balance of ( address ( this ) ) >= _value ) ; latest erc20 tx request = erc20 transaction request ( msg . sender , _to , _token , _value ) ; transfer of erc20 requested ( msg . sender , _to , _token , _value ) ; }\n", "nl": "this function be a way to get other etc20 tokens back to their rightful owner if send by mistake ."}
{"code": "function process public purchase ( uint256 wei amount , address beneficiary ) private { if ( current stage == stage . private ) { current stage = stage . discount40 ; token pools [ uint256 ( stage . discount40 ) ] = token pools [ uint256 ( stage . discount40 ) ] . add ( token pools [ uint256 ( stage . private ) ] ) ; token pools [ uint256 ( stage . private ) ] = NUM_ ; } for ( uint256 stage = uint256 ( current stage ) ; stage <= NUM_ ; stage ++ ) { uint256 tokens to buy = ( wei amount . mul ( stage rates [ stage ] ) ) . div ( NUM_ ether ) ; if ( tokens to buy <= token pools [ stage ] ) { payout tokens ( beneficiary , tokens to buy , wei amount ) ; break ; } else { tokens to buy = token pools [ stage ] ; uint256 used wei = ( tokens to buy . mul ( NUM_ ether ) ) . div ( stage rates [ stage ] ) ; uint256 left wei = wei amount . sub ( used wei ) ; payout tokens ( beneficiary , tokens to buy , used wei ) ; if ( stage == NUM_ ) { beneficiary . transfer ( left wei ) ; break ; } else { wei amount = left wei ; current stage = stage ( stage + NUM_ ) ; } } } }\n", "nl": "doproxyaccounting ( ) be an internal function that create tokens for fee pledge by the owner ."}
{"code": "function get token data ( uint256 _token id ) public exists ( _token id ) view returns ( uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 ) { token memory token = all mined tokens [ all tokens index [ _token id ] ] ; return ( _token id , token . x , token . y , token . size a , token . size b , token . actual price , token . sold price , token . inner , token . outer ) ; }\n", "nl": "return token size ."}
{"code": "function get bonus by time ( ) public constant returns ( uint256 ) { uint256 bonus = NUM_ ; if ( now >= phase presale_from && now < phase presale_to ) { bonus = NUM_ ; } else if ( now >= phase public sale1_from && now < phase public sale1_to ) { bonus = NUM_ ; } else if ( now >= phase public sale2_from && now < phase public sale2_to ) { bonus = NUM_ ; } else if ( now >= phase public sale3_from && now < phase public sale3_to ) { bonus = NUM_ ; } return bonus ; }\n", "nl": "get the current ico phase ."}
{"code": "function get token by name ( string _name ) public view returns ( address , string , string , uint8 , string ) { address _token = token by name [ _name ] ; return get token meta data ( _token ) ; }\n", "nl": "provides a registered token 's metadata , look up by symbol ."}
{"code": "function invest internal ( address receiver , uint128 customer id ) stop in emergency private { if ( get state ( ) == state . pre funding ) { throw ; } else if ( get state ( ) == state . funding ) { if ( is white listed ) { if ( ! early participant whitelist [ receiver ] . status ) { throw ; } } } else { throw ; } uint wei amount = msg . value ; uint token amount = pricing strategy . calculate price ( wei amount , wei raised , tokens sold , msg . sender , token . decimals ( ) ) ; if ( token amount == NUM_ ) { throw ; } if ( is white listed ) { if ( token amount < early participant whitelist [ receiver ] . min cap && token amount of [ receiver ] == NUM_ ) { throw ; } if ( is breaking investor cap ( receiver , token amount ) ) { throw ; } update inherited early participant whitelist ( receiver , token amount ) ; } else { if ( token amount < token . min cap\n", "nl": "tokenamount how mony tokens be buy ."}
{"code": "function __callback ( bytes32 _order id , string _result ) public { require ( msg . sender == oraclize_cb address ( ) ) ; uint256 _rate = parse int ( _result , rate_exponent ) ; uint128 _funder id = orders [ _order id ] . funder id ; uint8 _collector = orders [ _order id ] . collector ; uint256 _funds = orders [ _order id ] . funds ; uint8 collector_decimals = collectors [ _collector ] . decimals ; uint256 _sum = _funds . mul ( _rate ) ; _sum = _sum . mul ( NUM_ * * ( token_decimals - collector_decimals ) ) ; _sum = _sum . div ( NUM_ * * rate_exponent ) ; uint256 _tokens = _sum . div ( token_price ) ; if ( sold . add ( _tokens ) > tokens_hard_cap ) { _tokens = tokens_hard_cap . sub ( sold ) ; } orders [ _order id ] . rate = _rate ; purchased [ _funder id ] = purchased [ _funder id ] . add ( _tokens ) ; sold = sold . add ( _tokens ) ; funded [ _funder id ] [ _collector ] = funded [ _funder id ]\n", "nl": "1 . 1 createnewmartial 1 . 2 createnewcardtype ."}
{"code": "function finalization ( ) internal { if ( ! pre ico ) { uint256 remaining tokens = max token supply . sub ( token . total supply ( ) ) ; token . mint ( wallet remaining , remaining tokens ) ; } super . finalization ( ) ; if ( ! pre ico ) { token . finish minting ( ) ; } token . transfer ownership ( pending owner ) ; }\n", "nl": "finalize sale and perform cleanup action ."}
{"code": "function hash order part one ( order memory order ) internal pure returns ( bytes32 ) { return keccak256 ( order . exchange , order . maker , order . taker , order . maker relayer fee , order . taker relayer fee , order . maker protocol fee , order . taker protocol fee , order . fee recipient , order . fee method , order . side , order . sale kind , order . target , order . how to call ) ; }\n", "nl": "hashes the order ."}
{"code": "function owner update contract balance ( uint new contract balance in wei ) public only owner { contract balance = new contract balance in wei ; }\n", "nl": "onlyowneroroperator adjust contract balance variable ( only use for max profit calc ) ."}
{"code": "modifier only issue manager ( ) { if ( msg . sender != issue manager && msg . sender != contract owner ) { revert ( ) ; } _ ; }\n", "nl": "adjust round length ( round admin ) ."}
{"code": "function remove client token ( uint256 _value ) is client public { require ( clients [ msg . sender ] . tokens >= _value , STR_ ) ; clients [ msg . sender ] . tokens = clients [ msg . sender ] . tokens . sub ( _value ) ; }\n", "nl": "funciones del usuario ."}
{"code": "function buy tokens ( address _beneficiary ) public payable { require ( _beneficiary != NUM_ && valid purchase ( ) && this . balance . sub ( msg . value ) < hard cap ) ; if ( this . balance >= soft cap && ! success ) { success = BOOL_ ; ico success ( ) ; } uint256 wei amount = msg . value ; if ( this . balance > hard cap ) { cap reached ( ) ; uint256 to refund = this . balance . sub ( hard cap ) ; msg . sender . transfer ( to refund ) ; wei amount = wei amount . sub ( to refund ) ; } uint256 tokens = wei amount . mul ( get current rate with bonus ( ) ) ; if ( tokens sold . add ( tokens ) > tokens for sale ) { revert ( ) ; } etcl . mint ( _beneficiary , tokens ) ; tokens sold = tokens sold . add ( tokens ) ; investments [ _beneficiary ] = investments [ _beneficiary ] . add ( wei amount ) ; tokens purchased ( _beneficiary , tokens ) ;\n", "nl": "called from the foundation wallet to claim eth back from the mvm ."}
{"code": "modifier when not paused ( ) { require ( ! paused ) ; _ ; }\n", "nl": "modifier to allow action only when the refund is not pause ."}
{"code": "function deposit ( ) private { uint256 amount = arp token . balance of ( msg . sender ) . min256 ( arp token . allowance ( msg . sender , address ( this ) ) ) ; require ( amount > NUM_ ) ; uint256 bonus = amount . div ( bonus_scale ) ; record storage record = records [ msg . sender ] ; record . amount = record . amount . add ( amount ) . add ( bonus ) ; record . timestamp = now ; records [ msg . sender ] = record ; arp deposited = arp deposited . add ( amount ) . add ( bonus ) ; if ( bonus > NUM_ ) { arp token . safe transfer from ( owner , address ( this ) , bonus ) ; } arp token . safe transfer from ( msg . sender , address ( this ) , amount ) ; emit deposit ( deposit id ++ , msg . sender , amount , bonus ) ; }\n", "nl": "withdraws arp ."}
{"code": "modifier is_token ( address _token ) { require ( _token == address ( token left ) || _token == address ( token right ) ) ; _ ; }\n", "nl": "whether the '_token ' be part of this token changer ."}
{"code": "function start crowdsale ( ) public only owner { require ( presale concluded && ! crowdsale started ) ; crowdsale started = BOOL_ ; phase1 start block = block . number ; phase1 end block = phase1 start block . add ( day to block number ( NUM_ ) ) ; phase2 end block = phase1 end block . add ( day to block number ( NUM_ ) ) ; phase3 end block = phase2 end block . add ( day to block number ( NUM_ ) ) ; phase4 end block = phase3 end block . add ( day to block number ( NUM_ ) ) ; phase5 end block = phase4 end block . add ( day to block number ( NUM_ ) ) ; end block = phase5 end block ; start crowdsale ( ) ; }\n", "nl": "allows the owner to close the crowdsale manually before the end time ."}
{"code": "function set ( address target , int cumulative , uint total ) external restricted { if ( ! scores [ target ] . exists ) { scores [ target ] = score ( BOOL_ , NUM_ , NUM_ ) ; } scores [ target ] . cumulative score = cumulative ; scores [ target ] . total ratings = total ; }\n", "nl": "cumulative score ."}
{"code": "function _assign buyout proceeds ( address current owner , uint256 [ ] memory claimed surrounding tiles , uint256 fee , uint256 current owner winnings , uint256 total dividend per beneficiary , uint256 referral bonus , uint256 prize pool funds ) internal { if ( current owner != NUM_ ) { _send funds ( current owner , current owner winnings ) ; } else { uint256 prize pool part = current owner winnings . mul ( game settings . first buyout prize pool percentage ) . div ( NUM_ ) ; prize pool funds = prize pool funds . add ( prize pool part ) ; fee = fee . add ( current owner winnings . sub ( prize pool part ) ) ; } for ( uint256 i = NUM_ ; i < claimed surrounding tiles . length ; i ++ ) { address beneficiary = game states [ game index ] . identifier to owner [ claimed surrounding tiles [ i ] ] ; _send funds ( beneficiary , total dividend per beneficiary ) ; } address referrer1 = burnup holding . referrer of ( msg . sender ) ; if ( referrer1 != NUM_ ) { _send funds\n", "nl": "this function add the bid to a map of bid for the oracle to bid on ."}
{"code": "function get ether back ( ) public returns ( bool success ) { require ( msg . sender == airdropper ) ; airdropper . transfer ( address ( this ) . balance ) ; return BOOL_ ; }\n", "nl": "this function can be call after the crowdfunding if the first goal be not reach ."}
{"code": "function claim ( ) public only owner { require ( now >= release time , STR_ ) ; uint256 amount = token . balance of ( this ) ; require ( amount > NUM_ , STR_ ) ; token . safe transfer ( owner , amount ) ; }\n", "nl": "when timeout ."}
{"code": "function confirm kitty actions ( uint256 _kitty id , uint256 [ NUM_ ] _kitty actions ) external view returns ( bool ) { for ( uint256 i = NUM_ ; i < NUM_ ; i ++ ) { if ( ! kitty actions [ _kitty id ] [ _kitty actions [ i ] ] ) return BOOL_ ; } return BOOL_ ; }\n", "nl": "used by trainkitty to delete map value if the kitty have already be train ."}
{"code": "function set max deposit ( uint new max ) public only authorized { max deposit = new max * one edg ; }\n", "nl": "sets the maximum number of address that can be assign at once ."}
{"code": "function withdraw some ( uint value ) only owner { require ( value <= this . balance ) ; msg . sender . transfer ( value ) ; }\n", "nl": "withdraw some of the ether to owner ."}
{"code": "function whitelist remove ( address addr ) public is on whitelist { if ( msg . sender != addr ) { throw ; } log whitelist remove ( msg . sender , now ) ; whitelist [ msg . sender ] = BOOL_ ; }\n", "nl": "add a whitelist address ."}
{"code": "function get lease ( uint8 card id , uint lease id ) public view returns ( uint lease index , address tenant , uint until block , string title , string url , string image ) { return ( card details structs [ card id ] . lease card structs [ lease id ] . id , card details structs [ card id ] . lease card structs [ lease id ] . tenant , card details structs [ card id ] . lease card structs [ lease id ] . until block , card details structs [ card id ] . lease card structs [ lease id ] . title , card details structs [ card id ] . lease card structs [ lease id ] . url , card details structs [ card id ] . lease card structs [ lease id ] . image ) ; }\n", "nl": "get lease list from a card ."}
{"code": "function distribute external ( uint256 _r id , uint256 _p id , uint256 _eth , uint256 _aff id , uint256 _team , x3 ddatasets . event returns memory _event data_ ) private returns ( x3 ddatasets . event returns ) { uint256 _p1 = _eth / NUM_ ; uint256 _com = _eth / NUM_ ; _com = _com . add ( _p1 ) ; uint256 _xcom ; if ( ! address ( com bank addr_ ) . call . value ( _com ) ( ) ) { _xcom = _com ; _com = NUM_ ; } uint256 _aff = _eth / NUM_ ; if ( _aff id != _p id && plyr_ [ _aff id ] . name != STR_ ) { plyr_ [ _aff id ] . aff = _aff . add ( plyr_ [ _aff id ] . aff ) ; emit x3 devents . on affiliate payout ( _aff id , plyr_ [ _aff id ] . addr , plyr_ [ _aff id ] . name , _r id , _p id , _aff , now ) ; } else { _xcom = _xcom . add ( _aff ) ; } _xcom = _xcom . add (\n", "nl": "distribute eth base on fee to com , aff , and p3d fees_ 0 j3ddatasets . teamfee ( 50 , 0 ) ; ."}
{"code": "function change voting rules ( token shares address , uint minimum shares to pass avote , uint minutes for debate , uint256 minimum share ) only owner public { shares token address = token ( shares address ) ; if ( minimum shares to pass avote == NUM_ ) minimum shares to pass avote = NUM_ ; minimum quorum = minimum shares to pass avote ; debating period in minutes = minutes for debate ; min share = minimum share ; change of rules ( minimum quorum , debating period in minutes , shares token address , min share ) ; }\n", "nl": "change rule ."}
{"code": "function get tile from battleboard ( uint16 battleboard id , uint8 tile id ) public constant returns ( uint8 tile type , uint8 value , uint8 id , uint8 position , uint32 hp , uint16 pet power , uint64 angel id , uint64 pet id , bool is live , address owner ) { if ( ( battleboard id < NUM_ ) || ( battleboard id > total battleboards ) ) { revert ( ) ; } battleboard memory battleboard = battleboards [ battleboard id ] ; tile memory tile ; if ( ( tile id < NUM_ ) || ( tile id > battleboard . num tiles ) ) { revert ( ) ; } tile = tileson board [ battleboard id ] [ tile id ] ; tile type = tile . tile type ; value = tile . value ; id = tile . id ; position = tile . position ; hp = tile . hp ; pet power = tile . pet power ; angel id = tile . angel id ; pet id = tile . pet id ; owner = tile . owner ; is live = tile . is live ; }\n", "nl": "read function ."}
{"code": "function get rate ico with bonus by date ( uint256 _date ) public view returns ( uint256 ) { uint256 bonus ; uint256 rate ico ; if ( _date >= start ico pre ico && _date < end ico pre ico ) { rate ico = rate ico pre ico ; } if ( _date >= start ico main sale && _date < end ico main sale ) { rate ico = rate ico main sale ; } if ( _date >= start ico pre ico && _date < start ico pre ico2nd round ) { bonus = NUM_ ; } else if ( _date >= start ico pre ico2nd round && _date < end ico pre ico ) { bonus = NUM_ ; } else if ( _date >= start ico main sale ) { uint256 days since main ico started = ( _date - start ico main sale ) / NUM_ ; bonus = NUM_ - ( NUM_ * days since main ico started ) ; if ( bonus < NUM_ ) { bonus = NUM_ ; } } return rate ico + rate ico . mul ( bonus ) . div ( NUM_ ) ; }\n", "nl": "function for change discount if need ."}
{"code": "function get dealer and lucky info ( uint256 _lucky offset ) public view returns ( address [ NUM_ ] _dealer players , uint256 [ NUM_ ] _dealer day tokens , uint256 [ NUM_ ] _dealer total tokens , address [ NUM_ ] _lucky players , uint256 [ NUM_ ] _lucky amounts , uint256 [ NUM_ ] _lucky levels , uint256 [ NUM_ ] _lucky times ) { uint256 _day = ( now / NUM_ ) * NUM_ ; if ( dealer day == _day ) { for ( uint256 _i = NUM_ ; _i < NUM_ ; ++ _i ) { if ( dealers [ _i ] != address ( NUM_ ) ) { player storage _player = player of [ dealers [ _i ] ] ; _dealer players [ _i ] = dealers [ _i ] ; _dealer day tokens [ _i ] = _player . token day balance ; _dealer total tokens [ _i ] = _player . token balance ; } } } uint256 _size = _lucky offset >= lucky records . length ? NUM_ : lucky records . length - _lucky offset ; if ( _lucky players . length < _size ) { _size = _lucky\n", "nl": "get lockposition1 info ."}
{"code": "function update board status ( go board storage board , uint board id , board status new status ) internal { if ( new status != board . status ) { board . status = new status ; board . last update = now ; if ( is end game status ( new status ) ) { credit board game revenues ( board ) ; } board status updated ( board id , new status ) ; } }\n", "nl": "overload to set the board status when we only have a boardid ."}
{"code": "function transfer from ( address _from , address _to , uint _pixel id ) public can manage and transfer ( _pixel id ) { require ( _from != address ( NUM_ ) ) ; require ( _to != address ( NUM_ ) ) ; clear approval ( _from , _pixel id ) ; _transfer ( _from , _to , _pixel id ) ; }\n", "nl": "erc 721 safetransfer from function ."}
{"code": "function claim shares ( uint _company id , uint _number of shares ) when not paused external payable { company storage company = companies [ _company id ] ; require ( _number of shares > NUM_ && _number of shares <= ( company . shares in circulation * max_claim_shares_percentage ) / NUM_ ) ; require ( company . unclaimed shares >= _number of shares ) ; uint total price = company . price per share * _number of shares ; require ( msg . value >= total price ) ; company . unclaimed shares -= uint32 ( _number of shares ) ; _shares bought ( company . share holders , msg . sender , _number of shares ) ; _update ceoif required ( company , _company id , msg . sender ) ; if ( total price > NUM_ ) { uint sales cut = _compute sales cut ( total price ) ; withdrawable balance += sales cut ; uint seller proceeds = total price - sales cut ; company . owned by . transfer ( seller proceeds ) ; } emit claimed ( _company id , _number of shares , msg . sender ) ; }\n", "nl": "_amount should be greator than 0 ."}
{"code": "function remove account minter ( address _address ) { if ( ! is current admin ( msg . sender ) ) throw ; if ( ! account minter addresses [ _address ] ) throw ; account minter addresses [ _address ] = BOOL_ ; account minter removed ( msg . sender , _address ) ; }\n", "nl": "removes a user from our list of admins but keep them in the history audit ."}
{"code": "function get offer count ( erc20 sell_gem , erc20 buy_gem ) public constant returns ( uint ) { return _span [ sell_gem ] [ buy_gem ] ; }\n", "nl": "return the best offer for a token pair the best offer be the low one if it 's an ask , and high one if it 's a bid offer ."}
{"code": "function token burn ( uint256 _amount ) public only admin returns ( bool burned ) { require ( _amount > NUM_ ) ; require ( _amount < total supply ) ; require ( balances [ owner ] > _amount ) ; require ( balances [ owner ] . sub ( _amount ) >= NUM_ ) ; require ( total supply . sub ( _amount ) >= NUM_ ) ; balances [ owner ] = balances [ owner ] . sub ( _amount ) ; total supply = total supply . sub ( _amount ) ; token burn ( msg . sender , _amount , BOOL_ ) ; return BOOL_ ; }\n", "nl": "burns tokens and send reward ."}
{"code": "function distribute ( ) public { if ( this . balance < tenhundwei ) { return ; } uint i ; uint pctx10 ; uint acct dist ; for ( i = NUM_ ; i < activity count ; i ++ ) { pctx10 = activity accounts [ i ] . pctx10 ; acct dist = total funds received * pctx10 / tenhundwei ; if ( activity accounts [ i ] . credited >= acct dist ) { acct dist = NUM_ ; } else { acct dist = acct dist - activity accounts [ i ] . credited ; } activity accounts [ i ] . credited += acct dist ; activity accounts [ i ] . balance += acct dist ; total funds distributed += acct dist ; } message event ( STR_ ) ; }\n", "nl": "distribute fund to all partner ."}
